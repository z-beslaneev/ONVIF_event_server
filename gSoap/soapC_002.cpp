/* soapC_nnn.cpp
   Generated by gSOAP 2.8.78 for WS/onvifFull.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.cpp ver 2.8.78 2019-03-11 21:45:00 GMT")


void wstop__FullTopicExpression__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_wstop__FullTopicExpression(soap, &this->wstop__FullTopicExpression__::__item);
}

void wstop__FullTopicExpression__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstop__FullTopicExpression(soap, &this->wstop__FullTopicExpression__::__item);
#endif
}

int wstop__FullTopicExpression__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__FullTopicExpression__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__FullTopicExpression__(struct soap *soap, const char *tag, int id, const wstop__FullTopicExpression__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wstop__FullTopicExpression(soap, tag, id, &a->wstop__FullTopicExpression__::__item, "");
}

void *wstop__FullTopicExpression__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__FullTopicExpression__(soap, tag, this, type);
}

SOAP_FMAC3 wstop__FullTopicExpression__ * SOAP_FMAC4 soap_in_wstop__FullTopicExpression__(struct soap *soap, const char *tag, wstop__FullTopicExpression__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wstop__FullTopicExpression__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__FullTopicExpression__, sizeof(wstop__FullTopicExpression__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__FullTopicExpression__)
		return (wstop__FullTopicExpression__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_wstop__FullTopicExpression(soap, tag, &a->wstop__FullTopicExpression__::__item, "wstop:FullTopicExpression"))
		return NULL;
	return a;
}

SOAP_FMAC1 wstop__FullTopicExpression__ * SOAP_FMAC2 soap_instantiate_wstop__FullTopicExpression__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__FullTopicExpression__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__FullTopicExpression__ *p;
	size_t k = sizeof(wstop__FullTopicExpression__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__FullTopicExpression__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__FullTopicExpression__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__FullTopicExpression__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__FullTopicExpression__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__FullTopicExpression__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__FullTopicExpression__(soap, tag ? tag : "wstop:FullTopicExpression", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__FullTopicExpression__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__FullTopicExpression__(soap, this, tag, type);
}

SOAP_FMAC3 wstop__FullTopicExpression__ * SOAP_FMAC4 soap_get_wstop__FullTopicExpression__(struct soap *soap, wstop__FullTopicExpression__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__FullTopicExpression__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__FullTopicExpression(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wstop__FullTopicExpression), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wstop__FullTopicExpression(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__FullTopicExpression, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*(\\|([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*)*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__FullTopicExpression, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_wstop__FullTopicExpression, SOAP_TYPE_wstop__FullTopicExpression, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__FullTopicExpression(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_wstop__FullTopicExpression(soap, tag ? tag : "wstop:FullTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wstop__FullTopicExpression(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__FullTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Entity__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Entity(soap, &this->tt__Entity__::__item);
}

void tt__Entity__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Entity__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Entity__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Entity__(struct soap *soap, const char *tag, int id, const tt__Entity__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Entity(soap, tag, id, &a->tt__Entity__::__item, "");
}

void *tt__Entity__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Entity__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Entity__ * SOAP_FMAC4 soap_in_tt__Entity__(struct soap *soap, const char *tag, tt__Entity__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Entity__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Entity__, sizeof(tt__Entity__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Entity__)
		return (tt__Entity__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Entity(soap, tag, &a->tt__Entity__::__item, "tt:Entity"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Entity__ * SOAP_FMAC2 soap_instantiate_tt__Entity__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Entity__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Entity__ *p;
	size_t k = sizeof(tt__Entity__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Entity__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Entity__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Entity__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Entity__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Entity__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Entity__(soap, tag ? tag : "tt:Entity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Entity__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Entity__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Entity__ * SOAP_FMAC4 soap_get_tt__Entity__(struct soap *soap, tt__Entity__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Entity__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MoveStatus__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__MoveStatus(soap, &this->tt__MoveStatus__::__item);
}

void tt__MoveStatus__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__MoveStatus__::__item, SOAP_TYPE_tt__MoveStatus);
#endif
}

int tt__MoveStatus__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MoveStatus__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveStatus__(struct soap *soap, const char *tag, int id, const tt__MoveStatus__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__MoveStatus(soap, tag, id, &a->tt__MoveStatus__::__item, "");
}

void *tt__MoveStatus__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MoveStatus__(soap, tag, this, type);
}

SOAP_FMAC3 tt__MoveStatus__ * SOAP_FMAC4 soap_in_tt__MoveStatus__(struct soap *soap, const char *tag, tt__MoveStatus__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__MoveStatus__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveStatus__, sizeof(tt__MoveStatus__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MoveStatus__)
		return (tt__MoveStatus__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__MoveStatus(soap, tag, &a->tt__MoveStatus__::__item, "tt:MoveStatus"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__MoveStatus__ * SOAP_FMAC2 soap_instantiate_tt__MoveStatus__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MoveStatus__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MoveStatus__ *p;
	size_t k = sizeof(tt__MoveStatus__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MoveStatus__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MoveStatus__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MoveStatus__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MoveStatus__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MoveStatus__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MoveStatus__(soap, tag ? tag : "tt:MoveStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MoveStatus__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MoveStatus__(soap, this, tag, type);
}

SOAP_FMAC3 tt__MoveStatus__ * SOAP_FMAC4 soap_get_tt__MoveStatus__(struct soap *soap, tt__MoveStatus__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveStatus__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReferenceToken__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &this->tt__ReferenceToken__::__item);
}

void tt__ReferenceToken__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ReferenceToken__::__item, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__ReferenceToken__::__item);
#endif
}

int tt__ReferenceToken__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReferenceToken__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken__(struct soap *soap, const char *tag, int id, const tt__ReferenceToken__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ReferenceToken(soap, tag, id, &a->tt__ReferenceToken__::__item, "");
}

void *tt__ReferenceToken__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReferenceToken__(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReferenceToken__ * SOAP_FMAC4 soap_in_tt__ReferenceToken__(struct soap *soap, const char *tag, tt__ReferenceToken__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ReferenceToken__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReferenceToken__, sizeof(tt__ReferenceToken__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReferenceToken__)
		return (tt__ReferenceToken__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ReferenceToken(soap, tag, &a->tt__ReferenceToken__::__item, "tt:ReferenceToken"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ReferenceToken__ * SOAP_FMAC2 soap_instantiate_tt__ReferenceToken__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReferenceToken__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReferenceToken__ *p;
	size_t k = sizeof(tt__ReferenceToken__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReferenceToken__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReferenceToken__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReferenceToken__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReferenceToken__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReferenceToken__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReferenceToken__(soap, tag ? tag : "tt:ReferenceToken", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReferenceToken__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReferenceToken__(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReferenceToken__ * SOAP_FMAC4 soap_get_tt__ReferenceToken__(struct soap *soap, tt__ReferenceToken__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceToken(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__ReferenceToken), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__ReferenceToken(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 64, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__ReferenceToken, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceToken(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__ReferenceToken(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__OSDType(soap, &this->tt__OSDType__::__item);
}

void tt__OSDType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__OSDType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDType__(struct soap *soap, const char *tag, int id, const tt__OSDType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__OSDType(soap, tag, id, &a->tt__OSDType__::__item, "");
}

void *tt__OSDType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDType__ * SOAP_FMAC4 soap_in_tt__OSDType__(struct soap *soap, const char *tag, tt__OSDType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__OSDType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDType__, sizeof(tt__OSDType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDType__)
		return (tt__OSDType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__OSDType(soap, tag, &a->tt__OSDType__::__item, "tt:OSDType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__OSDType__ * SOAP_FMAC2 soap_instantiate_tt__OSDType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDType__ *p;
	size_t k = sizeof(tt__OSDType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDType__(soap, tag ? tag : "tt:OSDType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDType__ * SOAP_FMAC4 soap_get_tt__OSDType__(struct soap *soap, tt__OSDType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioClassType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__AudioClassType(soap, &this->tt__AudioClassType__::__item);
}

void tt__AudioClassType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__AudioClassType(soap, &this->tt__AudioClassType__::__item);
#endif
}

int tt__AudioClassType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioClassType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassType__(struct soap *soap, const char *tag, int id, const tt__AudioClassType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__AudioClassType(soap, tag, id, &a->tt__AudioClassType__::__item, "");
}

void *tt__AudioClassType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioClassType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioClassType__ * SOAP_FMAC4 soap_in_tt__AudioClassType__(struct soap *soap, const char *tag, tt__AudioClassType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__AudioClassType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassType__, sizeof(tt__AudioClassType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioClassType__)
		return (tt__AudioClassType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__AudioClassType(soap, tag, &a->tt__AudioClassType__::__item, "tt:AudioClassType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__AudioClassType__ * SOAP_FMAC2 soap_instantiate_tt__AudioClassType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioClassType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioClassType__ *p;
	size_t k = sizeof(tt__AudioClassType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioClassType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioClassType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioClassType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioClassType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioClassType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioClassType__(soap, tag ? tag : "tt:AudioClassType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioClassType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioClassType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioClassType__ * SOAP_FMAC4 soap_get_tt__AudioClassType__(struct soap *soap, tt__AudioClassType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioClassType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__AudioClassType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__AudioClassType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__AudioClassType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__AudioClassType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__AudioClassType, SOAP_TYPE_tt__AudioClassType, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassType(soap, tag ? tag : "tt:AudioClassType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__AudioClassType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ModeOfOperation__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ModeOfOperation(soap, &this->tt__ModeOfOperation__::__item);
}

void tt__ModeOfOperation__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__ModeOfOperation__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ModeOfOperation__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ModeOfOperation__(struct soap *soap, const char *tag, int id, const tt__ModeOfOperation__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ModeOfOperation(soap, tag, id, &a->tt__ModeOfOperation__::__item, "");
}

void *tt__ModeOfOperation__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ModeOfOperation__(soap, tag, this, type);
}

SOAP_FMAC3 tt__ModeOfOperation__ * SOAP_FMAC4 soap_in_tt__ModeOfOperation__(struct soap *soap, const char *tag, tt__ModeOfOperation__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ModeOfOperation__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ModeOfOperation__, sizeof(tt__ModeOfOperation__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ModeOfOperation__)
		return (tt__ModeOfOperation__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ModeOfOperation(soap, tag, &a->tt__ModeOfOperation__::__item, "tt:ModeOfOperation"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ModeOfOperation__ * SOAP_FMAC2 soap_instantiate_tt__ModeOfOperation__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ModeOfOperation__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ModeOfOperation__ *p;
	size_t k = sizeof(tt__ModeOfOperation__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ModeOfOperation__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ModeOfOperation__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ModeOfOperation__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ModeOfOperation__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ModeOfOperation__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ModeOfOperation__(soap, tag ? tag : "tt:ModeOfOperation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ModeOfOperation__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ModeOfOperation__(soap, this, tag, type);
}

SOAP_FMAC3 tt__ModeOfOperation__ * SOAP_FMAC4 soap_get_tt__ModeOfOperation__(struct soap *soap, tt__ModeOfOperation__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ModeOfOperation__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingJobState__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobState(soap, &this->tt__RecordingJobState__::__item);
}

void tt__RecordingJobState__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobState(soap, &this->tt__RecordingJobState__::__item);
#endif
}

int tt__RecordingJobState__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingJobState__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobState__(struct soap *soap, const char *tag, int id, const tt__RecordingJobState__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__RecordingJobState(soap, tag, id, &a->tt__RecordingJobState__::__item, "");
}

void *tt__RecordingJobState__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingJobState__(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingJobState__ * SOAP_FMAC4 soap_in_tt__RecordingJobState__(struct soap *soap, const char *tag, tt__RecordingJobState__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__RecordingJobState__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobState__, sizeof(tt__RecordingJobState__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingJobState__)
		return (tt__RecordingJobState__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__RecordingJobState(soap, tag, &a->tt__RecordingJobState__::__item, "tt:RecordingJobState"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__RecordingJobState__ * SOAP_FMAC2 soap_instantiate_tt__RecordingJobState__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingJobState__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingJobState__ *p;
	size_t k = sizeof(tt__RecordingJobState__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingJobState__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingJobState__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingJobState__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingJobState__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingJobState__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingJobState__(soap, tag ? tag : "tt:RecordingJobState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingJobState__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingJobState__(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingJobState__ * SOAP_FMAC4 soap_get_tt__RecordingJobState__(struct soap *soap, tt__RecordingJobState__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobState__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobState(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobState(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__RecordingJobState), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__RecordingJobState(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__RecordingJobState, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__RecordingJobState, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__RecordingJobState, SOAP_TYPE_tt__RecordingJobState, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobState(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobState(soap, tag ? tag : "tt:RecordingJobState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__RecordingJobState(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingJobMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobMode(soap, &this->tt__RecordingJobMode__::__item);
}

void tt__RecordingJobMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobMode(soap, &this->tt__RecordingJobMode__::__item);
#endif
}

int tt__RecordingJobMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingJobMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobMode__(struct soap *soap, const char *tag, int id, const tt__RecordingJobMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__RecordingJobMode(soap, tag, id, &a->tt__RecordingJobMode__::__item, "");
}

void *tt__RecordingJobMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingJobMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingJobMode__ * SOAP_FMAC4 soap_in_tt__RecordingJobMode__(struct soap *soap, const char *tag, tt__RecordingJobMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__RecordingJobMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobMode__, sizeof(tt__RecordingJobMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingJobMode__)
		return (tt__RecordingJobMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__RecordingJobMode(soap, tag, &a->tt__RecordingJobMode__::__item, "tt:RecordingJobMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__RecordingJobMode__ * SOAP_FMAC2 soap_instantiate_tt__RecordingJobMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingJobMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingJobMode__ *p;
	size_t k = sizeof(tt__RecordingJobMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingJobMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingJobMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingJobMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingJobMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingJobMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingJobMode__(soap, tag ? tag : "tt:RecordingJobMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingJobMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingJobMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingJobMode__ * SOAP_FMAC4 soap_get_tt__RecordingJobMode__(struct soap *soap, tt__RecordingJobMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobMode(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobMode(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__RecordingJobMode), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__RecordingJobMode(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__RecordingJobMode, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__RecordingJobMode, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__RecordingJobMode, SOAP_TYPE_tt__RecordingJobMode, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobMode(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobMode(soap, tag ? tag : "tt:RecordingJobMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__RecordingJobMode(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TrackType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__TrackType(soap, &this->tt__TrackType__::__item);
}

void tt__TrackType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__TrackType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TrackType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackType__(struct soap *soap, const char *tag, int id, const tt__TrackType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__TrackType(soap, tag, id, &a->tt__TrackType__::__item, "");
}

void *tt__TrackType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TrackType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__TrackType__ * SOAP_FMAC4 soap_in_tt__TrackType__(struct soap *soap, const char *tag, tt__TrackType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__TrackType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackType__, sizeof(tt__TrackType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TrackType__)
		return (tt__TrackType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__TrackType(soap, tag, &a->tt__TrackType__::__item, "tt:TrackType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__TrackType__ * SOAP_FMAC2 soap_instantiate_tt__TrackType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TrackType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TrackType__ *p;
	size_t k = sizeof(tt__TrackType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TrackType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TrackType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TrackType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TrackType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TrackType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TrackType__(soap, tag ? tag : "tt:TrackType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TrackType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TrackType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__TrackType__ * SOAP_FMAC4 soap_get_tt__TrackType__(struct soap *soap, tt__TrackType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingStatus__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RecordingStatus(soap, &this->tt__RecordingStatus__::__item);
}

void tt__RecordingStatus__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__RecordingStatus__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingStatus__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingStatus__(struct soap *soap, const char *tag, int id, const tt__RecordingStatus__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__RecordingStatus(soap, tag, id, &a->tt__RecordingStatus__::__item, "");
}

void *tt__RecordingStatus__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingStatus__(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingStatus__ * SOAP_FMAC4 soap_in_tt__RecordingStatus__(struct soap *soap, const char *tag, tt__RecordingStatus__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__RecordingStatus__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingStatus__, sizeof(tt__RecordingStatus__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingStatus__)
		return (tt__RecordingStatus__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__RecordingStatus(soap, tag, &a->tt__RecordingStatus__::__item, "tt:RecordingStatus"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__RecordingStatus__ * SOAP_FMAC2 soap_instantiate_tt__RecordingStatus__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingStatus__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingStatus__ *p;
	size_t k = sizeof(tt__RecordingStatus__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingStatus__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingStatus__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingStatus__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingStatus__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingStatus__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingStatus__(soap, tag ? tag : "tt:RecordingStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingStatus__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingStatus__(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingStatus__ * SOAP_FMAC4 soap_get_tt__RecordingStatus__(struct soap *soap, tt__RecordingStatus__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingStatus__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SearchState__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &this->tt__SearchState__::__item);
}

void tt__SearchState__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__SearchState__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SearchState__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchState__(struct soap *soap, const char *tag, int id, const tt__SearchState__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__SearchState(soap, tag, id, &a->tt__SearchState__::__item, "");
}

void *tt__SearchState__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SearchState__(soap, tag, this, type);
}

SOAP_FMAC3 tt__SearchState__ * SOAP_FMAC4 soap_in_tt__SearchState__(struct soap *soap, const char *tag, tt__SearchState__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__SearchState__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchState__, sizeof(tt__SearchState__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SearchState__)
		return (tt__SearchState__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__SearchState(soap, tag, &a->tt__SearchState__::__item, "tt:SearchState"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__SearchState__ * SOAP_FMAC2 soap_instantiate_tt__SearchState__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SearchState__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SearchState__ *p;
	size_t k = sizeof(tt__SearchState__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SearchState__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SearchState__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SearchState__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SearchState__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SearchState__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SearchState__(soap, tag ? tag : "tt:SearchState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SearchState__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SearchState__(soap, this, tag, type);
}

SOAP_FMAC3 tt__SearchState__ * SOAP_FMAC4 soap_get_tt__SearchState__(struct soap *soap, tt__SearchState__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchState__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__XPathExpression__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__XPathExpression(soap, &this->tt__XPathExpression__::__item);
}

void tt__XPathExpression__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__XPathExpression__::__item, SOAP_TYPE_tt__XPathExpression);
	soap_serialize_tt__XPathExpression(soap, &this->tt__XPathExpression__::__item);
#endif
}

int tt__XPathExpression__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__XPathExpression__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__XPathExpression__(struct soap *soap, const char *tag, int id, const tt__XPathExpression__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__XPathExpression(soap, tag, id, &a->tt__XPathExpression__::__item, "");
}

void *tt__XPathExpression__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__XPathExpression__(soap, tag, this, type);
}

SOAP_FMAC3 tt__XPathExpression__ * SOAP_FMAC4 soap_in_tt__XPathExpression__(struct soap *soap, const char *tag, tt__XPathExpression__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__XPathExpression__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__XPathExpression__, sizeof(tt__XPathExpression__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__XPathExpression__)
		return (tt__XPathExpression__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__XPathExpression(soap, tag, &a->tt__XPathExpression__::__item, "tt:XPathExpression"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__XPathExpression__ * SOAP_FMAC2 soap_instantiate_tt__XPathExpression__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__XPathExpression__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__XPathExpression__ *p;
	size_t k = sizeof(tt__XPathExpression__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__XPathExpression__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__XPathExpression__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__XPathExpression__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__XPathExpression__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__XPathExpression__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__XPathExpression__(soap, tag ? tag : "tt:XPathExpression", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__XPathExpression__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__XPathExpression__(soap, this, tag, type);
}

SOAP_FMAC3 tt__XPathExpression__ * SOAP_FMAC4 soap_get_tt__XPathExpression__(struct soap *soap, tt__XPathExpression__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__XPathExpression__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__XPathExpression(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__XPathExpression(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__XPathExpression), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__XPathExpression(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__XPathExpression, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__XPathExpression, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__XPathExpression, SOAP_TYPE_tt__XPathExpression, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__XPathExpression(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__XPathExpression(soap, tag ? tag : "tt:XPathExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__XPathExpression(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__XPathExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Description__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Description(soap, &this->tt__Description__::__item);
}

void tt__Description__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Description(soap, &this->tt__Description__::__item);
#endif
}

int tt__Description__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Description__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Description__(struct soap *soap, const char *tag, int id, const tt__Description__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Description(soap, tag, id, &a->tt__Description__::__item, "");
}

void *tt__Description__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Description__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Description__ * SOAP_FMAC4 soap_in_tt__Description__(struct soap *soap, const char *tag, tt__Description__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Description__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Description__, sizeof(tt__Description__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Description__)
		return (tt__Description__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Description(soap, tag, &a->tt__Description__::__item, "tt:Description"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Description__ * SOAP_FMAC2 soap_instantiate_tt__Description__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Description__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Description__ *p;
	size_t k = sizeof(tt__Description__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Description__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Description__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Description__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Description__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Description__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Description__(soap, tag ? tag : "tt:Description", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Description__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Description__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Description__ * SOAP_FMAC4 soap_get_tt__Description__(struct soap *soap, tt__Description__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Description__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Description(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Description(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__Description), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__Description(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Description, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Description, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__Description, SOAP_TYPE_tt__Description, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Description(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__Description(soap, tag ? tag : "tt:Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__Description(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReceiverState__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReceiverState(soap, &this->tt__ReceiverState__::__item);
}

void tt__ReceiverState__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__ReceiverState__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReceiverState__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverState__(struct soap *soap, const char *tag, int id, const tt__ReceiverState__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ReceiverState(soap, tag, id, &a->tt__ReceiverState__::__item, "");
}

void *tt__ReceiverState__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReceiverState__(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReceiverState__ * SOAP_FMAC4 soap_in_tt__ReceiverState__(struct soap *soap, const char *tag, tt__ReceiverState__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ReceiverState__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverState__, sizeof(tt__ReceiverState__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReceiverState__)
		return (tt__ReceiverState__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ReceiverState(soap, tag, &a->tt__ReceiverState__::__item, "tt:ReceiverState"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ReceiverState__ * SOAP_FMAC2 soap_instantiate_tt__ReceiverState__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReceiverState__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReceiverState__ *p;
	size_t k = sizeof(tt__ReceiverState__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReceiverState__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReceiverState__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReceiverState__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReceiverState__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReceiverState__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReceiverState__(soap, tag ? tag : "tt:ReceiverState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReceiverState__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReceiverState__(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReceiverState__ * SOAP_FMAC4 soap_get_tt__ReceiverState__(struct soap *soap, tt__ReceiverState__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverState__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReceiverMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReceiverMode(soap, &this->tt__ReceiverMode__::__item);
}

void tt__ReceiverMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__ReceiverMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReceiverMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverMode__(struct soap *soap, const char *tag, int id, const tt__ReceiverMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ReceiverMode(soap, tag, id, &a->tt__ReceiverMode__::__item, "");
}

void *tt__ReceiverMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReceiverMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReceiverMode__ * SOAP_FMAC4 soap_in_tt__ReceiverMode__(struct soap *soap, const char *tag, tt__ReceiverMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ReceiverMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverMode__, sizeof(tt__ReceiverMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReceiverMode__)
		return (tt__ReceiverMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ReceiverMode(soap, tag, &a->tt__ReceiverMode__::__item, "tt:ReceiverMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ReceiverMode__ * SOAP_FMAC2 soap_instantiate_tt__ReceiverMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReceiverMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReceiverMode__ *p;
	size_t k = sizeof(tt__ReceiverMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReceiverMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReceiverMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReceiverMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReceiverMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReceiverMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReceiverMode__(soap, tag ? tag : "tt:ReceiverMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReceiverMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReceiverMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReceiverMode__ * SOAP_FMAC4 soap_get_tt__ReceiverMode__(struct soap *soap, tt__ReceiverMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Direction__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Direction(soap, &this->tt__Direction__::__item);
}

void tt__Direction__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Direction__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Direction__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Direction__(struct soap *soap, const char *tag, int id, const tt__Direction__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Direction(soap, tag, id, &a->tt__Direction__::__item, "");
}

void *tt__Direction__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Direction__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Direction__ * SOAP_FMAC4 soap_in_tt__Direction__(struct soap *soap, const char *tag, tt__Direction__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Direction__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Direction__, sizeof(tt__Direction__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Direction__)
		return (tt__Direction__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Direction(soap, tag, &a->tt__Direction__::__item, "tt:Direction"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Direction__ * SOAP_FMAC2 soap_instantiate_tt__Direction__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Direction__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Direction__ *p;
	size_t k = sizeof(tt__Direction__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Direction__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Direction__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Direction__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Direction__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Direction__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Direction__(soap, tag ? tag : "tt:Direction", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Direction__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Direction__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Direction__ * SOAP_FMAC4 soap_get_tt__Direction__(struct soap *soap, tt__Direction__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Direction__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PropertyOperation__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__PropertyOperation(soap, &this->tt__PropertyOperation__::__item);
}

void tt__PropertyOperation__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PropertyOperation__::__item, SOAP_TYPE_tt__PropertyOperation);
#endif
}

int tt__PropertyOperation__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PropertyOperation__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PropertyOperation__(struct soap *soap, const char *tag, int id, const tt__PropertyOperation__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__PropertyOperation(soap, tag, id, &a->tt__PropertyOperation__::__item, "");
}

void *tt__PropertyOperation__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PropertyOperation__(soap, tag, this, type);
}

SOAP_FMAC3 tt__PropertyOperation__ * SOAP_FMAC4 soap_in_tt__PropertyOperation__(struct soap *soap, const char *tag, tt__PropertyOperation__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__PropertyOperation__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PropertyOperation__, sizeof(tt__PropertyOperation__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PropertyOperation__)
		return (tt__PropertyOperation__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__PropertyOperation(soap, tag, &a->tt__PropertyOperation__::__item, "tt:PropertyOperation"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__PropertyOperation__ * SOAP_FMAC2 soap_instantiate_tt__PropertyOperation__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PropertyOperation__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PropertyOperation__ *p;
	size_t k = sizeof(tt__PropertyOperation__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PropertyOperation__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PropertyOperation__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PropertyOperation__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PropertyOperation__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PropertyOperation__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PropertyOperation__(soap, tag ? tag : "tt:PropertyOperation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PropertyOperation__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PropertyOperation__(soap, this, tag, type);
}

SOAP_FMAC3 tt__PropertyOperation__ * SOAP_FMAC4 soap_get_tt__PropertyOperation__(struct soap *soap, tt__PropertyOperation__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PropertyOperation__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TopicNamespaceLocation__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__TopicNamespaceLocation(soap, &this->tt__TopicNamespaceLocation__::__item);
}

void tt__TopicNamespaceLocation__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__TopicNamespaceLocation(soap, &this->tt__TopicNamespaceLocation__::__item);
#endif
}

int tt__TopicNamespaceLocation__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TopicNamespaceLocation__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TopicNamespaceLocation__(struct soap *soap, const char *tag, int id, const tt__TopicNamespaceLocation__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__TopicNamespaceLocation(soap, tag, id, &a->tt__TopicNamespaceLocation__::__item, "");
}

void *tt__TopicNamespaceLocation__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TopicNamespaceLocation__(soap, tag, this, type);
}

SOAP_FMAC3 tt__TopicNamespaceLocation__ * SOAP_FMAC4 soap_in_tt__TopicNamespaceLocation__(struct soap *soap, const char *tag, tt__TopicNamespaceLocation__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__TopicNamespaceLocation__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TopicNamespaceLocation__, sizeof(tt__TopicNamespaceLocation__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TopicNamespaceLocation__)
		return (tt__TopicNamespaceLocation__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__TopicNamespaceLocation(soap, tag, &a->tt__TopicNamespaceLocation__::__item, "tt:TopicNamespaceLocation"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__TopicNamespaceLocation__ * SOAP_FMAC2 soap_instantiate_tt__TopicNamespaceLocation__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TopicNamespaceLocation__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TopicNamespaceLocation__ *p;
	size_t k = sizeof(tt__TopicNamespaceLocation__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TopicNamespaceLocation__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TopicNamespaceLocation__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TopicNamespaceLocation__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TopicNamespaceLocation__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TopicNamespaceLocation__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TopicNamespaceLocation__(soap, tag ? tag : "tt:TopicNamespaceLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TopicNamespaceLocation__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TopicNamespaceLocation__(soap, this, tag, type);
}

SOAP_FMAC3 tt__TopicNamespaceLocation__ * SOAP_FMAC4 soap_get_tt__TopicNamespaceLocation__(struct soap *soap, tt__TopicNamespaceLocation__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TopicNamespaceLocation__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DefoggingMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__DefoggingMode(soap, &this->tt__DefoggingMode__::__item);
}

void tt__DefoggingMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__DefoggingMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DefoggingMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingMode__(struct soap *soap, const char *tag, int id, const tt__DefoggingMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__DefoggingMode(soap, tag, id, &a->tt__DefoggingMode__::__item, "");
}

void *tt__DefoggingMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DefoggingMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__DefoggingMode__ * SOAP_FMAC4 soap_in_tt__DefoggingMode__(struct soap *soap, const char *tag, tt__DefoggingMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__DefoggingMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingMode__, sizeof(tt__DefoggingMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DefoggingMode__)
		return (tt__DefoggingMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__DefoggingMode(soap, tag, &a->tt__DefoggingMode__::__item, "tt:DefoggingMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__DefoggingMode__ * SOAP_FMAC2 soap_instantiate_tt__DefoggingMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DefoggingMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DefoggingMode__ *p;
	size_t k = sizeof(tt__DefoggingMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DefoggingMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DefoggingMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DefoggingMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DefoggingMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DefoggingMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DefoggingMode__(soap, tag ? tag : "tt:DefoggingMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DefoggingMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DefoggingMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__DefoggingMode__ * SOAP_FMAC4 soap_get_tt__DefoggingMode__(struct soap *soap, tt__DefoggingMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DefoggingMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ToneCompensationMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ToneCompensationMode(soap, &this->tt__ToneCompensationMode__::__item);
}

void tt__ToneCompensationMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__ToneCompensationMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ToneCompensationMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationMode__(struct soap *soap, const char *tag, int id, const tt__ToneCompensationMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ToneCompensationMode(soap, tag, id, &a->tt__ToneCompensationMode__::__item, "");
}

void *tt__ToneCompensationMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ToneCompensationMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__ToneCompensationMode__ * SOAP_FMAC4 soap_in_tt__ToneCompensationMode__(struct soap *soap, const char *tag, tt__ToneCompensationMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ToneCompensationMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationMode__, sizeof(tt__ToneCompensationMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ToneCompensationMode__)
		return (tt__ToneCompensationMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ToneCompensationMode(soap, tag, &a->tt__ToneCompensationMode__::__item, "tt:ToneCompensationMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ToneCompensationMode__ * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ToneCompensationMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ToneCompensationMode__ *p;
	size_t k = sizeof(tt__ToneCompensationMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ToneCompensationMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ToneCompensationMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ToneCompensationMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ToneCompensationMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ToneCompensationMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ToneCompensationMode__(soap, tag ? tag : "tt:ToneCompensationMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ToneCompensationMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ToneCompensationMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__ToneCompensationMode__ * SOAP_FMAC4 soap_get_tt__ToneCompensationMode__(struct soap *soap, tt__ToneCompensationMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensationMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoBoundaryType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__IrCutFilterAutoBoundaryType(soap, &this->tt__IrCutFilterAutoBoundaryType__::__item);
}

void tt__IrCutFilterAutoBoundaryType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__IrCutFilterAutoBoundaryType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoBoundaryType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoBoundaryType__(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoBoundaryType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__IrCutFilterAutoBoundaryType(soap, tag, id, &a->tt__IrCutFilterAutoBoundaryType__::__item, "");
}

void *tt__IrCutFilterAutoBoundaryType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoBoundaryType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoBoundaryType__ * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoBoundaryType__(struct soap *soap, const char *tag, tt__IrCutFilterAutoBoundaryType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IrCutFilterAutoBoundaryType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoBoundaryType__, sizeof(tt__IrCutFilterAutoBoundaryType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoBoundaryType__)
		return (tt__IrCutFilterAutoBoundaryType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__IrCutFilterAutoBoundaryType(soap, tag, &a->tt__IrCutFilterAutoBoundaryType__::__item, "tt:IrCutFilterAutoBoundaryType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoBoundaryType__ * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoBoundaryType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IrCutFilterAutoBoundaryType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoBoundaryType__ *p;
	size_t k = sizeof(tt__IrCutFilterAutoBoundaryType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoBoundaryType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoBoundaryType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoBoundaryType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoBoundaryType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoBoundaryType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoBoundaryType__(soap, tag ? tag : "tt:IrCutFilterAutoBoundaryType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoBoundaryType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoBoundaryType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoBoundaryType__ * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoBoundaryType__(struct soap *soap, tt__IrCutFilterAutoBoundaryType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoBoundaryType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilizationMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ImageStabilizationMode(soap, &this->tt__ImageStabilizationMode__::__item);
}

void tt__ImageStabilizationMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__ImageStabilizationMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilizationMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationMode__(struct soap *soap, const char *tag, int id, const tt__ImageStabilizationMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ImageStabilizationMode(soap, tag, id, &a->tt__ImageStabilizationMode__::__item, "");
}

void *tt__ImageStabilizationMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilizationMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilizationMode__ * SOAP_FMAC4 soap_in_tt__ImageStabilizationMode__(struct soap *soap, const char *tag, tt__ImageStabilizationMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ImageStabilizationMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationMode__, sizeof(tt__ImageStabilizationMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilizationMode__)
		return (tt__ImageStabilizationMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ImageStabilizationMode(soap, tag, &a->tt__ImageStabilizationMode__::__item, "tt:ImageStabilizationMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationMode__ * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImageStabilizationMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilizationMode__ *p;
	size_t k = sizeof(tt__ImageStabilizationMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilizationMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilizationMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilizationMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilizationMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilizationMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilizationMode__(soap, tag ? tag : "tt:ImageStabilizationMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilizationMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilizationMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilizationMode__ * SOAP_FMAC4 soap_get_tt__ImageStabilizationMode__(struct soap *soap, tt__ImageStabilizationMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__IrCutFilterMode(soap, &this->tt__IrCutFilterMode__::__item);
}

void tt__IrCutFilterMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IrCutFilterMode__::__item, SOAP_TYPE_tt__IrCutFilterMode);
#endif
}

int tt__IrCutFilterMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterMode__(struct soap *soap, const char *tag, int id, const tt__IrCutFilterMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__IrCutFilterMode(soap, tag, id, &a->tt__IrCutFilterMode__::__item, "");
}

void *tt__IrCutFilterMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterMode__ * SOAP_FMAC4 soap_in_tt__IrCutFilterMode__(struct soap *soap, const char *tag, tt__IrCutFilterMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IrCutFilterMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterMode__, sizeof(tt__IrCutFilterMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterMode__)
		return (tt__IrCutFilterMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__IrCutFilterMode(soap, tag, &a->tt__IrCutFilterMode__::__item, "tt:IrCutFilterMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IrCutFilterMode__ * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IrCutFilterMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterMode__ *p;
	size_t k = sizeof(tt__IrCutFilterMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterMode__(soap, tag ? tag : "tt:IrCutFilterMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterMode__ * SOAP_FMAC4 soap_get_tt__IrCutFilterMode__(struct soap *soap, tt__IrCutFilterMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalanceMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceMode__::__item);
}

void tt__WhiteBalanceMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__WhiteBalanceMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalanceMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceMode__(struct soap *soap, const char *tag, int id, const tt__WhiteBalanceMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__WhiteBalanceMode(soap, tag, id, &a->tt__WhiteBalanceMode__::__item, "");
}

void *tt__WhiteBalanceMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalanceMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalanceMode__ * SOAP_FMAC4 soap_in_tt__WhiteBalanceMode__(struct soap *soap, const char *tag, tt__WhiteBalanceMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__WhiteBalanceMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceMode__, sizeof(tt__WhiteBalanceMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalanceMode__)
		return (tt__WhiteBalanceMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__WhiteBalanceMode(soap, tag, &a->tt__WhiteBalanceMode__::__item, "tt:WhiteBalanceMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__WhiteBalanceMode__ * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalanceMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalanceMode__ *p;
	size_t k = sizeof(tt__WhiteBalanceMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalanceMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalanceMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalanceMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalanceMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalanceMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalanceMode__(soap, tag ? tag : "tt:WhiteBalanceMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalanceMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalanceMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalanceMode__ * SOAP_FMAC4 soap_get_tt__WhiteBalanceMode__(struct soap *soap, tt__WhiteBalanceMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Enabled__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Enabled(soap, &this->tt__Enabled__::__item);
}

void tt__Enabled__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Enabled__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Enabled__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Enabled__(struct soap *soap, const char *tag, int id, const tt__Enabled__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Enabled(soap, tag, id, &a->tt__Enabled__::__item, "");
}

void *tt__Enabled__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Enabled__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Enabled__ * SOAP_FMAC4 soap_in_tt__Enabled__(struct soap *soap, const char *tag, tt__Enabled__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Enabled__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Enabled__, sizeof(tt__Enabled__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Enabled__)
		return (tt__Enabled__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Enabled(soap, tag, &a->tt__Enabled__::__item, "tt:Enabled"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Enabled__ * SOAP_FMAC2 soap_instantiate_tt__Enabled__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Enabled__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Enabled__ *p;
	size_t k = sizeof(tt__Enabled__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Enabled__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Enabled__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Enabled__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Enabled__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Enabled__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Enabled__(soap, tag ? tag : "tt:Enabled", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Enabled__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Enabled__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Enabled__ * SOAP_FMAC4 soap_get_tt__Enabled__(struct soap *soap, tt__Enabled__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Enabled__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ExposureMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ExposureMode(soap, &this->tt__ExposureMode__::__item);
}

void tt__ExposureMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__ExposureMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ExposureMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureMode__(struct soap *soap, const char *tag, int id, const tt__ExposureMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ExposureMode(soap, tag, id, &a->tt__ExposureMode__::__item, "");
}

void *tt__ExposureMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ExposureMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__ExposureMode__ * SOAP_FMAC4 soap_in_tt__ExposureMode__(struct soap *soap, const char *tag, tt__ExposureMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ExposureMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureMode__, sizeof(tt__ExposureMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ExposureMode__)
		return (tt__ExposureMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ExposureMode(soap, tag, &a->tt__ExposureMode__::__item, "tt:ExposureMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ExposureMode__ * SOAP_FMAC2 soap_instantiate_tt__ExposureMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ExposureMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ExposureMode__ *p;
	size_t k = sizeof(tt__ExposureMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ExposureMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ExposureMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ExposureMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ExposureMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ExposureMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ExposureMode__(soap, tag ? tag : "tt:ExposureMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ExposureMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ExposureMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__ExposureMode__ * SOAP_FMAC4 soap_get_tt__ExposureMode__(struct soap *soap, tt__ExposureMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ExposurePriority__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ExposurePriority(soap, &this->tt__ExposurePriority__::__item);
}

void tt__ExposurePriority__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ExposurePriority__::__item, SOAP_TYPE_tt__ExposurePriority);
#endif
}

int tt__ExposurePriority__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ExposurePriority__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposurePriority__(struct soap *soap, const char *tag, int id, const tt__ExposurePriority__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ExposurePriority(soap, tag, id, &a->tt__ExposurePriority__::__item, "");
}

void *tt__ExposurePriority__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ExposurePriority__(soap, tag, this, type);
}

SOAP_FMAC3 tt__ExposurePriority__ * SOAP_FMAC4 soap_in_tt__ExposurePriority__(struct soap *soap, const char *tag, tt__ExposurePriority__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ExposurePriority__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposurePriority__, sizeof(tt__ExposurePriority__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ExposurePriority__)
		return (tt__ExposurePriority__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ExposurePriority(soap, tag, &a->tt__ExposurePriority__::__item, "tt:ExposurePriority"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ExposurePriority__ * SOAP_FMAC2 soap_instantiate_tt__ExposurePriority__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ExposurePriority__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ExposurePriority__ *p;
	size_t k = sizeof(tt__ExposurePriority__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ExposurePriority__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ExposurePriority__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ExposurePriority__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ExposurePriority__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ExposurePriority__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ExposurePriority__(soap, tag ? tag : "tt:ExposurePriority", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ExposurePriority__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ExposurePriority__(soap, this, tag, type);
}

SOAP_FMAC3 tt__ExposurePriority__ * SOAP_FMAC4 soap_get_tt__ExposurePriority__(struct soap *soap, tt__ExposurePriority__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposurePriority__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BacklightCompensationMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__BacklightCompensationMode(soap, &this->tt__BacklightCompensationMode__::__item);
}

void tt__BacklightCompensationMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__BacklightCompensationMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensationMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationMode__(struct soap *soap, const char *tag, int id, const tt__BacklightCompensationMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__BacklightCompensationMode(soap, tag, id, &a->tt__BacklightCompensationMode__::__item, "");
}

void *tt__BacklightCompensationMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BacklightCompensationMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensationMode__ * SOAP_FMAC4 soap_in_tt__BacklightCompensationMode__(struct soap *soap, const char *tag, tt__BacklightCompensationMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__BacklightCompensationMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationMode__, sizeof(tt__BacklightCompensationMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BacklightCompensationMode__)
		return (tt__BacklightCompensationMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__BacklightCompensationMode(soap, tag, &a->tt__BacklightCompensationMode__::__item, "tt:BacklightCompensationMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__BacklightCompensationMode__ * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BacklightCompensationMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BacklightCompensationMode__ *p;
	size_t k = sizeof(tt__BacklightCompensationMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BacklightCompensationMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BacklightCompensationMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BacklightCompensationMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BacklightCompensationMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BacklightCompensationMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BacklightCompensationMode__(soap, tag ? tag : "tt:BacklightCompensationMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensationMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensationMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensationMode__ * SOAP_FMAC4 soap_get_tt__BacklightCompensationMode__(struct soap *soap, tt__BacklightCompensationMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WideDynamicMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__WideDynamicMode(soap, &this->tt__WideDynamicMode__::__item);
}

void tt__WideDynamicMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__WideDynamicMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicMode__(struct soap *soap, const char *tag, int id, const tt__WideDynamicMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__WideDynamicMode(soap, tag, id, &a->tt__WideDynamicMode__::__item, "");
}

void *tt__WideDynamicMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WideDynamicMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicMode__ * SOAP_FMAC4 soap_in_tt__WideDynamicMode__(struct soap *soap, const char *tag, tt__WideDynamicMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__WideDynamicMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicMode__, sizeof(tt__WideDynamicMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WideDynamicMode__)
		return (tt__WideDynamicMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__WideDynamicMode(soap, tag, &a->tt__WideDynamicMode__::__item, "tt:WideDynamicMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__WideDynamicMode__ * SOAP_FMAC2 soap_instantiate_tt__WideDynamicMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WideDynamicMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WideDynamicMode__ *p;
	size_t k = sizeof(tt__WideDynamicMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WideDynamicMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WideDynamicMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WideDynamicMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WideDynamicMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WideDynamicMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WideDynamicMode__(soap, tag ? tag : "tt:WideDynamicMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicMode__ * SOAP_FMAC4 soap_get_tt__WideDynamicMode__(struct soap *soap, tt__WideDynamicMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AutoFocusMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__AutoFocusMode(soap, &this->tt__AutoFocusMode__::__item);
}

void tt__AutoFocusMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__AutoFocusMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AutoFocusMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AutoFocusMode__(struct soap *soap, const char *tag, int id, const tt__AutoFocusMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__AutoFocusMode(soap, tag, id, &a->tt__AutoFocusMode__::__item, "");
}

void *tt__AutoFocusMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AutoFocusMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__AutoFocusMode__ * SOAP_FMAC4 soap_in_tt__AutoFocusMode__(struct soap *soap, const char *tag, tt__AutoFocusMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__AutoFocusMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AutoFocusMode__, sizeof(tt__AutoFocusMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AutoFocusMode__)
		return (tt__AutoFocusMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__AutoFocusMode(soap, tag, &a->tt__AutoFocusMode__::__item, "tt:AutoFocusMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__AutoFocusMode__ * SOAP_FMAC2 soap_instantiate_tt__AutoFocusMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AutoFocusMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AutoFocusMode__ *p;
	size_t k = sizeof(tt__AutoFocusMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AutoFocusMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AutoFocusMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AutoFocusMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AutoFocusMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AutoFocusMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AutoFocusMode__(soap, tag ? tag : "tt:AutoFocusMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AutoFocusMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AutoFocusMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__AutoFocusMode__ * SOAP_FMAC4 soap_get_tt__AutoFocusMode__(struct soap *soap, tt__AutoFocusMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AutoFocusMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourOperation__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__PTZPresetTourOperation(soap, &this->tt__PTZPresetTourOperation__::__item);
}

void tt__PTZPresetTourOperation__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZPresetTourOperation__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourOperation__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourOperation__(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourOperation__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__PTZPresetTourOperation(soap, tag, id, &a->tt__PTZPresetTourOperation__::__item, "");
}

void *tt__PTZPresetTourOperation__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourOperation__(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourOperation__ * SOAP_FMAC4 soap_in_tt__PTZPresetTourOperation__(struct soap *soap, const char *tag, tt__PTZPresetTourOperation__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__PTZPresetTourOperation__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourOperation__, sizeof(tt__PTZPresetTourOperation__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourOperation__)
		return (tt__PTZPresetTourOperation__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__PTZPresetTourOperation(soap, tag, &a->tt__PTZPresetTourOperation__::__item, "tt:PTZPresetTourOperation"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourOperation__ * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourOperation__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourOperation__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourOperation__ *p;
	size_t k = sizeof(tt__PTZPresetTourOperation__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourOperation__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourOperation__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourOperation__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourOperation__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourOperation__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourOperation__(soap, tag ? tag : "tt:PTZPresetTourOperation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourOperation__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourOperation__(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourOperation__ * SOAP_FMAC4 soap_get_tt__PTZPresetTourOperation__(struct soap *soap, tt__PTZPresetTourOperation__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourOperation__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourDirection__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__PTZPresetTourDirection(soap, &this->tt__PTZPresetTourDirection__::__item);
}

void tt__PTZPresetTourDirection__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZPresetTourDirection__::__item, SOAP_TYPE_tt__PTZPresetTourDirection);
#endif
}

int tt__PTZPresetTourDirection__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourDirection__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourDirection__(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourDirection__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__PTZPresetTourDirection(soap, tag, id, &a->tt__PTZPresetTourDirection__::__item, "");
}

void *tt__PTZPresetTourDirection__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourDirection__(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourDirection__ * SOAP_FMAC4 soap_in_tt__PTZPresetTourDirection__(struct soap *soap, const char *tag, tt__PTZPresetTourDirection__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__PTZPresetTourDirection__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourDirection__, sizeof(tt__PTZPresetTourDirection__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourDirection__)
		return (tt__PTZPresetTourDirection__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__PTZPresetTourDirection(soap, tag, &a->tt__PTZPresetTourDirection__::__item, "tt:PTZPresetTourDirection"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourDirection__ * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourDirection__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourDirection__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourDirection__ *p;
	size_t k = sizeof(tt__PTZPresetTourDirection__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourDirection__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourDirection__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourDirection__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourDirection__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourDirection__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourDirection__(soap, tag ? tag : "tt:PTZPresetTourDirection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourDirection__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourDirection__(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourDirection__ * SOAP_FMAC4 soap_get_tt__PTZPresetTourDirection__(struct soap *soap, tt__PTZPresetTourDirection__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourDirection__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourState__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__PTZPresetTourState(soap, &this->tt__PTZPresetTourState__::__item);
}

void tt__PTZPresetTourState__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZPresetTourState__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourState__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourState__(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourState__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__PTZPresetTourState(soap, tag, id, &a->tt__PTZPresetTourState__::__item, "");
}

void *tt__PTZPresetTourState__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourState__(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourState__ * SOAP_FMAC4 soap_in_tt__PTZPresetTourState__(struct soap *soap, const char *tag, tt__PTZPresetTourState__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__PTZPresetTourState__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourState__, sizeof(tt__PTZPresetTourState__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourState__)
		return (tt__PTZPresetTourState__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__PTZPresetTourState(soap, tag, &a->tt__PTZPresetTourState__::__item, "tt:PTZPresetTourState"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourState__ * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourState__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourState__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourState__ *p;
	size_t k = sizeof(tt__PTZPresetTourState__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourState__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourState__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourState__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourState__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourState__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourState__(soap, tag ? tag : "tt:PTZPresetTourState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourState__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourState__(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourState__ * SOAP_FMAC4 soap_get_tt__PTZPresetTourState__(struct soap *soap, tt__PTZPresetTourState__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourState__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AuxiliaryData__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &this->tt__AuxiliaryData__::__item);
}

void tt__AuxiliaryData__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AuxiliaryData__::__item, SOAP_TYPE_tt__AuxiliaryData);
	soap_serialize_tt__AuxiliaryData(soap, &this->tt__AuxiliaryData__::__item);
#endif
}

int tt__AuxiliaryData__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AuxiliaryData__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AuxiliaryData__(struct soap *soap, const char *tag, int id, const tt__AuxiliaryData__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__AuxiliaryData(soap, tag, id, &a->tt__AuxiliaryData__::__item, "");
}

void *tt__AuxiliaryData__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AuxiliaryData__(soap, tag, this, type);
}

SOAP_FMAC3 tt__AuxiliaryData__ * SOAP_FMAC4 soap_in_tt__AuxiliaryData__(struct soap *soap, const char *tag, tt__AuxiliaryData__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__AuxiliaryData__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AuxiliaryData__, sizeof(tt__AuxiliaryData__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AuxiliaryData__)
		return (tt__AuxiliaryData__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__AuxiliaryData(soap, tag, &a->tt__AuxiliaryData__::__item, "tt:AuxiliaryData"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__AuxiliaryData__ * SOAP_FMAC2 soap_instantiate_tt__AuxiliaryData__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AuxiliaryData__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AuxiliaryData__ *p;
	size_t k = sizeof(tt__AuxiliaryData__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AuxiliaryData__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AuxiliaryData__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AuxiliaryData__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AuxiliaryData__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AuxiliaryData__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AuxiliaryData__(soap, tag ? tag : "tt:AuxiliaryData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AuxiliaryData__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AuxiliaryData__(soap, this, tag, type);
}

SOAP_FMAC3 tt__AuxiliaryData__ * SOAP_FMAC4 soap_get_tt__AuxiliaryData__(struct soap *soap, tt__AuxiliaryData__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AuxiliaryData__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AuxiliaryData(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AuxiliaryData(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__AuxiliaryData), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__AuxiliaryData(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 128, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__AuxiliaryData, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AuxiliaryData(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__AuxiliaryData(soap, tag ? tag : "tt:AuxiliaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__AuxiliaryData(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReverseMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReverseMode(soap, &this->tt__ReverseMode__::__item);
}

void tt__ReverseMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__ReverseMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReverseMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseMode__(struct soap *soap, const char *tag, int id, const tt__ReverseMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ReverseMode(soap, tag, id, &a->tt__ReverseMode__::__item, "");
}

void *tt__ReverseMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReverseMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReverseMode__ * SOAP_FMAC4 soap_in_tt__ReverseMode__(struct soap *soap, const char *tag, tt__ReverseMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ReverseMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseMode__, sizeof(tt__ReverseMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReverseMode__)
		return (tt__ReverseMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ReverseMode(soap, tag, &a->tt__ReverseMode__::__item, "tt:ReverseMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ReverseMode__ * SOAP_FMAC2 soap_instantiate_tt__ReverseMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReverseMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReverseMode__ *p;
	size_t k = sizeof(tt__ReverseMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReverseMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReverseMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReverseMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReverseMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReverseMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReverseMode__(soap, tag ? tag : "tt:ReverseMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReverseMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReverseMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReverseMode__ * SOAP_FMAC4 soap_get_tt__ReverseMode__(struct soap *soap, tt__ReverseMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EFlipMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__EFlipMode(soap, &this->tt__EFlipMode__::__item);
}

void tt__EFlipMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__EFlipMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EFlipMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipMode__(struct soap *soap, const char *tag, int id, const tt__EFlipMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__EFlipMode(soap, tag, id, &a->tt__EFlipMode__::__item, "");
}

void *tt__EFlipMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EFlipMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__EFlipMode__ * SOAP_FMAC4 soap_in_tt__EFlipMode__(struct soap *soap, const char *tag, tt__EFlipMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__EFlipMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipMode__, sizeof(tt__EFlipMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EFlipMode__)
		return (tt__EFlipMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__EFlipMode(soap, tag, &a->tt__EFlipMode__::__item, "tt:EFlipMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__EFlipMode__ * SOAP_FMAC2 soap_instantiate_tt__EFlipMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EFlipMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EFlipMode__ *p;
	size_t k = sizeof(tt__EFlipMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EFlipMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EFlipMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EFlipMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EFlipMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EFlipMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EFlipMode__(soap, tag ? tag : "tt:EFlipMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EFlipMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EFlipMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__EFlipMode__ * SOAP_FMAC4 soap_get_tt__EFlipMode__(struct soap *soap, tt__EFlipMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DigitalIdleState__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__DigitalIdleState(soap, &this->tt__DigitalIdleState__::__item);
}

void tt__DigitalIdleState__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DigitalIdleState__::__item, SOAP_TYPE_tt__DigitalIdleState);
#endif
}

int tt__DigitalIdleState__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DigitalIdleState__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DigitalIdleState__(struct soap *soap, const char *tag, int id, const tt__DigitalIdleState__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__DigitalIdleState(soap, tag, id, &a->tt__DigitalIdleState__::__item, "");
}

void *tt__DigitalIdleState__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DigitalIdleState__(soap, tag, this, type);
}

SOAP_FMAC3 tt__DigitalIdleState__ * SOAP_FMAC4 soap_in_tt__DigitalIdleState__(struct soap *soap, const char *tag, tt__DigitalIdleState__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__DigitalIdleState__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DigitalIdleState__, sizeof(tt__DigitalIdleState__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DigitalIdleState__)
		return (tt__DigitalIdleState__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__DigitalIdleState(soap, tag, &a->tt__DigitalIdleState__::__item, "tt:DigitalIdleState"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__DigitalIdleState__ * SOAP_FMAC2 soap_instantiate_tt__DigitalIdleState__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DigitalIdleState__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DigitalIdleState__ *p;
	size_t k = sizeof(tt__DigitalIdleState__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DigitalIdleState__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DigitalIdleState__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DigitalIdleState__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DigitalIdleState__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DigitalIdleState__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DigitalIdleState__(soap, tag ? tag : "tt:DigitalIdleState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DigitalIdleState__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DigitalIdleState__(soap, this, tag, type);
}

SOAP_FMAC3 tt__DigitalIdleState__ * SOAP_FMAC4 soap_get_tt__DigitalIdleState__(struct soap *soap, tt__DigitalIdleState__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DigitalIdleState__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelayMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RelayMode(soap, &this->tt__RelayMode__::__item);
}

void tt__RelayMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__RelayMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelayMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayMode__(struct soap *soap, const char *tag, int id, const tt__RelayMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__RelayMode(soap, tag, id, &a->tt__RelayMode__::__item, "");
}

void *tt__RelayMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelayMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelayMode__ * SOAP_FMAC4 soap_in_tt__RelayMode__(struct soap *soap, const char *tag, tt__RelayMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__RelayMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayMode__, sizeof(tt__RelayMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelayMode__)
		return (tt__RelayMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__RelayMode(soap, tag, &a->tt__RelayMode__::__item, "tt:RelayMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__RelayMode__ * SOAP_FMAC2 soap_instantiate_tt__RelayMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelayMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelayMode__ *p;
	size_t k = sizeof(tt__RelayMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelayMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelayMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelayMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelayMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelayMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelayMode__(soap, tag ? tag : "tt:RelayMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelayMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelayMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelayMode__ * SOAP_FMAC4 soap_get_tt__RelayMode__(struct soap *soap, tt__RelayMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelayIdleState__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RelayIdleState(soap, &this->tt__RelayIdleState__::__item);
}

void tt__RelayIdleState__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__RelayIdleState__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelayIdleState__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayIdleState__(struct soap *soap, const char *tag, int id, const tt__RelayIdleState__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__RelayIdleState(soap, tag, id, &a->tt__RelayIdleState__::__item, "");
}

void *tt__RelayIdleState__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelayIdleState__(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelayIdleState__ * SOAP_FMAC4 soap_in_tt__RelayIdleState__(struct soap *soap, const char *tag, tt__RelayIdleState__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__RelayIdleState__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayIdleState__, sizeof(tt__RelayIdleState__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelayIdleState__)
		return (tt__RelayIdleState__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__RelayIdleState(soap, tag, &a->tt__RelayIdleState__::__item, "tt:RelayIdleState"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__RelayIdleState__ * SOAP_FMAC2 soap_instantiate_tt__RelayIdleState__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelayIdleState__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelayIdleState__ *p;
	size_t k = sizeof(tt__RelayIdleState__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelayIdleState__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelayIdleState__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelayIdleState__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelayIdleState__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelayIdleState__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelayIdleState__(soap, tag ? tag : "tt:RelayIdleState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelayIdleState__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelayIdleState__(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelayIdleState__ * SOAP_FMAC4 soap_get_tt__RelayIdleState__(struct soap *soap, tt__RelayIdleState__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayIdleState__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelayLogicalState__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RelayLogicalState(soap, &this->tt__RelayLogicalState__::__item);
}

void tt__RelayLogicalState__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__RelayLogicalState__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelayLogicalState__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayLogicalState__(struct soap *soap, const char *tag, int id, const tt__RelayLogicalState__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__RelayLogicalState(soap, tag, id, &a->tt__RelayLogicalState__::__item, "");
}

void *tt__RelayLogicalState__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelayLogicalState__(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelayLogicalState__ * SOAP_FMAC4 soap_in_tt__RelayLogicalState__(struct soap *soap, const char *tag, tt__RelayLogicalState__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__RelayLogicalState__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayLogicalState__, sizeof(tt__RelayLogicalState__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelayLogicalState__)
		return (tt__RelayLogicalState__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__RelayLogicalState(soap, tag, &a->tt__RelayLogicalState__::__item, "tt:RelayLogicalState"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__RelayLogicalState__ * SOAP_FMAC2 soap_instantiate_tt__RelayLogicalState__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelayLogicalState__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelayLogicalState__ *p;
	size_t k = sizeof(tt__RelayLogicalState__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelayLogicalState__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelayLogicalState__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelayLogicalState__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelayLogicalState__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelayLogicalState__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelayLogicalState__(soap, tag ? tag : "tt:RelayLogicalState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelayLogicalState__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelayLogicalState__(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelayLogicalState__ * SOAP_FMAC4 soap_get_tt__RelayLogicalState__(struct soap *soap, tt__RelayLogicalState__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayLogicalState__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__UserLevel__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__UserLevel(soap, &this->tt__UserLevel__::__item);
}

void tt__UserLevel__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__UserLevel__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__UserLevel__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserLevel__(struct soap *soap, const char *tag, int id, const tt__UserLevel__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__UserLevel(soap, tag, id, &a->tt__UserLevel__::__item, "");
}

void *tt__UserLevel__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__UserLevel__(soap, tag, this, type);
}

SOAP_FMAC3 tt__UserLevel__ * SOAP_FMAC4 soap_in_tt__UserLevel__(struct soap *soap, const char *tag, tt__UserLevel__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__UserLevel__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserLevel__, sizeof(tt__UserLevel__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__UserLevel__)
		return (tt__UserLevel__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__UserLevel(soap, tag, &a->tt__UserLevel__::__item, "tt:UserLevel"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__UserLevel__ * SOAP_FMAC2 soap_instantiate_tt__UserLevel__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__UserLevel__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__UserLevel__ *p;
	size_t k = sizeof(tt__UserLevel__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__UserLevel__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__UserLevel__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__UserLevel__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__UserLevel__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__UserLevel__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__UserLevel__(soap, tag ? tag : "tt:UserLevel", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__UserLevel__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__UserLevel__(soap, this, tag, type);
}

SOAP_FMAC3 tt__UserLevel__ * SOAP_FMAC4 soap_get_tt__UserLevel__(struct soap *soap, tt__UserLevel__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserLevel__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SetDateTimeType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__SetDateTimeType(soap, &this->tt__SetDateTimeType__::__item);
}

void tt__SetDateTimeType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__SetDateTimeType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SetDateTimeType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SetDateTimeType__(struct soap *soap, const char *tag, int id, const tt__SetDateTimeType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__SetDateTimeType(soap, tag, id, &a->tt__SetDateTimeType__::__item, "");
}

void *tt__SetDateTimeType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SetDateTimeType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__SetDateTimeType__ * SOAP_FMAC4 soap_in_tt__SetDateTimeType__(struct soap *soap, const char *tag, tt__SetDateTimeType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__SetDateTimeType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SetDateTimeType__, sizeof(tt__SetDateTimeType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SetDateTimeType__)
		return (tt__SetDateTimeType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__SetDateTimeType(soap, tag, &a->tt__SetDateTimeType__::__item, "tt:SetDateTimeType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__SetDateTimeType__ * SOAP_FMAC2 soap_instantiate_tt__SetDateTimeType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SetDateTimeType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SetDateTimeType__ *p;
	size_t k = sizeof(tt__SetDateTimeType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SetDateTimeType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SetDateTimeType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SetDateTimeType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SetDateTimeType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SetDateTimeType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SetDateTimeType__(soap, tag ? tag : "tt:SetDateTimeType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SetDateTimeType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SetDateTimeType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__SetDateTimeType__ * SOAP_FMAC4 soap_get_tt__SetDateTimeType__(struct soap *soap, tt__SetDateTimeType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SetDateTimeType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FactoryDefaultType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__FactoryDefaultType(soap, &this->tt__FactoryDefaultType__::__item);
}

void tt__FactoryDefaultType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__FactoryDefaultType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FactoryDefaultType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FactoryDefaultType__(struct soap *soap, const char *tag, int id, const tt__FactoryDefaultType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__FactoryDefaultType(soap, tag, id, &a->tt__FactoryDefaultType__::__item, "");
}

void *tt__FactoryDefaultType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FactoryDefaultType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__FactoryDefaultType__ * SOAP_FMAC4 soap_in_tt__FactoryDefaultType__(struct soap *soap, const char *tag, tt__FactoryDefaultType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__FactoryDefaultType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FactoryDefaultType__, sizeof(tt__FactoryDefaultType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FactoryDefaultType__)
		return (tt__FactoryDefaultType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__FactoryDefaultType(soap, tag, &a->tt__FactoryDefaultType__::__item, "tt:FactoryDefaultType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__FactoryDefaultType__ * SOAP_FMAC2 soap_instantiate_tt__FactoryDefaultType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FactoryDefaultType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FactoryDefaultType__ *p;
	size_t k = sizeof(tt__FactoryDefaultType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FactoryDefaultType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FactoryDefaultType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FactoryDefaultType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FactoryDefaultType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FactoryDefaultType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FactoryDefaultType__(soap, tag ? tag : "tt:FactoryDefaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FactoryDefaultType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FactoryDefaultType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__FactoryDefaultType__ * SOAP_FMAC4 soap_get_tt__FactoryDefaultType__(struct soap *soap, tt__FactoryDefaultType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FactoryDefaultType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemLogType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__SystemLogType(soap, &this->tt__SystemLogType__::__item);
}

void tt__SystemLogType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__SystemLogType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemLogType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogType__(struct soap *soap, const char *tag, int id, const tt__SystemLogType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__SystemLogType(soap, tag, id, &a->tt__SystemLogType__::__item, "");
}

void *tt__SystemLogType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemLogType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemLogType__ * SOAP_FMAC4 soap_in_tt__SystemLogType__(struct soap *soap, const char *tag, tt__SystemLogType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__SystemLogType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogType__, sizeof(tt__SystemLogType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemLogType__)
		return (tt__SystemLogType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__SystemLogType(soap, tag, &a->tt__SystemLogType__::__item, "tt:SystemLogType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__SystemLogType__ * SOAP_FMAC2 soap_instantiate_tt__SystemLogType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemLogType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemLogType__ *p;
	size_t k = sizeof(tt__SystemLogType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemLogType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemLogType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemLogType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemLogType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemLogType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemLogType__(soap, tag ? tag : "tt:SystemLogType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemLogType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemLogType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemLogType__ * SOAP_FMAC4 soap_get_tt__SystemLogType__(struct soap *soap, tt__SystemLogType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CapabilityCategory__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__CapabilityCategory(soap, &this->tt__CapabilityCategory__::__item);
}

void tt__CapabilityCategory__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__CapabilityCategory__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CapabilityCategory__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilityCategory__(struct soap *soap, const char *tag, int id, const tt__CapabilityCategory__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__CapabilityCategory(soap, tag, id, &a->tt__CapabilityCategory__::__item, "");
}

void *tt__CapabilityCategory__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CapabilityCategory__(soap, tag, this, type);
}

SOAP_FMAC3 tt__CapabilityCategory__ * SOAP_FMAC4 soap_in_tt__CapabilityCategory__(struct soap *soap, const char *tag, tt__CapabilityCategory__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__CapabilityCategory__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilityCategory__, sizeof(tt__CapabilityCategory__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CapabilityCategory__)
		return (tt__CapabilityCategory__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__CapabilityCategory(soap, tag, &a->tt__CapabilityCategory__::__item, "tt:CapabilityCategory"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__CapabilityCategory__ * SOAP_FMAC2 soap_instantiate_tt__CapabilityCategory__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CapabilityCategory__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CapabilityCategory__ *p;
	size_t k = sizeof(tt__CapabilityCategory__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CapabilityCategory__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CapabilityCategory__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CapabilityCategory__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CapabilityCategory__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CapabilityCategory__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CapabilityCategory__(soap, tag ? tag : "tt:CapabilityCategory", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CapabilityCategory__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CapabilityCategory__(soap, this, tag, type);
}

SOAP_FMAC3 tt__CapabilityCategory__ * SOAP_FMAC4 soap_get_tt__CapabilityCategory__(struct soap *soap, tt__CapabilityCategory__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilityCategory__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11AuthAndMangementSuite__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Dot11AuthAndMangementSuite(soap, &this->tt__Dot11AuthAndMangementSuite__::__item);
}

void tt__Dot11AuthAndMangementSuite__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Dot11AuthAndMangementSuite__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11AuthAndMangementSuite__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AuthAndMangementSuite__(struct soap *soap, const char *tag, int id, const tt__Dot11AuthAndMangementSuite__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Dot11AuthAndMangementSuite(soap, tag, id, &a->tt__Dot11AuthAndMangementSuite__::__item, "");
}

void *tt__Dot11AuthAndMangementSuite__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11AuthAndMangementSuite__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11AuthAndMangementSuite__ * SOAP_FMAC4 soap_in_tt__Dot11AuthAndMangementSuite__(struct soap *soap, const char *tag, tt__Dot11AuthAndMangementSuite__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot11AuthAndMangementSuite__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite__, sizeof(tt__Dot11AuthAndMangementSuite__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11AuthAndMangementSuite__)
		return (tt__Dot11AuthAndMangementSuite__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, &a->tt__Dot11AuthAndMangementSuite__::__item, "tt:Dot11AuthAndMangementSuite"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot11AuthAndMangementSuite__ * SOAP_FMAC2 soap_instantiate_tt__Dot11AuthAndMangementSuite__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11AuthAndMangementSuite__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11AuthAndMangementSuite__ *p;
	size_t k = sizeof(tt__Dot11AuthAndMangementSuite__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11AuthAndMangementSuite__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11AuthAndMangementSuite__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11AuthAndMangementSuite__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11AuthAndMangementSuite__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11AuthAndMangementSuite__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11AuthAndMangementSuite__(soap, tag ? tag : "tt:Dot11AuthAndMangementSuite", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11AuthAndMangementSuite__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11AuthAndMangementSuite__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11AuthAndMangementSuite__ * SOAP_FMAC4 soap_get_tt__Dot11AuthAndMangementSuite__(struct soap *soap, tt__Dot11AuthAndMangementSuite__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AuthAndMangementSuite__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11SignalStrength__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Dot11SignalStrength(soap, &this->tt__Dot11SignalStrength__::__item);
}

void tt__Dot11SignalStrength__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Dot11SignalStrength__::__item, SOAP_TYPE_tt__Dot11SignalStrength);
#endif
}

int tt__Dot11SignalStrength__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11SignalStrength__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SignalStrength__(struct soap *soap, const char *tag, int id, const tt__Dot11SignalStrength__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Dot11SignalStrength(soap, tag, id, &a->tt__Dot11SignalStrength__::__item, "");
}

void *tt__Dot11SignalStrength__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11SignalStrength__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11SignalStrength__ * SOAP_FMAC4 soap_in_tt__Dot11SignalStrength__(struct soap *soap, const char *tag, tt__Dot11SignalStrength__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot11SignalStrength__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SignalStrength__, sizeof(tt__Dot11SignalStrength__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11SignalStrength__)
		return (tt__Dot11SignalStrength__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Dot11SignalStrength(soap, tag, &a->tt__Dot11SignalStrength__::__item, "tt:Dot11SignalStrength"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot11SignalStrength__ * SOAP_FMAC2 soap_instantiate_tt__Dot11SignalStrength__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11SignalStrength__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11SignalStrength__ *p;
	size_t k = sizeof(tt__Dot11SignalStrength__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11SignalStrength__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11SignalStrength__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11SignalStrength__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11SignalStrength__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11SignalStrength__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11SignalStrength__(soap, tag ? tag : "tt:Dot11SignalStrength", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11SignalStrength__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11SignalStrength__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11SignalStrength__ * SOAP_FMAC4 soap_get_tt__Dot11SignalStrength__(struct soap *soap, tt__Dot11SignalStrength__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SignalStrength__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11PSKPassphrase__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Dot11PSKPassphrase(soap, &this->tt__Dot11PSKPassphrase__::__item);
}

void tt__Dot11PSKPassphrase__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Dot11PSKPassphrase__::__item, SOAP_TYPE_tt__Dot11PSKPassphrase);
	soap_serialize_tt__Dot11PSKPassphrase(soap, &this->tt__Dot11PSKPassphrase__::__item);
#endif
}

int tt__Dot11PSKPassphrase__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11PSKPassphrase__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKPassphrase__(struct soap *soap, const char *tag, int id, const tt__Dot11PSKPassphrase__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Dot11PSKPassphrase(soap, tag, id, &a->tt__Dot11PSKPassphrase__::__item, "");
}

void *tt__Dot11PSKPassphrase__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11PSKPassphrase__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11PSKPassphrase__ * SOAP_FMAC4 soap_in_tt__Dot11PSKPassphrase__(struct soap *soap, const char *tag, tt__Dot11PSKPassphrase__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot11PSKPassphrase__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKPassphrase__, sizeof(tt__Dot11PSKPassphrase__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11PSKPassphrase__)
		return (tt__Dot11PSKPassphrase__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Dot11PSKPassphrase(soap, tag, &a->tt__Dot11PSKPassphrase__::__item, "tt:Dot11PSKPassphrase"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot11PSKPassphrase__ * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKPassphrase__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11PSKPassphrase__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11PSKPassphrase__ *p;
	size_t k = sizeof(tt__Dot11PSKPassphrase__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11PSKPassphrase__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11PSKPassphrase__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11PSKPassphrase__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11PSKPassphrase__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11PSKPassphrase__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11PSKPassphrase__(soap, tag ? tag : "tt:Dot11PSKPassphrase", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11PSKPassphrase__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11PSKPassphrase__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11PSKPassphrase__ * SOAP_FMAC4 soap_get_tt__Dot11PSKPassphrase__(struct soap *soap, tt__Dot11PSKPassphrase__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKPassphrase__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSKPassphrase(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__Dot11PSKPassphrase), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Dot11PSKPassphrase, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[ -~]{8,63}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Dot11PSKPassphrase, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__Dot11PSKPassphrase, SOAP_TYPE_tt__Dot11PSKPassphrase, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKPassphrase(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11PSKPassphrase(soap, tag ? tag : "tt:Dot11PSKPassphrase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__Dot11PSKPassphrase(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKPassphrase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11PSK__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Dot11PSK(soap, &this->tt__Dot11PSK__::__item);
}

void tt__Dot11PSK__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Dot11PSK__::__item, SOAP_TYPE_tt__Dot11PSK);
	soap_serialize_tt__Dot11PSK(soap, &this->tt__Dot11PSK__::__item);
#endif
}

int tt__Dot11PSK__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11PSK__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSK__(struct soap *soap, const char *tag, int id, const tt__Dot11PSK__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Dot11PSK(soap, tag, id, &a->tt__Dot11PSK__::__item, "");
}

void *tt__Dot11PSK__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11PSK__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11PSK__ * SOAP_FMAC4 soap_in_tt__Dot11PSK__(struct soap *soap, const char *tag, tt__Dot11PSK__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot11PSK__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSK__, sizeof(tt__Dot11PSK__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11PSK__)
		return (tt__Dot11PSK__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Dot11PSK(soap, tag, &a->tt__Dot11PSK__::__item, "tt:Dot11PSK"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot11PSK__ * SOAP_FMAC2 soap_instantiate_tt__Dot11PSK__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11PSK__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11PSK__ *p;
	size_t k = sizeof(tt__Dot11PSK__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11PSK__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11PSK__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11PSK__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11PSK__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11PSK__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11PSK__(soap, tag ? tag : "tt:Dot11PSK", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11PSK__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11PSK__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11PSK__ * SOAP_FMAC4 soap_get_tt__Dot11PSK__(struct soap *soap, tt__Dot11PSK__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSK__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11PSK(struct soap *soap, xsd__hexBinary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSK(struct soap *soap, const xsd__hexBinary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_tt__Dot11PSK);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11PSK2s(struct soap *soap, xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSK(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_tt__Dot11PSK, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11PSK(struct soap *soap, const char *s, xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	if (a->__size < 32)
		return soap->error = SOAP_LENGTH;
	if (a->__size > 32)
		return soap->error = SOAP_LENGTH;
	return SOAP_OK;
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_tt__Dot11PSK(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSK, sizeof(xsd__hexBinary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
		if (a->__size < 32)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
		if (a->__size > 32)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSK, SOAP_TYPE_tt__Dot11PSK, sizeof(xsd__hexBinary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSK(struct soap *soap, const xsd__hexBinary *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11PSK(soap, tag ? tag : "tt:Dot11PSK", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_tt__Dot11PSK(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11Cipher__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Dot11Cipher(soap, &this->tt__Dot11Cipher__::__item);
}

void tt__Dot11Cipher__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Dot11Cipher__::__item, SOAP_TYPE_tt__Dot11Cipher);
#endif
}

int tt__Dot11Cipher__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11Cipher__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Cipher__(struct soap *soap, const char *tag, int id, const tt__Dot11Cipher__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Dot11Cipher(soap, tag, id, &a->tt__Dot11Cipher__::__item, "");
}

void *tt__Dot11Cipher__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11Cipher__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11Cipher__ * SOAP_FMAC4 soap_in_tt__Dot11Cipher__(struct soap *soap, const char *tag, tt__Dot11Cipher__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot11Cipher__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Cipher__, sizeof(tt__Dot11Cipher__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11Cipher__)
		return (tt__Dot11Cipher__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Dot11Cipher(soap, tag, &a->tt__Dot11Cipher__::__item, "tt:Dot11Cipher"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot11Cipher__ * SOAP_FMAC2 soap_instantiate_tt__Dot11Cipher__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11Cipher__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11Cipher__ *p;
	size_t k = sizeof(tt__Dot11Cipher__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11Cipher__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11Cipher__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11Cipher__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11Cipher__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11Cipher__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11Cipher__(soap, tag ? tag : "tt:Dot11Cipher", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11Cipher__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11Cipher__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11Cipher__ * SOAP_FMAC4 soap_get_tt__Dot11Cipher__(struct soap *soap, tt__Dot11Cipher__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Cipher__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11SecurityMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Dot11SecurityMode(soap, &this->tt__Dot11SecurityMode__::__item);
}

void tt__Dot11SecurityMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Dot11SecurityMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11SecurityMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityMode__(struct soap *soap, const char *tag, int id, const tt__Dot11SecurityMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Dot11SecurityMode(soap, tag, id, &a->tt__Dot11SecurityMode__::__item, "");
}

void *tt__Dot11SecurityMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11SecurityMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11SecurityMode__ * SOAP_FMAC4 soap_in_tt__Dot11SecurityMode__(struct soap *soap, const char *tag, tt__Dot11SecurityMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot11SecurityMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityMode__, sizeof(tt__Dot11SecurityMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11SecurityMode__)
		return (tt__Dot11SecurityMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Dot11SecurityMode(soap, tag, &a->tt__Dot11SecurityMode__::__item, "tt:Dot11SecurityMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot11SecurityMode__ * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11SecurityMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11SecurityMode__ *p;
	size_t k = sizeof(tt__Dot11SecurityMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11SecurityMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11SecurityMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11SecurityMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11SecurityMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11SecurityMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11SecurityMode__(soap, tag ? tag : "tt:Dot11SecurityMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11SecurityMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11SecurityMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11SecurityMode__ * SOAP_FMAC4 soap_get_tt__Dot11SecurityMode__(struct soap *soap, tt__Dot11SecurityMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11StationMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Dot11StationMode(soap, &this->tt__Dot11StationMode__::__item);
}

void tt__Dot11StationMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Dot11StationMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11StationMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11StationMode__(struct soap *soap, const char *tag, int id, const tt__Dot11StationMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Dot11StationMode(soap, tag, id, &a->tt__Dot11StationMode__::__item, "");
}

void *tt__Dot11StationMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11StationMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11StationMode__ * SOAP_FMAC4 soap_in_tt__Dot11StationMode__(struct soap *soap, const char *tag, tt__Dot11StationMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot11StationMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11StationMode__, sizeof(tt__Dot11StationMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11StationMode__)
		return (tt__Dot11StationMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Dot11StationMode(soap, tag, &a->tt__Dot11StationMode__::__item, "tt:Dot11StationMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot11StationMode__ * SOAP_FMAC2 soap_instantiate_tt__Dot11StationMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11StationMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11StationMode__ *p;
	size_t k = sizeof(tt__Dot11StationMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11StationMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11StationMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11StationMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11StationMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11StationMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11StationMode__(soap, tag ? tag : "tt:Dot11StationMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11StationMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11StationMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11StationMode__ * SOAP_FMAC4 soap_get_tt__Dot11StationMode__(struct soap *soap, tt__Dot11StationMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11StationMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11SSIDType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &this->tt__Dot11SSIDType__::__item);
}

void tt__Dot11SSIDType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &this->tt__Dot11SSIDType__::__item);
#endif
}

int tt__Dot11SSIDType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11SSIDType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SSIDType__(struct soap *soap, const char *tag, int id, const tt__Dot11SSIDType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Dot11SSIDType(soap, tag, id, &a->tt__Dot11SSIDType__::__item, "");
}

void *tt__Dot11SSIDType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11SSIDType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11SSIDType__ * SOAP_FMAC4 soap_in_tt__Dot11SSIDType__(struct soap *soap, const char *tag, tt__Dot11SSIDType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot11SSIDType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SSIDType__, sizeof(tt__Dot11SSIDType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11SSIDType__)
		return (tt__Dot11SSIDType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Dot11SSIDType(soap, tag, &a->tt__Dot11SSIDType__::__item, "tt:Dot11SSIDType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot11SSIDType__ * SOAP_FMAC2 soap_instantiate_tt__Dot11SSIDType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11SSIDType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11SSIDType__ *p;
	size_t k = sizeof(tt__Dot11SSIDType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11SSIDType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11SSIDType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11SSIDType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11SSIDType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11SSIDType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11SSIDType__(soap, tag ? tag : "tt:Dot11SSIDType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11SSIDType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11SSIDType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11SSIDType__ * SOAP_FMAC4 soap_get_tt__Dot11SSIDType__(struct soap *soap, tt__Dot11SSIDType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SSIDType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11SSIDType(struct soap *soap, xsd__hexBinary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11SSIDType(struct soap *soap, const xsd__hexBinary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_tt__Dot11SSIDType);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11SSIDType2s(struct soap *soap, xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SSIDType(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_tt__Dot11SSIDType, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11SSIDType(struct soap *soap, const char *s, xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	if (a->__size < 1)
		return soap->error = SOAP_LENGTH;
	if (a->__size > 32)
		return soap->error = SOAP_LENGTH;
	return SOAP_OK;
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_tt__Dot11SSIDType(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SSIDType, sizeof(xsd__hexBinary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
		if (a->__size < 1)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
		if (a->__size > 32)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SSIDType, SOAP_TYPE_tt__Dot11SSIDType, sizeof(xsd__hexBinary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SSIDType(struct soap *soap, const xsd__hexBinary *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11SSIDType(soap, tag ? tag : "tt:Dot11SSIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_tt__Dot11SSIDType(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SSIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DynamicDNSType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__DynamicDNSType(soap, &this->tt__DynamicDNSType__::__item);
}

void tt__DynamicDNSType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__DynamicDNSType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DynamicDNSType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSType__(struct soap *soap, const char *tag, int id, const tt__DynamicDNSType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__DynamicDNSType(soap, tag, id, &a->tt__DynamicDNSType__::__item, "");
}

void *tt__DynamicDNSType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DynamicDNSType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__DynamicDNSType__ * SOAP_FMAC4 soap_in_tt__DynamicDNSType__(struct soap *soap, const char *tag, tt__DynamicDNSType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__DynamicDNSType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSType__, sizeof(tt__DynamicDNSType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DynamicDNSType__)
		return (tt__DynamicDNSType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__DynamicDNSType(soap, tag, &a->tt__DynamicDNSType__::__item, "tt:DynamicDNSType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__DynamicDNSType__ * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DynamicDNSType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DynamicDNSType__ *p;
	size_t k = sizeof(tt__DynamicDNSType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DynamicDNSType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DynamicDNSType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DynamicDNSType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DynamicDNSType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DynamicDNSType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DynamicDNSType__(soap, tag ? tag : "tt:DynamicDNSType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DynamicDNSType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DynamicDNSType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__DynamicDNSType__ * SOAP_FMAC4 soap_get_tt__DynamicDNSType__(struct soap *soap, tt__DynamicDNSType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPAddressFilterType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__IPAddressFilterType(soap, &this->tt__IPAddressFilterType__::__item);
}

void tt__IPAddressFilterType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__IPAddressFilterType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddressFilterType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterType__(struct soap *soap, const char *tag, int id, const tt__IPAddressFilterType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__IPAddressFilterType(soap, tag, id, &a->tt__IPAddressFilterType__::__item, "");
}

void *tt__IPAddressFilterType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPAddressFilterType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddressFilterType__ * SOAP_FMAC4 soap_in_tt__IPAddressFilterType__(struct soap *soap, const char *tag, tt__IPAddressFilterType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IPAddressFilterType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterType__, sizeof(tt__IPAddressFilterType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPAddressFilterType__)
		return (tt__IPAddressFilterType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__IPAddressFilterType(soap, tag, &a->tt__IPAddressFilterType__::__item, "tt:IPAddressFilterType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IPAddressFilterType__ * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilterType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddressFilterType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPAddressFilterType__ *p;
	size_t k = sizeof(tt__IPAddressFilterType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPAddressFilterType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPAddressFilterType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPAddressFilterType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPAddressFilterType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPAddressFilterType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPAddressFilterType__(soap, tag ? tag : "tt:IPAddressFilterType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddressFilterType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddressFilterType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddressFilterType__ * SOAP_FMAC4 soap_get_tt__IPAddressFilterType__(struct soap *soap, tt__IPAddressFilterType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Domain__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Domain(soap, &this->tt__Domain__::__item);
}

void tt__Domain__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Domain(soap, &this->tt__Domain__::__item);
#endif
}

int tt__Domain__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Domain__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Domain__(struct soap *soap, const char *tag, int id, const tt__Domain__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Domain(soap, tag, id, &a->tt__Domain__::__item, "");
}

void *tt__Domain__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Domain__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Domain__ * SOAP_FMAC4 soap_in_tt__Domain__(struct soap *soap, const char *tag, tt__Domain__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Domain__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Domain__, sizeof(tt__Domain__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Domain__)
		return (tt__Domain__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Domain(soap, tag, &a->tt__Domain__::__item, "tt:Domain"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Domain__ * SOAP_FMAC2 soap_instantiate_tt__Domain__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Domain__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Domain__ *p;
	size_t k = sizeof(tt__Domain__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Domain__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Domain__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Domain__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Domain__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Domain__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Domain__(soap, tag ? tag : "tt:Domain", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Domain__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Domain__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Domain__ * SOAP_FMAC4 soap_get_tt__Domain__(struct soap *soap, tt__Domain__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Domain__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DNSName__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__DNSName(soap, &this->tt__DNSName__::__item);
}

void tt__DNSName__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DNSName__::__item, SOAP_TYPE_tt__DNSName);
	soap_serialize_tt__DNSName(soap, &this->tt__DNSName__::__item);
#endif
}

int tt__DNSName__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DNSName__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSName__(struct soap *soap, const char *tag, int id, const tt__DNSName__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__DNSName(soap, tag, id, &a->tt__DNSName__::__item, "");
}

void *tt__DNSName__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DNSName__(soap, tag, this, type);
}

SOAP_FMAC3 tt__DNSName__ * SOAP_FMAC4 soap_in_tt__DNSName__(struct soap *soap, const char *tag, tt__DNSName__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__DNSName__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSName__, sizeof(tt__DNSName__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DNSName__)
		return (tt__DNSName__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__DNSName(soap, tag, &a->tt__DNSName__::__item, "tt:DNSName"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__DNSName__ * SOAP_FMAC2 soap_instantiate_tt__DNSName__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DNSName__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DNSName__ *p;
	size_t k = sizeof(tt__DNSName__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DNSName__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DNSName__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DNSName__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DNSName__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DNSName__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DNSName__(soap, tag ? tag : "tt:DNSName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DNSName__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DNSName__(soap, this, tag, type);
}

SOAP_FMAC3 tt__DNSName__ * SOAP_FMAC4 soap_get_tt__DNSName__(struct soap *soap, tt__DNSName__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSName__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__IPType(soap, &this->tt__IPType__::__item);
}

void tt__IPType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__IPType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPType__(struct soap *soap, const char *tag, int id, const tt__IPType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__IPType(soap, tag, id, &a->tt__IPType__::__item, "");
}

void *tt__IPType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPType__ * SOAP_FMAC4 soap_in_tt__IPType__(struct soap *soap, const char *tag, tt__IPType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IPType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPType__, sizeof(tt__IPType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPType__)
		return (tt__IPType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__IPType(soap, tag, &a->tt__IPType__::__item, "tt:IPType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IPType__ * SOAP_FMAC2 soap_instantiate_tt__IPType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPType__ *p;
	size_t k = sizeof(tt__IPType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPType__(soap, tag ? tag : "tt:IPType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPType__ * SOAP_FMAC4 soap_get_tt__IPType__(struct soap *soap, tt__IPType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__HwAddress__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__HwAddress(soap, &this->tt__HwAddress__::__item);
}

void tt__HwAddress__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__HwAddress(soap, &this->tt__HwAddress__::__item);
#endif
}

int tt__HwAddress__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__HwAddress__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HwAddress__(struct soap *soap, const char *tag, int id, const tt__HwAddress__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__HwAddress(soap, tag, id, &a->tt__HwAddress__::__item, "");
}

void *tt__HwAddress__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__HwAddress__(soap, tag, this, type);
}

SOAP_FMAC3 tt__HwAddress__ * SOAP_FMAC4 soap_in_tt__HwAddress__(struct soap *soap, const char *tag, tt__HwAddress__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__HwAddress__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HwAddress__, sizeof(tt__HwAddress__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__HwAddress__)
		return (tt__HwAddress__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__HwAddress(soap, tag, &a->tt__HwAddress__::__item, "tt:HwAddress"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__HwAddress__ * SOAP_FMAC2 soap_instantiate_tt__HwAddress__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__HwAddress__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__HwAddress__ *p;
	size_t k = sizeof(tt__HwAddress__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__HwAddress__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__HwAddress__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__HwAddress__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__HwAddress__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__HwAddress__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__HwAddress__(soap, tag ? tag : "tt:HwAddress", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__HwAddress__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__HwAddress__(soap, this, tag, type);
}

SOAP_FMAC3 tt__HwAddress__ * SOAP_FMAC4 soap_get_tt__HwAddress__(struct soap *soap, tt__HwAddress__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HwAddress__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6Address__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__IPv6Address(soap, &this->tt__IPv6Address__::__item);
}

void tt__IPv6Address__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IPv6Address__::__item, SOAP_TYPE_tt__IPv6Address);
	soap_serialize_tt__IPv6Address(soap, &this->tt__IPv6Address__::__item);
#endif
}

int tt__IPv6Address__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6Address__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Address__(struct soap *soap, const char *tag, int id, const tt__IPv6Address__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__IPv6Address(soap, tag, id, &a->tt__IPv6Address__::__item, "");
}

void *tt__IPv6Address__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6Address__(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6Address__ * SOAP_FMAC4 soap_in_tt__IPv6Address__(struct soap *soap, const char *tag, tt__IPv6Address__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IPv6Address__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6Address__, sizeof(tt__IPv6Address__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6Address__)
		return (tt__IPv6Address__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__IPv6Address(soap, tag, &a->tt__IPv6Address__::__item, "tt:IPv6Address"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IPv6Address__ * SOAP_FMAC2 soap_instantiate_tt__IPv6Address__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6Address__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6Address__ *p;
	size_t k = sizeof(tt__IPv6Address__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6Address__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6Address__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6Address__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6Address__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6Address__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6Address__(soap, tag ? tag : "tt:IPv6Address", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6Address__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6Address__(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6Address__ * SOAP_FMAC4 soap_get_tt__IPv6Address__(struct soap *soap, tt__IPv6Address__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6Address__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv4Address__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__IPv4Address(soap, &this->tt__IPv4Address__::__item);
}

void tt__IPv4Address__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IPv4Address__::__item, SOAP_TYPE_tt__IPv4Address);
	soap_serialize_tt__IPv4Address(soap, &this->tt__IPv4Address__::__item);
#endif
}

int tt__IPv4Address__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4Address__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Address__(struct soap *soap, const char *tag, int id, const tt__IPv4Address__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__IPv4Address(soap, tag, id, &a->tt__IPv4Address__::__item, "");
}

void *tt__IPv4Address__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv4Address__(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4Address__ * SOAP_FMAC4 soap_in_tt__IPv4Address__(struct soap *soap, const char *tag, tt__IPv4Address__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IPv4Address__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4Address__, sizeof(tt__IPv4Address__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv4Address__)
		return (tt__IPv4Address__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__IPv4Address(soap, tag, &a->tt__IPv4Address__::__item, "tt:IPv4Address"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IPv4Address__ * SOAP_FMAC2 soap_instantiate_tt__IPv4Address__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4Address__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv4Address__ *p;
	size_t k = sizeof(tt__IPv4Address__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv4Address__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv4Address__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv4Address__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv4Address__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv4Address__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv4Address__(soap, tag ? tag : "tt:IPv4Address", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4Address__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4Address__(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4Address__ * SOAP_FMAC4 soap_get_tt__IPv4Address__(struct soap *soap, tt__IPv4Address__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4Address__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkHostType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__NetworkHostType(soap, &this->tt__NetworkHostType__::__item);
}

void tt__NetworkHostType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__NetworkHostType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkHostType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostType__(struct soap *soap, const char *tag, int id, const tt__NetworkHostType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__NetworkHostType(soap, tag, id, &a->tt__NetworkHostType__::__item, "");
}

void *tt__NetworkHostType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkHostType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkHostType__ * SOAP_FMAC4 soap_in_tt__NetworkHostType__(struct soap *soap, const char *tag, tt__NetworkHostType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__NetworkHostType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostType__, sizeof(tt__NetworkHostType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkHostType__)
		return (tt__NetworkHostType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__NetworkHostType(soap, tag, &a->tt__NetworkHostType__::__item, "tt:NetworkHostType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__NetworkHostType__ * SOAP_FMAC2 soap_instantiate_tt__NetworkHostType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkHostType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkHostType__ *p;
	size_t k = sizeof(tt__NetworkHostType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkHostType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkHostType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkHostType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkHostType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkHostType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkHostType__(soap, tag ? tag : "tt:NetworkHostType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkHostType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkHostType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkHostType__ * SOAP_FMAC4 soap_get_tt__NetworkHostType__(struct soap *soap, tt__NetworkHostType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkProtocolType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__NetworkProtocolType(soap, &this->tt__NetworkProtocolType__::__item);
}

void tt__NetworkProtocolType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__NetworkProtocolType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkProtocolType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolType__(struct soap *soap, const char *tag, int id, const tt__NetworkProtocolType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__NetworkProtocolType(soap, tag, id, &a->tt__NetworkProtocolType__::__item, "");
}

void *tt__NetworkProtocolType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkProtocolType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkProtocolType__ * SOAP_FMAC4 soap_in_tt__NetworkProtocolType__(struct soap *soap, const char *tag, tt__NetworkProtocolType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__NetworkProtocolType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolType__, sizeof(tt__NetworkProtocolType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkProtocolType__)
		return (tt__NetworkProtocolType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__NetworkProtocolType(soap, tag, &a->tt__NetworkProtocolType__::__item, "tt:NetworkProtocolType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__NetworkProtocolType__ * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocolType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkProtocolType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkProtocolType__ *p;
	size_t k = sizeof(tt__NetworkProtocolType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkProtocolType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkProtocolType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkProtocolType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkProtocolType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkProtocolType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkProtocolType__(soap, tag ? tag : "tt:NetworkProtocolType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkProtocolType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkProtocolType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkProtocolType__ * SOAP_FMAC4 soap_get_tt__NetworkProtocolType__(struct soap *soap, tt__NetworkProtocolType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6DHCPConfiguration__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__IPv6DHCPConfiguration(soap, &this->tt__IPv6DHCPConfiguration__::__item);
}

void tt__IPv6DHCPConfiguration__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IPv6DHCPConfiguration__::__item, SOAP_TYPE_tt__IPv6DHCPConfiguration);
#endif
}

int tt__IPv6DHCPConfiguration__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6DHCPConfiguration__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6DHCPConfiguration__(struct soap *soap, const char *tag, int id, const tt__IPv6DHCPConfiguration__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__IPv6DHCPConfiguration(soap, tag, id, &a->tt__IPv6DHCPConfiguration__::__item, "");
}

void *tt__IPv6DHCPConfiguration__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6DHCPConfiguration__(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6DHCPConfiguration__ * SOAP_FMAC4 soap_in_tt__IPv6DHCPConfiguration__(struct soap *soap, const char *tag, tt__IPv6DHCPConfiguration__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IPv6DHCPConfiguration__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration__, sizeof(tt__IPv6DHCPConfiguration__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6DHCPConfiguration__)
		return (tt__IPv6DHCPConfiguration__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__IPv6DHCPConfiguration(soap, tag, &a->tt__IPv6DHCPConfiguration__::__item, "tt:IPv6DHCPConfiguration"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IPv6DHCPConfiguration__ * SOAP_FMAC2 soap_instantiate_tt__IPv6DHCPConfiguration__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6DHCPConfiguration__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6DHCPConfiguration__ *p;
	size_t k = sizeof(tt__IPv6DHCPConfiguration__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6DHCPConfiguration__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6DHCPConfiguration__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6DHCPConfiguration__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6DHCPConfiguration__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6DHCPConfiguration__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6DHCPConfiguration__(soap, tag ? tag : "tt:IPv6DHCPConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6DHCPConfiguration__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6DHCPConfiguration__(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6DHCPConfiguration__ * SOAP_FMAC4 soap_get_tt__IPv6DHCPConfiguration__(struct soap *soap, tt__IPv6DHCPConfiguration__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6DHCPConfiguration__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IANA_IfTypes__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__IANA_IfTypes(soap, &this->tt__IANA_IfTypes__::__item);
}

void tt__IANA_IfTypes__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__IANA_IfTypes__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IANA_IfTypes__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IANA_IfTypes__(struct soap *soap, const char *tag, int id, const tt__IANA_IfTypes__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__IANA_IfTypes(soap, tag, id, &a->tt__IANA_IfTypes__::__item, "");
}

void *tt__IANA_IfTypes__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IANA_IfTypes__(soap, tag, this, type);
}

SOAP_FMAC3 tt__IANA_IfTypes__ * SOAP_FMAC4 soap_in_tt__IANA_IfTypes__(struct soap *soap, const char *tag, tt__IANA_IfTypes__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IANA_IfTypes__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IANA_IfTypes__, sizeof(tt__IANA_IfTypes__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IANA_IfTypes__)
		return (tt__IANA_IfTypes__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__IANA_IfTypes(soap, tag, &a->tt__IANA_IfTypes__::__item, "tt:IANA-IfTypes"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IANA_IfTypes__ * SOAP_FMAC2 soap_instantiate_tt__IANA_IfTypes__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IANA_IfTypes__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IANA_IfTypes__ *p;
	size_t k = sizeof(tt__IANA_IfTypes__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IANA_IfTypes__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IANA_IfTypes__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IANA_IfTypes__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IANA_IfTypes__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IANA_IfTypes__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IANA_IfTypes__(soap, tag ? tag : "tt:IANA-IfTypes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IANA_IfTypes__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IANA_IfTypes__(soap, this, tag, type);
}

SOAP_FMAC3 tt__IANA_IfTypes__ * SOAP_FMAC4 soap_get_tt__IANA_IfTypes__(struct soap *soap, tt__IANA_IfTypes__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IANA_IfTypes__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Duplex__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Duplex(soap, &this->tt__Duplex__::__item);
}

void tt__Duplex__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Duplex__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Duplex__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Duplex__(struct soap *soap, const char *tag, int id, const tt__Duplex__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Duplex(soap, tag, id, &a->tt__Duplex__::__item, "");
}

void *tt__Duplex__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Duplex__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Duplex__ * SOAP_FMAC4 soap_in_tt__Duplex__(struct soap *soap, const char *tag, tt__Duplex__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Duplex__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Duplex__, sizeof(tt__Duplex__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Duplex__)
		return (tt__Duplex__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Duplex(soap, tag, &a->tt__Duplex__::__item, "tt:Duplex"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Duplex__ * SOAP_FMAC2 soap_instantiate_tt__Duplex__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Duplex__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Duplex__ *p;
	size_t k = sizeof(tt__Duplex__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Duplex__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Duplex__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Duplex__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Duplex__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Duplex__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Duplex__(soap, tag ? tag : "tt:Duplex", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Duplex__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Duplex__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Duplex__ * SOAP_FMAC4 soap_get_tt__Duplex__(struct soap *soap, tt__Duplex__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Duplex__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceConfigPriority__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__NetworkInterfaceConfigPriority(soap, &this->tt__NetworkInterfaceConfigPriority__::__item);
}

void tt__NetworkInterfaceConfigPriority__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__NetworkInterfaceConfigPriority(soap, &this->tt__NetworkInterfaceConfigPriority__::__item);
#endif
}

int tt__NetworkInterfaceConfigPriority__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceConfigPriority__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceConfigPriority__(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceConfigPriority__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__NetworkInterfaceConfigPriority(soap, tag, id, &a->tt__NetworkInterfaceConfigPriority__::__item, "");
}

void *tt__NetworkInterfaceConfigPriority__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceConfigPriority__(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceConfigPriority__ * SOAP_FMAC4 soap_in_tt__NetworkInterfaceConfigPriority__(struct soap *soap, const char *tag, tt__NetworkInterfaceConfigPriority__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__NetworkInterfaceConfigPriority__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceConfigPriority__, sizeof(tt__NetworkInterfaceConfigPriority__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceConfigPriority__)
		return (tt__NetworkInterfaceConfigPriority__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__NetworkInterfaceConfigPriority(soap, tag, &a->tt__NetworkInterfaceConfigPriority__::__item, "tt:NetworkInterfaceConfigPriority"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceConfigPriority__ * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceConfigPriority__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceConfigPriority__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceConfigPriority__ *p;
	size_t k = sizeof(tt__NetworkInterfaceConfigPriority__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceConfigPriority__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceConfigPriority__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceConfigPriority__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceConfigPriority__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceConfigPriority__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceConfigPriority__(soap, tag ? tag : "tt:NetworkInterfaceConfigPriority", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceConfigPriority__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceConfigPriority__(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceConfigPriority__ * SOAP_FMAC4 soap_get_tt__NetworkInterfaceConfigPriority__(struct soap *soap, tt__NetworkInterfaceConfigPriority__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceConfigPriority__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DiscoveryMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &this->tt__DiscoveryMode__::__item);
}

void tt__DiscoveryMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__DiscoveryMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DiscoveryMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DiscoveryMode__(struct soap *soap, const char *tag, int id, const tt__DiscoveryMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__DiscoveryMode(soap, tag, id, &a->tt__DiscoveryMode__::__item, "");
}

void *tt__DiscoveryMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DiscoveryMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__DiscoveryMode__ * SOAP_FMAC4 soap_in_tt__DiscoveryMode__(struct soap *soap, const char *tag, tt__DiscoveryMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__DiscoveryMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DiscoveryMode__, sizeof(tt__DiscoveryMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DiscoveryMode__)
		return (tt__DiscoveryMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__DiscoveryMode(soap, tag, &a->tt__DiscoveryMode__::__item, "tt:DiscoveryMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__DiscoveryMode__ * SOAP_FMAC2 soap_instantiate_tt__DiscoveryMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DiscoveryMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DiscoveryMode__ *p;
	size_t k = sizeof(tt__DiscoveryMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DiscoveryMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DiscoveryMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DiscoveryMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DiscoveryMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DiscoveryMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DiscoveryMode__(soap, tag ? tag : "tt:DiscoveryMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DiscoveryMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DiscoveryMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__DiscoveryMode__ * SOAP_FMAC4 soap_get_tt__DiscoveryMode__(struct soap *soap, tt__DiscoveryMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DiscoveryMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ScopeDefinition__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ScopeDefinition(soap, &this->tt__ScopeDefinition__::__item);
}

void tt__ScopeDefinition__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__ScopeDefinition__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ScopeDefinition__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ScopeDefinition__(struct soap *soap, const char *tag, int id, const tt__ScopeDefinition__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ScopeDefinition(soap, tag, id, &a->tt__ScopeDefinition__::__item, "");
}

void *tt__ScopeDefinition__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ScopeDefinition__(soap, tag, this, type);
}

SOAP_FMAC3 tt__ScopeDefinition__ * SOAP_FMAC4 soap_in_tt__ScopeDefinition__(struct soap *soap, const char *tag, tt__ScopeDefinition__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ScopeDefinition__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ScopeDefinition__, sizeof(tt__ScopeDefinition__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ScopeDefinition__)
		return (tt__ScopeDefinition__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ScopeDefinition(soap, tag, &a->tt__ScopeDefinition__::__item, "tt:ScopeDefinition"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ScopeDefinition__ * SOAP_FMAC2 soap_instantiate_tt__ScopeDefinition__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ScopeDefinition__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ScopeDefinition__ *p;
	size_t k = sizeof(tt__ScopeDefinition__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ScopeDefinition__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ScopeDefinition__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ScopeDefinition__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ScopeDefinition__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ScopeDefinition__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ScopeDefinition__(soap, tag ? tag : "tt:ScopeDefinition", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ScopeDefinition__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ScopeDefinition__(soap, this, tag, type);
}

SOAP_FMAC3 tt__ScopeDefinition__ * SOAP_FMAC4 soap_get_tt__ScopeDefinition__(struct soap *soap, tt__ScopeDefinition__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ScopeDefinition__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TransportProtocol__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__TransportProtocol(soap, &this->tt__TransportProtocol__::__item);
}

void tt__TransportProtocol__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__TransportProtocol__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TransportProtocol__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TransportProtocol__(struct soap *soap, const char *tag, int id, const tt__TransportProtocol__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__TransportProtocol(soap, tag, id, &a->tt__TransportProtocol__::__item, "");
}

void *tt__TransportProtocol__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TransportProtocol__(soap, tag, this, type);
}

SOAP_FMAC3 tt__TransportProtocol__ * SOAP_FMAC4 soap_in_tt__TransportProtocol__(struct soap *soap, const char *tag, tt__TransportProtocol__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__TransportProtocol__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransportProtocol__, sizeof(tt__TransportProtocol__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TransportProtocol__)
		return (tt__TransportProtocol__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__TransportProtocol(soap, tag, &a->tt__TransportProtocol__::__item, "tt:TransportProtocol"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__TransportProtocol__ * SOAP_FMAC2 soap_instantiate_tt__TransportProtocol__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TransportProtocol__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TransportProtocol__ *p;
	size_t k = sizeof(tt__TransportProtocol__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TransportProtocol__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TransportProtocol__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TransportProtocol__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TransportProtocol__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TransportProtocol__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TransportProtocol__(soap, tag ? tag : "tt:TransportProtocol", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TransportProtocol__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TransportProtocol__(soap, this, tag, type);
}

SOAP_FMAC3 tt__TransportProtocol__ * SOAP_FMAC4 soap_get_tt__TransportProtocol__(struct soap *soap, tt__TransportProtocol__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TransportProtocol__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__StreamType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__StreamType(soap, &this->tt__StreamType__::__item);
}

void tt__StreamType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__StreamType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__StreamType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StreamType__(struct soap *soap, const char *tag, int id, const tt__StreamType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__StreamType(soap, tag, id, &a->tt__StreamType__::__item, "");
}

void *tt__StreamType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__StreamType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__StreamType__ * SOAP_FMAC4 soap_in_tt__StreamType__(struct soap *soap, const char *tag, tt__StreamType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__StreamType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamType__, sizeof(tt__StreamType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__StreamType__)
		return (tt__StreamType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__StreamType(soap, tag, &a->tt__StreamType__::__item, "tt:StreamType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__StreamType__ * SOAP_FMAC2 soap_instantiate_tt__StreamType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__StreamType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__StreamType__ *p;
	size_t k = sizeof(tt__StreamType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__StreamType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__StreamType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__StreamType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__StreamType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__StreamType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__StreamType__(soap, tag ? tag : "tt:StreamType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__StreamType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__StreamType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__StreamType__ * SOAP_FMAC4 soap_get_tt__StreamType__(struct soap *soap, tt__StreamType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StreamType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataCompressionType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__MetadataCompressionType(soap, &this->tt__MetadataCompressionType__::__item);
}

void tt__MetadataCompressionType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__MetadataCompressionType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataCompressionType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataCompressionType__(struct soap *soap, const char *tag, int id, const tt__MetadataCompressionType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__MetadataCompressionType(soap, tag, id, &a->tt__MetadataCompressionType__::__item, "");
}

void *tt__MetadataCompressionType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataCompressionType__(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataCompressionType__ * SOAP_FMAC4 soap_in_tt__MetadataCompressionType__(struct soap *soap, const char *tag, tt__MetadataCompressionType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__MetadataCompressionType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataCompressionType__, sizeof(tt__MetadataCompressionType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataCompressionType__)
		return (tt__MetadataCompressionType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__MetadataCompressionType(soap, tag, &a->tt__MetadataCompressionType__::__item, "tt:MetadataCompressionType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__MetadataCompressionType__ * SOAP_FMAC2 soap_instantiate_tt__MetadataCompressionType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataCompressionType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataCompressionType__ *p;
	size_t k = sizeof(tt__MetadataCompressionType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataCompressionType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataCompressionType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataCompressionType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataCompressionType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataCompressionType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataCompressionType__(soap, tag ? tag : "tt:MetadataCompressionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataCompressionType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataCompressionType__(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataCompressionType__ * SOAP_FMAC4 soap_get_tt__MetadataCompressionType__(struct soap *soap, tt__MetadataCompressionType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataCompressionType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioEncodingMimeNames__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__AudioEncodingMimeNames(soap, &this->tt__AudioEncodingMimeNames__::__item);
}

void tt__AudioEncodingMimeNames__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__AudioEncodingMimeNames__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncodingMimeNames__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncodingMimeNames__(struct soap *soap, const char *tag, int id, const tt__AudioEncodingMimeNames__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__AudioEncodingMimeNames(soap, tag, id, &a->tt__AudioEncodingMimeNames__::__item, "");
}

void *tt__AudioEncodingMimeNames__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioEncodingMimeNames__(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncodingMimeNames__ * SOAP_FMAC4 soap_in_tt__AudioEncodingMimeNames__(struct soap *soap, const char *tag, tt__AudioEncodingMimeNames__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__AudioEncodingMimeNames__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncodingMimeNames__, sizeof(tt__AudioEncodingMimeNames__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioEncodingMimeNames__)
		return (tt__AudioEncodingMimeNames__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__AudioEncodingMimeNames(soap, tag, &a->tt__AudioEncodingMimeNames__::__item, "tt:AudioEncodingMimeNames"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__AudioEncodingMimeNames__ * SOAP_FMAC2 soap_instantiate_tt__AudioEncodingMimeNames__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncodingMimeNames__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioEncodingMimeNames__ *p;
	size_t k = sizeof(tt__AudioEncodingMimeNames__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioEncodingMimeNames__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioEncodingMimeNames__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioEncodingMimeNames__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioEncodingMimeNames__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioEncodingMimeNames__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioEncodingMimeNames__(soap, tag ? tag : "tt:AudioEncodingMimeNames", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncodingMimeNames__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncodingMimeNames__(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncodingMimeNames__ * SOAP_FMAC4 soap_get_tt__AudioEncodingMimeNames__(struct soap *soap, tt__AudioEncodingMimeNames__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncodingMimeNames__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioEncoding__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__AudioEncoding(soap, &this->tt__AudioEncoding__::__item);
}

void tt__AudioEncoding__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__AudioEncoding__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoding__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoding__(struct soap *soap, const char *tag, int id, const tt__AudioEncoding__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__AudioEncoding(soap, tag, id, &a->tt__AudioEncoding__::__item, "");
}

void *tt__AudioEncoding__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioEncoding__(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoding__ * SOAP_FMAC4 soap_in_tt__AudioEncoding__(struct soap *soap, const char *tag, tt__AudioEncoding__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__AudioEncoding__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoding__, sizeof(tt__AudioEncoding__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioEncoding__)
		return (tt__AudioEncoding__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__AudioEncoding(soap, tag, &a->tt__AudioEncoding__::__item, "tt:AudioEncoding"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__AudioEncoding__ * SOAP_FMAC2 soap_instantiate_tt__AudioEncoding__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoding__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioEncoding__ *p;
	size_t k = sizeof(tt__AudioEncoding__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioEncoding__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioEncoding__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioEncoding__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioEncoding__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioEncoding__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioEncoding__(soap, tag ? tag : "tt:AudioEncoding", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoding__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoding__(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoding__ * SOAP_FMAC4 soap_get_tt__AudioEncoding__(struct soap *soap, tt__AudioEncoding__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoding__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncodingProfiles__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__VideoEncodingProfiles(soap, &this->tt__VideoEncodingProfiles__::__item);
}

void tt__VideoEncodingProfiles__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__VideoEncodingProfiles__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncodingProfiles__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncodingProfiles__(struct soap *soap, const char *tag, int id, const tt__VideoEncodingProfiles__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__VideoEncodingProfiles(soap, tag, id, &a->tt__VideoEncodingProfiles__::__item, "");
}

void *tt__VideoEncodingProfiles__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncodingProfiles__(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncodingProfiles__ * SOAP_FMAC4 soap_in_tt__VideoEncodingProfiles__(struct soap *soap, const char *tag, tt__VideoEncodingProfiles__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__VideoEncodingProfiles__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncodingProfiles__, sizeof(tt__VideoEncodingProfiles__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncodingProfiles__)
		return (tt__VideoEncodingProfiles__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__VideoEncodingProfiles(soap, tag, &a->tt__VideoEncodingProfiles__::__item, "tt:VideoEncodingProfiles"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__VideoEncodingProfiles__ * SOAP_FMAC2 soap_instantiate_tt__VideoEncodingProfiles__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncodingProfiles__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncodingProfiles__ *p;
	size_t k = sizeof(tt__VideoEncodingProfiles__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncodingProfiles__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncodingProfiles__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncodingProfiles__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncodingProfiles__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncodingProfiles__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncodingProfiles__(soap, tag ? tag : "tt:VideoEncodingProfiles", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncodingProfiles__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncodingProfiles__(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncodingProfiles__ * SOAP_FMAC4 soap_get_tt__VideoEncodingProfiles__(struct soap *soap, tt__VideoEncodingProfiles__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncodingProfiles__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncodingMimeNames__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__VideoEncodingMimeNames(soap, &this->tt__VideoEncodingMimeNames__::__item);
}

void tt__VideoEncodingMimeNames__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__VideoEncodingMimeNames__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncodingMimeNames__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncodingMimeNames__(struct soap *soap, const char *tag, int id, const tt__VideoEncodingMimeNames__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__VideoEncodingMimeNames(soap, tag, id, &a->tt__VideoEncodingMimeNames__::__item, "");
}

void *tt__VideoEncodingMimeNames__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncodingMimeNames__(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncodingMimeNames__ * SOAP_FMAC4 soap_in_tt__VideoEncodingMimeNames__(struct soap *soap, const char *tag, tt__VideoEncodingMimeNames__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__VideoEncodingMimeNames__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncodingMimeNames__, sizeof(tt__VideoEncodingMimeNames__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncodingMimeNames__)
		return (tt__VideoEncodingMimeNames__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__VideoEncodingMimeNames(soap, tag, &a->tt__VideoEncodingMimeNames__::__item, "tt:VideoEncodingMimeNames"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__VideoEncodingMimeNames__ * SOAP_FMAC2 soap_instantiate_tt__VideoEncodingMimeNames__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncodingMimeNames__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncodingMimeNames__ *p;
	size_t k = sizeof(tt__VideoEncodingMimeNames__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncodingMimeNames__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncodingMimeNames__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncodingMimeNames__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncodingMimeNames__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncodingMimeNames__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncodingMimeNames__(soap, tag ? tag : "tt:VideoEncodingMimeNames", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncodingMimeNames__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncodingMimeNames__(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncodingMimeNames__ * SOAP_FMAC4 soap_get_tt__VideoEncodingMimeNames__(struct soap *soap, tt__VideoEncodingMimeNames__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncodingMimeNames__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__H264Profile__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__H264Profile(soap, &this->tt__H264Profile__::__item);
}

void tt__H264Profile__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__H264Profile__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Profile__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Profile__(struct soap *soap, const char *tag, int id, const tt__H264Profile__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__H264Profile(soap, tag, id, &a->tt__H264Profile__::__item, "");
}

void *tt__H264Profile__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__H264Profile__(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Profile__ * SOAP_FMAC4 soap_in_tt__H264Profile__(struct soap *soap, const char *tag, tt__H264Profile__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__H264Profile__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Profile__, sizeof(tt__H264Profile__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__H264Profile__)
		return (tt__H264Profile__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__H264Profile(soap, tag, &a->tt__H264Profile__::__item, "tt:H264Profile"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__H264Profile__ * SOAP_FMAC2 soap_instantiate_tt__H264Profile__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264Profile__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__H264Profile__ *p;
	size_t k = sizeof(tt__H264Profile__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__H264Profile__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__H264Profile__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__H264Profile__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__H264Profile__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__H264Profile__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__H264Profile__(soap, tag ? tag : "tt:H264Profile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Profile__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Profile__(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Profile__ * SOAP_FMAC4 soap_get_tt__H264Profile__(struct soap *soap, tt__H264Profile__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Profile__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Mpeg4Profile__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Mpeg4Profile(soap, &this->tt__Mpeg4Profile__::__item);
}

void tt__Mpeg4Profile__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Mpeg4Profile__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Profile__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Profile__(struct soap *soap, const char *tag, int id, const tt__Mpeg4Profile__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Mpeg4Profile(soap, tag, id, &a->tt__Mpeg4Profile__::__item, "");
}

void *tt__Mpeg4Profile__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Mpeg4Profile__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Profile__ * SOAP_FMAC4 soap_in_tt__Mpeg4Profile__(struct soap *soap, const char *tag, tt__Mpeg4Profile__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Mpeg4Profile__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Profile__, sizeof(tt__Mpeg4Profile__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Mpeg4Profile__)
		return (tt__Mpeg4Profile__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Mpeg4Profile(soap, tag, &a->tt__Mpeg4Profile__::__item, "tt:Mpeg4Profile"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Mpeg4Profile__ * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Profile__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4Profile__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Mpeg4Profile__ *p;
	size_t k = sizeof(tt__Mpeg4Profile__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Mpeg4Profile__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Mpeg4Profile__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Mpeg4Profile__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Mpeg4Profile__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Mpeg4Profile__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Mpeg4Profile__(soap, tag ? tag : "tt:Mpeg4Profile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Profile__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Profile__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Profile__ * SOAP_FMAC4 soap_get_tt__Mpeg4Profile__(struct soap *soap, tt__Mpeg4Profile__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Profile__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoding__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__VideoEncoding(soap, &this->tt__VideoEncoding__::__item);
}

void tt__VideoEncoding__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__VideoEncoding__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoding__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoding__(struct soap *soap, const char *tag, int id, const tt__VideoEncoding__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__VideoEncoding(soap, tag, id, &a->tt__VideoEncoding__::__item, "");
}

void *tt__VideoEncoding__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoding__(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoding__ * SOAP_FMAC4 soap_in_tt__VideoEncoding__(struct soap *soap, const char *tag, tt__VideoEncoding__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__VideoEncoding__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoding__, sizeof(tt__VideoEncoding__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoding__)
		return (tt__VideoEncoding__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__VideoEncoding(soap, tag, &a->tt__VideoEncoding__::__item, "tt:VideoEncoding"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__VideoEncoding__ * SOAP_FMAC2 soap_instantiate_tt__VideoEncoding__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoding__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoding__ *p;
	size_t k = sizeof(tt__VideoEncoding__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoding__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoding__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoding__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoding__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoding__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoding__(soap, tag ? tag : "tt:VideoEncoding", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoding__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoding__(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoding__ * SOAP_FMAC4 soap_get_tt__VideoEncoding__(struct soap *soap, tt__VideoEncoding__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoding__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ViewModes__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ViewModes(soap, &this->tt__ViewModes__::__item);
}

void tt__ViewModes__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__ViewModes__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ViewModes__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ViewModes__(struct soap *soap, const char *tag, int id, const tt__ViewModes__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ViewModes(soap, tag, id, &a->tt__ViewModes__::__item, "");
}

void *tt__ViewModes__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ViewModes__(soap, tag, this, type);
}

SOAP_FMAC3 tt__ViewModes__ * SOAP_FMAC4 soap_in_tt__ViewModes__(struct soap *soap, const char *tag, tt__ViewModes__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ViewModes__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ViewModes__, sizeof(tt__ViewModes__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ViewModes__)
		return (tt__ViewModes__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ViewModes(soap, tag, &a->tt__ViewModes__::__item, "tt:ViewModes"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ViewModes__ * SOAP_FMAC2 soap_instantiate_tt__ViewModes__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ViewModes__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ViewModes__ *p;
	size_t k = sizeof(tt__ViewModes__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ViewModes__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ViewModes__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ViewModes__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ViewModes__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ViewModes__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ViewModes__(soap, tag ? tag : "tt:ViewModes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ViewModes__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ViewModes__(soap, this, tag, type);
}

SOAP_FMAC3 tt__ViewModes__ * SOAP_FMAC4 soap_get_tt__ViewModes__(struct soap *soap, tt__ViewModes__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ViewModes__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SceneOrientationOption__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__SceneOrientationOption(soap, &this->tt__SceneOrientationOption__::__item);
}

void tt__SceneOrientationOption__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__SceneOrientationOption__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SceneOrientationOption__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientationOption__(struct soap *soap, const char *tag, int id, const tt__SceneOrientationOption__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__SceneOrientationOption(soap, tag, id, &a->tt__SceneOrientationOption__::__item, "");
}

void *tt__SceneOrientationOption__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SceneOrientationOption__(soap, tag, this, type);
}

SOAP_FMAC3 tt__SceneOrientationOption__ * SOAP_FMAC4 soap_in_tt__SceneOrientationOption__(struct soap *soap, const char *tag, tt__SceneOrientationOption__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__SceneOrientationOption__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientationOption__, sizeof(tt__SceneOrientationOption__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SceneOrientationOption__)
		return (tt__SceneOrientationOption__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__SceneOrientationOption(soap, tag, &a->tt__SceneOrientationOption__::__item, "tt:SceneOrientationOption"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__SceneOrientationOption__ * SOAP_FMAC2 soap_instantiate_tt__SceneOrientationOption__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SceneOrientationOption__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SceneOrientationOption__ *p;
	size_t k = sizeof(tt__SceneOrientationOption__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SceneOrientationOption__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SceneOrientationOption__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SceneOrientationOption__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SceneOrientationOption__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SceneOrientationOption__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SceneOrientationOption__(soap, tag ? tag : "tt:SceneOrientationOption", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SceneOrientationOption__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SceneOrientationOption__(soap, this, tag, type);
}

SOAP_FMAC3 tt__SceneOrientationOption__ * SOAP_FMAC4 soap_get_tt__SceneOrientationOption__(struct soap *soap, tt__SceneOrientationOption__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SceneOrientationOption__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SceneOrientationMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__SceneOrientationMode(soap, &this->tt__SceneOrientationMode__::__item);
}

void tt__SceneOrientationMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__SceneOrientationMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SceneOrientationMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientationMode__(struct soap *soap, const char *tag, int id, const tt__SceneOrientationMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__SceneOrientationMode(soap, tag, id, &a->tt__SceneOrientationMode__::__item, "");
}

void *tt__SceneOrientationMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SceneOrientationMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__SceneOrientationMode__ * SOAP_FMAC4 soap_in_tt__SceneOrientationMode__(struct soap *soap, const char *tag, tt__SceneOrientationMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__SceneOrientationMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientationMode__, sizeof(tt__SceneOrientationMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SceneOrientationMode__)
		return (tt__SceneOrientationMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__SceneOrientationMode(soap, tag, &a->tt__SceneOrientationMode__::__item, "tt:SceneOrientationMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__SceneOrientationMode__ * SOAP_FMAC2 soap_instantiate_tt__SceneOrientationMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SceneOrientationMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SceneOrientationMode__ *p;
	size_t k = sizeof(tt__SceneOrientationMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SceneOrientationMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SceneOrientationMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SceneOrientationMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SceneOrientationMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SceneOrientationMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SceneOrientationMode__(soap, tag ? tag : "tt:SceneOrientationMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SceneOrientationMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SceneOrientationMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__SceneOrientationMode__ * SOAP_FMAC4 soap_get_tt__SceneOrientationMode__(struct soap *soap, tt__SceneOrientationMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SceneOrientationMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RotateMode__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RotateMode(soap, &this->tt__RotateMode__::__item);
}

void tt__RotateMode__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__RotateMode__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RotateMode__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateMode__(struct soap *soap, const char *tag, int id, const tt__RotateMode__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__RotateMode(soap, tag, id, &a->tt__RotateMode__::__item, "");
}

void *tt__RotateMode__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RotateMode__(soap, tag, this, type);
}

SOAP_FMAC3 tt__RotateMode__ * SOAP_FMAC4 soap_in_tt__RotateMode__(struct soap *soap, const char *tag, tt__RotateMode__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__RotateMode__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateMode__, sizeof(tt__RotateMode__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RotateMode__)
		return (tt__RotateMode__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__RotateMode(soap, tag, &a->tt__RotateMode__::__item, "tt:RotateMode"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__RotateMode__ * SOAP_FMAC2 soap_instantiate_tt__RotateMode__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RotateMode__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RotateMode__ *p;
	size_t k = sizeof(tt__RotateMode__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RotateMode__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RotateMode__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RotateMode__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RotateMode__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RotateMode__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RotateMode__(soap, tag ? tag : "tt:RotateMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RotateMode__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RotateMode__(soap, this, tag, type);
}

SOAP_FMAC3 tt__RotateMode__ * SOAP_FMAC4 soap_get_tt__RotateMode__(struct soap *soap, tt__RotateMode__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateMode__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Name__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &this->tt__Name__::__item);
}

void tt__Name__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Name__::__item, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__Name__::__item);
#endif
}

int tt__Name__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Name__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name__(struct soap *soap, const char *tag, int id, const tt__Name__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__Name(soap, tag, id, &a->tt__Name__::__item, "");
}

void *tt__Name__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Name__(soap, tag, this, type);
}

SOAP_FMAC3 tt__Name__ * SOAP_FMAC4 soap_in_tt__Name__(struct soap *soap, const char *tag, tt__Name__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Name__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Name__, sizeof(tt__Name__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Name__)
		return (tt__Name__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__Name(soap, tag, &a->tt__Name__::__item, "tt:Name"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Name__ * SOAP_FMAC2 soap_instantiate_tt__Name__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Name__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Name__ *p;
	size_t k = sizeof(tt__Name__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Name__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Name__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Name__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Name__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Name__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Name__(soap, tag ? tag : "tt:Name", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Name__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Name__(soap, this, tag, type);
}

SOAP_FMAC3 tt__Name__ * SOAP_FMAC4 soap_get_tt__Name__(struct soap *soap, tt__Name__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Name(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__Name), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__Name(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Name, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 64, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Name, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__Name, SOAP_TYPE_tt__Name, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Name(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__Name(soap, tag ? tag : "tt:Name", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__Name(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__StorageType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tds__StorageType(soap, &this->tds__StorageType__::__item);
}

void tds__StorageType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tds__StorageType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__StorageType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__StorageType__(struct soap *soap, const char *tag, int id, const tds__StorageType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tds__StorageType(soap, tag, id, &a->tds__StorageType__::__item, "");
}

void *tds__StorageType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__StorageType__(soap, tag, this, type);
}

SOAP_FMAC3 tds__StorageType__ * SOAP_FMAC4 soap_in_tds__StorageType__(struct soap *soap, const char *tag, tds__StorageType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tds__StorageType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageType__, sizeof(tds__StorageType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__StorageType__)
		return (tds__StorageType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tds__StorageType(soap, tag, &a->tds__StorageType__::__item, "tds:StorageType"))
		return NULL;
	return a;
}

SOAP_FMAC1 tds__StorageType__ * SOAP_FMAC2 soap_instantiate_tds__StorageType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__StorageType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__StorageType__ *p;
	size_t k = sizeof(tds__StorageType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__StorageType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__StorageType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__StorageType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__StorageType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__StorageType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__StorageType__(soap, tag ? tag : "tds:StorageType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__StorageType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__StorageType__(soap, this, tag, type);
}

SOAP_FMAC3 tds__StorageType__ * SOAP_FMAC4 soap_get_tds__StorageType__(struct soap *soap, tds__StorageType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__StorageType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__AutoGeoModes__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tds__AutoGeoModes(soap, &this->tds__AutoGeoModes__::__item);
}

void tds__AutoGeoModes__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tds__AutoGeoModes__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__AutoGeoModes__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__AutoGeoModes__(struct soap *soap, const char *tag, int id, const tds__AutoGeoModes__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tds__AutoGeoModes(soap, tag, id, &a->tds__AutoGeoModes__::__item, "");
}

void *tds__AutoGeoModes__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__AutoGeoModes__(soap, tag, this, type);
}

SOAP_FMAC3 tds__AutoGeoModes__ * SOAP_FMAC4 soap_in_tds__AutoGeoModes__(struct soap *soap, const char *tag, tds__AutoGeoModes__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tds__AutoGeoModes__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__AutoGeoModes__, sizeof(tds__AutoGeoModes__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__AutoGeoModes__)
		return (tds__AutoGeoModes__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tds__AutoGeoModes(soap, tag, &a->tds__AutoGeoModes__::__item, "tds:AutoGeoModes"))
		return NULL;
	return a;
}

SOAP_FMAC1 tds__AutoGeoModes__ * SOAP_FMAC2 soap_instantiate_tds__AutoGeoModes__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__AutoGeoModes__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__AutoGeoModes__ *p;
	size_t k = sizeof(tds__AutoGeoModes__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__AutoGeoModes__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__AutoGeoModes__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__AutoGeoModes__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__AutoGeoModes__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__AutoGeoModes__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__AutoGeoModes__(soap, tag ? tag : "tds:AutoGeoModes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__AutoGeoModes__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__AutoGeoModes__(soap, this, tag, type);
}

SOAP_FMAC3 tds__AutoGeoModes__ * SOAP_FMAC4 soap_get_tds__AutoGeoModes__(struct soap *soap, tds__AutoGeoModes__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__AutoGeoModes__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsd__FaultCodeOpenType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__FaultCodeOpenType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wsd__FaultCodeOpenType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wsd__FaultCodeOpenType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_wsd__FaultCodeOpenType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_wsd__FaultCodeOpenType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_wsd__FaultCodeOpenType, SOAP_TYPE_wsd__FaultCodeOpenType, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsd__FaultCodeOpenType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_wsd__FaultCodeOpenType(soap, tag ? tag : "wsd:FaultCodeOpenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wsd__FaultCodeOpenType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__FaultCodeOpenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsd__UriListType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__UriListType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wsd__UriListType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wsd__UriListType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_wsd__UriListType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_wsd__UriListType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_wsd__UriListType, SOAP_TYPE_wsd__UriListType, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsd__UriListType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_wsd__UriListType(soap, tag ? tag : "wsd:UriListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wsd__UriListType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__UriListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsd__OpenRelationshipType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__OpenRelationshipType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wsd__OpenRelationshipType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wsd__OpenRelationshipType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_wsd__OpenRelationshipType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_wsd__OpenRelationshipType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_wsd__OpenRelationshipType, SOAP_TYPE_wsd__OpenRelationshipType, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsd__OpenRelationshipType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_wsd__OpenRelationshipType(soap, tag ? tag : "wsd:OpenRelationshipType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wsd__OpenRelationshipType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__OpenRelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag ? tag : "wsnt:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceTokenList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceTokenList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__ReferenceTokenList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__ReferenceTokenList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__ReferenceTokenList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__ReferenceTokenList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__ReferenceTokenList, SOAP_TYPE_tt__ReferenceTokenList, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceTokenList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReferenceTokenList(soap, tag ? tag : "tt:ReferenceTokenList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__ReferenceTokenList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceTokenList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringAttrList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringAttrList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__StringAttrList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__StringAttrList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__StringAttrList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__StringAttrList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__StringAttrList, SOAP_TYPE_tt__StringAttrList, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringAttrList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__StringAttrList(soap, tag ? tag : "tt:StringAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__StringAttrList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatAttrList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatAttrList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__FloatAttrList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__FloatAttrList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__FloatAttrList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__FloatAttrList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__FloatAttrList, SOAP_TYPE_tt__FloatAttrList, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatAttrList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__FloatAttrList(soap, tag ? tag : "tt:FloatAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__FloatAttrList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntAttrList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntAttrList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__IntAttrList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__IntAttrList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__IntAttrList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__IntAttrList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__IntAttrList, SOAP_TYPE_tt__IntAttrList, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntAttrList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntAttrList(soap, tag ? tag : "tt:IntAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__IntAttrList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__EAPMethodTypes(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__EAPMethodTypes(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tds__EAPMethodTypes), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tds__EAPMethodTypes(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tds__EAPMethodTypes, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tds__EAPMethodTypes, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tds__EAPMethodTypes, SOAP_TYPE_tds__EAPMethodTypes, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__EAPMethodTypes(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tds__EAPMethodTypes(soap, tag ? tag : "tds:EAPMethodTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tds__EAPMethodTypes(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__EAPMethodTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tmk__VideoSurveillanceSystem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tmk__VideoSurveillanceSystem::ChannelDisconnect = NULL;
	this->tmk__VideoSurveillanceSystem::ChannelConnect = NULL;
	this->tmk__VideoSurveillanceSystem::RecordTurnOff = NULL;
	this->tmk__VideoSurveillanceSystem::RecordTurnOn = NULL;
	this->tmk__VideoSurveillanceSystem::MotionDetectorTrigger = NULL;
	this->tmk__VideoSurveillanceSystem::ReadRecordRequest = NULL;
	this->tmk__VideoSurveillanceSystem::DeleteRecordRequest = NULL;
	this->tmk__VideoSurveillanceSystem::EditDbRecordRequest = NULL;
	this->tmk__VideoSurveillanceSystem::CopyDbRecordRequest = NULL;
	this->tmk__VideoSurveillanceSystem::Authorization = NULL;
	this->tmk__VideoSurveillanceSystem::ServerPowerOn = NULL;
	this->tmk__VideoSurveillanceSystem::ServerPowerOff = NULL;
	soap_default_bool(soap, &this->tmk__VideoSurveillanceSystem::topic);
}

void tmk__VideoSurveillanceSystem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__VideoSurveillanceSystem::ChannelDisconnect);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__VideoSurveillanceSystem::ChannelConnect);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__VideoSurveillanceSystem::RecordTurnOff);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__VideoSurveillanceSystem::RecordTurnOn);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__VideoSurveillanceSystem::MotionDetectorTrigger);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__VideoSurveillanceSystem::ReadRecordRequest);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__VideoSurveillanceSystem::DeleteRecordRequest);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__VideoSurveillanceSystem::EditDbRecordRequest);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__VideoSurveillanceSystem::CopyDbRecordRequest);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__VideoSurveillanceSystem::Authorization);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__VideoSurveillanceSystem::ServerPowerOn);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__VideoSurveillanceSystem::ServerPowerOff);
#endif
}

int tmk__VideoSurveillanceSystem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tmk__VideoSurveillanceSystem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmk__VideoSurveillanceSystem(struct soap *soap, const char *tag, int id, const tmk__VideoSurveillanceSystem *a, const char *type)
{
	soap_set_attr(soap, "topic", soap_bool2s(soap, ((tmk__VideoSurveillanceSystem*)a)->topic), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmk__VideoSurveillanceSystem), type))
		return soap->error;
	if (!a->tmk__VideoSurveillanceSystem::ChannelDisconnect)
	{	if (soap_element_empty(soap, "tmk:ChannelDisconnect"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:ChannelDisconnect", -1, &a->tmk__VideoSurveillanceSystem::ChannelDisconnect, ""))
		return soap->error;
	if (!a->tmk__VideoSurveillanceSystem::ChannelConnect)
	{	if (soap_element_empty(soap, "tmk:ChannelConnect"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:ChannelConnect", -1, &a->tmk__VideoSurveillanceSystem::ChannelConnect, ""))
		return soap->error;
	if (!a->tmk__VideoSurveillanceSystem::RecordTurnOff)
	{	if (soap_element_empty(soap, "tmk:RecordTurnOff"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:RecordTurnOff", -1, &a->tmk__VideoSurveillanceSystem::RecordTurnOff, ""))
		return soap->error;
	if (!a->tmk__VideoSurveillanceSystem::RecordTurnOn)
	{	if (soap_element_empty(soap, "tmk:RecordTurnOn"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:RecordTurnOn", -1, &a->tmk__VideoSurveillanceSystem::RecordTurnOn, ""))
		return soap->error;
	if (!a->tmk__VideoSurveillanceSystem::MotionDetectorTrigger)
	{	if (soap_element_empty(soap, "tmk:MotionDetectorTrigger"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:MotionDetectorTrigger", -1, &a->tmk__VideoSurveillanceSystem::MotionDetectorTrigger, ""))
		return soap->error;
	if (!a->tmk__VideoSurveillanceSystem::ReadRecordRequest)
	{	if (soap_element_empty(soap, "tmk:ReadRecordRequest"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:ReadRecordRequest", -1, &a->tmk__VideoSurveillanceSystem::ReadRecordRequest, ""))
		return soap->error;
	if (!a->tmk__VideoSurveillanceSystem::DeleteRecordRequest)
	{	if (soap_element_empty(soap, "tmk:DeleteRecordRequest"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:DeleteRecordRequest", -1, &a->tmk__VideoSurveillanceSystem::DeleteRecordRequest, ""))
		return soap->error;
	if (!a->tmk__VideoSurveillanceSystem::EditDbRecordRequest)
	{	if (soap_element_empty(soap, "tmk:EditDbRecordRequest"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:EditDbRecordRequest", -1, &a->tmk__VideoSurveillanceSystem::EditDbRecordRequest, ""))
		return soap->error;
	if (!a->tmk__VideoSurveillanceSystem::CopyDbRecordRequest)
	{	if (soap_element_empty(soap, "tmk:CopyDbRecordRequest"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:CopyDbRecordRequest", -1, &a->tmk__VideoSurveillanceSystem::CopyDbRecordRequest, ""))
		return soap->error;
	if (!a->tmk__VideoSurveillanceSystem::Authorization)
	{	if (soap_element_empty(soap, "tmk:Authorization"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:Authorization", -1, &a->tmk__VideoSurveillanceSystem::Authorization, ""))
		return soap->error;
	if (!a->tmk__VideoSurveillanceSystem::ServerPowerOn)
	{	if (soap_element_empty(soap, "tmk:ServerPowerOn"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:ServerPowerOn", -1, &a->tmk__VideoSurveillanceSystem::ServerPowerOn, ""))
		return soap->error;
	if (!a->tmk__VideoSurveillanceSystem::ServerPowerOff)
	{	if (soap_element_empty(soap, "tmk:ServerPowerOff"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:ServerPowerOff", -1, &a->tmk__VideoSurveillanceSystem::ServerPowerOff, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tmk__VideoSurveillanceSystem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tmk__VideoSurveillanceSystem(soap, tag, this, type);
}

SOAP_FMAC3 tmk__VideoSurveillanceSystem * SOAP_FMAC4 soap_in_tmk__VideoSurveillanceSystem(struct soap *soap, const char *tag, tmk__VideoSurveillanceSystem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tmk__VideoSurveillanceSystem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmk__VideoSurveillanceSystem, sizeof(tmk__VideoSurveillanceSystem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tmk__VideoSurveillanceSystem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tmk__VideoSurveillanceSystem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "topic", 5, 1), &((tmk__VideoSurveillanceSystem*)a)->topic))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ChannelDisconnect1 = 1;
	size_t soap_flag_ChannelConnect1 = 1;
	size_t soap_flag_RecordTurnOff1 = 1;
	size_t soap_flag_RecordTurnOn1 = 1;
	size_t soap_flag_MotionDetectorTrigger1 = 1;
	size_t soap_flag_ReadRecordRequest1 = 1;
	size_t soap_flag_DeleteRecordRequest1 = 1;
	size_t soap_flag_EditDbRecordRequest1 = 1;
	size_t soap_flag_CopyDbRecordRequest1 = 1;
	size_t soap_flag_Authorization1 = 1;
	size_t soap_flag_ServerPowerOn1 = 1;
	size_t soap_flag_ServerPowerOff1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChannelDisconnect1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:ChannelDisconnect", &a->tmk__VideoSurveillanceSystem::ChannelDisconnect, "tt:MessageDescription"))
				{	soap_flag_ChannelDisconnect1--;
					continue;
				}
			}
			if (soap_flag_ChannelConnect1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:ChannelConnect", &a->tmk__VideoSurveillanceSystem::ChannelConnect, "tt:MessageDescription"))
				{	soap_flag_ChannelConnect1--;
					continue;
				}
			}
			if (soap_flag_RecordTurnOff1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:RecordTurnOff", &a->tmk__VideoSurveillanceSystem::RecordTurnOff, "tt:MessageDescription"))
				{	soap_flag_RecordTurnOff1--;
					continue;
				}
			}
			if (soap_flag_RecordTurnOn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:RecordTurnOn", &a->tmk__VideoSurveillanceSystem::RecordTurnOn, "tt:MessageDescription"))
				{	soap_flag_RecordTurnOn1--;
					continue;
				}
			}
			if (soap_flag_MotionDetectorTrigger1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:MotionDetectorTrigger", &a->tmk__VideoSurveillanceSystem::MotionDetectorTrigger, "tt:MessageDescription"))
				{	soap_flag_MotionDetectorTrigger1--;
					continue;
				}
			}
			if (soap_flag_ReadRecordRequest1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:ReadRecordRequest", &a->tmk__VideoSurveillanceSystem::ReadRecordRequest, "tt:MessageDescription"))
				{	soap_flag_ReadRecordRequest1--;
					continue;
				}
			}
			if (soap_flag_DeleteRecordRequest1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:DeleteRecordRequest", &a->tmk__VideoSurveillanceSystem::DeleteRecordRequest, "tt:MessageDescription"))
				{	soap_flag_DeleteRecordRequest1--;
					continue;
				}
			}
			if (soap_flag_EditDbRecordRequest1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:EditDbRecordRequest", &a->tmk__VideoSurveillanceSystem::EditDbRecordRequest, "tt:MessageDescription"))
				{	soap_flag_EditDbRecordRequest1--;
					continue;
				}
			}
			if (soap_flag_CopyDbRecordRequest1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:CopyDbRecordRequest", &a->tmk__VideoSurveillanceSystem::CopyDbRecordRequest, "tt:MessageDescription"))
				{	soap_flag_CopyDbRecordRequest1--;
					continue;
				}
			}
			if (soap_flag_Authorization1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:Authorization", &a->tmk__VideoSurveillanceSystem::Authorization, "tt:MessageDescription"))
				{	soap_flag_Authorization1--;
					continue;
				}
			}
			if (soap_flag_ServerPowerOn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:ServerPowerOn", &a->tmk__VideoSurveillanceSystem::ServerPowerOn, "tt:MessageDescription"))
				{	soap_flag_ServerPowerOn1--;
					continue;
				}
			}
			if (soap_flag_ServerPowerOff1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:ServerPowerOff", &a->tmk__VideoSurveillanceSystem::ServerPowerOff, "tt:MessageDescription"))
				{	soap_flag_ServerPowerOff1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tmk__VideoSurveillanceSystem::ChannelDisconnect || !a->tmk__VideoSurveillanceSystem::ChannelConnect || !a->tmk__VideoSurveillanceSystem::RecordTurnOff || !a->tmk__VideoSurveillanceSystem::RecordTurnOn || !a->tmk__VideoSurveillanceSystem::MotionDetectorTrigger || !a->tmk__VideoSurveillanceSystem::ReadRecordRequest || !a->tmk__VideoSurveillanceSystem::DeleteRecordRequest || !a->tmk__VideoSurveillanceSystem::EditDbRecordRequest || !a->tmk__VideoSurveillanceSystem::CopyDbRecordRequest || !a->tmk__VideoSurveillanceSystem::Authorization || !a->tmk__VideoSurveillanceSystem::ServerPowerOn || !a->tmk__VideoSurveillanceSystem::ServerPowerOff))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tmk__VideoSurveillanceSystem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmk__VideoSurveillanceSystem, SOAP_TYPE_tmk__VideoSurveillanceSystem, sizeof(tmk__VideoSurveillanceSystem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tmk__VideoSurveillanceSystem * SOAP_FMAC2 soap_instantiate_tmk__VideoSurveillanceSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tmk__VideoSurveillanceSystem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tmk__VideoSurveillanceSystem *p;
	size_t k = sizeof(tmk__VideoSurveillanceSystem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tmk__VideoSurveillanceSystem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tmk__VideoSurveillanceSystem);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tmk__VideoSurveillanceSystem, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tmk__VideoSurveillanceSystem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tmk__VideoSurveillanceSystem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tmk__VideoSurveillanceSystem(soap, tag ? tag : "tmk:VideoSurveillanceSystem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tmk__VideoSurveillanceSystem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tmk__VideoSurveillanceSystem(soap, this, tag, type);
}

SOAP_FMAC3 tmk__VideoSurveillanceSystem * SOAP_FMAC4 soap_get_tmk__VideoSurveillanceSystem(struct soap *soap, tmk__VideoSurveillanceSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmk__VideoSurveillanceSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tmk__MetalDetector::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tmk__MetalDetector::Detect = NULL;
	soap_default_bool(soap, &this->tmk__MetalDetector::topic);
}

void tmk__MetalDetector::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__MetalDetector::Detect);
#endif
}

int tmk__MetalDetector::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tmk__MetalDetector(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmk__MetalDetector(struct soap *soap, const char *tag, int id, const tmk__MetalDetector *a, const char *type)
{
	soap_set_attr(soap, "topic", soap_bool2s(soap, ((tmk__MetalDetector*)a)->topic), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmk__MetalDetector), type))
		return soap->error;
	if (!a->tmk__MetalDetector::Detect)
	{	if (soap_element_empty(soap, "tmk:Detect"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:Detect", -1, &a->tmk__MetalDetector::Detect, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tmk__MetalDetector::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tmk__MetalDetector(soap, tag, this, type);
}

SOAP_FMAC3 tmk__MetalDetector * SOAP_FMAC4 soap_in_tmk__MetalDetector(struct soap *soap, const char *tag, tmk__MetalDetector *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tmk__MetalDetector*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmk__MetalDetector, sizeof(tmk__MetalDetector), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tmk__MetalDetector)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tmk__MetalDetector *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "topic", 5, 1), &((tmk__MetalDetector*)a)->topic))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Detect1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Detect1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:Detect", &a->tmk__MetalDetector::Detect, "tt:MessageDescription"))
				{	soap_flag_Detect1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tmk__MetalDetector::Detect))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tmk__MetalDetector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmk__MetalDetector, SOAP_TYPE_tmk__MetalDetector, sizeof(tmk__MetalDetector), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tmk__MetalDetector * SOAP_FMAC2 soap_instantiate_tmk__MetalDetector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tmk__MetalDetector(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tmk__MetalDetector *p;
	size_t k = sizeof(tmk__MetalDetector);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tmk__MetalDetector, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tmk__MetalDetector);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tmk__MetalDetector, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tmk__MetalDetector location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tmk__MetalDetector::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tmk__MetalDetector(soap, tag ? tag : "tmk:MetalDetector", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tmk__MetalDetector::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tmk__MetalDetector(soap, this, tag, type);
}

SOAP_FMAC3 tmk__MetalDetector * SOAP_FMAC4 soap_get_tmk__MetalDetector(struct soap *soap, tmk__MetalDetector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmk__MetalDetector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tmk__SteamDetector::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tmk__SteamDetector::Detect = NULL;
	soap_default_bool(soap, &this->tmk__SteamDetector::topic);
}

void tmk__SteamDetector::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__SteamDetector::Detect);
#endif
}

int tmk__SteamDetector::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tmk__SteamDetector(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmk__SteamDetector(struct soap *soap, const char *tag, int id, const tmk__SteamDetector *a, const char *type)
{
	soap_set_attr(soap, "topic", soap_bool2s(soap, ((tmk__SteamDetector*)a)->topic), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmk__SteamDetector), type))
		return soap->error;
	if (!a->tmk__SteamDetector::Detect)
	{	if (soap_element_empty(soap, "tmk:Detect"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:Detect", -1, &a->tmk__SteamDetector::Detect, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tmk__SteamDetector::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tmk__SteamDetector(soap, tag, this, type);
}

SOAP_FMAC3 tmk__SteamDetector * SOAP_FMAC4 soap_in_tmk__SteamDetector(struct soap *soap, const char *tag, tmk__SteamDetector *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tmk__SteamDetector*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmk__SteamDetector, sizeof(tmk__SteamDetector), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tmk__SteamDetector)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tmk__SteamDetector *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "topic", 5, 1), &((tmk__SteamDetector*)a)->topic))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Detect1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Detect1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:Detect", &a->tmk__SteamDetector::Detect, "tt:MessageDescription"))
				{	soap_flag_Detect1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tmk__SteamDetector::Detect))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tmk__SteamDetector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmk__SteamDetector, SOAP_TYPE_tmk__SteamDetector, sizeof(tmk__SteamDetector), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tmk__SteamDetector * SOAP_FMAC2 soap_instantiate_tmk__SteamDetector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tmk__SteamDetector(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tmk__SteamDetector *p;
	size_t k = sizeof(tmk__SteamDetector);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tmk__SteamDetector, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tmk__SteamDetector);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tmk__SteamDetector, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tmk__SteamDetector location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tmk__SteamDetector::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tmk__SteamDetector(soap, tag ? tag : "tmk:SteamDetector", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tmk__SteamDetector::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tmk__SteamDetector(soap, this, tag, type);
}

SOAP_FMAC3 tmk__SteamDetector * SOAP_FMAC4 soap_get_tmk__SteamDetector(struct soap *soap, tmk__SteamDetector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmk__SteamDetector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tmk__RadiationMonitoring::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tmk__RadiationMonitoring::Detect = NULL;
	soap_default_bool(soap, &this->tmk__RadiationMonitoring::topic);
}

void tmk__RadiationMonitoring::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__RadiationMonitoring::Detect);
#endif
}

int tmk__RadiationMonitoring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tmk__RadiationMonitoring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmk__RadiationMonitoring(struct soap *soap, const char *tag, int id, const tmk__RadiationMonitoring *a, const char *type)
{
	soap_set_attr(soap, "topic", soap_bool2s(soap, ((tmk__RadiationMonitoring*)a)->topic), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmk__RadiationMonitoring), type))
		return soap->error;
	if (!a->tmk__RadiationMonitoring::Detect)
	{	if (soap_element_empty(soap, "tmk:Detect"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:Detect", -1, &a->tmk__RadiationMonitoring::Detect, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tmk__RadiationMonitoring::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tmk__RadiationMonitoring(soap, tag, this, type);
}

SOAP_FMAC3 tmk__RadiationMonitoring * SOAP_FMAC4 soap_in_tmk__RadiationMonitoring(struct soap *soap, const char *tag, tmk__RadiationMonitoring *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tmk__RadiationMonitoring*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmk__RadiationMonitoring, sizeof(tmk__RadiationMonitoring), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tmk__RadiationMonitoring)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tmk__RadiationMonitoring *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "topic", 5, 1), &((tmk__RadiationMonitoring*)a)->topic))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Detect1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Detect1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:Detect", &a->tmk__RadiationMonitoring::Detect, "tt:MessageDescription"))
				{	soap_flag_Detect1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tmk__RadiationMonitoring::Detect))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tmk__RadiationMonitoring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmk__RadiationMonitoring, SOAP_TYPE_tmk__RadiationMonitoring, sizeof(tmk__RadiationMonitoring), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tmk__RadiationMonitoring * SOAP_FMAC2 soap_instantiate_tmk__RadiationMonitoring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tmk__RadiationMonitoring(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tmk__RadiationMonitoring *p;
	size_t k = sizeof(tmk__RadiationMonitoring);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tmk__RadiationMonitoring, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tmk__RadiationMonitoring);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tmk__RadiationMonitoring, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tmk__RadiationMonitoring location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tmk__RadiationMonitoring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tmk__RadiationMonitoring(soap, tag ? tag : "tmk:RadiationMonitoring", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tmk__RadiationMonitoring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tmk__RadiationMonitoring(soap, this, tag, type);
}

SOAP_FMAC3 tmk__RadiationMonitoring * SOAP_FMAC4 soap_get_tmk__RadiationMonitoring(struct soap *soap, tmk__RadiationMonitoring *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmk__RadiationMonitoring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tmk__NeutronProbing::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tmk__NeutronProbing::Detect = NULL;
	soap_default_bool(soap, &this->tmk__NeutronProbing::topic);
}

void tmk__NeutronProbing::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__NeutronProbing::Detect);
#endif
}

int tmk__NeutronProbing::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tmk__NeutronProbing(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmk__NeutronProbing(struct soap *soap, const char *tag, int id, const tmk__NeutronProbing *a, const char *type)
{
	soap_set_attr(soap, "topic", soap_bool2s(soap, ((tmk__NeutronProbing*)a)->topic), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmk__NeutronProbing), type))
		return soap->error;
	if (!a->tmk__NeutronProbing::Detect)
	{	if (soap_element_empty(soap, "tmk:Detect"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:Detect", -1, &a->tmk__NeutronProbing::Detect, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tmk__NeutronProbing::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tmk__NeutronProbing(soap, tag, this, type);
}

SOAP_FMAC3 tmk__NeutronProbing * SOAP_FMAC4 soap_in_tmk__NeutronProbing(struct soap *soap, const char *tag, tmk__NeutronProbing *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tmk__NeutronProbing*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmk__NeutronProbing, sizeof(tmk__NeutronProbing), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tmk__NeutronProbing)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tmk__NeutronProbing *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "topic", 5, 1), &((tmk__NeutronProbing*)a)->topic))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Detect1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Detect1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:Detect", &a->tmk__NeutronProbing::Detect, "tt:MessageDescription"))
				{	soap_flag_Detect1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tmk__NeutronProbing::Detect))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tmk__NeutronProbing *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmk__NeutronProbing, SOAP_TYPE_tmk__NeutronProbing, sizeof(tmk__NeutronProbing), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tmk__NeutronProbing * SOAP_FMAC2 soap_instantiate_tmk__NeutronProbing(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tmk__NeutronProbing(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tmk__NeutronProbing *p;
	size_t k = sizeof(tmk__NeutronProbing);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tmk__NeutronProbing, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tmk__NeutronProbing);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tmk__NeutronProbing, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tmk__NeutronProbing location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tmk__NeutronProbing::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tmk__NeutronProbing(soap, tag ? tag : "tmk:NeutronProbing", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tmk__NeutronProbing::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tmk__NeutronProbing(soap, this, tag, type);
}

SOAP_FMAC3 tmk__NeutronProbing * SOAP_FMAC4 soap_get_tmk__NeutronProbing(struct soap *soap, tmk__NeutronProbing *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmk__NeutronProbing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tmk__Introscopy::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tmk__Introscopy::LimitExceeded = NULL;
	soap_default_bool(soap, &this->tmk__Introscopy::topic);
}

void tmk__Introscopy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__Introscopy::LimitExceeded);
#endif
}

int tmk__Introscopy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tmk__Introscopy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmk__Introscopy(struct soap *soap, const char *tag, int id, const tmk__Introscopy *a, const char *type)
{
	soap_set_attr(soap, "topic", soap_bool2s(soap, ((tmk__Introscopy*)a)->topic), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmk__Introscopy), type))
		return soap->error;
	if (!a->tmk__Introscopy::LimitExceeded)
	{	if (soap_element_empty(soap, "tmk:LimitExceeded"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:LimitExceeded", -1, &a->tmk__Introscopy::LimitExceeded, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tmk__Introscopy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tmk__Introscopy(soap, tag, this, type);
}

SOAP_FMAC3 tmk__Introscopy * SOAP_FMAC4 soap_in_tmk__Introscopy(struct soap *soap, const char *tag, tmk__Introscopy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tmk__Introscopy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmk__Introscopy, sizeof(tmk__Introscopy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tmk__Introscopy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tmk__Introscopy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "topic", 5, 1), &((tmk__Introscopy*)a)->topic))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_LimitExceeded1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LimitExceeded1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:LimitExceeded", &a->tmk__Introscopy::LimitExceeded, "tt:MessageDescription"))
				{	soap_flag_LimitExceeded1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tmk__Introscopy::LimitExceeded))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tmk__Introscopy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmk__Introscopy, SOAP_TYPE_tmk__Introscopy, sizeof(tmk__Introscopy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tmk__Introscopy * SOAP_FMAC2 soap_instantiate_tmk__Introscopy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tmk__Introscopy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tmk__Introscopy *p;
	size_t k = sizeof(tmk__Introscopy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tmk__Introscopy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tmk__Introscopy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tmk__Introscopy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tmk__Introscopy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tmk__Introscopy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tmk__Introscopy(soap, tag ? tag : "tmk:Introscopy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tmk__Introscopy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tmk__Introscopy(soap, this, tag, type);
}

SOAP_FMAC3 tmk__Introscopy * SOAP_FMAC4 soap_get_tmk__Introscopy(struct soap *soap, tmk__Introscopy *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmk__Introscopy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tmk__GasAnalysis::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tmk__GasAnalysis::ConcentrationExceeded = NULL;
	soap_default_bool(soap, &this->tmk__GasAnalysis::topic);
}

void tmk__GasAnalysis::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__GasAnalysis::ConcentrationExceeded);
#endif
}

int tmk__GasAnalysis::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tmk__GasAnalysis(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmk__GasAnalysis(struct soap *soap, const char *tag, int id, const tmk__GasAnalysis *a, const char *type)
{
	soap_set_attr(soap, "topic", soap_bool2s(soap, ((tmk__GasAnalysis*)a)->topic), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmk__GasAnalysis), type))
		return soap->error;
	if (!a->tmk__GasAnalysis::ConcentrationExceeded)
	{	if (soap_element_empty(soap, "tmk:ConcentrationExceeded"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:ConcentrationExceeded", -1, &a->tmk__GasAnalysis::ConcentrationExceeded, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tmk__GasAnalysis::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tmk__GasAnalysis(soap, tag, this, type);
}

SOAP_FMAC3 tmk__GasAnalysis * SOAP_FMAC4 soap_in_tmk__GasAnalysis(struct soap *soap, const char *tag, tmk__GasAnalysis *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tmk__GasAnalysis*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmk__GasAnalysis, sizeof(tmk__GasAnalysis), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tmk__GasAnalysis)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tmk__GasAnalysis *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "topic", 5, 1), &((tmk__GasAnalysis*)a)->topic))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ConcentrationExceeded1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConcentrationExceeded1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:ConcentrationExceeded", &a->tmk__GasAnalysis::ConcentrationExceeded, "tt:MessageDescription"))
				{	soap_flag_ConcentrationExceeded1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tmk__GasAnalysis::ConcentrationExceeded))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tmk__GasAnalysis *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmk__GasAnalysis, SOAP_TYPE_tmk__GasAnalysis, sizeof(tmk__GasAnalysis), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tmk__GasAnalysis * SOAP_FMAC2 soap_instantiate_tmk__GasAnalysis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tmk__GasAnalysis(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tmk__GasAnalysis *p;
	size_t k = sizeof(tmk__GasAnalysis);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tmk__GasAnalysis, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tmk__GasAnalysis);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tmk__GasAnalysis, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tmk__GasAnalysis location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tmk__GasAnalysis::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tmk__GasAnalysis(soap, tag ? tag : "tmk:GasAnalysis", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tmk__GasAnalysis::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tmk__GasAnalysis(soap, this, tag, type);
}

SOAP_FMAC3 tmk__GasAnalysis * SOAP_FMAC4 soap_get_tmk__GasAnalysis(struct soap *soap, tmk__GasAnalysis *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmk__GasAnalysis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tmk__FireAlarm::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tmk__FireAlarm::Alarm = NULL;
	this->tmk__FireAlarm::Fire = NULL;
	this->tmk__FireAlarm::Fault = NULL;
	soap_default_bool(soap, &this->tmk__FireAlarm::topic);
}

void tmk__FireAlarm::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__FireAlarm::Alarm);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__FireAlarm::Fire);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__FireAlarm::Fault);
#endif
}

int tmk__FireAlarm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tmk__FireAlarm(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmk__FireAlarm(struct soap *soap, const char *tag, int id, const tmk__FireAlarm *a, const char *type)
{
	soap_set_attr(soap, "topic", soap_bool2s(soap, ((tmk__FireAlarm*)a)->topic), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmk__FireAlarm), type))
		return soap->error;
	if (!a->tmk__FireAlarm::Alarm)
	{	if (soap_element_empty(soap, "tmk:Alarm"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:Alarm", -1, &a->tmk__FireAlarm::Alarm, ""))
		return soap->error;
	if (!a->tmk__FireAlarm::Fire)
	{	if (soap_element_empty(soap, "tmk:Fire"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:Fire", -1, &a->tmk__FireAlarm::Fire, ""))
		return soap->error;
	if (!a->tmk__FireAlarm::Fault)
	{	if (soap_element_empty(soap, "tmk:Fault"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:Fault", -1, &a->tmk__FireAlarm::Fault, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tmk__FireAlarm::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tmk__FireAlarm(soap, tag, this, type);
}

SOAP_FMAC3 tmk__FireAlarm * SOAP_FMAC4 soap_in_tmk__FireAlarm(struct soap *soap, const char *tag, tmk__FireAlarm *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tmk__FireAlarm*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmk__FireAlarm, sizeof(tmk__FireAlarm), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tmk__FireAlarm)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tmk__FireAlarm *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "topic", 5, 1), &((tmk__FireAlarm*)a)->topic))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Alarm1 = 1;
	size_t soap_flag_Fire1 = 1;
	size_t soap_flag_Fault1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Alarm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:Alarm", &a->tmk__FireAlarm::Alarm, "tt:MessageDescription"))
				{	soap_flag_Alarm1--;
					continue;
				}
			}
			if (soap_flag_Fire1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:Fire", &a->tmk__FireAlarm::Fire, "tt:MessageDescription"))
				{	soap_flag_Fire1--;
					continue;
				}
			}
			if (soap_flag_Fault1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:Fault", &a->tmk__FireAlarm::Fault, "tt:MessageDescription"))
				{	soap_flag_Fault1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tmk__FireAlarm::Alarm || !a->tmk__FireAlarm::Fire || !a->tmk__FireAlarm::Fault))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tmk__FireAlarm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmk__FireAlarm, SOAP_TYPE_tmk__FireAlarm, sizeof(tmk__FireAlarm), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tmk__FireAlarm * SOAP_FMAC2 soap_instantiate_tmk__FireAlarm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tmk__FireAlarm(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tmk__FireAlarm *p;
	size_t k = sizeof(tmk__FireAlarm);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tmk__FireAlarm, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tmk__FireAlarm);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tmk__FireAlarm, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tmk__FireAlarm location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tmk__FireAlarm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tmk__FireAlarm(soap, tag ? tag : "tmk:FireAlarm", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tmk__FireAlarm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tmk__FireAlarm(soap, this, tag, type);
}

SOAP_FMAC3 tmk__FireAlarm * SOAP_FMAC4 soap_get_tmk__FireAlarm(struct soap *soap, tmk__FireAlarm *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmk__FireAlarm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tmk__AccessControl::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tmk__AccessControl::Accident = NULL;
	this->tmk__AccessControl::Fault = NULL;
	soap_default_bool(soap, &this->tmk__AccessControl::topic);
}

void tmk__AccessControl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__AccessControl::Accident);
	soap_serialize_PointerTott__MessageDescription(soap, &this->tmk__AccessControl::Fault);
#endif
}

int tmk__AccessControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tmk__AccessControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmk__AccessControl(struct soap *soap, const char *tag, int id, const tmk__AccessControl *a, const char *type)
{
	soap_set_attr(soap, "topic", soap_bool2s(soap, ((tmk__AccessControl*)a)->topic), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmk__AccessControl), type))
		return soap->error;
	if (!a->tmk__AccessControl::Accident)
	{	if (soap_element_empty(soap, "tmk:Accident"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:Accident", -1, &a->tmk__AccessControl::Accident, ""))
		return soap->error;
	if (!a->tmk__AccessControl::Fault)
	{	if (soap_element_empty(soap, "tmk:Fault"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MessageDescription(soap, "tmk:Fault", -1, &a->tmk__AccessControl::Fault, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tmk__AccessControl::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tmk__AccessControl(soap, tag, this, type);
}

SOAP_FMAC3 tmk__AccessControl * SOAP_FMAC4 soap_in_tmk__AccessControl(struct soap *soap, const char *tag, tmk__AccessControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tmk__AccessControl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmk__AccessControl, sizeof(tmk__AccessControl), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tmk__AccessControl)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tmk__AccessControl *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "topic", 5, 1), &((tmk__AccessControl*)a)->topic))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Accident1 = 1;
	size_t soap_flag_Fault1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Accident1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:Accident", &a->tmk__AccessControl::Accident, "tt:MessageDescription"))
				{	soap_flag_Accident1--;
					continue;
				}
			}
			if (soap_flag_Fault1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescription(soap, "tmk:Fault", &a->tmk__AccessControl::Fault, "tt:MessageDescription"))
				{	soap_flag_Fault1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tmk__AccessControl::Accident || !a->tmk__AccessControl::Fault))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tmk__AccessControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmk__AccessControl, SOAP_TYPE_tmk__AccessControl, sizeof(tmk__AccessControl), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tmk__AccessControl * SOAP_FMAC2 soap_instantiate_tmk__AccessControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tmk__AccessControl(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tmk__AccessControl *p;
	size_t k = sizeof(tmk__AccessControl);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tmk__AccessControl, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tmk__AccessControl);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tmk__AccessControl, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tmk__AccessControl location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tmk__AccessControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tmk__AccessControl(soap, tag ? tag : "tmk:AccessControl", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tmk__AccessControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tmk__AccessControl(soap, this, tag, type);
}

SOAP_FMAC3 tmk__AccessControl * SOAP_FMAC4 soap_get_tmk__AccessControl(struct soap *soap, tmk__AccessControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmk__AccessControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsa__AttributedURI::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->wsa__AttributedURI::__item);
	soap_default_xsd__anyAttribute(soap, &this->wsa__AttributedURI::__anyAttribute);
}

void wsa__AttributedURI::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsa__AttributedURI::__item, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->wsa__AttributedURI::__item);
#endif
}

int wsa__AttributedURI::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsa__AttributedURI(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__AttributedURI(struct soap *soap, const char *tag, int id, const wsa__AttributedURI *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsa__AttributedURI*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__anyURI(soap, tag, id, &a->wsa__AttributedURI::__item, "");
}

void *wsa__AttributedURI::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsa__AttributedURI(soap, tag, this, type);
}

SOAP_FMAC3 wsa__AttributedURI * SOAP_FMAC4 soap_in_wsa__AttributedURI(struct soap *soap, const char *tag, wsa__AttributedURI *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsa__AttributedURI*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__AttributedURI, sizeof(wsa__AttributedURI), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsa__AttributedURI)
		return (wsa__AttributedURI *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsa__AttributedURI*)a)->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__anyURI(soap, tag, &a->wsa__AttributedURI::__item, "wsa:AttributedURI"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsa__AttributedURI * SOAP_FMAC2 soap_instantiate_wsa__AttributedURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__AttributedURI(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsa__AttributedURI *p;
	size_t k = sizeof(wsa__AttributedURI);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa__AttributedURI, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsa__AttributedURI);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsa__AttributedURI, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsa__AttributedURI location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsa__AttributedURI::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsa__AttributedURI(soap, tag ? tag : "wsa:AttributedURI", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsa__AttributedURI::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsa__AttributedURI(soap, this, tag, type);
}

SOAP_FMAC3 wsa__AttributedURI * SOAP_FMAC4 soap_get_wsa__AttributedURI(struct soap *soap, wsa__AttributedURI *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__AttributedURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsa__AttributedQName::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__QName(soap, &this->wsa__AttributedQName::__item);
	soap_default_xsd__anyAttribute(soap, &this->wsa__AttributedQName::__anyAttribute);
}

void wsa__AttributedQName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsa__AttributedQName::__item, SOAP_TYPE_xsd__QName);
	soap_serialize_xsd__QName(soap, &this->wsa__AttributedQName::__item);
#endif
}

int wsa__AttributedQName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsa__AttributedQName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__AttributedQName(struct soap *soap, const char *tag, int id, const wsa__AttributedQName *a, const char *type)
{
	std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsa__AttributedQName*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__QName(soap, tag, id, &soap_tmp___item, "");
}

void *wsa__AttributedQName::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsa__AttributedQName(soap, tag, this, type);
}

SOAP_FMAC3 wsa__AttributedQName * SOAP_FMAC4 soap_in_wsa__AttributedQName(struct soap *soap, const char *tag, wsa__AttributedQName *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsa__AttributedQName*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__AttributedQName, sizeof(wsa__AttributedQName), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsa__AttributedQName)
		return (wsa__AttributedQName *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsa__AttributedQName*)a)->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__QName(soap, tag, &a->wsa__AttributedQName::__item, "wsa:AttributedQName"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsa__AttributedQName * SOAP_FMAC2 soap_instantiate_wsa__AttributedQName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__AttributedQName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsa__AttributedQName *p;
	size_t k = sizeof(wsa__AttributedQName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa__AttributedQName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsa__AttributedQName);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsa__AttributedQName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsa__AttributedQName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsa__AttributedQName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsa__AttributedQName(soap, tag ? tag : "wsa:AttributedQName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsa__AttributedQName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsa__AttributedQName(soap, this, tag, type);
}

SOAP_FMAC3 wsa__AttributedQName * SOAP_FMAC4 soap_get_wsa__AttributedQName(struct soap *soap, wsa__AttributedQName *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__AttributedQName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsa__RetryAfterType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__nonNegativeInteger(soap, &this->wsa__RetryAfterType::__item);
	soap_default_xsd__anyAttribute(soap, &this->wsa__RetryAfterType::__anyAttribute);
}

void wsa__RetryAfterType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsa__RetryAfterType::__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->wsa__RetryAfterType::__item);
#endif
}

int wsa__RetryAfterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsa__RetryAfterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__RetryAfterType(struct soap *soap, const char *tag, int id, const wsa__RetryAfterType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsa__RetryAfterType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->wsa__RetryAfterType::__item, "");
}

void *wsa__RetryAfterType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsa__RetryAfterType(soap, tag, this, type);
}

SOAP_FMAC3 wsa__RetryAfterType * SOAP_FMAC4 soap_in_wsa__RetryAfterType(struct soap *soap, const char *tag, wsa__RetryAfterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsa__RetryAfterType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RetryAfterType, sizeof(wsa__RetryAfterType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsa__RetryAfterType)
		return (wsa__RetryAfterType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsa__RetryAfterType*)a)->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->wsa__RetryAfterType::__item, "wsa:RetryAfterType"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsa__RetryAfterType * SOAP_FMAC2 soap_instantiate_wsa__RetryAfterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__RetryAfterType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsa__RetryAfterType *p;
	size_t k = sizeof(wsa__RetryAfterType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa__RetryAfterType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsa__RetryAfterType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsa__RetryAfterType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsa__RetryAfterType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsa__RetryAfterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsa__RetryAfterType(soap, tag ? tag : "wsa:RetryAfterType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsa__RetryAfterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsa__RetryAfterType(soap, this, tag, type);
}

SOAP_FMAC3 wsa__RetryAfterType * SOAP_FMAC4 soap_get_wsa__RetryAfterType(struct soap *soap, wsa__RetryAfterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RetryAfterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsa__ReplyAfterType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__nonNegativeInteger(soap, &this->wsa__ReplyAfterType::__item);
	soap_default_xsd__anyAttribute(soap, &this->wsa__ReplyAfterType::__anyAttribute);
}

void wsa__ReplyAfterType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsa__ReplyAfterType::__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->wsa__ReplyAfterType::__item);
#endif
}

int wsa__ReplyAfterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsa__ReplyAfterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReplyAfterType(struct soap *soap, const char *tag, int id, const wsa__ReplyAfterType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsa__ReplyAfterType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->wsa__ReplyAfterType::__item, "");
}

void *wsa__ReplyAfterType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsa__ReplyAfterType(soap, tag, this, type);
}

SOAP_FMAC3 wsa__ReplyAfterType * SOAP_FMAC4 soap_in_wsa__ReplyAfterType(struct soap *soap, const char *tag, wsa__ReplyAfterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsa__ReplyAfterType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReplyAfterType, sizeof(wsa__ReplyAfterType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsa__ReplyAfterType)
		return (wsa__ReplyAfterType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsa__ReplyAfterType*)a)->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->wsa__ReplyAfterType::__item, "wsa:ReplyAfterType"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsa__ReplyAfterType * SOAP_FMAC2 soap_instantiate_wsa__ReplyAfterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__ReplyAfterType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsa__ReplyAfterType *p;
	size_t k = sizeof(wsa__ReplyAfterType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa__ReplyAfterType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsa__ReplyAfterType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsa__ReplyAfterType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsa__ReplyAfterType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsa__ReplyAfterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsa__ReplyAfterType(soap, tag ? tag : "wsa:ReplyAfterType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsa__ReplyAfterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsa__ReplyAfterType(soap, this, tag, type);
}

SOAP_FMAC3 wsa__ReplyAfterType * SOAP_FMAC4 soap_get_wsa__ReplyAfterType(struct soap *soap, wsa__ReplyAfterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReplyAfterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsa__Relationship::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->wsa__Relationship::__item);
	this->wsa__Relationship::RelationshipType = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsa__Relationship::__anyAttribute);
}

void wsa__Relationship::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsa__Relationship::__item, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->wsa__Relationship::__item);
#endif
}

int wsa__Relationship::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsa__Relationship(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__Relationship(struct soap *soap, const char *tag, int id, const wsa__Relationship *a, const char *type)
{
	if (((wsa__Relationship*)a)->RelationshipType)
	{	soap_set_attr(soap, "RelationshipType", soap_xsd__QName2s(soap, *((wsa__Relationship*)a)->RelationshipType), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsa__Relationship*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__anyURI(soap, tag, id, &a->wsa__Relationship::__item, "");
}

void *wsa__Relationship::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsa__Relationship(soap, tag, this, type);
}

SOAP_FMAC3 wsa__Relationship * SOAP_FMAC4 soap_in_wsa__Relationship(struct soap *soap, const char *tag, wsa__Relationship *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsa__Relationship*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__Relationship, sizeof(wsa__Relationship), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsa__Relationship)
		return (wsa__Relationship *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "RelationshipType", 2, 0);
		if (t)
		{
			if (!(((wsa__Relationship*)a)->RelationshipType = soap_new_xsd__QName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__QName(soap, t, ((wsa__Relationship*)a)->RelationshipType))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsa__Relationship*)a)->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__anyURI(soap, tag, &a->wsa__Relationship::__item, "wsa:Relationship"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsa__Relationship * SOAP_FMAC2 soap_instantiate_wsa__Relationship(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__Relationship(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsa__Relationship *p;
	size_t k = sizeof(wsa__Relationship);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa__Relationship, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsa__Relationship);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsa__Relationship, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsa__Relationship location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsa__Relationship::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsa__Relationship(soap, tag ? tag : "wsa:Relationship", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsa__Relationship::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsa__Relationship(soap, this, tag, type);
}

SOAP_FMAC3 wsa__Relationship * SOAP_FMAC4 soap_get_wsa__Relationship(struct soap *soap, wsa__Relationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__Relationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsa__ServiceNameType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__QName(soap, &this->wsa__ServiceNameType::__item);
	this->wsa__ServiceNameType::PortName = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsa__ServiceNameType::__anyAttribute);
}

void wsa__ServiceNameType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsa__ServiceNameType::__item, SOAP_TYPE_xsd__QName);
	soap_serialize_xsd__QName(soap, &this->wsa__ServiceNameType::__item);
#endif
}

int wsa__ServiceNameType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsa__ServiceNameType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ServiceNameType(struct soap *soap, const char *tag, int id, const wsa__ServiceNameType *a, const char *type)
{
	std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
	if (((wsa__ServiceNameType*)a)->PortName)
	{	soap_set_attr(soap, "PortName", soap_xsd__NCName2s(soap, *((wsa__ServiceNameType*)a)->PortName), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsa__ServiceNameType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__QName(soap, tag, id, &soap_tmp___item, "");
}

void *wsa__ServiceNameType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsa__ServiceNameType(soap, tag, this, type);
}

SOAP_FMAC3 wsa__ServiceNameType * SOAP_FMAC4 soap_in_wsa__ServiceNameType(struct soap *soap, const char *tag, wsa__ServiceNameType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsa__ServiceNameType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ServiceNameType, sizeof(wsa__ServiceNameType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsa__ServiceNameType)
		return (wsa__ServiceNameType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "PortName", 5, 0);
		if (t)
		{
			if (!(((wsa__ServiceNameType*)a)->PortName = soap_new_xsd__NCName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__NCName(soap, t, ((wsa__ServiceNameType*)a)->PortName))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsa__ServiceNameType*)a)->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__QName(soap, tag, &a->wsa__ServiceNameType::__item, "wsa:ServiceNameType"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsa__ServiceNameType * SOAP_FMAC2 soap_instantiate_wsa__ServiceNameType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__ServiceNameType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsa__ServiceNameType *p;
	size_t k = sizeof(wsa__ServiceNameType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa__ServiceNameType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsa__ServiceNameType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsa__ServiceNameType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsa__ServiceNameType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsa__ServiceNameType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsa__ServiceNameType(soap, tag ? tag : "wsa:ServiceNameType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsa__ServiceNameType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsa__ServiceNameType(soap, this, tag, type);
}

SOAP_FMAC3 wsa__ServiceNameType * SOAP_FMAC4 soap_get_wsa__ServiceNameType(struct soap *soap, wsa__ServiceNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsa__ReferenceParametersType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsa__ReferenceParametersType::__any);
}

void wsa__ReferenceParametersType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsa__ReferenceParametersType::__any);
#endif
}

int wsa__ReferenceParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsa__ReferenceParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const wsa__ReferenceParametersType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsa__ReferenceParametersType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsa__ReferenceParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsa__ReferenceParametersType(soap, tag, this, type);
}

SOAP_FMAC3 wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, wsa__ReferenceParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsa__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(wsa__ReferenceParametersType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsa__ReferenceParametersType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsa__ReferenceParametersType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsa__ReferenceParametersType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(wsa__ReferenceParametersType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsa__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__ReferenceParametersType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsa__ReferenceParametersType *p;
	size_t k = sizeof(wsa__ReferenceParametersType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa__ReferenceParametersType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsa__ReferenceParametersType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsa__ReferenceParametersType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsa__ReferenceParametersType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsa__ReferenceParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsa__ReferenceParametersType(soap, tag ? tag : "wsa:ReferenceParametersType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsa__ReferenceParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsa__ReferenceParametersType(soap, this, tag, type);
}

SOAP_FMAC3 wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsa__ReferencePropertiesType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsa__ReferencePropertiesType::__any);
}

void wsa__ReferencePropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsa__ReferencePropertiesType::__any);
#endif
}

int wsa__ReferencePropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsa__ReferencePropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, const wsa__ReferencePropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferencePropertiesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsa__ReferencePropertiesType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsa__ReferencePropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsa__ReferencePropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 wsa__ReferencePropertiesType * SOAP_FMAC4 soap_in_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, wsa__ReferencePropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsa__ReferencePropertiesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(wsa__ReferencePropertiesType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsa__ReferencePropertiesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsa__ReferencePropertiesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsa__ReferencePropertiesType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsa__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferencePropertiesType, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(wsa__ReferencePropertiesType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsa__ReferencePropertiesType * SOAP_FMAC2 soap_instantiate_wsa__ReferencePropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__ReferencePropertiesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsa__ReferencePropertiesType *p;
	size_t k = sizeof(wsa__ReferencePropertiesType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa__ReferencePropertiesType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsa__ReferencePropertiesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsa__ReferencePropertiesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsa__ReferencePropertiesType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsa__ReferencePropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsa__ReferencePropertiesType(soap, tag ? tag : "wsa:ReferencePropertiesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsa__ReferencePropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsa__ReferencePropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 wsa__ReferencePropertiesType * SOAP_FMAC4 soap_get_wsa__ReferencePropertiesType(struct soap *soap, wsa__ReferencePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsa__EndpointReferenceType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsa__EndpointReferenceType::Address = NULL;
	this->wsa__EndpointReferenceType::ReferenceProperties = NULL;
	this->wsa__EndpointReferenceType::ReferenceParameters = NULL;
	this->wsa__EndpointReferenceType::PortType = NULL;
	this->wsa__EndpointReferenceType::ServiceName = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsa__EndpointReferenceType::__any);
	soap_default_xsd__anyAttribute(soap, &this->wsa__EndpointReferenceType::__anyAttribute);
}

void wsa__EndpointReferenceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa__AttributedURI(soap, &this->wsa__EndpointReferenceType::Address);
	soap_serialize_PointerTowsa__ReferencePropertiesType(soap, &this->wsa__EndpointReferenceType::ReferenceProperties);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &this->wsa__EndpointReferenceType::ReferenceParameters);
	soap_serialize_PointerTowsa__AttributedQName(soap, &this->wsa__EndpointReferenceType::PortType);
	soap_serialize_PointerTowsa__ServiceNameType(soap, &this->wsa__EndpointReferenceType::ServiceName);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsa__EndpointReferenceType::__any);
#endif
}

int wsa__EndpointReferenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsa__EndpointReferenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const wsa__EndpointReferenceType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsa__EndpointReferenceType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (!a->wsa__EndpointReferenceType::Address)
	{	if (soap_element_empty(soap, "wsa:Address"))
			return soap->error;
	}
	else if (soap_out_PointerTowsa__AttributedURI(soap, "wsa:Address", -1, &a->wsa__EndpointReferenceType::Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", -1, &a->wsa__EndpointReferenceType::ReferenceProperties, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->wsa__EndpointReferenceType::ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa__AttributedQName(soap, "wsa:PortType", -1, &a->wsa__EndpointReferenceType::PortType, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", -1, &a->wsa__EndpointReferenceType::ServiceName, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsa__EndpointReferenceType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsa__EndpointReferenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsa__EndpointReferenceType(soap, tag, this, type);
}

SOAP_FMAC3 wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, wsa__EndpointReferenceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsa__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(wsa__EndpointReferenceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsa__EndpointReferenceType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsa__EndpointReferenceType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsa__EndpointReferenceType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_ReferenceProperties1 = 1;
	size_t soap_flag_ReferenceParameters1 = 1;
	size_t soap_flag_PortType1 = 1;
	size_t soap_flag_ServiceName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__AttributedURI(soap, "wsa:Address", &a->wsa__EndpointReferenceType::Address, "wsa:AttributedURI"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap_flag_ReferenceProperties1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", &a->wsa__EndpointReferenceType::ReferenceProperties, "wsa:ReferencePropertiesType"))
				{	soap_flag_ReferenceProperties1--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->wsa__EndpointReferenceType::ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters1--;
					continue;
				}
			}
			if (soap_flag_PortType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__AttributedQName(soap, "wsa:PortType", &a->wsa__EndpointReferenceType::PortType, "wsa:AttributedQName"))
				{	soap_flag_PortType1--;
					continue;
				}
			}
			if (soap_flag_ServiceName1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", &a->wsa__EndpointReferenceType::ServiceName, "wsa:ServiceNameType"))
				{	soap_flag_ServiceName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsa__EndpointReferenceType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->wsa__EndpointReferenceType::Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(wsa__EndpointReferenceType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsa__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__EndpointReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsa__EndpointReferenceType *p;
	size_t k = sizeof(wsa__EndpointReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa__EndpointReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsa__EndpointReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsa__EndpointReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsa__EndpointReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsa__EndpointReferenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsa__EndpointReferenceType(soap, tag ? tag : "wsa:EndpointReferenceType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsa__EndpointReferenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsa__EndpointReferenceType(soap, this, tag, type);
}

SOAP_FMAC3 wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsd__AppSequenceType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &this->wsd__AppSequenceType::InstanceId);
	this->wsd__AppSequenceType::SequenceId = NULL;
	soap_default_unsignedInt(soap, &this->wsd__AppSequenceType::MessageNumber);
	soap_default_xsd__anyAttribute(soap, &this->wsd__AppSequenceType::__anyAttribute);
}

void wsd__AppSequenceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int wsd__AppSequenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsd__AppSequenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__AppSequenceType(struct soap *soap, const char *tag, int id, const wsd__AppSequenceType *a, const char *type)
{
	soap_set_attr(soap, "InstanceId", soap_unsignedInt2s(soap, ((wsd__AppSequenceType*)a)->InstanceId), 1);
	if (((wsd__AppSequenceType*)a)->SequenceId)
	{	soap_set_attr(soap, "SequenceId", soap_xsd__anyURI2s(soap, *((wsd__AppSequenceType*)a)->SequenceId), 1);
	}
	soap_set_attr(soap, "MessageNumber", soap_unsignedInt2s(soap, ((wsd__AppSequenceType*)a)->MessageNumber), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsd__AppSequenceType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsd__AppSequenceType), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsd__AppSequenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsd__AppSequenceType(soap, tag, this, type);
}

SOAP_FMAC3 wsd__AppSequenceType * SOAP_FMAC4 soap_in_wsd__AppSequenceType(struct soap *soap, const char *tag, wsd__AppSequenceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsd__AppSequenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsd__AppSequenceType, sizeof(wsd__AppSequenceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsd__AppSequenceType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsd__AppSequenceType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "InstanceId", 5, 1), &((wsd__AppSequenceType*)a)->InstanceId))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "SequenceId", 4, 0);
		if (t)
		{
			if (!(((wsd__AppSequenceType*)a)->SequenceId = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((wsd__AppSequenceType*)a)->SequenceId))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "MessageNumber", 5, 1), &((wsd__AppSequenceType*)a)->MessageNumber))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsd__AppSequenceType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsd__AppSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsd__AppSequenceType, SOAP_TYPE_wsd__AppSequenceType, sizeof(wsd__AppSequenceType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsd__AppSequenceType * SOAP_FMAC2 soap_instantiate_wsd__AppSequenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsd__AppSequenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsd__AppSequenceType *p;
	size_t k = sizeof(wsd__AppSequenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsd__AppSequenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsd__AppSequenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsd__AppSequenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsd__AppSequenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsd__AppSequenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsd__AppSequenceType(soap, tag ? tag : "wsd:AppSequenceType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsd__AppSequenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsd__AppSequenceType(soap, this, tag, type);
}

SOAP_FMAC3 wsd__AppSequenceType * SOAP_FMAC4 soap_get_wsd__AppSequenceType(struct soap *soap, wsd__AppSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__AppSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsd__SigType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__SigType::__any);
	soap_default_xsd__anyURI(soap, &this->wsd__SigType::Scheme);
	this->wsd__SigType::KeyId = NULL;
	soap_default_xsd__IDREFS(soap, &this->wsd__SigType::Refs);
	this->wsd__SigType::Sig.xsd__base64Binary::soap_default(soap);
	soap_default_xsd__anyAttribute(soap, &this->wsd__SigType::__anyAttribute);
}

void wsd__SigType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__SigType::__any);
#endif
}

int wsd__SigType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsd__SigType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__SigType(struct soap *soap, const char *tag, int id, const wsd__SigType *a, const char *type)
{
	soap_set_attr(soap, "Scheme", soap_xsd__anyURI2s(soap, ((wsd__SigType*)a)->Scheme), 1);
	if (((wsd__SigType*)a)->KeyId)
	{	soap_set_attr(soap, "KeyId", soap_xsd__base64Binary2s(soap, *((wsd__SigType*)a)->KeyId), 1);
	}
	soap_set_attr(soap, "Refs", soap_xsd__IDREFS2s(soap, ((wsd__SigType*)a)->Refs), 1);
	soap_set_attr(soap, "Sig", soap_xsd__base64Binary2s(soap, ((wsd__SigType*)a)->Sig), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsd__SigType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsd__SigType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsd__SigType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsd__SigType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsd__SigType(soap, tag, this, type);
}

SOAP_FMAC3 wsd__SigType * SOAP_FMAC4 soap_in_wsd__SigType(struct soap *soap, const char *tag, wsd__SigType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsd__SigType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsd__SigType, sizeof(wsd__SigType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsd__SigType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsd__SigType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Scheme", 4, 1), &((wsd__SigType*)a)->Scheme))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "KeyId", 1, 0);
		if (t)
		{
			if (!(((wsd__SigType*)a)->KeyId = soap_new_xsd__base64Binary(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__base64Binary(soap, t, ((wsd__SigType*)a)->KeyId))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__IDREFS(soap, soap_attr_value(soap, "Refs", 5, 1), &((wsd__SigType*)a)->Refs))
		return NULL;
	if (soap_s2xsd__base64Binary(soap, soap_attr_value(soap, "Sig", 1, 1), &((wsd__SigType*)a)->Sig))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsd__SigType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsd__SigType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsd__SigType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsd__SigType, SOAP_TYPE_wsd__SigType, sizeof(wsd__SigType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsd__SigType * SOAP_FMAC2 soap_instantiate_wsd__SigType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsd__SigType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsd__SigType *p;
	size_t k = sizeof(wsd__SigType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsd__SigType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsd__SigType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsd__SigType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsd__SigType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsd__SigType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsd__SigType(soap, tag ? tag : "wsd:SigType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsd__SigType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsd__SigType(soap, this, tag, type);
}

SOAP_FMAC3 wsd__SigType * SOAP_FMAC4 soap_get_wsd__SigType(struct soap *soap, wsd__SigType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsd__SecurityType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsd__SecurityType::Sig = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsd__SecurityType::__anyAttribute);
}

void wsd__SecurityType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsd__SigType(soap, &this->wsd__SecurityType::Sig);
#endif
}

int wsd__SecurityType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsd__SecurityType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__SecurityType(struct soap *soap, const char *tag, int id, const wsd__SecurityType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsd__SecurityType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsd__SecurityType), type))
		return soap->error;
	if (soap_out_PointerTowsd__SigType(soap, "wsd:Sig", -1, &a->wsd__SecurityType::Sig, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsd__SecurityType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsd__SecurityType(soap, tag, this, type);
}

SOAP_FMAC3 wsd__SecurityType * SOAP_FMAC4 soap_in_wsd__SecurityType(struct soap *soap, const char *tag, wsd__SecurityType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsd__SecurityType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsd__SecurityType, sizeof(wsd__SecurityType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsd__SecurityType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsd__SecurityType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsd__SecurityType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Sig1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sig1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsd__SigType(soap, "wsd:Sig", &a->wsd__SecurityType::Sig, "wsd:SigType"))
				{	soap_flag_Sig1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsd__SecurityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsd__SecurityType, SOAP_TYPE_wsd__SecurityType, sizeof(wsd__SecurityType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsd__SecurityType * SOAP_FMAC2 soap_instantiate_wsd__SecurityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsd__SecurityType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsd__SecurityType *p;
	size_t k = sizeof(wsd__SecurityType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsd__SecurityType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsd__SecurityType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsd__SecurityType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsd__SecurityType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsd__SecurityType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsd__SecurityType(soap, tag ? tag : "wsd:SecurityType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsd__SecurityType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsd__SecurityType(soap, this, tag, type);
}

SOAP_FMAC3 wsd__SecurityType * SOAP_FMAC4 soap_get_wsd__SecurityType(struct soap *soap, wsd__SecurityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__SecurityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsd__ScopesType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_wsd__UriListType(soap, &this->wsd__ScopesType::__item);
	this->wsd__ScopesType::MatchBy = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsd__ScopesType::__anyAttribute);
}

void wsd__ScopesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsd__ScopesType::__item, SOAP_TYPE_wsd__UriListType);
	soap_serialize_wsd__UriListType(soap, &this->wsd__ScopesType::__item);
#endif
}

int wsd__ScopesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsd__ScopesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__ScopesType(struct soap *soap, const char *tag, int id, const wsd__ScopesType *a, const char *type)
{
	if (((wsd__ScopesType*)a)->MatchBy)
	{	soap_set_attr(soap, "MatchBy", soap_xsd__anyURI2s(soap, *((wsd__ScopesType*)a)->MatchBy), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsd__ScopesType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wsd__UriListType(soap, tag, id, &a->wsd__ScopesType::__item, "");
}

void *wsd__ScopesType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsd__ScopesType(soap, tag, this, type);
}

SOAP_FMAC3 wsd__ScopesType * SOAP_FMAC4 soap_in_wsd__ScopesType(struct soap *soap, const char *tag, wsd__ScopesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsd__ScopesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsd__ScopesType, sizeof(wsd__ScopesType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsd__ScopesType)
		return (wsd__ScopesType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "MatchBy", 4, 0);
		if (t)
		{
			if (!(((wsd__ScopesType*)a)->MatchBy = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((wsd__ScopesType*)a)->MatchBy))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsd__ScopesType*)a)->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_wsd__UriListType(soap, tag, &a->wsd__ScopesType::__item, "wsd:ScopesType"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsd__ScopesType * SOAP_FMAC2 soap_instantiate_wsd__ScopesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsd__ScopesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsd__ScopesType *p;
	size_t k = sizeof(wsd__ScopesType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsd__ScopesType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsd__ScopesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsd__ScopesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsd__ScopesType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsd__ScopesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsd__ScopesType(soap, tag ? tag : "wsd:ScopesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsd__ScopesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsd__ScopesType(soap, this, tag, type);
}

SOAP_FMAC3 wsd__ScopesType * SOAP_FMAC4 soap_get_wsd__ScopesType(struct soap *soap, wsd__ScopesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsd__ResolveMatchType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsd__ResolveMatchType::wsa__EndpointReference = NULL;
	this->wsd__ResolveMatchType::Types = NULL;
	this->wsd__ResolveMatchType::Scopes = NULL;
	soap_default_wsd__UriListType(soap, &this->wsd__ResolveMatchType::XAddrs);
	soap_default_unsignedInt(soap, &this->wsd__ResolveMatchType::MetadataVersion);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__ResolveMatchType::__any);
	soap_default_xsd__anyAttribute(soap, &this->wsd__ResolveMatchType::__anyAttribute);
}

void wsd__ResolveMatchType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &this->wsd__ResolveMatchType::wsa__EndpointReference);
	soap_serialize_PointerTowsd__QNameListType(soap, &this->wsd__ResolveMatchType::Types);
	soap_serialize_PointerTowsd__ScopesType(soap, &this->wsd__ResolveMatchType::Scopes);
	soap_embedded(soap, &this->wsd__ResolveMatchType::XAddrs, SOAP_TYPE_wsd__UriListType);
	soap_serialize_wsd__UriListType(soap, &this->wsd__ResolveMatchType::XAddrs);
	soap_embedded(soap, &this->wsd__ResolveMatchType::MetadataVersion, SOAP_TYPE_unsignedInt);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__ResolveMatchType::__any);
#endif
}

int wsd__ResolveMatchType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsd__ResolveMatchType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__ResolveMatchType(struct soap *soap, const char *tag, int id, const wsd__ResolveMatchType *a, const char *type)
{
	std::string soap_temp_Types(a->Types ? soap_QName2s(soap, a->Types->c_str()) : ""), *soap_tmp_Types = a->Types ? &soap_temp_Types : NULL;
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsd__ResolveMatchType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsd__ResolveMatchType), type))
		return soap->error;
	if (!a->wsd__ResolveMatchType::wsa__EndpointReference)
	{	if (soap_element_empty(soap, "wsa:EndpointReference"))
			return soap->error;
	}
	else if (soap_out_PointerTowsa__EndpointReferenceType(soap, "wsa:EndpointReference", -1, &a->wsd__ResolveMatchType::wsa__EndpointReference, ""))
		return soap->error;
	if (soap_tmp_Types && soap_out_wsd__QNameListType(soap, "wsd:Types", -1, soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsd__ScopesType(soap, "wsd:Scopes", -1, &a->wsd__ResolveMatchType::Scopes, ""))
		return soap->error;
	if (soap_out_wsd__UriListType(soap, "wsd:XAddrs", -1, &a->wsd__ResolveMatchType::XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsd:MetadataVersion", -1, &a->wsd__ResolveMatchType::MetadataVersion, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsd__ResolveMatchType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsd__ResolveMatchType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsd__ResolveMatchType(soap, tag, this, type);
}

SOAP_FMAC3 wsd__ResolveMatchType * SOAP_FMAC4 soap_in_wsd__ResolveMatchType(struct soap *soap, const char *tag, wsd__ResolveMatchType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsd__ResolveMatchType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsd__ResolveMatchType, sizeof(wsd__ResolveMatchType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsd__ResolveMatchType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsd__ResolveMatchType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsd__ResolveMatchType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_wsa__EndpointReference1 = 1;
	size_t soap_flag_Types1 = 1;
	size_t soap_flag_Scopes1 = 1;
	size_t soap_flag_XAddrs1 = 1;
	size_t soap_flag_MetadataVersion1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__EndpointReferenceType(soap, "wsa:EndpointReference", &a->wsd__ResolveMatchType::wsa__EndpointReference, "wsa:EndpointReferenceType"))
				{	soap_flag_wsa__EndpointReference1--;
					continue;
				}
			}
			if (soap_flag_Types1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsd__QNameListType(soap, "wsd:Types", &a->wsd__ResolveMatchType::Types, "xsd:QName"))
				{	soap_flag_Types1--;
					continue;
				}
			}
			if (soap_flag_Scopes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsd__ScopesType(soap, "wsd:Scopes", &a->wsd__ResolveMatchType::Scopes, "wsd:ScopesType"))
				{	soap_flag_Scopes1--;
					continue;
				}
			}
			if (soap_flag_XAddrs1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsd__UriListType(soap, "wsd:XAddrs", &a->wsd__ResolveMatchType::XAddrs, "wsd:UriListType"))
				{	soap_flag_XAddrs1--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsd:MetadataVersion", &a->wsd__ResolveMatchType::MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsd__ResolveMatchType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->wsd__ResolveMatchType::wsa__EndpointReference || soap_flag_XAddrs1 > 0 || soap_flag_MetadataVersion1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsd__ResolveMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsd__ResolveMatchType, SOAP_TYPE_wsd__ResolveMatchType, sizeof(wsd__ResolveMatchType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsd__ResolveMatchType * SOAP_FMAC2 soap_instantiate_wsd__ResolveMatchType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsd__ResolveMatchType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsd__ResolveMatchType *p;
	size_t k = sizeof(wsd__ResolveMatchType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsd__ResolveMatchType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsd__ResolveMatchType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsd__ResolveMatchType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsd__ResolveMatchType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsd__ResolveMatchType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsd__ResolveMatchType(soap, tag ? tag : "wsd:ResolveMatchType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsd__ResolveMatchType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsd__ResolveMatchType(soap, this, tag, type);
}

SOAP_FMAC3 wsd__ResolveMatchType * SOAP_FMAC4 soap_get_wsd__ResolveMatchType(struct soap *soap, wsd__ResolveMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsd__ResolveMatchesType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsd__ResolveMatchesType::ResolveMatch = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__ResolveMatchesType::__any);
	soap_default_xsd__anyAttribute(soap, &this->wsd__ResolveMatchesType::__anyAttribute);
}

void wsd__ResolveMatchesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsd__ResolveMatchType(soap, &this->wsd__ResolveMatchesType::ResolveMatch);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__ResolveMatchesType::__any);
#endif
}

int wsd__ResolveMatchesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsd__ResolveMatchesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__ResolveMatchesType(struct soap *soap, const char *tag, int id, const wsd__ResolveMatchesType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsd__ResolveMatchesType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsd__ResolveMatchesType), type))
		return soap->error;
	if (soap_out_PointerTowsd__ResolveMatchType(soap, "wsd:ResolveMatch", -1, &a->wsd__ResolveMatchesType::ResolveMatch, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsd__ResolveMatchesType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsd__ResolveMatchesType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsd__ResolveMatchesType(soap, tag, this, type);
}

SOAP_FMAC3 wsd__ResolveMatchesType * SOAP_FMAC4 soap_in_wsd__ResolveMatchesType(struct soap *soap, const char *tag, wsd__ResolveMatchesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsd__ResolveMatchesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsd__ResolveMatchesType, sizeof(wsd__ResolveMatchesType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsd__ResolveMatchesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsd__ResolveMatchesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsd__ResolveMatchesType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ResolveMatch1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResolveMatch1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsd__ResolveMatchType(soap, "wsd:ResolveMatch", &a->wsd__ResolveMatchesType::ResolveMatch, "wsd:ResolveMatchType"))
				{	soap_flag_ResolveMatch1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsd__ResolveMatchesType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsd__ResolveMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsd__ResolveMatchesType, SOAP_TYPE_wsd__ResolveMatchesType, sizeof(wsd__ResolveMatchesType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsd__ResolveMatchesType * SOAP_FMAC2 soap_instantiate_wsd__ResolveMatchesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsd__ResolveMatchesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsd__ResolveMatchesType *p;
	size_t k = sizeof(wsd__ResolveMatchesType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsd__ResolveMatchesType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsd__ResolveMatchesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsd__ResolveMatchesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsd__ResolveMatchesType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsd__ResolveMatchesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsd__ResolveMatchesType(soap, tag ? tag : "wsd:ResolveMatchesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsd__ResolveMatchesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsd__ResolveMatchesType(soap, this, tag, type);
}

SOAP_FMAC3 wsd__ResolveMatchesType * SOAP_FMAC4 soap_get_wsd__ResolveMatchesType(struct soap *soap, wsd__ResolveMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsd__ResolveType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsd__ResolveType::wsa__EndpointReference = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__ResolveType::__any);
	soap_default_xsd__anyAttribute(soap, &this->wsd__ResolveType::__anyAttribute);
}

void wsd__ResolveType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &this->wsd__ResolveType::wsa__EndpointReference);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__ResolveType::__any);
#endif
}

int wsd__ResolveType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsd__ResolveType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__ResolveType(struct soap *soap, const char *tag, int id, const wsd__ResolveType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsd__ResolveType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsd__ResolveType), type))
		return soap->error;
	if (!a->wsd__ResolveType::wsa__EndpointReference)
	{	if (soap_element_empty(soap, "wsa:EndpointReference"))
			return soap->error;
	}
	else if (soap_out_PointerTowsa__EndpointReferenceType(soap, "wsa:EndpointReference", -1, &a->wsd__ResolveType::wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsd__ResolveType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsd__ResolveType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsd__ResolveType(soap, tag, this, type);
}

SOAP_FMAC3 wsd__ResolveType * SOAP_FMAC4 soap_in_wsd__ResolveType(struct soap *soap, const char *tag, wsd__ResolveType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsd__ResolveType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsd__ResolveType, sizeof(wsd__ResolveType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsd__ResolveType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsd__ResolveType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsd__ResolveType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_wsa__EndpointReference1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__EndpointReferenceType(soap, "wsa:EndpointReference", &a->wsd__ResolveType::wsa__EndpointReference, "wsa:EndpointReferenceType"))
				{	soap_flag_wsa__EndpointReference1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsd__ResolveType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->wsd__ResolveType::wsa__EndpointReference))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsd__ResolveType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsd__ResolveType, SOAP_TYPE_wsd__ResolveType, sizeof(wsd__ResolveType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsd__ResolveType * SOAP_FMAC2 soap_instantiate_wsd__ResolveType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsd__ResolveType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsd__ResolveType *p;
	size_t k = sizeof(wsd__ResolveType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsd__ResolveType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsd__ResolveType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsd__ResolveType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsd__ResolveType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsd__ResolveType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsd__ResolveType(soap, tag ? tag : "wsd:ResolveType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsd__ResolveType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsd__ResolveType(soap, this, tag, type);
}

SOAP_FMAC3 wsd__ResolveType * SOAP_FMAC4 soap_get_wsd__ResolveType(struct soap *soap, wsd__ResolveType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsd__ProbeMatchType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsd__ProbeMatchType::wsa__EndpointReference = NULL;
	this->wsd__ProbeMatchType::Types = NULL;
	this->wsd__ProbeMatchType::Scopes = NULL;
	this->wsd__ProbeMatchType::XAddrs = NULL;
	soap_default_unsignedInt(soap, &this->wsd__ProbeMatchType::MetadataVersion);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__ProbeMatchType::__any);
	soap_default_xsd__anyAttribute(soap, &this->wsd__ProbeMatchType::__anyAttribute);
}

void wsd__ProbeMatchType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &this->wsd__ProbeMatchType::wsa__EndpointReference);
	soap_serialize_PointerTowsd__QNameListType(soap, &this->wsd__ProbeMatchType::Types);
	soap_serialize_PointerTowsd__ScopesType(soap, &this->wsd__ProbeMatchType::Scopes);
	soap_serialize_PointerTowsd__UriListType(soap, &this->wsd__ProbeMatchType::XAddrs);
	soap_embedded(soap, &this->wsd__ProbeMatchType::MetadataVersion, SOAP_TYPE_unsignedInt);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__ProbeMatchType::__any);
#endif
}

int wsd__ProbeMatchType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsd__ProbeMatchType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__ProbeMatchType(struct soap *soap, const char *tag, int id, const wsd__ProbeMatchType *a, const char *type)
{
	std::string soap_temp_Types(a->Types ? soap_QName2s(soap, a->Types->c_str()) : ""), *soap_tmp_Types = a->Types ? &soap_temp_Types : NULL;
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsd__ProbeMatchType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsd__ProbeMatchType), type))
		return soap->error;
	if (!a->wsd__ProbeMatchType::wsa__EndpointReference)
	{	if (soap_element_empty(soap, "wsa:EndpointReference"))
			return soap->error;
	}
	else if (soap_out_PointerTowsa__EndpointReferenceType(soap, "wsa:EndpointReference", -1, &a->wsd__ProbeMatchType::wsa__EndpointReference, ""))
		return soap->error;
	if (soap_tmp_Types && soap_out_wsd__QNameListType(soap, "wsd:Types", -1, soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsd__ScopesType(soap, "wsd:Scopes", -1, &a->wsd__ProbeMatchType::Scopes, ""))
		return soap->error;
	if (soap_out_PointerTowsd__UriListType(soap, "wsd:XAddrs", -1, &a->wsd__ProbeMatchType::XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsd:MetadataVersion", -1, &a->wsd__ProbeMatchType::MetadataVersion, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsd__ProbeMatchType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsd__ProbeMatchType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsd__ProbeMatchType(soap, tag, this, type);
}

SOAP_FMAC3 wsd__ProbeMatchType * SOAP_FMAC4 soap_in_wsd__ProbeMatchType(struct soap *soap, const char *tag, wsd__ProbeMatchType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsd__ProbeMatchType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsd__ProbeMatchType, sizeof(wsd__ProbeMatchType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsd__ProbeMatchType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsd__ProbeMatchType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsd__ProbeMatchType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_wsa__EndpointReference1 = 1;
	size_t soap_flag_Types1 = 1;
	size_t soap_flag_Scopes1 = 1;
	size_t soap_flag_XAddrs1 = 1;
	size_t soap_flag_MetadataVersion1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__EndpointReferenceType(soap, "wsa:EndpointReference", &a->wsd__ProbeMatchType::wsa__EndpointReference, "wsa:EndpointReferenceType"))
				{	soap_flag_wsa__EndpointReference1--;
					continue;
				}
			}
			if (soap_flag_Types1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsd__QNameListType(soap, "wsd:Types", &a->wsd__ProbeMatchType::Types, "xsd:QName"))
				{	soap_flag_Types1--;
					continue;
				}
			}
			if (soap_flag_Scopes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsd__ScopesType(soap, "wsd:Scopes", &a->wsd__ProbeMatchType::Scopes, "wsd:ScopesType"))
				{	soap_flag_Scopes1--;
					continue;
				}
			}
			if (soap_flag_XAddrs1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsd__UriListType(soap, "wsd:XAddrs", &a->wsd__ProbeMatchType::XAddrs, "wsd:UriListType"))
				{	soap_flag_XAddrs1--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsd:MetadataVersion", &a->wsd__ProbeMatchType::MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsd__ProbeMatchType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->wsd__ProbeMatchType::wsa__EndpointReference || soap_flag_MetadataVersion1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsd__ProbeMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsd__ProbeMatchType, SOAP_TYPE_wsd__ProbeMatchType, sizeof(wsd__ProbeMatchType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsd__ProbeMatchType * SOAP_FMAC2 soap_instantiate_wsd__ProbeMatchType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsd__ProbeMatchType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsd__ProbeMatchType *p;
	size_t k = sizeof(wsd__ProbeMatchType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsd__ProbeMatchType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsd__ProbeMatchType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsd__ProbeMatchType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsd__ProbeMatchType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsd__ProbeMatchType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsd__ProbeMatchType(soap, tag ? tag : "wsd:ProbeMatchType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsd__ProbeMatchType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsd__ProbeMatchType(soap, this, tag, type);
}

SOAP_FMAC3 wsd__ProbeMatchType * SOAP_FMAC4 soap_get_wsd__ProbeMatchType(struct soap *soap, wsd__ProbeMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsd__ByeType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsd__ByeType::wsa__EndpointReference = NULL;
	this->wsd__ByeType::Types = NULL;
	this->wsd__ByeType::Scopes = NULL;
	this->wsd__ByeType::XAddrs = NULL;
	this->wsd__ByeType::MetadataVersion = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__ByeType::__any);
	soap_default_xsd__anyAttribute(soap, &this->wsd__ByeType::__anyAttribute);
}

void wsd__ByeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &this->wsd__ByeType::wsa__EndpointReference);
	soap_serialize_PointerTowsd__QNameListType(soap, &this->wsd__ByeType::Types);
	soap_serialize_PointerTowsd__ScopesType(soap, &this->wsd__ByeType::Scopes);
	soap_serialize_PointerTowsd__UriListType(soap, &this->wsd__ByeType::XAddrs);
	soap_serialize_PointerTounsignedInt(soap, &this->wsd__ByeType::MetadataVersion);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__ByeType::__any);
#endif
}

int wsd__ByeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsd__ByeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__ByeType(struct soap *soap, const char *tag, int id, const wsd__ByeType *a, const char *type)
{
	std::string soap_temp_Types(a->Types ? soap_QName2s(soap, a->Types->c_str()) : ""), *soap_tmp_Types = a->Types ? &soap_temp_Types : NULL;
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsd__ByeType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsd__ByeType), type))
		return soap->error;
	if (!a->wsd__ByeType::wsa__EndpointReference)
	{	if (soap_element_empty(soap, "wsa:EndpointReference"))
			return soap->error;
	}
	else if (soap_out_PointerTowsa__EndpointReferenceType(soap, "wsa:EndpointReference", -1, &a->wsd__ByeType::wsa__EndpointReference, ""))
		return soap->error;
	if (soap_tmp_Types && soap_out_wsd__QNameListType(soap, "wsd:Types", -1, soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsd__ScopesType(soap, "wsd:Scopes", -1, &a->wsd__ByeType::Scopes, ""))
		return soap->error;
	if (soap_out_PointerTowsd__UriListType(soap, "wsd:XAddrs", -1, &a->wsd__ByeType::XAddrs, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "wsd:MetadataVersion", -1, &a->wsd__ByeType::MetadataVersion, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsd__ByeType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsd__ByeType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsd__ByeType(soap, tag, this, type);
}

SOAP_FMAC3 wsd__ByeType * SOAP_FMAC4 soap_in_wsd__ByeType(struct soap *soap, const char *tag, wsd__ByeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsd__ByeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsd__ByeType, sizeof(wsd__ByeType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsd__ByeType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsd__ByeType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsd__ByeType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_wsa__EndpointReference1 = 1;
	size_t soap_flag_Types1 = 1;
	size_t soap_flag_Scopes1 = 1;
	size_t soap_flag_XAddrs1 = 1;
	size_t soap_flag_MetadataVersion1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__EndpointReferenceType(soap, "wsa:EndpointReference", &a->wsd__ByeType::wsa__EndpointReference, "wsa:EndpointReferenceType"))
				{	soap_flag_wsa__EndpointReference1--;
					continue;
				}
			}
			if (soap_flag_Types1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsd__QNameListType(soap, "wsd:Types", &a->wsd__ByeType::Types, "xsd:QName"))
				{	soap_flag_Types1--;
					continue;
				}
			}
			if (soap_flag_Scopes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsd__ScopesType(soap, "wsd:Scopes", &a->wsd__ByeType::Scopes, "wsd:ScopesType"))
				{	soap_flag_Scopes1--;
					continue;
				}
			}
			if (soap_flag_XAddrs1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsd__UriListType(soap, "wsd:XAddrs", &a->wsd__ByeType::XAddrs, "wsd:UriListType"))
				{	soap_flag_XAddrs1--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTounsignedInt(soap, "wsd:MetadataVersion", &a->wsd__ByeType::MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsd__ByeType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->wsd__ByeType::wsa__EndpointReference))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsd__ByeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsd__ByeType, SOAP_TYPE_wsd__ByeType, sizeof(wsd__ByeType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsd__ByeType * SOAP_FMAC2 soap_instantiate_wsd__ByeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsd__ByeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsd__ByeType *p;
	size_t k = sizeof(wsd__ByeType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsd__ByeType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsd__ByeType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsd__ByeType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsd__ByeType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsd__ByeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsd__ByeType(soap, tag ? tag : "wsd:ByeType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsd__ByeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsd__ByeType(soap, this, tag, type);
}

SOAP_FMAC3 wsd__ByeType * SOAP_FMAC4 soap_get_wsd__ByeType(struct soap *soap, wsd__ByeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsd__HelloType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsd__HelloType::wsa__EndpointReference = NULL;
	this->wsd__HelloType::Types = NULL;
	this->wsd__HelloType::Scopes = NULL;
	this->wsd__HelloType::XAddrs = NULL;
	soap_default_unsignedInt(soap, &this->wsd__HelloType::MetadataVersion);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__HelloType::__any);
	soap_default_xsd__anyAttribute(soap, &this->wsd__HelloType::__anyAttribute);
}

void wsd__HelloType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &this->wsd__HelloType::wsa__EndpointReference);
	soap_serialize_PointerTowsd__QNameListType(soap, &this->wsd__HelloType::Types);
	soap_serialize_PointerTowsd__ScopesType(soap, &this->wsd__HelloType::Scopes);
	soap_serialize_PointerTowsd__UriListType(soap, &this->wsd__HelloType::XAddrs);
	soap_embedded(soap, &this->wsd__HelloType::MetadataVersion, SOAP_TYPE_unsignedInt);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsd__HelloType::__any);
#endif
}

int wsd__HelloType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsd__HelloType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsd__HelloType(struct soap *soap, const char *tag, int id, const wsd__HelloType *a, const char *type)
{
	std::string soap_temp_Types(a->Types ? soap_QName2s(soap, a->Types->c_str()) : ""), *soap_tmp_Types = a->Types ? &soap_temp_Types : NULL;
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsd__HelloType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsd__HelloType), type))
		return soap->error;
	if (!a->wsd__HelloType::wsa__EndpointReference)
	{	if (soap_element_empty(soap, "wsa:EndpointReference"))
			return soap->error;
	}
	else if (soap_out_PointerTowsa__EndpointReferenceType(soap, "wsa:EndpointReference", -1, &a->wsd__HelloType::wsa__EndpointReference, ""))
		return soap->error;
	if (soap_tmp_Types && soap_out_wsd__QNameListType(soap, "wsd:Types", -1, soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsd__ScopesType(soap, "wsd:Scopes", -1, &a->wsd__HelloType::Scopes, ""))
		return soap->error;
	if (soap_out_PointerTowsd__UriListType(soap, "wsd:XAddrs", -1, &a->wsd__HelloType::XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsd:MetadataVersion", -1, &a->wsd__HelloType::MetadataVersion, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsd__HelloType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsd__HelloType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsd__HelloType(soap, tag, this, type);
}

SOAP_FMAC3 wsd__HelloType * SOAP_FMAC4 soap_in_wsd__HelloType(struct soap *soap, const char *tag, wsd__HelloType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsd__HelloType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsd__HelloType, sizeof(wsd__HelloType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsd__HelloType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsd__HelloType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsd__HelloType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_wsa__EndpointReference1 = 1;
	size_t soap_flag_Types1 = 1;
	size_t soap_flag_Scopes1 = 1;
	size_t soap_flag_XAddrs1 = 1;
	size_t soap_flag_MetadataVersion1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__EndpointReferenceType(soap, "wsa:EndpointReference", &a->wsd__HelloType::wsa__EndpointReference, "wsa:EndpointReferenceType"))
				{	soap_flag_wsa__EndpointReference1--;
					continue;
				}
			}
			if (soap_flag_Types1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsd__QNameListType(soap, "wsd:Types", &a->wsd__HelloType::Types, "xsd:QName"))
				{	soap_flag_Types1--;
					continue;
				}
			}
			if (soap_flag_Scopes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsd__ScopesType(soap, "wsd:Scopes", &a->wsd__HelloType::Scopes, "wsd:ScopesType"))
				{	soap_flag_Scopes1--;
					continue;
				}
			}
			if (soap_flag_XAddrs1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsd__UriListType(soap, "wsd:XAddrs", &a->wsd__HelloType::XAddrs, "wsd:UriListType"))
				{	soap_flag_XAddrs1--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsd:MetadataVersion", &a->wsd__HelloType::MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsd__HelloType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->wsd__HelloType::wsa__EndpointReference || soap_flag_MetadataVersion1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsd__HelloType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsd__HelloType, SOAP_TYPE_wsd__HelloType, sizeof(wsd__HelloType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsd__HelloType * SOAP_FMAC2 soap_instantiate_wsd__HelloType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsd__HelloType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsd__HelloType *p;
	size_t k = sizeof(wsd__HelloType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsd__HelloType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsd__HelloType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsd__HelloType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsd__HelloType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsd__HelloType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsd__HelloType(soap, tag ? tag : "wsd:HelloType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsd__HelloType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsd__HelloType(soap, this, tag, type);
}

SOAP_FMAC3 wsd__HelloType * SOAP_FMAC4 soap_get_wsd__HelloType(struct soap *soap, wsd__HelloType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsd__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsrf__ResourceUnavailableFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsrf__ResourceUnavailableFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsrf__ResourceUnavailableFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsrf__ResourceUnavailableFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrf__ResourceUnavailableFaultType(struct soap *soap, const char *tag, int id, const wsrf__ResourceUnavailableFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrf__ResourceUnavailableFaultType), type ? type : "wsrf:ResourceUnavailableFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsrf__ResourceUnavailableFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsrf__ResourceUnavailableFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsrf__ResourceUnavailableFaultType * SOAP_FMAC4 soap_in_wsrf__ResourceUnavailableFaultType(struct soap *soap, const char *tag, wsrf__ResourceUnavailableFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsrf__ResourceUnavailableFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrf__ResourceUnavailableFaultType, sizeof(wsrf__ResourceUnavailableFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsrf__ResourceUnavailableFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsrf__ResourceUnavailableFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsrf__ResourceUnavailableFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrf__ResourceUnavailableFaultType, SOAP_TYPE_wsrf__ResourceUnavailableFaultType, sizeof(wsrf__ResourceUnavailableFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsrf__ResourceUnavailableFaultType * SOAP_FMAC2 soap_instantiate_wsrf__ResourceUnavailableFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrf__ResourceUnavailableFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsrf__ResourceUnavailableFaultType *p;
	size_t k = sizeof(wsrf__ResourceUnavailableFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrf__ResourceUnavailableFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsrf__ResourceUnavailableFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsrf__ResourceUnavailableFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsrf__ResourceUnavailableFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsrf__ResourceUnavailableFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsrf__ResourceUnavailableFaultType(soap, tag ? tag : "wsrf:ResourceUnavailableFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsrf__ResourceUnavailableFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsrf__ResourceUnavailableFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsrf__ResourceUnavailableFaultType * SOAP_FMAC4 soap_get_wsrf__ResourceUnavailableFaultType(struct soap *soap, wsrf__ResourceUnavailableFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrf__ResourceUnavailableFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsrf__ResourceUnknownFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsrf__ResourceUnknownFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsrf__ResourceUnknownFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsrf__ResourceUnknownFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrf__ResourceUnknownFaultType(struct soap *soap, const char *tag, int id, const wsrf__ResourceUnknownFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrf__ResourceUnknownFaultType), type ? type : "wsrf:ResourceUnknownFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsrf__ResourceUnknownFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsrf__ResourceUnknownFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsrf__ResourceUnknownFaultType * SOAP_FMAC4 soap_in_wsrf__ResourceUnknownFaultType(struct soap *soap, const char *tag, wsrf__ResourceUnknownFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsrf__ResourceUnknownFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrf__ResourceUnknownFaultType, sizeof(wsrf__ResourceUnknownFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsrf__ResourceUnknownFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsrf__ResourceUnknownFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsrf__ResourceUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrf__ResourceUnknownFaultType, SOAP_TYPE_wsrf__ResourceUnknownFaultType, sizeof(wsrf__ResourceUnknownFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsrf__ResourceUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsrf__ResourceUnknownFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrf__ResourceUnknownFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsrf__ResourceUnknownFaultType *p;
	size_t k = sizeof(wsrf__ResourceUnknownFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrf__ResourceUnknownFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsrf__ResourceUnknownFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsrf__ResourceUnknownFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsrf__ResourceUnknownFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsrf__ResourceUnknownFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsrf__ResourceUnknownFaultType(soap, tag ? tag : "wsrf:ResourceUnknownFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsrf__ResourceUnknownFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsrf__ResourceUnknownFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsrf__ResourceUnknownFaultType * SOAP_FMAC4 soap_get_wsrf__ResourceUnknownFaultType(struct soap *soap, wsrf__ResourceUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrf__ResourceUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__GetEventPropertiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::TopicNamespaceLocation);
	this->_tev__GetEventPropertiesResponse::wsnt__FixedTopicSet = (bool)1;
	this->_tev__GetEventPropertiesResponse::wstop__TopicSet = NULL;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::wsnt__TopicExpressionDialect);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::MessageContentFilterDialect);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::ProducerPropertiesFilterDialect);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::MessageContentSchemaLocation);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_tev__GetEventPropertiesResponse::__any);
}

void _tev__GetEventPropertiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::TopicNamespaceLocation);
	soap_embedded(soap, &this->_tev__GetEventPropertiesResponse::wsnt__FixedTopicSet, SOAP_TYPE_bool);
	soap_serialize_PointerTowstop__TopicSetType(soap, &this->_tev__GetEventPropertiesResponse::wstop__TopicSet);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::wsnt__TopicExpressionDialect);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::MessageContentFilterDialect);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::ProducerPropertiesFilterDialect);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::MessageContentSchemaLocation);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_tev__GetEventPropertiesResponse::__any);
#endif
}

int _tev__GetEventPropertiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__GetEventPropertiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, int id, const _tev__GetEventPropertiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventPropertiesResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:TopicNamespaceLocation");
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tev:TopicNamespaceLocation", -1, &a->_tev__GetEventPropertiesResponse::TopicNamespaceLocation, ""))
		return soap->error;
	if (soap_out_bool(soap, "wsnt:FixedTopicSet", -1, &a->_tev__GetEventPropertiesResponse::wsnt__FixedTopicSet, ""))
		return soap->error;
	if (!a->_tev__GetEventPropertiesResponse::wstop__TopicSet)
	{	if (soap_element_empty(soap, "wstop:TopicSet"))
			return soap->error;
	}
	else if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &a->_tev__GetEventPropertiesResponse::wstop__TopicSet, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "wsnt:TopicExpressionDialect", -1, &a->_tev__GetEventPropertiesResponse::wsnt__TopicExpressionDialect, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tev:MessageContentFilterDialect", -1, &a->_tev__GetEventPropertiesResponse::MessageContentFilterDialect, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tev:ProducerPropertiesFilterDialect", -1, &a->_tev__GetEventPropertiesResponse::ProducerPropertiesFilterDialect, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tev:MessageContentSchemaLocation", -1, &a->_tev__GetEventPropertiesResponse::MessageContentSchemaLocation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_tev__GetEventPropertiesResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__GetEventPropertiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__GetEventPropertiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__GetEventPropertiesResponse * SOAP_FMAC4 soap_in__tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, _tev__GetEventPropertiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__GetEventPropertiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(_tev__GetEventPropertiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__GetEventPropertiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__GetEventPropertiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_wsnt__FixedTopicSet1 = 1;
	size_t soap_flag_wstop__TopicSet1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tev:TopicNamespaceLocation", &a->_tev__GetEventPropertiesResponse::TopicNamespaceLocation, "xsd:anyURI"))
					continue;
			}
			if (soap_flag_wsnt__FixedTopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "wsnt:FixedTopicSet", &a->_tev__GetEventPropertiesResponse::wsnt__FixedTopicSet, "xsd:boolean"))
				{	soap_flag_wsnt__FixedTopicSet1--;
					continue;
				}
			}
			if (soap_flag_wstop__TopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &a->_tev__GetEventPropertiesResponse::wstop__TopicSet, "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "wsnt:TopicExpressionDialect", &a->_tev__GetEventPropertiesResponse::wsnt__TopicExpressionDialect, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tev:MessageContentFilterDialect", &a->_tev__GetEventPropertiesResponse::MessageContentFilterDialect, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tev:ProducerPropertiesFilterDialect", &a->_tev__GetEventPropertiesResponse::ProducerPropertiesFilterDialect, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tev:MessageContentSchemaLocation", &a->_tev__GetEventPropertiesResponse::MessageContentSchemaLocation, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_tev__GetEventPropertiesResponse::__any, "xsd:anyType"))
					continue;
			}
			soap_check_result(soap, "tev:TopicNamespaceLocation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tev__GetEventPropertiesResponse::TopicNamespaceLocation.size() < 1 || soap_flag_wsnt__FixedTopicSet1 > 0 || !a->_tev__GetEventPropertiesResponse::wstop__TopicSet || a->_tev__GetEventPropertiesResponse::wsnt__TopicExpressionDialect.size() < 1 || a->_tev__GetEventPropertiesResponse::MessageContentFilterDialect.size() < 1 || a->_tev__GetEventPropertiesResponse::MessageContentSchemaLocation.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__GetEventPropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventPropertiesResponse, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(_tev__GetEventPropertiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__GetEventPropertiesResponse * SOAP_FMAC2 soap_instantiate__tev__GetEventPropertiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__GetEventPropertiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__GetEventPropertiesResponse *p;
	size_t k = sizeof(_tev__GetEventPropertiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__GetEventPropertiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__GetEventPropertiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__GetEventPropertiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__GetEventPropertiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__GetEventPropertiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__GetEventPropertiesResponse(soap, tag ? tag : "tev:GetEventPropertiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__GetEventPropertiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__GetEventPropertiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__GetEventPropertiesResponse * SOAP_FMAC4 soap_get__tev__GetEventPropertiesResponse(struct soap *soap, _tev__GetEventPropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__GetEventProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tev__GetEventProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tev__GetEventProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__GetEventProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventProperties(struct soap *soap, const char *tag, int id, const _tev__GetEventProperties *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventProperties), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__GetEventProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__GetEventProperties(soap, tag, this, type);
}

SOAP_FMAC3 _tev__GetEventProperties * SOAP_FMAC4 soap_in__tev__GetEventProperties(struct soap *soap, const char *tag, _tev__GetEventProperties *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__GetEventProperties*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventProperties, sizeof(_tev__GetEventProperties), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__GetEventProperties)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__GetEventProperties *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__GetEventProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventProperties, SOAP_TYPE__tev__GetEventProperties, sizeof(_tev__GetEventProperties), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__GetEventProperties * SOAP_FMAC2 soap_instantiate__tev__GetEventProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__GetEventProperties(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__GetEventProperties *p;
	size_t k = sizeof(_tev__GetEventProperties);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__GetEventProperties, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__GetEventProperties);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__GetEventProperties, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__GetEventProperties location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__GetEventProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__GetEventProperties(soap, tag ? tag : "tev:GetEventProperties", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__GetEventProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__GetEventProperties(soap, this, tag, type);
}

SOAP_FMAC3 _tev__GetEventProperties * SOAP_FMAC4 soap_get__tev__GetEventProperties(struct soap *soap, _tev__GetEventProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__SetSynchronizationPointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tev__SetSynchronizationPointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tev__SetSynchronizationPointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__SetSynchronizationPointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, const _tev__SetSynchronizationPointResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SetSynchronizationPointResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__SetSynchronizationPointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__SetSynchronizationPointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__SetSynchronizationPointResponse * SOAP_FMAC4 soap_in__tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, _tev__SetSynchronizationPointResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__SetSynchronizationPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(_tev__SetSynchronizationPointResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__SetSynchronizationPointResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__SetSynchronizationPointResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__SetSynchronizationPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SetSynchronizationPointResponse, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(_tev__SetSynchronizationPointResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__SetSynchronizationPointResponse * SOAP_FMAC2 soap_instantiate__tev__SetSynchronizationPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__SetSynchronizationPointResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__SetSynchronizationPointResponse *p;
	size_t k = sizeof(_tev__SetSynchronizationPointResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__SetSynchronizationPointResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__SetSynchronizationPointResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__SetSynchronizationPointResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__SetSynchronizationPointResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__SetSynchronizationPointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__SetSynchronizationPointResponse(soap, tag ? tag : "tev:SetSynchronizationPointResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__SetSynchronizationPointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__SetSynchronizationPointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__SetSynchronizationPointResponse * SOAP_FMAC4 soap_get__tev__SetSynchronizationPointResponse(struct soap *soap, _tev__SetSynchronizationPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__SetSynchronizationPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tev__SetSynchronizationPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tev__SetSynchronizationPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__SetSynchronizationPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const _tev__SetSynchronizationPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SetSynchronizationPoint), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__SetSynchronizationPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__SetSynchronizationPoint(soap, tag, this, type);
}

SOAP_FMAC3 _tev__SetSynchronizationPoint * SOAP_FMAC4 soap_in__tev__SetSynchronizationPoint(struct soap *soap, const char *tag, _tev__SetSynchronizationPoint *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__SetSynchronizationPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(_tev__SetSynchronizationPoint), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__SetSynchronizationPoint)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__SetSynchronizationPoint *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__SetSynchronizationPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SetSynchronizationPoint, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(_tev__SetSynchronizationPoint), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate__tev__SetSynchronizationPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__SetSynchronizationPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__SetSynchronizationPoint *p;
	size_t k = sizeof(_tev__SetSynchronizationPoint);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__SetSynchronizationPoint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__SetSynchronizationPoint);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__SetSynchronizationPoint, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__SetSynchronizationPoint location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__SetSynchronizationPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__SetSynchronizationPoint(soap, tag ? tag : "tev:SetSynchronizationPoint", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__SetSynchronizationPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__SetSynchronizationPoint(soap, this, tag, type);
}

SOAP_FMAC3 _tev__SetSynchronizationPoint * SOAP_FMAC4 soap_get__tev__SetSynchronizationPoint(struct soap *soap, _tev__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__SeekResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tev__SeekResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tev__SeekResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__SeekResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SeekResponse(struct soap *soap, const char *tag, int id, const _tev__SeekResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SeekResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__SeekResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__SeekResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__SeekResponse * SOAP_FMAC4 soap_in__tev__SeekResponse(struct soap *soap, const char *tag, _tev__SeekResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__SeekResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SeekResponse, sizeof(_tev__SeekResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__SeekResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__SeekResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__SeekResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SeekResponse, SOAP_TYPE__tev__SeekResponse, sizeof(_tev__SeekResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__SeekResponse * SOAP_FMAC2 soap_instantiate__tev__SeekResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__SeekResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__SeekResponse *p;
	size_t k = sizeof(_tev__SeekResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__SeekResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__SeekResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__SeekResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__SeekResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__SeekResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__SeekResponse(soap, tag ? tag : "tev:SeekResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__SeekResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__SeekResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__SeekResponse * SOAP_FMAC4 soap_get__tev__SeekResponse(struct soap *soap, _tev__SeekResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SeekResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__Seek::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__dateTime(soap, &this->_tev__Seek::UtcTime);
	this->_tev__Seek::Reverse = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_tev__Seek::__any);
}

void _tev__Seek::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tev__Seek::UtcTime, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->_tev__Seek::UtcTime);
	soap_serialize_PointerTobool(soap, &this->_tev__Seek::Reverse);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_tev__Seek::__any);
#endif
}

int _tev__Seek::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__Seek(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__Seek(struct soap *soap, const char *tag, int id, const _tev__Seek *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__Seek), type))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tev:UtcTime", -1, &a->_tev__Seek::UtcTime, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tev:Reverse", -1, &a->_tev__Seek::Reverse, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_tev__Seek::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__Seek::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__Seek(soap, tag, this, type);
}

SOAP_FMAC3 _tev__Seek * SOAP_FMAC4 soap_in__tev__Seek(struct soap *soap, const char *tag, _tev__Seek *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__Seek*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__Seek, sizeof(_tev__Seek), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__Seek)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__Seek *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UtcTime1 = 1;
	size_t soap_flag_Reverse1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UtcTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tev:UtcTime", &a->_tev__Seek::UtcTime, "xsd:dateTime"))
				{	soap_flag_UtcTime1--;
					continue;
				}
			}
			if (soap_flag_Reverse1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tev:Reverse", &a->_tev__Seek::Reverse, "xsd:boolean"))
				{	soap_flag_Reverse1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_tev__Seek::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__Seek *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__Seek, SOAP_TYPE__tev__Seek, sizeof(_tev__Seek), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__Seek * SOAP_FMAC2 soap_instantiate__tev__Seek(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__Seek(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__Seek *p;
	size_t k = sizeof(_tev__Seek);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__Seek, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__Seek);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__Seek, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__Seek location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__Seek::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__Seek(soap, tag ? tag : "tev:Seek", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__Seek::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__Seek(soap, this, tag, type);
}

SOAP_FMAC3 _tev__Seek * SOAP_FMAC4 soap_get__tev__Seek(struct soap *soap, _tev__Seek *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__Seek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__PullMessagesFaultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__duration(soap, &this->_tev__PullMessagesFaultResponse::MaxTimeout);
	soap_default_int(soap, &this->_tev__PullMessagesFaultResponse::MaxMessageLimit);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_tev__PullMessagesFaultResponse::__any);
}

void _tev__PullMessagesFaultResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tev__PullMessagesFaultResponse::MaxTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->_tev__PullMessagesFaultResponse::MaxTimeout);
	soap_embedded(soap, &this->_tev__PullMessagesFaultResponse::MaxMessageLimit, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_tev__PullMessagesFaultResponse::__any);
#endif
}

int _tev__PullMessagesFaultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__PullMessagesFaultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, int id, const _tev__PullMessagesFaultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessagesFaultResponse), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tev:MaxTimeout", -1, &a->_tev__PullMessagesFaultResponse::MaxTimeout, ""))
		return soap->error;
	if (soap_out_int(soap, "tev:MaxMessageLimit", -1, &a->_tev__PullMessagesFaultResponse::MaxMessageLimit, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_tev__PullMessagesFaultResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__PullMessagesFaultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__PullMessagesFaultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_in__tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, _tev__PullMessagesFaultResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__PullMessagesFaultResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(_tev__PullMessagesFaultResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__PullMessagesFaultResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__PullMessagesFaultResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MaxTimeout1 = 1;
	size_t soap_flag_MaxMessageLimit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaxTimeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tev:MaxTimeout", &a->_tev__PullMessagesFaultResponse::MaxTimeout, "xsd:duration"))
				{	soap_flag_MaxTimeout1--;
					continue;
				}
			}
			if (soap_flag_MaxMessageLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tev:MaxMessageLimit", &a->_tev__PullMessagesFaultResponse::MaxMessageLimit, "xsd:int"))
				{	soap_flag_MaxMessageLimit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_tev__PullMessagesFaultResponse::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaxTimeout1 > 0 || soap_flag_MaxMessageLimit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__PullMessagesFaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesFaultResponse, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(_tev__PullMessagesFaultResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__PullMessagesFaultResponse * SOAP_FMAC2 soap_instantiate__tev__PullMessagesFaultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__PullMessagesFaultResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__PullMessagesFaultResponse *p;
	size_t k = sizeof(_tev__PullMessagesFaultResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__PullMessagesFaultResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__PullMessagesFaultResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__PullMessagesFaultResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__PullMessagesFaultResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__PullMessagesFaultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__PullMessagesFaultResponse(soap, tag ? tag : "tev:PullMessagesFaultResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__PullMessagesFaultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__PullMessagesFaultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_get__tev__PullMessagesFaultResponse(struct soap *soap, _tev__PullMessagesFaultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessagesFaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__PullMessagesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__dateTime(soap, &this->_tev__PullMessagesResponse::CurrentTime);
	soap_default_xsd__dateTime(soap, &this->_tev__PullMessagesResponse::TerminationTime);
	soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_tev__PullMessagesResponse::wsnt__NotificationMessage);
}

void _tev__PullMessagesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tev__PullMessagesResponse::CurrentTime, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->_tev__PullMessagesResponse::CurrentTime);
	soap_embedded(soap, &this->_tev__PullMessagesResponse::TerminationTime, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->_tev__PullMessagesResponse::TerminationTime);
	soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_tev__PullMessagesResponse::wsnt__NotificationMessage);
#endif
}

int _tev__PullMessagesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__PullMessagesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessagesResponse(struct soap *soap, const char *tag, int id, const _tev__PullMessagesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessagesResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:CurrentTime");
	if (soap_out_xsd__dateTime(soap, "tev:CurrentTime", -1, &a->_tev__PullMessagesResponse::CurrentTime, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tev:TerminationTime", -1, &a->_tev__PullMessagesResponse::TerminationTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->_tev__PullMessagesResponse::wsnt__NotificationMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__PullMessagesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__PullMessagesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__PullMessagesResponse * SOAP_FMAC4 soap_in__tev__PullMessagesResponse(struct soap *soap, const char *tag, _tev__PullMessagesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__PullMessagesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesResponse, sizeof(_tev__PullMessagesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__PullMessagesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__PullMessagesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CurrentTime1 = 1;
	size_t soap_flag_TerminationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tev:CurrentTime", &a->_tev__PullMessagesResponse::CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			}
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tev:TerminationTime", &a->_tev__PullMessagesResponse::TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->_tev__PullMessagesResponse::wsnt__NotificationMessage, "wsnt:NotificationMessageHolderType"))
					continue;
			}
			soap_check_result(soap, "tev:CurrentTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentTime1 > 0 || soap_flag_TerminationTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__PullMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesResponse, SOAP_TYPE__tev__PullMessagesResponse, sizeof(_tev__PullMessagesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__PullMessagesResponse * SOAP_FMAC2 soap_instantiate__tev__PullMessagesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__PullMessagesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__PullMessagesResponse *p;
	size_t k = sizeof(_tev__PullMessagesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__PullMessagesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__PullMessagesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__PullMessagesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__PullMessagesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__PullMessagesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__PullMessagesResponse(soap, tag ? tag : "tev:PullMessagesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__PullMessagesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__PullMessagesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__PullMessagesResponse * SOAP_FMAC4 soap_get__tev__PullMessagesResponse(struct soap *soap, _tev__PullMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__PullMessages::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__duration(soap, &this->_tev__PullMessages::Timeout);
	soap_default_int(soap, &this->_tev__PullMessages::MessageLimit);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_tev__PullMessages::__any);
}

void _tev__PullMessages::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tev__PullMessages::Timeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->_tev__PullMessages::Timeout);
	soap_embedded(soap, &this->_tev__PullMessages::MessageLimit, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_tev__PullMessages::__any);
#endif
}

int _tev__PullMessages::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__PullMessages(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessages(struct soap *soap, const char *tag, int id, const _tev__PullMessages *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessages), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tev:Timeout", -1, &a->_tev__PullMessages::Timeout, ""))
		return soap->error;
	if (soap_out_int(soap, "tev:MessageLimit", -1, &a->_tev__PullMessages::MessageLimit, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_tev__PullMessages::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__PullMessages::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__PullMessages(soap, tag, this, type);
}

SOAP_FMAC3 _tev__PullMessages * SOAP_FMAC4 soap_in__tev__PullMessages(struct soap *soap, const char *tag, _tev__PullMessages *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__PullMessages*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessages, sizeof(_tev__PullMessages), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__PullMessages)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__PullMessages *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Timeout1 = 1;
	size_t soap_flag_MessageLimit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tev:Timeout", &a->_tev__PullMessages::Timeout, "xsd:duration"))
				{	soap_flag_Timeout1--;
					continue;
				}
			}
			if (soap_flag_MessageLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tev:MessageLimit", &a->_tev__PullMessages::MessageLimit, "xsd:int"))
				{	soap_flag_MessageLimit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_tev__PullMessages::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timeout1 > 0 || soap_flag_MessageLimit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__PullMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessages, SOAP_TYPE__tev__PullMessages, sizeof(_tev__PullMessages), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__PullMessages * SOAP_FMAC2 soap_instantiate__tev__PullMessages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__PullMessages(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__PullMessages *p;
	size_t k = sizeof(_tev__PullMessages);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__PullMessages, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__PullMessages);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__PullMessages, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__PullMessages location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__PullMessages::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__PullMessages(soap, tag ? tag : "tev:PullMessages", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__PullMessages::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__PullMessages(soap, this, tag, type);
}

SOAP_FMAC3 _tev__PullMessages * SOAP_FMAC4 soap_get__tev__PullMessages(struct soap *soap, _tev__PullMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__CreatePullPointSubscriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_tev__CreatePullPointSubscriptionResponse::SubscriptionReference);
	soap_default_xsd__dateTime(soap, &this->_tev__CreatePullPointSubscriptionResponse::wsnt__CurrentTime);
	soap_default_xsd__dateTime(soap, &this->_tev__CreatePullPointSubscriptionResponse::wsnt__TerminationTime);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_tev__CreatePullPointSubscriptionResponse::__any);
}

void _tev__CreatePullPointSubscriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tev__CreatePullPointSubscriptionResponse::SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_tev__CreatePullPointSubscriptionResponse::SubscriptionReference);
	soap_embedded(soap, &this->_tev__CreatePullPointSubscriptionResponse::wsnt__CurrentTime, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->_tev__CreatePullPointSubscriptionResponse::wsnt__CurrentTime);
	soap_embedded(soap, &this->_tev__CreatePullPointSubscriptionResponse::wsnt__TerminationTime, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->_tev__CreatePullPointSubscriptionResponse::wsnt__TerminationTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_tev__CreatePullPointSubscriptionResponse::__any);
#endif
}

int _tev__CreatePullPointSubscriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__CreatePullPointSubscriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, int id, const _tev__CreatePullPointSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:SubscriptionReference");
	if (soap_out_wsa5__EndpointReferenceType(soap, "tev:SubscriptionReference", -1, &a->_tev__CreatePullPointSubscriptionResponse::SubscriptionReference, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsnt:CurrentTime", -1, &a->_tev__CreatePullPointSubscriptionResponse::wsnt__CurrentTime, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsnt:TerminationTime", -1, &a->_tev__CreatePullPointSubscriptionResponse::wsnt__TerminationTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_tev__CreatePullPointSubscriptionResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__CreatePullPointSubscriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__CreatePullPointSubscriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, _tev__CreatePullPointSubscriptionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__CreatePullPointSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(_tev__CreatePullPointSubscriptionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__CreatePullPointSubscriptionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__CreatePullPointSubscriptionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SubscriptionReference1 = 1;
	size_t soap_flag_wsnt__CurrentTime1 = 1;
	size_t soap_flag_wsnt__TerminationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "tev:SubscriptionReference", &a->_tev__CreatePullPointSubscriptionResponse::SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference1--;
					continue;
				}
			}
			if (soap_flag_wsnt__CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsnt:CurrentTime", &a->_tev__CreatePullPointSubscriptionResponse::wsnt__CurrentTime, "xsd:dateTime"))
				{	soap_flag_wsnt__CurrentTime1--;
					continue;
				}
			}
			if (soap_flag_wsnt__TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsnt:TerminationTime", &a->_tev__CreatePullPointSubscriptionResponse::wsnt__TerminationTime, "xsd:dateTime"))
				{	soap_flag_wsnt__TerminationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_tev__CreatePullPointSubscriptionResponse::__any, "xsd:anyType"))
					continue;
			}
			soap_check_result(soap, "tev:SubscriptionReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference1 > 0 || soap_flag_wsnt__CurrentTime1 > 0 || soap_flag_wsnt__TerminationTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__CreatePullPointSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(_tev__CreatePullPointSubscriptionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__CreatePullPointSubscriptionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__CreatePullPointSubscriptionResponse *p;
	size_t k = sizeof(_tev__CreatePullPointSubscriptionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__CreatePullPointSubscriptionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__CreatePullPointSubscriptionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__CreatePullPointSubscriptionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__CreatePullPointSubscriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__CreatePullPointSubscriptionResponse(soap, tag ? tag : "tev:CreatePullPointSubscriptionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__CreatePullPointSubscriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__CreatePullPointSubscriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscriptionResponse(struct soap *soap, _tev__CreatePullPointSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__CreatePullPointSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tev__CreatePullPointSubscription::Filter = NULL;
	this->_tev__CreatePullPointSubscription::InitialTerminationTime = NULL;
	this->_tev__CreatePullPointSubscription::SubscriptionPolicy = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_tev__CreatePullPointSubscription::__any);
}

void _tev__CreatePullPointSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__FilterType(soap, &this->_tev__CreatePullPointSubscription::Filter);
	soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, &this->_tev__CreatePullPointSubscription::InitialTerminationTime);
	soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, &this->_tev__CreatePullPointSubscription::SubscriptionPolicy);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_tev__CreatePullPointSubscription::__any);
#endif
}

int _tev__CreatePullPointSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__CreatePullPointSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscription(struct soap *soap, const char *tag, int id, const _tev__CreatePullPointSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscription), type))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tev:Filter", -1, &a->_tev__CreatePullPointSubscription::Filter, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "tev:InitialTerminationTime", -1, &a->_tev__CreatePullPointSubscription::InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:SubscriptionPolicy", -1, &a->_tev__CreatePullPointSubscription::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_tev__CreatePullPointSubscription::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__CreatePullPointSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__CreatePullPointSubscription(soap, tag, this, type);
}

SOAP_FMAC3 _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscription(struct soap *soap, const char *tag, _tev__CreatePullPointSubscription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__CreatePullPointSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(_tev__CreatePullPointSubscription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__CreatePullPointSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__CreatePullPointSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_InitialTerminationTime1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "tev:Filter", &a->_tev__CreatePullPointSubscription::Filter, "wsnt:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_InitialTerminationTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "tev:InitialTerminationTime", &a->_tev__CreatePullPointSubscription::InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:SubscriptionPolicy", &a->_tev__CreatePullPointSubscription::SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_tev__CreatePullPointSubscription::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__CreatePullPointSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(_tev__CreatePullPointSubscription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__CreatePullPointSubscription * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__CreatePullPointSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__CreatePullPointSubscription *p;
	size_t k = sizeof(_tev__CreatePullPointSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__CreatePullPointSubscription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__CreatePullPointSubscription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__CreatePullPointSubscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__CreatePullPointSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__CreatePullPointSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__CreatePullPointSubscription(soap, tag ? tag : "tev:CreatePullPointSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__CreatePullPointSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__CreatePullPointSubscription(soap, this, tag, type);
}

SOAP_FMAC3 _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscription(struct soap *soap, _tev__CreatePullPointSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__GetServiceCapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tev__GetServiceCapabilitiesResponse::Capabilities = NULL;
}

void _tev__GetServiceCapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotev__Capabilities(soap, &this->_tev__GetServiceCapabilitiesResponse::Capabilities);
#endif
}

int _tev__GetServiceCapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__GetServiceCapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tev__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tev:Capabilities");
	if (!a->_tev__GetServiceCapabilitiesResponse::Capabilities)
	{	if (soap_element_empty(soap, "tev:Capabilities"))
			return soap->error;
	}
	else if (soap_out_PointerTotev__Capabilities(soap, "tev:Capabilities", -1, &a->_tev__GetServiceCapabilitiesResponse::Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__GetServiceCapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__GetServiceCapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, _tev__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(_tev__GetServiceCapabilitiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__GetServiceCapabilitiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__GetServiceCapabilitiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotev__Capabilities(soap, "tev:Capabilities", &a->_tev__GetServiceCapabilitiesResponse::Capabilities, "tev:Capabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			soap_check_result(soap, "tev:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tev__GetServiceCapabilitiesResponse::Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(_tev__GetServiceCapabilitiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tev__GetServiceCapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__GetServiceCapabilitiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__GetServiceCapabilitiesResponse *p;
	size_t k = sizeof(_tev__GetServiceCapabilitiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__GetServiceCapabilitiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__GetServiceCapabilitiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__GetServiceCapabilitiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__GetServiceCapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__GetServiceCapabilitiesResponse(soap, tag ? tag : "tev:GetServiceCapabilitiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__GetServiceCapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__GetServiceCapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tev__GetServiceCapabilitiesResponse(struct soap *soap, _tev__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__GetServiceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tev__GetServiceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tev__GetServiceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__GetServiceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const _tev__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__GetServiceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tev__GetServiceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tev__GetServiceCapabilities * SOAP_FMAC4 soap_in__tev__GetServiceCapabilities(struct soap *soap, const char *tag, _tev__GetServiceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(_tev__GetServiceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__GetServiceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__GetServiceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilities, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(_tev__GetServiceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tev__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__GetServiceCapabilities *p;
	size_t k = sizeof(_tev__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__GetServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__GetServiceCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__GetServiceCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__GetServiceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__GetServiceCapabilities(soap, tag ? tag : "tev:GetServiceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__GetServiceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__GetServiceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tev__GetServiceCapabilities * SOAP_FMAC4 soap_get__tev__GetServiceCapabilities(struct soap *soap, _tev__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tev__SubscriptionPolicy::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tev__SubscriptionPolicy::__any);
	this->tev__SubscriptionPolicy::ChangedOnly = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tev__SubscriptionPolicy::__anyAttribute);
}

void tev__SubscriptionPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tev__SubscriptionPolicy::__any);
#endif
}

int tev__SubscriptionPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tev__SubscriptionPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tev__SubscriptionPolicy(struct soap *soap, const char *tag, int id, const tev__SubscriptionPolicy *a, const char *type)
{
	if (((tev__SubscriptionPolicy*)a)->ChangedOnly)
	{	soap_set_attr(soap, "ChangedOnly", soap_bool2s(soap, *((tev__SubscriptionPolicy*)a)->ChangedOnly), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tev__SubscriptionPolicy*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tev__SubscriptionPolicy), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tev__SubscriptionPolicy::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tev__SubscriptionPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tev__SubscriptionPolicy(soap, tag, this, type);
}

SOAP_FMAC3 tev__SubscriptionPolicy * SOAP_FMAC4 soap_in_tev__SubscriptionPolicy(struct soap *soap, const char *tag, tev__SubscriptionPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tev__SubscriptionPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__SubscriptionPolicy, sizeof(tev__SubscriptionPolicy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tev__SubscriptionPolicy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tev__SubscriptionPolicy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "ChangedOnly", 5, 0);
		if (t)
		{
			if (!(((tev__SubscriptionPolicy*)a)->ChangedOnly = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tev__SubscriptionPolicy*)a)->ChangedOnly))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tev__SubscriptionPolicy*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tev__SubscriptionPolicy::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tev__SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__SubscriptionPolicy, SOAP_TYPE_tev__SubscriptionPolicy, sizeof(tev__SubscriptionPolicy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tev__SubscriptionPolicy * SOAP_FMAC2 soap_instantiate_tev__SubscriptionPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tev__SubscriptionPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tev__SubscriptionPolicy *p;
	size_t k = sizeof(tev__SubscriptionPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tev__SubscriptionPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tev__SubscriptionPolicy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tev__SubscriptionPolicy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tev__SubscriptionPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tev__SubscriptionPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tev__SubscriptionPolicy(soap, tag ? tag : "tev:SubscriptionPolicy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tev__SubscriptionPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tev__SubscriptionPolicy(soap, this, tag, type);
}

SOAP_FMAC3 tev__SubscriptionPolicy * SOAP_FMAC4 soap_get_tev__SubscriptionPolicy(struct soap *soap, tev__SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in_tev__SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tev__Capabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tev__Capabilities::__any);
	this->tev__Capabilities::WSSubscriptionPolicySupport = NULL;
	this->tev__Capabilities::WSPullPointSupport = NULL;
	this->tev__Capabilities::WSPausableSubscriptionManagerInterfaceSupport = NULL;
	this->tev__Capabilities::MaxNotificationProducers = NULL;
	this->tev__Capabilities::MaxPullPoints = NULL;
	this->tev__Capabilities::PersistentNotificationStorage = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tev__Capabilities::__anyAttribute);
}

void tev__Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tev__Capabilities::__any);
#endif
}

int tev__Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tev__Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tev__Capabilities(struct soap *soap, const char *tag, int id, const tev__Capabilities *a, const char *type)
{
	if (((tev__Capabilities*)a)->WSSubscriptionPolicySupport)
	{	soap_set_attr(soap, "WSSubscriptionPolicySupport", soap_bool2s(soap, *((tev__Capabilities*)a)->WSSubscriptionPolicySupport), 1);
	}
	if (((tev__Capabilities*)a)->WSPullPointSupport)
	{	soap_set_attr(soap, "WSPullPointSupport", soap_bool2s(soap, *((tev__Capabilities*)a)->WSPullPointSupport), 1);
	}
	if (((tev__Capabilities*)a)->WSPausableSubscriptionManagerInterfaceSupport)
	{	soap_set_attr(soap, "WSPausableSubscriptionManagerInterfaceSupport", soap_bool2s(soap, *((tev__Capabilities*)a)->WSPausableSubscriptionManagerInterfaceSupport), 1);
	}
	if (((tev__Capabilities*)a)->MaxNotificationProducers)
	{	soap_set_attr(soap, "MaxNotificationProducers", soap_int2s(soap, *((tev__Capabilities*)a)->MaxNotificationProducers), 1);
	}
	if (((tev__Capabilities*)a)->MaxPullPoints)
	{	soap_set_attr(soap, "MaxPullPoints", soap_int2s(soap, *((tev__Capabilities*)a)->MaxPullPoints), 1);
	}
	if (((tev__Capabilities*)a)->PersistentNotificationStorage)
	{	soap_set_attr(soap, "PersistentNotificationStorage", soap_bool2s(soap, *((tev__Capabilities*)a)->PersistentNotificationStorage), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tev__Capabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tev__Capabilities), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tev__Capabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tev__Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tev__Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 tev__Capabilities * SOAP_FMAC4 soap_in_tev__Capabilities(struct soap *soap, const char *tag, tev__Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tev__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__Capabilities, sizeof(tev__Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tev__Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tev__Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "WSSubscriptionPolicySupport", 5, 0);
		if (t)
		{
			if (!(((tev__Capabilities*)a)->WSSubscriptionPolicySupport = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tev__Capabilities*)a)->WSSubscriptionPolicySupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "WSPullPointSupport", 5, 0);
		if (t)
		{
			if (!(((tev__Capabilities*)a)->WSPullPointSupport = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tev__Capabilities*)a)->WSPullPointSupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "WSPausableSubscriptionManagerInterfaceSupport", 5, 0);
		if (t)
		{
			if (!(((tev__Capabilities*)a)->WSPausableSubscriptionManagerInterfaceSupport = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tev__Capabilities*)a)->WSPausableSubscriptionManagerInterfaceSupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxNotificationProducers", 5, 0);
		if (t)
		{
			if (!(((tev__Capabilities*)a)->MaxNotificationProducers = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tev__Capabilities*)a)->MaxNotificationProducers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxPullPoints", 5, 0);
		if (t)
		{
			if (!(((tev__Capabilities*)a)->MaxPullPoints = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tev__Capabilities*)a)->MaxPullPoints))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PersistentNotificationStorage", 5, 0);
		if (t)
		{
			if (!(((tev__Capabilities*)a)->PersistentNotificationStorage = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tev__Capabilities*)a)->PersistentNotificationStorage))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tev__Capabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tev__Capabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tev__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__Capabilities, SOAP_TYPE_tev__Capabilities, sizeof(tev__Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tev__Capabilities * SOAP_FMAC2 soap_instantiate_tev__Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tev__Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tev__Capabilities *p;
	size_t k = sizeof(tev__Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tev__Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tev__Capabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tev__Capabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tev__Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tev__Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tev__Capabilities(soap, tag ? tag : "tev:Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tev__Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tev__Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 tev__Capabilities * SOAP_FMAC4 soap_get_tev__Capabilities(struct soap *soap, tev__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tev__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__TopicSetType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wstop__ExtensibleDocumented::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__TopicSetType::__any);
}

void wstop__TopicSetType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__TopicSetType::__any);
	this->wstop__ExtensibleDocumented::soap_serialize(soap);
#endif
}

int wstop__TopicSetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__TopicSetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicSetType(struct soap *soap, const char *tag, int id, const wstop__TopicSetType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wstop__ExtensibleDocumented*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicSetType), type ? type : "wstop:TopicSetType"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->wstop__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wstop__TopicSetType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__TopicSetType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__TopicSetType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__TopicSetType * SOAP_FMAC4 soap_in_wstop__TopicSetType(struct soap *soap, const char *tag, wstop__TopicSetType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__TopicSetType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__TopicSetType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__TopicSetType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wstop__ExtensibleDocumented*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_documentation2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->wstop__ExtensibleDocumented::documentation, "wstop:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wstop__TopicSetType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__TopicSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicSetType, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__TopicSetType * SOAP_FMAC2 soap_instantiate_wstop__TopicSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__TopicSetType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__TopicSetType *p;
	size_t k = sizeof(wstop__TopicSetType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__TopicSetType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__TopicSetType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__TopicSetType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__TopicSetType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__TopicSetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__TopicSetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__TopicSetType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__TopicSetType * SOAP_FMAC4 soap_get_wstop__TopicSetType(struct soap *soap, wstop__TopicSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__TopicType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wstop__ExtensibleDocumented::soap_default(soap);
	this->wstop__TopicType::MessagePattern = NULL;
	soap_default_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->wstop__TopicType::Topic);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__TopicType::__any);
	soap_default_xsd__NCName(soap, &this->wstop__TopicType::name);
	this->wstop__TopicType::messageTypes = NULL;
	this->wstop__TopicType::final_ = (bool)0;
}

void wstop__TopicType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &this->wstop__TopicType::MessagePattern);
	soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->wstop__TopicType::Topic);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__TopicType::__any);
	this->wstop__ExtensibleDocumented::soap_serialize(soap);
#endif
}

int wstop__TopicType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__TopicType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicType(struct soap *soap, const char *tag, int id, const wstop__TopicType *a, const char *type)
{
	soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((wstop__TopicType*)a)->name), 1);
	if (((wstop__TopicType*)a)->messageTypes)
	{	soap_set_attr(soap, "messageTypes", soap_xsd__QName2s(soap, *((wstop__TopicType*)a)->messageTypes), 1);
	}
	if (((wstop__TopicType*)a)->final_ != (bool)0)
	{	soap_set_attr(soap, "final", soap_bool2s(soap, ((wstop__TopicType*)a)->final_), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wstop__ExtensibleDocumented*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicType), type ? type : "wstop:TopicType"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->wstop__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->wstop__TopicType::MessagePattern, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", -1, &a->wstop__TopicType::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wstop__TopicType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__TopicType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__TopicType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__TopicType * SOAP_FMAC4 soap_in_wstop__TopicType(struct soap *soap, const char *tag, wstop__TopicType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__TopicType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__TopicType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__TopicType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &((wstop__TopicType*)a)->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(((wstop__TopicType*)a)->messageTypes = soap_new_xsd__QName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__QName(soap, t, ((wstop__TopicType*)a)->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 5, 0), &((wstop__TopicType*)a)->final_))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wstop__ExtensibleDocumented*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_documentation2 = 1;
	size_t soap_flag_MessagePattern1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->wstop__ExtensibleDocumented::documentation, "wstop:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			}
			if (soap_flag_MessagePattern1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->wstop__TopicType::MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", &a->wstop__TopicType::Topic, "wstop:TopicType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wstop__TopicType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__TopicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicType, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__TopicType * SOAP_FMAC2 soap_instantiate_wstop__TopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__TopicType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__TopicType *p;
	size_t k = sizeof(wstop__TopicType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__TopicType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__TopicType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__TopicType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__TopicType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__TopicType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__TopicType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__TopicType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__TopicType * SOAP_FMAC4 soap_get_wstop__TopicType(struct soap *soap, wstop__TopicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__TopicNamespaceType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wstop__ExtensibleDocumented::soap_default(soap);
	soap_default_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, &this->wstop__TopicNamespaceType::Topic);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__TopicNamespaceType::__any);
	this->wstop__TopicNamespaceType::name = NULL;
	soap_default_xsd__anyURI(soap, &this->wstop__TopicNamespaceType::targetNamespace);
	this->wstop__TopicNamespaceType::final_ = (bool)0;
}

void wstop__TopicNamespaceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, &this->wstop__TopicNamespaceType::Topic);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__TopicNamespaceType::__any);
	this->wstop__ExtensibleDocumented::soap_serialize(soap);
#endif
}

int wstop__TopicNamespaceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__TopicNamespaceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicNamespaceType(struct soap *soap, const char *tag, int id, const wstop__TopicNamespaceType *a, const char *type)
{
	if (((wstop__TopicNamespaceType*)a)->name)
	{	soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, *((wstop__TopicNamespaceType*)a)->name), 1);
	}
	soap_set_attr(soap, "targetNamespace", soap_xsd__anyURI2s(soap, ((wstop__TopicNamespaceType*)a)->targetNamespace), 1);
	if (((wstop__TopicNamespaceType*)a)->final_ != (bool)0)
	{	soap_set_attr(soap, "final", soap_bool2s(soap, ((wstop__TopicNamespaceType*)a)->final_), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wstop__ExtensibleDocumented*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicNamespaceType), type ? type : "wstop:TopicNamespaceType"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->wstop__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", -1, &a->wstop__TopicNamespaceType::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wstop__TopicNamespaceType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__TopicNamespaceType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__TopicNamespaceType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__TopicNamespaceType * SOAP_FMAC4 soap_in_wstop__TopicNamespaceType(struct soap *soap, const char *tag, wstop__TopicNamespaceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__TopicNamespaceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(wstop__TopicNamespaceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__TopicNamespaceType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__TopicNamespaceType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "name", 5, 0);
		if (t)
		{
			if (!(((wstop__TopicNamespaceType*)a)->name = soap_new_xsd__NCName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__NCName(soap, t, ((wstop__TopicNamespaceType*)a)->name))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 4, 1), &((wstop__TopicNamespaceType*)a)->targetNamespace))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 5, 0), &((wstop__TopicNamespaceType*)a)->final_))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wstop__ExtensibleDocumented*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_documentation2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->wstop__ExtensibleDocumented::documentation, "wstop:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", &a->wstop__TopicNamespaceType::Topic, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wstop__TopicNamespaceType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__TopicNamespaceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicNamespaceType, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(wstop__TopicNamespaceType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__TopicNamespaceType * SOAP_FMAC2 soap_instantiate_wstop__TopicNamespaceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__TopicNamespaceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__TopicNamespaceType *p;
	size_t k = sizeof(wstop__TopicNamespaceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__TopicNamespaceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__TopicNamespaceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__TopicNamespaceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__TopicNamespaceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__TopicNamespaceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__TopicNamespaceType(soap, tag ? tag : "wstop:TopicNamespaceType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__TopicNamespaceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__TopicNamespaceType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__TopicNamespaceType * SOAP_FMAC4 soap_get_wstop__TopicNamespaceType(struct soap *soap, wstop__TopicNamespaceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicNamespaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__QueryExpressionType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &this->wstop__QueryExpressionType::__any);
	soap_default_xsd__anyURI(soap, &this->wstop__QueryExpressionType::Dialect);
	soap_default_xsd__anyType(soap, &this->wstop__QueryExpressionType::__mixed);
}

void wstop__QueryExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyType(soap, &this->wstop__QueryExpressionType::__any);
	soap_serialize_xsd__anyType(soap, &this->wstop__QueryExpressionType::__mixed);
#endif
}

int wstop__QueryExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__QueryExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__QueryExpressionType(struct soap *soap, const char *tag, int id, const wstop__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((wstop__QueryExpressionType*)a)->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__QueryExpressionType), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->wstop__QueryExpressionType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->wstop__QueryExpressionType::__mixed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__QueryExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__QueryExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__QueryExpressionType * SOAP_FMAC4 soap_in_wstop__QueryExpressionType(struct soap *soap, const char *tag, wstop__QueryExpressionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__QueryExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__QueryExpressionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__QueryExpressionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &((wstop__QueryExpressionType*)a)->Dialect))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->wstop__QueryExpressionType::__any, "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->wstop__QueryExpressionType::__mixed, "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__QueryExpressionType, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wstop__QueryExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__QueryExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__QueryExpressionType *p;
	size_t k = sizeof(wstop__QueryExpressionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__QueryExpressionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__QueryExpressionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__QueryExpressionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__QueryExpressionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__QueryExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__QueryExpressionType(soap, tag ? tag : "wstop:QueryExpressionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__QueryExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__QueryExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__QueryExpressionType * SOAP_FMAC4 soap_get_wstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__ExtensibleDocumented::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wstop__ExtensibleDocumented::documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wstop__ExtensibleDocumented::__anyAttribute);
}

void wstop__ExtensibleDocumented::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &this->wstop__ExtensibleDocumented::documentation);
#endif
}

int wstop__ExtensibleDocumented::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__ExtensibleDocumented(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, int id, const wstop__ExtensibleDocumented *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wstop__ExtensibleDocumented*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__ExtensibleDocumented), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->wstop__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__ExtensibleDocumented::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__ExtensibleDocumented(soap, tag, this, type);
}

SOAP_FMAC3 wstop__ExtensibleDocumented * SOAP_FMAC4 soap_in_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, wstop__ExtensibleDocumented *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__ExtensibleDocumented*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(wstop__ExtensibleDocumented), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__ExtensibleDocumented)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__ExtensibleDocumented *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wstop__ExtensibleDocumented*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_documentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->wstop__ExtensibleDocumented::documentation, "wstop:Documentation"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__ExtensibleDocumented *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__ExtensibleDocumented, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(wstop__ExtensibleDocumented), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__ExtensibleDocumented * SOAP_FMAC2 soap_instantiate_wstop__ExtensibleDocumented(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__ExtensibleDocumented(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicNamespaceType"))
		return soap_instantiate_wstop__TopicNamespaceType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicType"))
		return soap_instantiate_wstop__TopicType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicSetType"))
		return soap_instantiate_wstop__TopicSetType(soap, n, NULL, NULL, size);
	wstop__ExtensibleDocumented *p;
	size_t k = sizeof(wstop__ExtensibleDocumented);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__ExtensibleDocumented, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__ExtensibleDocumented);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__ExtensibleDocumented, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__ExtensibleDocumented location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__ExtensibleDocumented::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__ExtensibleDocumented(soap, tag ? tag : "wstop:ExtensibleDocumented", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__ExtensibleDocumented::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__ExtensibleDocumented(soap, this, tag, type);
}

SOAP_FMAC3 wstop__ExtensibleDocumented * SOAP_FMAC4 soap_get_wstop__ExtensibleDocumented(struct soap *soap, wstop__ExtensibleDocumented *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ExtensibleDocumented(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__Documentation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__Documentation::__any);
	soap_default_xsd__anyType(soap, &this->wstop__Documentation::__mixed);
}

void wstop__Documentation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__Documentation::__any);
	soap_serialize_xsd__anyType(soap, &this->wstop__Documentation::__mixed);
#endif
}

int wstop__Documentation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__Documentation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__Documentation(struct soap *soap, const char *tag, int id, const wstop__Documentation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__Documentation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wstop__Documentation::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->wstop__Documentation::__mixed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__Documentation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wstop__Documentation(soap, tag, this, type);
}

SOAP_FMAC3 wstop__Documentation * SOAP_FMAC4 soap_in_wstop__Documentation(struct soap *soap, const char *tag, wstop__Documentation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__Documentation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__Documentation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__Documentation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wstop__Documentation::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->wstop__Documentation::__mixed, "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__Documentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__Documentation, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__Documentation * SOAP_FMAC2 soap_instantiate_wstop__Documentation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__Documentation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__Documentation *p;
	size_t k = sizeof(wstop__Documentation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__Documentation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__Documentation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__Documentation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__Documentation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__Documentation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__Documentation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__Documentation(soap, this, tag, type);
}

SOAP_FMAC3 wstop__Documentation * SOAP_FMAC4 soap_get_wstop__Documentation(struct soap *soap, wstop__Documentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsrfbf__BaseFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_xsd__dateTime(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	soap_default_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, &this->wsrfbf__BaseFaultType::Description);
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
}

void wsrfbf__BaseFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	soap_serialize_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, &this->wsrfbf__BaseFaultType::Description);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
#endif
}

int wsrfbf__BaseFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsrfbf__BaseFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, int id, const wsrfbf__BaseFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfbf__BaseFaultType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsrfbf__BaseFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsrfbf__BaseFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsrfbf__BaseFaultType * SOAP_FMAC4 soap_in_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, wsrfbf__BaseFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsrfbf__BaseFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(wsrfbf__BaseFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsrfbf__BaseFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsrfbf__BaseFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Originator1 = 1;
	size_t soap_flag_ErrorCode1 = 1;
	size_t soap_flag_FaultCause1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			}
			if (soap_flag_Originator1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator1--;
					continue;
				}
			}
			if (soap_flag_ErrorCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsrfbf__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfbf__BaseFaultType, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(wsrfbf__BaseFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsrfbf__BaseFaultType * SOAP_FMAC2 soap_instantiate_wsrfbf__BaseFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrfbf__BaseFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "wsnt:SubscribeCreationFailedFaultType"))
		return soap_instantiate_wsnt__SubscribeCreationFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidFilterFaultType"))
		return soap_instantiate_wsnt__InvalidFilterFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:TopicExpressionDialectUnknownFaultType"))
		return soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidTopicExpressionFaultType"))
		return soap_instantiate_wsnt__InvalidTopicExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:TopicNotSupportedFaultType"))
		return soap_instantiate_wsnt__TopicNotSupportedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:MultipleTopicsSpecifiedFaultType"))
		return soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
		return soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidMessageContentExpressionFaultType"))
		return soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnrecognizedPolicyRequestFaultType"))
		return soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnsupportedPolicyRequestFaultType"))
		return soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:NotifyMessageNotSupportedFaultType"))
		return soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
		return soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:NoCurrentMessageOnTopicFaultType"))
		return soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToGetMessagesFaultType"))
		return soap_instantiate_wsnt__UnableToGetMessagesFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToDestroyPullPointFaultType"))
		return soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToCreatePullPointFaultType"))
		return soap_instantiate_wsnt__UnableToCreatePullPointFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnacceptableTerminationTimeFaultType"))
		return soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToDestroySubscriptionFaultType"))
		return soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:PauseFailedFaultType"))
		return soap_instantiate_wsnt__PauseFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:ResumeFailedFaultType"))
		return soap_instantiate_wsnt__ResumeFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsrf:ResourceUnknownFaultType"))
		return soap_instantiate_wsrf__ResourceUnknownFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsrf:ResourceUnavailableFaultType"))
		return soap_instantiate_wsrf__ResourceUnavailableFaultType(soap, n, NULL, NULL, size);
	wsrfbf__BaseFaultType *p;
	size_t k = sizeof(wsrfbf__BaseFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrfbf__BaseFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsrfbf__BaseFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsrfbf__BaseFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsrfbf__BaseFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsrfbf__BaseFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsrfbf__BaseFaultType(soap, tag ? tag : "wsrfbf:BaseFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsrfbf__BaseFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsrfbf__BaseFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsrfbf__BaseFaultType * SOAP_FMAC4 soap_get_wsrfbf__BaseFaultType(struct soap *soap, wsrfbf__BaseFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfbf__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xop__Include::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->xop__Include::__any);
	soap_default_xsd__anyURI(soap, &this->xop__Include::href);
	soap_default_xsd__anyAttribute(soap, &this->xop__Include::__anyAttribute);
}

void xop__Include::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->xop__Include::__any);
#endif
}

int xop__Include::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xop__Include(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xop__Include(struct soap *soap, const char *tag, int id, const xop__Include *a, const char *type)
{
	soap_set_attr(soap, "href", soap_xsd__anyURI2s(soap, ((xop__Include*)a)->href), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((xop__Include*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xop__Include), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->xop__Include::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xop__Include::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xop__Include(soap, tag, this, type);
}

SOAP_FMAC3 xop__Include * SOAP_FMAC4 soap_in_xop__Include(struct soap *soap, const char *tag, xop__Include *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xop__Include*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xop__Include, sizeof(xop__Include), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xop__Include)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xop__Include *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "href", 4, 1), &((xop__Include*)a)->href))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((xop__Include*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->xop__Include::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xop__Include, SOAP_TYPE_xop__Include, sizeof(xop__Include), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xop__Include * SOAP_FMAC2 soap_instantiate_xop__Include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xop__Include(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xop__Include *p;
	size_t k = sizeof(xop__Include);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xop__Include, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xop__Include);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xop__Include, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xop__Include location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xop__Include::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xop__Include(soap, tag ? tag : "xop:Include", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xop__Include::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xop__Include(soap, this, tag, type);
}

SOAP_FMAC3 xop__Include * SOAP_FMAC4 soap_get_xop__Include(struct soap *soap, xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in_xop__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__ResumeSubscriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__ResumeSubscriptionResponse::__any);
}

void _wsnt__ResumeSubscriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__ResumeSubscriptionResponse::__any);
#endif
}

int _wsnt__ResumeSubscriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__ResumeSubscriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, const _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "-any");
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__ResumeSubscriptionResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__ResumeSubscriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__ResumeSubscriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__ResumeSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(_wsnt__ResumeSubscriptionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__ResumeSubscriptionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__ResumeSubscriptionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__ResumeSubscriptionResponse::__any, "xsd:anyType"))
					continue;
			}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__ResumeSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(_wsnt__ResumeSubscriptionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__ResumeSubscriptionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__ResumeSubscriptionResponse *p;
	size_t k = sizeof(_wsnt__ResumeSubscriptionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__ResumeSubscriptionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__ResumeSubscriptionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__ResumeSubscriptionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__ResumeSubscriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__ResumeSubscriptionResponse(soap, tag ? tag : "wsnt:ResumeSubscriptionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__ResumeSubscriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__ResumeSubscriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__ResumeSubscriptionResponse(struct soap *soap, _wsnt__ResumeSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__ResumeSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__ResumeSubscription::__any);
}

void _wsnt__ResumeSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__ResumeSubscription::__any);
#endif
}

int _wsnt__ResumeSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__ResumeSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscription(struct soap *soap, const char *tag, int id, const _wsnt__ResumeSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__ResumeSubscription::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__ResumeSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__ResumeSubscription(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__ResumeSubscription * SOAP_FMAC4 soap_in__wsnt__ResumeSubscription(struct soap *soap, const char *tag, _wsnt__ResumeSubscription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__ResumeSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(_wsnt__ResumeSubscription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__ResumeSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__ResumeSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__ResumeSubscription::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__ResumeSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscription, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(_wsnt__ResumeSubscription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__ResumeSubscription * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__ResumeSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__ResumeSubscription *p;
	size_t k = sizeof(_wsnt__ResumeSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__ResumeSubscription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__ResumeSubscription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__ResumeSubscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__ResumeSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__ResumeSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__ResumeSubscription(soap, tag ? tag : "wsnt:ResumeSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__ResumeSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__ResumeSubscription(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__ResumeSubscription * SOAP_FMAC4 soap_get__wsnt__ResumeSubscription(struct soap *soap, _wsnt__ResumeSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__PauseSubscriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__PauseSubscriptionResponse::__any);
}

void _wsnt__PauseSubscriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__PauseSubscriptionResponse::__any);
#endif
}

int _wsnt__PauseSubscriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__PauseSubscriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, const _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "-any");
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__PauseSubscriptionResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__PauseSubscriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__PauseSubscriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__PauseSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(_wsnt__PauseSubscriptionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__PauseSubscriptionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__PauseSubscriptionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__PauseSubscriptionResponse::__any, "xsd:anyType"))
					continue;
			}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__PauseSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscriptionResponse, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(_wsnt__PauseSubscriptionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__PauseSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__PauseSubscriptionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__PauseSubscriptionResponse *p;
	size_t k = sizeof(_wsnt__PauseSubscriptionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__PauseSubscriptionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__PauseSubscriptionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__PauseSubscriptionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__PauseSubscriptionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__PauseSubscriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__PauseSubscriptionResponse(soap, tag ? tag : "wsnt:PauseSubscriptionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__PauseSubscriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__PauseSubscriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__PauseSubscriptionResponse(struct soap *soap, _wsnt__PauseSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__PauseSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__PauseSubscription::__any);
}

void _wsnt__PauseSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__PauseSubscription::__any);
#endif
}

int _wsnt__PauseSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__PauseSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscription(struct soap *soap, const char *tag, int id, const _wsnt__PauseSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__PauseSubscription::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__PauseSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__PauseSubscription(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__PauseSubscription * SOAP_FMAC4 soap_in__wsnt__PauseSubscription(struct soap *soap, const char *tag, _wsnt__PauseSubscription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__PauseSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscription, sizeof(_wsnt__PauseSubscription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__PauseSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__PauseSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__PauseSubscription::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__PauseSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscription, SOAP_TYPE__wsnt__PauseSubscription, sizeof(_wsnt__PauseSubscription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__PauseSubscription * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__PauseSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__PauseSubscription *p;
	size_t k = sizeof(_wsnt__PauseSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__PauseSubscription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__PauseSubscription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__PauseSubscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__PauseSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__PauseSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__PauseSubscription(soap, tag ? tag : "wsnt:PauseSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__PauseSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__PauseSubscription(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__PauseSubscription * SOAP_FMAC4 soap_get__wsnt__PauseSubscription(struct soap *soap, _wsnt__PauseSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__UnsubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__UnsubscribeResponse::__any);
}

void _wsnt__UnsubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__UnsubscribeResponse::__any);
#endif
}

int _wsnt__UnsubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__UnsubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, int id, const _wsnt__UnsubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsubscribeResponse), type))
		return soap->error;
	soap_element_result(soap, "-any");
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__UnsubscribeResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__UnsubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__UnsubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_in__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, _wsnt__UnsubscribeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__UnsubscribeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(_wsnt__UnsubscribeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__UnsubscribeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__UnsubscribeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__UnsubscribeResponse::__any, "xsd:anyType"))
					continue;
			}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsubscribeResponse, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(_wsnt__UnsubscribeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__UnsubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__UnsubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__UnsubscribeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__UnsubscribeResponse *p;
	size_t k = sizeof(_wsnt__UnsubscribeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__UnsubscribeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__UnsubscribeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__UnsubscribeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__UnsubscribeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__UnsubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__UnsubscribeResponse(soap, tag ? tag : "wsnt:UnsubscribeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__UnsubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__UnsubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_get__wsnt__UnsubscribeResponse(struct soap *soap, _wsnt__UnsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Unsubscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__Unsubscribe::__any);
}

void _wsnt__Unsubscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__Unsubscribe::__any);
#endif
}

int _wsnt__Unsubscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Unsubscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Unsubscribe(struct soap *soap, const char *tag, int id, const _wsnt__Unsubscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Unsubscribe), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__Unsubscribe::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Unsubscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__Unsubscribe(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Unsubscribe * SOAP_FMAC4 soap_in__wsnt__Unsubscribe(struct soap *soap, const char *tag, _wsnt__Unsubscribe *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Unsubscribe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Unsubscribe, sizeof(_wsnt__Unsubscribe), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Unsubscribe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Unsubscribe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__Unsubscribe::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Unsubscribe, SOAP_TYPE__wsnt__Unsubscribe, sizeof(_wsnt__Unsubscribe), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Unsubscribe * SOAP_FMAC2 soap_instantiate__wsnt__Unsubscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__Unsubscribe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Unsubscribe *p;
	size_t k = sizeof(_wsnt__Unsubscribe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Unsubscribe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Unsubscribe);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Unsubscribe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Unsubscribe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Unsubscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Unsubscribe(soap, tag ? tag : "wsnt:Unsubscribe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Unsubscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Unsubscribe(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Unsubscribe * SOAP_FMAC4 soap_get__wsnt__Unsubscribe(struct soap *soap, _wsnt__Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__RenewResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__dateTime(soap, &this->_wsnt__RenewResponse::TerminationTime);
	this->_wsnt__RenewResponse::CurrentTime = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__RenewResponse::__any);
}

void _wsnt__RenewResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__RenewResponse::TerminationTime, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->_wsnt__RenewResponse::TerminationTime);
	soap_serialize_PointerToxsd__dateTime(soap, &this->_wsnt__RenewResponse::CurrentTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__RenewResponse::__any);
#endif
}

int _wsnt__RenewResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__RenewResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__RenewResponse(struct soap *soap, const char *tag, int id, const _wsnt__RenewResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__RenewResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:TerminationTime");
	if (soap_out_xsd__dateTime(soap, "wsnt:TerminationTime", -1, &a->_wsnt__RenewResponse::TerminationTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__dateTime(soap, "wsnt:CurrentTime", -1, &a->_wsnt__RenewResponse::CurrentTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__RenewResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__RenewResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__RenewResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__RenewResponse * SOAP_FMAC4 soap_in__wsnt__RenewResponse(struct soap *soap, const char *tag, _wsnt__RenewResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__RenewResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__RenewResponse, sizeof(_wsnt__RenewResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__RenewResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__RenewResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TerminationTime1 = 1;
	size_t soap_flag_CurrentTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsnt:TerminationTime", &a->_wsnt__RenewResponse::TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__dateTime(soap, "wsnt:CurrentTime", &a->_wsnt__RenewResponse::CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__RenewResponse::__any, "xsd:anyType"))
					continue;
			}
			soap_check_result(soap, "wsnt:TerminationTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__RenewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__RenewResponse, SOAP_TYPE__wsnt__RenewResponse, sizeof(_wsnt__RenewResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__RenewResponse * SOAP_FMAC2 soap_instantiate__wsnt__RenewResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__RenewResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__RenewResponse *p;
	size_t k = sizeof(_wsnt__RenewResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__RenewResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__RenewResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__RenewResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__RenewResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__RenewResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__RenewResponse(soap, tag ? tag : "wsnt:RenewResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__RenewResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__RenewResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__RenewResponse * SOAP_FMAC4 soap_get__wsnt__RenewResponse(struct soap *soap, _wsnt__RenewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__RenewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Renew::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_wsnt__Renew::TerminationTime = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__Renew::__any);
}

void _wsnt__Renew::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, &this->_wsnt__Renew::TerminationTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__Renew::__any);
#endif
}

int _wsnt__Renew::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Renew(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Renew(struct soap *soap, const char *tag, int id, const _wsnt__Renew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Renew), type))
		return soap->error;
	if (!a->_wsnt__Renew::TerminationTime)
	{	if (soap_element_nil(soap, "wsnt:TerminationTime"))
			return soap->error;
	}
	else if (soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", -1, &a->_wsnt__Renew::TerminationTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__Renew::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Renew::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__Renew(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Renew * SOAP_FMAC4 soap_in__wsnt__Renew(struct soap *soap, const char *tag, _wsnt__Renew *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Renew*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Renew, sizeof(_wsnt__Renew), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Renew)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Renew *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TerminationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", &a->_wsnt__Renew::TerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__Renew::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__Renew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Renew, SOAP_TYPE__wsnt__Renew, sizeof(_wsnt__Renew), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Renew * SOAP_FMAC2 soap_instantiate__wsnt__Renew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__Renew(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Renew *p;
	size_t k = sizeof(_wsnt__Renew);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Renew, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Renew);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Renew, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Renew location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Renew::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Renew(soap, tag ? tag : "wsnt:Renew", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Renew::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Renew(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Renew * SOAP_FMAC4 soap_get__wsnt__Renew(struct soap *soap, _wsnt__Renew *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__CreatePullPointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnt__CreatePullPointResponse::PullPoint);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__CreatePullPointResponse::__any);
	soap_default_xsd__anyAttribute(soap, &this->_wsnt__CreatePullPointResponse::__anyAttribute);
}

void _wsnt__CreatePullPointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__CreatePullPointResponse::PullPoint, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnt__CreatePullPointResponse::PullPoint);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__CreatePullPointResponse::__any);
#endif
}

int _wsnt__CreatePullPointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__CreatePullPointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, int id, const _wsnt__CreatePullPointResponse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wsnt__CreatePullPointResponse*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPointResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:PullPoint");
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", -1, &a->_wsnt__CreatePullPointResponse::PullPoint, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__CreatePullPointResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__CreatePullPointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__CreatePullPointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_in__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, _wsnt__CreatePullPointResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__CreatePullPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(_wsnt__CreatePullPointResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__CreatePullPointResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__CreatePullPointResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wsnt__CreatePullPointResponse*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_PullPoint1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PullPoint1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", &a->_wsnt__CreatePullPointResponse::PullPoint, "wsa5:EndpointReferenceType"))
				{	soap_flag_PullPoint1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__CreatePullPointResponse::__any, "xsd:anyType"))
					continue;
			}
			soap_check_result(soap, "wsnt:PullPoint");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PullPoint1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__CreatePullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPointResponse, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(_wsnt__CreatePullPointResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__CreatePullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__CreatePullPointResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__CreatePullPointResponse *p;
	size_t k = sizeof(_wsnt__CreatePullPointResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__CreatePullPointResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__CreatePullPointResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__CreatePullPointResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__CreatePullPointResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__CreatePullPointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__CreatePullPointResponse(soap, tag ? tag : "wsnt:CreatePullPointResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__CreatePullPointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__CreatePullPointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_get__wsnt__CreatePullPointResponse(struct soap *soap, _wsnt__CreatePullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__CreatePullPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__CreatePullPoint::__any);
	soap_default_xsd__anyAttribute(soap, &this->_wsnt__CreatePullPoint::__anyAttribute);
}

void _wsnt__CreatePullPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__CreatePullPoint::__any);
#endif
}

int _wsnt__CreatePullPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__CreatePullPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPoint(struct soap *soap, const char *tag, int id, const _wsnt__CreatePullPoint *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wsnt__CreatePullPoint*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPoint), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__CreatePullPoint::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__CreatePullPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__CreatePullPoint(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__CreatePullPoint * SOAP_FMAC4 soap_in__wsnt__CreatePullPoint(struct soap *soap, const char *tag, _wsnt__CreatePullPoint *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__CreatePullPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(_wsnt__CreatePullPoint), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__CreatePullPoint)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__CreatePullPoint *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wsnt__CreatePullPoint*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__CreatePullPoint::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__CreatePullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPoint, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(_wsnt__CreatePullPoint), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__CreatePullPoint * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__CreatePullPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__CreatePullPoint *p;
	size_t k = sizeof(_wsnt__CreatePullPoint);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__CreatePullPoint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__CreatePullPoint);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__CreatePullPoint, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__CreatePullPoint location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__CreatePullPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__CreatePullPoint(soap, tag ? tag : "wsnt:CreatePullPoint", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__CreatePullPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__CreatePullPoint(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__CreatePullPoint * SOAP_FMAC4 soap_get__wsnt__CreatePullPoint(struct soap *soap, _wsnt__CreatePullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__DestroyPullPointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__DestroyPullPointResponse::__any);
	soap_default_xsd__anyAttribute(soap, &this->_wsnt__DestroyPullPointResponse::__anyAttribute);
}

void _wsnt__DestroyPullPointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__DestroyPullPointResponse::__any);
#endif
}

int _wsnt__DestroyPullPointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__DestroyPullPointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, const _wsnt__DestroyPullPointResponse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wsnt__DestroyPullPointResponse*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse), type))
		return soap->error;
	soap_element_result(soap, "-any");
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__DestroyPullPointResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__DestroyPullPointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__DestroyPullPointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_in__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, _wsnt__DestroyPullPointResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__DestroyPullPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(_wsnt__DestroyPullPointResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__DestroyPullPointResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__DestroyPullPointResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wsnt__DestroyPullPointResponse*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__DestroyPullPointResponse::__any, "xsd:anyType"))
					continue;
			}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__DestroyPullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPointResponse, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(_wsnt__DestroyPullPointResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__DestroyPullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__DestroyPullPointResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__DestroyPullPointResponse *p;
	size_t k = sizeof(_wsnt__DestroyPullPointResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__DestroyPullPointResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__DestroyPullPointResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__DestroyPullPointResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__DestroyPullPointResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__DestroyPullPointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__DestroyPullPointResponse(soap, tag ? tag : "wsnt:DestroyPullPointResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__DestroyPullPointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__DestroyPullPointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_get__wsnt__DestroyPullPointResponse(struct soap *soap, _wsnt__DestroyPullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__DestroyPullPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__DestroyPullPoint::__any);
	soap_default_xsd__anyAttribute(soap, &this->_wsnt__DestroyPullPoint::__anyAttribute);
}

void _wsnt__DestroyPullPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__DestroyPullPoint::__any);
#endif
}

int _wsnt__DestroyPullPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__DestroyPullPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, int id, const _wsnt__DestroyPullPoint *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wsnt__DestroyPullPoint*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPoint), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__DestroyPullPoint::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__DestroyPullPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__DestroyPullPoint(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_in__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, _wsnt__DestroyPullPoint *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__DestroyPullPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(_wsnt__DestroyPullPoint), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__DestroyPullPoint)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__DestroyPullPoint *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wsnt__DestroyPullPoint*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__DestroyPullPoint::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__DestroyPullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPoint, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(_wsnt__DestroyPullPoint), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__DestroyPullPoint * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__DestroyPullPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__DestroyPullPoint *p;
	size_t k = sizeof(_wsnt__DestroyPullPoint);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__DestroyPullPoint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__DestroyPullPoint);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__DestroyPullPoint, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__DestroyPullPoint location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__DestroyPullPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__DestroyPullPoint(soap, tag ? tag : "wsnt:DestroyPullPoint", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__DestroyPullPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__DestroyPullPoint(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_get__wsnt__DestroyPullPoint(struct soap *soap, _wsnt__DestroyPullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__GetMessagesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_wsnt__GetMessagesResponse::NotificationMessage);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__GetMessagesResponse::__any);
	soap_default_xsd__anyAttribute(soap, &this->_wsnt__GetMessagesResponse::__anyAttribute);
}

void _wsnt__GetMessagesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_wsnt__GetMessagesResponse::NotificationMessage);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__GetMessagesResponse::__any);
#endif
}

int _wsnt__GetMessagesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__GetMessagesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, int id, const _wsnt__GetMessagesResponse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wsnt__GetMessagesResponse*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessagesResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:NotificationMessage");
	if (soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->_wsnt__GetMessagesResponse::NotificationMessage, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__GetMessagesResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__GetMessagesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__GetMessagesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_in__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, _wsnt__GetMessagesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__GetMessagesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(_wsnt__GetMessagesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__GetMessagesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__GetMessagesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wsnt__GetMessagesResponse*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->_wsnt__GetMessagesResponse::NotificationMessage, "wsnt:NotificationMessageHolderType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__GetMessagesResponse::__any, "xsd:anyType"))
					continue;
			}
			soap_check_result(soap, "wsnt:NotificationMessage");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__GetMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessagesResponse, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(_wsnt__GetMessagesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__GetMessagesResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetMessagesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__GetMessagesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__GetMessagesResponse *p;
	size_t k = sizeof(_wsnt__GetMessagesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__GetMessagesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__GetMessagesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__GetMessagesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__GetMessagesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__GetMessagesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__GetMessagesResponse(soap, tag ? tag : "wsnt:GetMessagesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__GetMessagesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__GetMessagesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_get__wsnt__GetMessagesResponse(struct soap *soap, _wsnt__GetMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__GetMessages::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_wsnt__GetMessages::MaximumNumber = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__GetMessages::__any);
	soap_default_xsd__anyAttribute(soap, &this->_wsnt__GetMessages::__anyAttribute);
}

void _wsnt__GetMessages::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->_wsnt__GetMessages::MaximumNumber);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__GetMessages::__any);
#endif
}

int _wsnt__GetMessages::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__GetMessages(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessages(struct soap *soap, const char *tag, int id, const _wsnt__GetMessages *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wsnt__GetMessages*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessages), type))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "wsnt:MaximumNumber", -1, &a->_wsnt__GetMessages::MaximumNumber, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__GetMessages::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__GetMessages::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__GetMessages(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__GetMessages * SOAP_FMAC4 soap_in__wsnt__GetMessages(struct soap *soap, const char *tag, _wsnt__GetMessages *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__GetMessages*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessages, sizeof(_wsnt__GetMessages), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__GetMessages)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__GetMessages *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wsnt__GetMessages*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_MaximumNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__nonNegativeInteger(soap, "wsnt:MaximumNumber", &a->_wsnt__GetMessages::MaximumNumber, "xsd:nonNegativeInteger"))
				{	soap_flag_MaximumNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__GetMessages::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__GetMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessages, SOAP_TYPE__wsnt__GetMessages, sizeof(_wsnt__GetMessages), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__GetMessages * SOAP_FMAC2 soap_instantiate__wsnt__GetMessages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__GetMessages(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__GetMessages *p;
	size_t k = sizeof(_wsnt__GetMessages);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__GetMessages, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__GetMessages);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__GetMessages, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__GetMessages location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__GetMessages::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__GetMessages(soap, tag ? tag : "wsnt:GetMessages", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__GetMessages::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__GetMessages(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__GetMessages * SOAP_FMAC4 soap_get__wsnt__GetMessages(struct soap *soap, _wsnt__GetMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__GetCurrentMessageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__GetCurrentMessageResponse::__any);
}

void _wsnt__GetCurrentMessageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__GetCurrentMessageResponse::__any);
#endif
}

int _wsnt__GetCurrentMessageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__GetCurrentMessageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, const _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse), type))
		return soap->error;
	soap_element_result(soap, "-any");
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__GetCurrentMessageResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__GetCurrentMessageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__GetCurrentMessageResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__GetCurrentMessageResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(_wsnt__GetCurrentMessageResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__GetCurrentMessageResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__GetCurrentMessageResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__GetCurrentMessageResponse::__any, "xsd:anyType"))
					continue;
			}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__GetCurrentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessageResponse, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(_wsnt__GetCurrentMessageResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__GetCurrentMessageResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__GetCurrentMessageResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__GetCurrentMessageResponse *p;
	size_t k = sizeof(_wsnt__GetCurrentMessageResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__GetCurrentMessageResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__GetCurrentMessageResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__GetCurrentMessageResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__GetCurrentMessageResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__GetCurrentMessageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__GetCurrentMessageResponse(soap, tag ? tag : "wsnt:GetCurrentMessageResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__GetCurrentMessageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__GetCurrentMessageResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessageResponse(struct soap *soap, _wsnt__GetCurrentMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__GetCurrentMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_wsnt__GetCurrentMessage::Topic.wsnt__TopicExpressionTypeCustom::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__GetCurrentMessage::__any);
}

void _wsnt__GetCurrentMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__GetCurrentMessage::Topic, SOAP_TYPE_wsnt__TopicExpressionTypeCustom);
	this->_wsnt__GetCurrentMessage::Topic.soap_serialize(soap);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__GetCurrentMessage::__any);
#endif
}

int _wsnt__GetCurrentMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__GetCurrentMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, int id, const _wsnt__GetCurrentMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessage), type))
		return soap->error;
	if ((a->_wsnt__GetCurrentMessage::Topic).soap_out(soap, "wsnt:Topic", -1, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__GetCurrentMessage::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__GetCurrentMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__GetCurrentMessage(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, _wsnt__GetCurrentMessage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__GetCurrentMessage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(_wsnt__GetCurrentMessage), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__GetCurrentMessage)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__GetCurrentMessage *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Topic1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Topic1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->_wsnt__GetCurrentMessage::Topic).soap_in(soap, "wsnt:Topic", "wsnt:TopicExpressionTypeCustom"))
				{	soap_flag_Topic1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__GetCurrentMessage::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Topic1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__GetCurrentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessage, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(_wsnt__GetCurrentMessage), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__GetCurrentMessage * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__GetCurrentMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__GetCurrentMessage *p;
	size_t k = sizeof(_wsnt__GetCurrentMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__GetCurrentMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__GetCurrentMessage);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__GetCurrentMessage, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__GetCurrentMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__GetCurrentMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__GetCurrentMessage(soap, tag ? tag : "wsnt:GetCurrentMessage", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__GetCurrentMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__GetCurrentMessage(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessage(struct soap *soap, _wsnt__GetCurrentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__SubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnt__SubscribeResponse::SubscriptionReference);
	this->_wsnt__SubscribeResponse::CurrentTime = NULL;
	this->_wsnt__SubscribeResponse::TerminationTime = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__SubscribeResponse::__any);
}

void _wsnt__SubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__SubscribeResponse::SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnt__SubscribeResponse::SubscriptionReference);
	soap_serialize_PointerToxsd__dateTime(soap, &this->_wsnt__SubscribeResponse::CurrentTime);
	soap_serialize_PointerToxsd__dateTime(soap, &this->_wsnt__SubscribeResponse::TerminationTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__SubscribeResponse::__any);
#endif
}

int _wsnt__SubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__SubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeResponse(struct soap *soap, const char *tag, int id, const _wsnt__SubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:SubscriptionReference");
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->_wsnt__SubscribeResponse::SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerToxsd__dateTime(soap, "wsnt:CurrentTime", -1, &a->_wsnt__SubscribeResponse::CurrentTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__dateTime(soap, "wsnt:TerminationTime", -1, &a->_wsnt__SubscribeResponse::TerminationTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__SubscribeResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__SubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__SubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__SubscribeResponse * SOAP_FMAC4 soap_in__wsnt__SubscribeResponse(struct soap *soap, const char *tag, _wsnt__SubscribeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__SubscribeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(_wsnt__SubscribeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__SubscribeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__SubscribeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SubscriptionReference1 = 1;
	size_t soap_flag_CurrentTime1 = 1;
	size_t soap_flag_TerminationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->_wsnt__SubscribeResponse::SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference1--;
					continue;
				}
			}
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__dateTime(soap, "wsnt:CurrentTime", &a->_wsnt__SubscribeResponse::CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			}
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__dateTime(soap, "wsnt:TerminationTime", &a->_wsnt__SubscribeResponse::TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__SubscribeResponse::__any, "xsd:anyType"))
					continue;
			}
			soap_check_result(soap, "wsnt:SubscriptionReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeResponse, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(_wsnt__SubscribeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__SubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__SubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__SubscribeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__SubscribeResponse *p;
	size_t k = sizeof(_wsnt__SubscribeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__SubscribeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__SubscribeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__SubscribeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__SubscribeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__SubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__SubscribeResponse(soap, tag ? tag : "wsnt:SubscribeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__SubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__SubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__SubscribeResponse * SOAP_FMAC4 soap_get__wsnt__SubscribeResponse(struct soap *soap, _wsnt__SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Subscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnt__Subscribe::ConsumerReference);
	this->_wsnt__Subscribe::Filter = NULL;
	this->_wsnt__Subscribe::InitialTerminationTime = NULL;
	this->_wsnt__Subscribe::SubscriptionPolicy = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__Subscribe::__any);
}

void _wsnt__Subscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__Subscribe::ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnt__Subscribe::ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &this->_wsnt__Subscribe::Filter);
	soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, &this->_wsnt__Subscribe::InitialTerminationTime);
	soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, &this->_wsnt__Subscribe::SubscriptionPolicy);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__Subscribe::__any);
#endif
}

int _wsnt__Subscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Subscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe(struct soap *soap, const char *tag, int id, const _wsnt__Subscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->_wsnt__Subscribe::ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->_wsnt__Subscribe::Filter, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", -1, &a->_wsnt__Subscribe::InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", -1, &a->_wsnt__Subscribe::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__Subscribe::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Subscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__Subscribe(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Subscribe * SOAP_FMAC4 soap_in__wsnt__Subscribe(struct soap *soap, const char *tag, _wsnt__Subscribe *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Subscribe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe, sizeof(_wsnt__Subscribe), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Subscribe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Subscribe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConsumerReference1 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_InitialTerminationTime1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->_wsnt__Subscribe::ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference1--;
					continue;
				}
			}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->_wsnt__Subscribe::Filter, "wsnt:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_InitialTerminationTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", &a->_wsnt__Subscribe::InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", &a->_wsnt__Subscribe::SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__Subscribe::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe, SOAP_TYPE__wsnt__Subscribe, sizeof(_wsnt__Subscribe), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Subscribe * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__Subscribe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Subscribe *p;
	size_t k = sizeof(_wsnt__Subscribe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Subscribe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Subscribe);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Subscribe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Subscribe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Subscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Subscribe(soap, tag ? tag : "wsnt:Subscribe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Subscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Subscribe(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Subscribe * SOAP_FMAC4 soap_get__wsnt__Subscribe(struct soap *soap, _wsnt__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__UseRaw::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _wsnt__UseRaw::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _wsnt__UseRaw::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__UseRaw(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UseRaw(struct soap *soap, const char *tag, int id, const _wsnt__UseRaw *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UseRaw), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__UseRaw::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__UseRaw(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__UseRaw * SOAP_FMAC4 soap_in__wsnt__UseRaw(struct soap *soap, const char *tag, _wsnt__UseRaw *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__UseRaw*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UseRaw, sizeof(_wsnt__UseRaw), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__UseRaw)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__UseRaw *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__UseRaw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UseRaw, SOAP_TYPE__wsnt__UseRaw, sizeof(_wsnt__UseRaw), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__UseRaw * SOAP_FMAC2 soap_instantiate__wsnt__UseRaw(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__UseRaw(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__UseRaw *p;
	size_t k = sizeof(_wsnt__UseRaw);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__UseRaw, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__UseRaw);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__UseRaw, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__UseRaw location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__UseRaw::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__UseRaw(soap, tag ? tag : "wsnt:UseRaw", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__UseRaw::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__UseRaw(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__UseRaw * SOAP_FMAC4 soap_get__wsnt__UseRaw(struct soap *soap, _wsnt__UseRaw *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UseRaw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Notify::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_wsnt__Notify::NotificationMessage);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__Notify::__any);
}

void _wsnt__Notify::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_wsnt__Notify::NotificationMessage);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnt__Notify::__any);
#endif
}

int _wsnt__Notify::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Notify(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Notify(struct soap *soap, const char *tag, int id, const _wsnt__Notify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Notify), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->_wsnt__Notify::NotificationMessage, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_wsnt__Notify::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Notify::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__Notify(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Notify * SOAP_FMAC4 soap_in__wsnt__Notify(struct soap *soap, const char *tag, _wsnt__Notify *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Notify*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Notify, sizeof(_wsnt__Notify), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Notify)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Notify *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->_wsnt__Notify::NotificationMessage, "wsnt:NotificationMessageHolderType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_wsnt__Notify::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_wsnt__Notify::NotificationMessage.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__Notify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Notify, SOAP_TYPE__wsnt__Notify, sizeof(_wsnt__Notify), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Notify * SOAP_FMAC2 soap_instantiate__wsnt__Notify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__Notify(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Notify *p;
	size_t k = sizeof(_wsnt__Notify);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Notify, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Notify);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Notify, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Notify location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Notify::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Notify(soap, tag ? tag : "wsnt:Notify", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Notify::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Notify(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Notify * SOAP_FMAC4 soap_get__wsnt__Notify(struct soap *soap, _wsnt__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__SubscriptionManagerRP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnt__SubscriptionManagerRP::ConsumerReference);
	this->_wsnt__SubscriptionManagerRP::Filter = NULL;
	this->_wsnt__SubscriptionManagerRP::SubscriptionPolicy = NULL;
	this->_wsnt__SubscriptionManagerRP::CreationTime = NULL;
}

void _wsnt__SubscriptionManagerRP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__SubscriptionManagerRP::ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnt__SubscriptionManagerRP::ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &this->_wsnt__SubscriptionManagerRP::Filter);
	soap_serialize_PointerTowsnt__SubscriptionPolicyType(soap, &this->_wsnt__SubscriptionManagerRP::SubscriptionPolicy);
	soap_serialize_PointerToxsd__dateTime(soap, &this->_wsnt__SubscriptionManagerRP::CreationTime);
#endif
}

int _wsnt__SubscriptionManagerRP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__SubscriptionManagerRP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, int id, const _wsnt__SubscriptionManagerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->_wsnt__SubscriptionManagerRP::ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->_wsnt__SubscriptionManagerRP::Filter, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", -1, &a->_wsnt__SubscriptionManagerRP::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_PointerToxsd__dateTime(soap, "wsnt:CreationTime", -1, &a->_wsnt__SubscriptionManagerRP::CreationTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__SubscriptionManagerRP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__SubscriptionManagerRP(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_in__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, _wsnt__SubscriptionManagerRP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__SubscriptionManagerRP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(_wsnt__SubscriptionManagerRP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__SubscriptionManagerRP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__SubscriptionManagerRP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConsumerReference1 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	size_t soap_flag_CreationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->_wsnt__SubscriptionManagerRP::ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference1--;
					continue;
				}
			}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->_wsnt__SubscriptionManagerRP::Filter, "wsnt:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", &a->_wsnt__SubscriptionManagerRP::SubscriptionPolicy, "wsnt:SubscriptionPolicyType"))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap_flag_CreationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__dateTime(soap, "wsnt:CreationTime", &a->_wsnt__SubscriptionManagerRP::CreationTime, "xsd:dateTime"))
				{	soap_flag_CreationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__SubscriptionManagerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscriptionManagerRP, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(_wsnt__SubscriptionManagerRP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__SubscriptionManagerRP * SOAP_FMAC2 soap_instantiate__wsnt__SubscriptionManagerRP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__SubscriptionManagerRP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__SubscriptionManagerRP *p;
	size_t k = sizeof(_wsnt__SubscriptionManagerRP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__SubscriptionManagerRP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__SubscriptionManagerRP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__SubscriptionManagerRP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__SubscriptionManagerRP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__SubscriptionManagerRP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__SubscriptionManagerRP(soap, tag ? tag : "wsnt:SubscriptionManagerRP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__SubscriptionManagerRP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__SubscriptionManagerRP(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_get__wsnt__SubscriptionManagerRP(struct soap *soap, _wsnt__SubscriptionManagerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscriptionManagerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__NotificationProducerRP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom(soap, &this->_wsnt__NotificationProducerRP::TopicExpression);
	this->_wsnt__NotificationProducerRP::FixedTopicSet = NULL;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_wsnt__NotificationProducerRP::TopicExpressionDialect);
	this->_wsnt__NotificationProducerRP::wstop__TopicSet = NULL;
}

void _wsnt__NotificationProducerRP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom(soap, &this->_wsnt__NotificationProducerRP::TopicExpression);
	soap_serialize_PointerTobool(soap, &this->_wsnt__NotificationProducerRP::FixedTopicSet);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_wsnt__NotificationProducerRP::TopicExpressionDialect);
	soap_serialize_PointerTowstop__TopicSetType(soap, &this->_wsnt__NotificationProducerRP::wstop__TopicSet);
#endif
}

int _wsnt__NotificationProducerRP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__NotificationProducerRP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, int id, const _wsnt__NotificationProducerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationProducerRP), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom(soap, "wsnt:TopicExpression", -1, &a->_wsnt__NotificationProducerRP::TopicExpression, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "wsnt:FixedTopicSet", -1, &a->_wsnt__NotificationProducerRP::FixedTopicSet, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "wsnt:TopicExpressionDialect", -1, &a->_wsnt__NotificationProducerRP::TopicExpressionDialect, ""))
		return soap->error;
	if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &a->_wsnt__NotificationProducerRP::wstop__TopicSet, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__NotificationProducerRP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__wsnt__NotificationProducerRP(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_in__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, _wsnt__NotificationProducerRP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__NotificationProducerRP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(_wsnt__NotificationProducerRP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__NotificationProducerRP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__NotificationProducerRP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FixedTopicSet1 = 1;
	size_t soap_flag_wstop__TopicSet1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom(soap, "wsnt:TopicExpression", &a->_wsnt__NotificationProducerRP::TopicExpression, "wsnt:TopicExpressionTypeCustom"))
					continue;
			}
			if (soap_flag_FixedTopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "wsnt:FixedTopicSet", &a->_wsnt__NotificationProducerRP::FixedTopicSet, "xsd:boolean"))
				{	soap_flag_FixedTopicSet1--;
					continue;
				}
				if (soap->error == SOAP_EMPTY)
				{	if (!(a->_wsnt__NotificationProducerRP::FixedTopicSet = (bool *)soap_malloc(soap, sizeof(bool))))
						return NULL;
					*a->_wsnt__NotificationProducerRP::FixedTopicSet = (bool)1;
					soap->error = SOAP_OK;
					soap_flag_FixedTopicSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "wsnt:TopicExpressionDialect", &a->_wsnt__NotificationProducerRP::TopicExpressionDialect, "xsd:anyURI"))
					continue;
			}
			if (soap_flag_wstop__TopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &a->_wsnt__NotificationProducerRP::wstop__TopicSet, "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__NotificationProducerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationProducerRP, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(_wsnt__NotificationProducerRP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__NotificationProducerRP * SOAP_FMAC2 soap_instantiate__wsnt__NotificationProducerRP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__NotificationProducerRP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__NotificationProducerRP *p;
	size_t k = sizeof(_wsnt__NotificationProducerRP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__NotificationProducerRP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__NotificationProducerRP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__NotificationProducerRP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__NotificationProducerRP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__NotificationProducerRP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__NotificationProducerRP(soap, tag ? tag : "wsnt:NotificationProducerRP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__NotificationProducerRP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__NotificationProducerRP(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_get__wsnt__NotificationProducerRP(struct soap *soap, _wsnt__NotificationProducerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationProducerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__ResumeFailedFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__ResumeFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__ResumeFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__ResumeFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, const wsnt__ResumeFailedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType), type ? type : "wsnt:ResumeFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__ResumeFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__ResumeFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_in_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, wsnt__ResumeFailedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__ResumeFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(wsnt__ResumeFailedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__ResumeFailedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__ResumeFailedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__ResumeFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__ResumeFailedFaultType, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(wsnt__ResumeFailedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__ResumeFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__ResumeFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__ResumeFailedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__ResumeFailedFaultType *p;
	size_t k = sizeof(wsnt__ResumeFailedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__ResumeFailedFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__ResumeFailedFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__ResumeFailedFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__ResumeFailedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__ResumeFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__ResumeFailedFaultType(soap, tag ? tag : "wsnt:ResumeFailedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__ResumeFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__ResumeFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_get_wsnt__ResumeFailedFaultType(struct soap *soap, wsnt__ResumeFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__PauseFailedFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__PauseFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__PauseFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__PauseFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, int id, const wsnt__PauseFailedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__PauseFailedFaultType), type ? type : "wsnt:PauseFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__PauseFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__PauseFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_in_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, wsnt__PauseFailedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__PauseFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(wsnt__PauseFailedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__PauseFailedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__PauseFailedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__PauseFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__PauseFailedFaultType, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(wsnt__PauseFailedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__PauseFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__PauseFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__PauseFailedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__PauseFailedFaultType *p;
	size_t k = sizeof(wsnt__PauseFailedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__PauseFailedFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__PauseFailedFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__PauseFailedFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__PauseFailedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__PauseFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__PauseFailedFaultType(soap, tag ? tag : "wsnt:PauseFailedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__PauseFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__PauseFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_get_wsnt__PauseFailedFaultType(struct soap *soap, wsnt__PauseFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnableToDestroySubscriptionFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__UnableToDestroySubscriptionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnableToDestroySubscriptionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType), type ? type : "wsnt:UnableToDestroySubscriptionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnableToDestroySubscriptionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnableToDestroySubscriptionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(wsnt__UnableToDestroySubscriptionFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnableToDestroySubscriptionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnableToDestroySubscriptionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(wsnt__UnableToDestroySubscriptionFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnableToDestroySubscriptionFaultType *p;
	size_t k = sizeof(wsnt__UnableToDestroySubscriptionFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnableToDestroySubscriptionFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnableToDestroySubscriptionFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnableToDestroySubscriptionFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnableToDestroySubscriptionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnableToDestroySubscriptionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnableToDestroySubscriptionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnt__UnableToDestroySubscriptionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnacceptableTerminationTimeFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_xsd__dateTime(soap, &this->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime);
	this->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime = NULL;
}

void wsnt__UnacceptableTerminationTimeFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime);
	soap_serialize_PointerToxsd__dateTime(soap, &this->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnacceptableTerminationTimeFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType), type ? type : "wsnt:UnacceptableTerminationTimeFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsnt:MinimumTime", -1, &a->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__dateTime(soap, "wsnt:MaximumTime", -1, &a->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnacceptableTerminationTimeFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnacceptableTerminationTimeFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(wsnt__UnacceptableTerminationTimeFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnacceptableTerminationTimeFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	size_t soap_flag_MinimumTime1 = 1;
	size_t soap_flag_MaximumTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap_flag_MinimumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsnt:MinimumTime", &a->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime1--;
					continue;
				}
			}
			if (soap_flag_MaximumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__dateTime(soap, "wsnt:MaximumTime", &a->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || soap_flag_MinimumTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnacceptableTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(wsnt__UnacceptableTerminationTimeFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnacceptableTerminationTimeFaultType *p;
	size_t k = sizeof(wsnt__UnacceptableTerminationTimeFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnacceptableTerminationTimeFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnacceptableTerminationTimeFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnacceptableTerminationTimeFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnacceptableTerminationTimeFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnacceptableTerminationTimeFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnacceptableTerminationTimeFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnableToCreatePullPointFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__UnableToCreatePullPointFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnableToCreatePullPointFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType), type ? type : "wsnt:UnableToCreatePullPointFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnableToCreatePullPointFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnableToCreatePullPointFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(wsnt__UnableToCreatePullPointFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnableToCreatePullPointFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnableToCreatePullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(wsnt__UnableToCreatePullPointFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnableToCreatePullPointFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnableToCreatePullPointFaultType *p;
	size_t k = sizeof(wsnt__UnableToCreatePullPointFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnableToCreatePullPointFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnableToCreatePullPointFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnableToCreatePullPointFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnableToCreatePullPointFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnableToCreatePullPointFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnableToCreatePullPointFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, wsnt__UnableToCreatePullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnableToDestroyPullPointFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__UnableToDestroyPullPointFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnableToDestroyPullPointFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnableToDestroyPullPointFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType), type ? type : "wsnt:UnableToDestroyPullPointFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnableToDestroyPullPointFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, wsnt__UnableToDestroyPullPointFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnableToDestroyPullPointFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(wsnt__UnableToDestroyPullPointFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnableToDestroyPullPointFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnableToDestroyPullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(wsnt__UnableToDestroyPullPointFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnableToDestroyPullPointFaultType *p;
	size_t k = sizeof(wsnt__UnableToDestroyPullPointFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnableToDestroyPullPointFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnableToDestroyPullPointFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnableToDestroyPullPointFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnableToDestroyPullPointFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnableToDestroyPullPointFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnableToDestroyPullPointFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, wsnt__UnableToDestroyPullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnableToGetMessagesFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__UnableToGetMessagesFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnableToGetMessagesFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnableToGetMessagesFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType), type ? type : "wsnt:UnableToGetMessagesFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnableToGetMessagesFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, wsnt__UnableToGetMessagesFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnableToGetMessagesFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(wsnt__UnableToGetMessagesFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnableToGetMessagesFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnableToGetMessagesFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnableToGetMessagesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(wsnt__UnableToGetMessagesFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToGetMessagesFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnableToGetMessagesFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnableToGetMessagesFaultType *p;
	size_t k = sizeof(wsnt__UnableToGetMessagesFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnableToGetMessagesFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnableToGetMessagesFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnableToGetMessagesFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnableToGetMessagesFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnableToGetMessagesFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnableToGetMessagesFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToGetMessagesFaultType(struct soap *soap, wsnt__UnableToGetMessagesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__NoCurrentMessageOnTopicFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__NoCurrentMessageOnTopicFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__NoCurrentMessageOnTopicFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, const wsnt__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType), type ? type : "wsnt:NoCurrentMessageOnTopicFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__NoCurrentMessageOnTopicFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_in_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, wsnt__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__NoCurrentMessageOnTopicFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(wsnt__NoCurrentMessageOnTopicFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__NoCurrentMessageOnTopicFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__NoCurrentMessageOnTopicFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(wsnt__NoCurrentMessageOnTopicFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__NoCurrentMessageOnTopicFaultType *p;
	size_t k = sizeof(wsnt__NoCurrentMessageOnTopicFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__NoCurrentMessageOnTopicFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__NoCurrentMessageOnTopicFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__NoCurrentMessageOnTopicFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__NoCurrentMessageOnTopicFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__NoCurrentMessageOnTopicFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__NoCurrentMessageOnTopicFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_get_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnt__NoCurrentMessageOnTopicFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnacceptableInitialTerminationTimeFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_xsd__dateTime(soap, &this->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime);
	this->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime = NULL;
}

void wsnt__UnacceptableInitialTerminationTimeFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime);
	soap_serialize_PointerToxsd__dateTime(soap, &this->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnacceptableInitialTerminationTimeFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType), type ? type : "wsnt:UnacceptableInitialTerminationTimeFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsnt:MinimumTime", -1, &a->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__dateTime(soap, "wsnt:MaximumTime", -1, &a->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnacceptableInitialTerminationTimeFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnacceptableInitialTerminationTimeFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnacceptableInitialTerminationTimeFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	size_t soap_flag_MinimumTime1 = 1;
	size_t soap_flag_MaximumTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap_flag_MinimumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsnt:MinimumTime", &a->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime1--;
					continue;
				}
			}
			if (soap_flag_MaximumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__dateTime(soap, "wsnt:MaximumTime", &a->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || soap_flag_MinimumTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnacceptableInitialTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnacceptableInitialTerminationTimeFaultType *p;
	size_t k = sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnacceptableInitialTerminationTimeFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnacceptableInitialTerminationTimeFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnacceptableInitialTerminationTimeFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnacceptableInitialTerminationTimeFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnacceptableInitialTerminationTimeFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableInitialTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.cpp */
