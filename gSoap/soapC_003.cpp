/* soapC_nnn.cpp
   Generated by gSOAP 2.8.78 for WS/onvifFull.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.cpp ver 2.8.78 2019-03-11 21:45:00 GMT")


void wsnt__NotifyMessageNotSupportedFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__NotifyMessageNotSupportedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__NotifyMessageNotSupportedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, const wsnt__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType), type ? type : "wsnt:NotifyMessageNotSupportedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__NotifyMessageNotSupportedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, wsnt__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__NotifyMessageNotSupportedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(wsnt__NotifyMessageNotSupportedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__NotifyMessageNotSupportedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__NotifyMessageNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(wsnt__NotifyMessageNotSupportedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__NotifyMessageNotSupportedFaultType *p;
	size_t k = sizeof(wsnt__NotifyMessageNotSupportedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__NotifyMessageNotSupportedFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__NotifyMessageNotSupportedFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__NotifyMessageNotSupportedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__NotifyMessageNotSupportedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__NotifyMessageNotSupportedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__NotifyMessageNotSupportedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnt__NotifyMessageNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnsupportedPolicyRequestFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy);
}

void wsnt__UnsupportedPolicyRequestFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnsupportedPolicyRequestFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType), type ? type : "wsnt:UnsupportedPolicyRequestFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnsupportedPolicy", -1, &a->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnsupportedPolicyRequestFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnsupportedPolicyRequestFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(wsnt__UnsupportedPolicyRequestFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnsupportedPolicyRequestFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnsupportedPolicy", &a->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnsupportedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(wsnt__UnsupportedPolicyRequestFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnsupportedPolicyRequestFaultType *p;
	size_t k = sizeof(wsnt__UnsupportedPolicyRequestFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnsupportedPolicyRequestFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnsupportedPolicyRequestFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnsupportedPolicyRequestFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnsupportedPolicyRequestFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnsupportedPolicyRequestFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnsupportedPolicyRequestFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnt__UnsupportedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnrecognizedPolicyRequestFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy);
}

void wsnt__UnrecognizedPolicyRequestFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnrecognizedPolicyRequestFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType), type ? type : "wsnt:UnrecognizedPolicyRequestFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnrecognizedPolicy", -1, &a->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnrecognizedPolicyRequestFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnrecognizedPolicyRequestFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(wsnt__UnrecognizedPolicyRequestFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnrecognizedPolicyRequestFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnrecognizedPolicy", &a->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnrecognizedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(wsnt__UnrecognizedPolicyRequestFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnrecognizedPolicyRequestFaultType *p;
	size_t k = sizeof(wsnt__UnrecognizedPolicyRequestFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnrecognizedPolicyRequestFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnrecognizedPolicyRequestFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnrecognizedPolicyRequestFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnrecognizedPolicyRequestFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnrecognizedPolicyRequestFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnrecognizedPolicyRequestFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnt__UnrecognizedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__InvalidMessageContentExpressionFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__InvalidMessageContentExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__InvalidMessageContentExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, const wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType), type ? type : "wsnt:InvalidMessageContentExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__InvalidMessageContentExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__InvalidMessageContentExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(wsnt__InvalidMessageContentExpressionFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__InvalidMessageContentExpressionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__InvalidMessageContentExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(wsnt__InvalidMessageContentExpressionFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__InvalidMessageContentExpressionFaultType *p;
	size_t k = sizeof(wsnt__InvalidMessageContentExpressionFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__InvalidMessageContentExpressionFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__InvalidMessageContentExpressionFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__InvalidMessageContentExpressionFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__InvalidMessageContentExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__InvalidMessageContentExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__InvalidMessageContentExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnt__InvalidMessageContentExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__InvalidProducerPropertiesExpressionFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__InvalidProducerPropertiesExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__InvalidProducerPropertiesExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, const wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType), type ? type : "wsnt:InvalidProducerPropertiesExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__InvalidProducerPropertiesExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__InvalidProducerPropertiesExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__InvalidProducerPropertiesExpressionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__InvalidProducerPropertiesExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__InvalidProducerPropertiesExpressionFaultType *p;
	size_t k = sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__InvalidProducerPropertiesExpressionFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__InvalidProducerPropertiesExpressionFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__InvalidProducerPropertiesExpressionFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__InvalidProducerPropertiesExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__InvalidProducerPropertiesExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnt__InvalidProducerPropertiesExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__MultipleTopicsSpecifiedFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__MultipleTopicsSpecifiedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__MultipleTopicsSpecifiedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, const wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType), type ? type : "wsnt:MultipleTopicsSpecifiedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__MultipleTopicsSpecifiedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_in_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__MultipleTopicsSpecifiedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(wsnt__MultipleTopicsSpecifiedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__MultipleTopicsSpecifiedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__MultipleTopicsSpecifiedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(wsnt__MultipleTopicsSpecifiedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__MultipleTopicsSpecifiedFaultType *p;
	size_t k = sizeof(wsnt__MultipleTopicsSpecifiedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__MultipleTopicsSpecifiedFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__MultipleTopicsSpecifiedFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__MultipleTopicsSpecifiedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__MultipleTopicsSpecifiedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__MultipleTopicsSpecifiedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__MultipleTopicsSpecifiedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_get_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnt__MultipleTopicsSpecifiedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__TopicNotSupportedFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__TopicNotSupportedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__TopicNotSupportedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__TopicNotSupportedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, const wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType), type ? type : "wsnt:TopicNotSupportedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__TopicNotSupportedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__TopicNotSupportedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(wsnt__TopicNotSupportedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__TopicNotSupportedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__TopicNotSupportedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__TopicNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(wsnt__TopicNotSupportedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__TopicNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicNotSupportedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__TopicNotSupportedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__TopicNotSupportedFaultType *p;
	size_t k = sizeof(wsnt__TopicNotSupportedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__TopicNotSupportedFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__TopicNotSupportedFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__TopicNotSupportedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__TopicNotSupportedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__TopicNotSupportedFaultType(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__TopicNotSupportedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__TopicNotSupportedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__TopicNotSupportedFaultType(struct soap *soap, wsnt__TopicNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__InvalidTopicExpressionFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__InvalidTopicExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__InvalidTopicExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, const wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType), type ? type : "wsnt:InvalidTopicExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__InvalidTopicExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__InvalidTopicExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(wsnt__InvalidTopicExpressionFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__InvalidTopicExpressionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(wsnt__InvalidTopicExpressionFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__InvalidTopicExpressionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__InvalidTopicExpressionFaultType *p;
	size_t k = sizeof(wsnt__InvalidTopicExpressionFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__InvalidTopicExpressionFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__InvalidTopicExpressionFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__InvalidTopicExpressionFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__InvalidTopicExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__InvalidTopicExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__InvalidTopicExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, wsnt__InvalidTopicExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__TopicExpressionDialectUnknownFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__TopicExpressionDialectUnknownFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__TopicExpressionDialectUnknownFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType), type ? type : "wsnt:TopicExpressionDialectUnknownFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__TopicExpressionDialectUnknownFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__TopicExpressionDialectUnknownFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(wsnt__TopicExpressionDialectUnknownFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__TopicExpressionDialectUnknownFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(wsnt__TopicExpressionDialectUnknownFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__TopicExpressionDialectUnknownFaultType *p;
	size_t k = sizeof(wsnt__TopicExpressionDialectUnknownFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__TopicExpressionDialectUnknownFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__TopicExpressionDialectUnknownFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__TopicExpressionDialectUnknownFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__TopicExpressionDialectUnknownFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__TopicExpressionDialectUnknownFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__TopicExpressionDialectUnknownFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnt__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__InvalidFilterFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__InvalidFilterFaultType::UnknownFilter);
}

void wsnt__InvalidFilterFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__InvalidFilterFaultType::UnknownFilter);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__InvalidFilterFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__InvalidFilterFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const wsnt__InvalidFilterFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType), type ? type : "wsnt:InvalidFilterFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnknownFilter", -1, &a->wsnt__InvalidFilterFaultType::UnknownFilter, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__InvalidFilterFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__InvalidFilterFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, wsnt__InvalidFilterFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__InvalidFilterFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(wsnt__InvalidFilterFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__InvalidFilterFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__InvalidFilterFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnknownFilter", &a->wsnt__InvalidFilterFaultType::UnknownFilter, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || a->wsnt__InvalidFilterFaultType::UnknownFilter.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidFilterFaultType, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(wsnt__InvalidFilterFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__InvalidFilterFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidFilterFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__InvalidFilterFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__InvalidFilterFaultType *p;
	size_t k = sizeof(wsnt__InvalidFilterFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__InvalidFilterFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__InvalidFilterFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__InvalidFilterFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__InvalidFilterFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__InvalidFilterFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__InvalidFilterFaultType(soap, tag ? tag : "wsnt:InvalidFilterFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__InvalidFilterFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__InvalidFilterFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidFilterFaultType(struct soap *soap, wsnt__InvalidFilterFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__SubscribeCreationFailedFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__SubscribeCreationFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__SubscribeCreationFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType), type ? type : "wsnt:SubscribeCreationFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__SubscribeCreationFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__SubscribeCreationFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(wsnt__SubscribeCreationFailedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__SubscribeCreationFailedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsrfbf__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(wsnt__SubscribeCreationFailedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__SubscribeCreationFailedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__SubscribeCreationFailedFaultType *p;
	size_t k = sizeof(wsnt__SubscribeCreationFailedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__SubscribeCreationFailedFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__SubscribeCreationFailedFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__SubscribeCreationFailedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__SubscribeCreationFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__SubscribeCreationFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__SubscribeCreationFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, wsnt__SubscribeCreationFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__NotificationMessageHolderType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsnt__NotificationMessageHolderType::SubscriptionReference = NULL;
	this->wsnt__NotificationMessageHolderType::Topic = NULL;
	this->wsnt__NotificationMessageHolderType::ProducerReference = NULL;
	this->wsnt__NotificationMessageHolderType::Message._wsnt__NotificationMessageHolderType_Message::soap_default(soap);
}

void wsnt__NotificationMessageHolderType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsnt__NotificationMessageHolderType::SubscriptionReference);
	soap_serialize_PointerTowsnt__TopicExpressionTypeCustom(soap, &this->wsnt__NotificationMessageHolderType::Topic);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsnt__NotificationMessageHolderType::ProducerReference);
	this->wsnt__NotificationMessageHolderType::Message.soap_serialize(soap);
#endif
}

int wsnt__NotificationMessageHolderType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__NotificationMessageHolderType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const wsnt__NotificationMessageHolderType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->wsnt__NotificationMessageHolderType::SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicExpressionTypeCustom(soap, "wsnt:Topic", -1, &a->wsnt__NotificationMessageHolderType::Topic, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", -1, &a->wsnt__NotificationMessageHolderType::ProducerReference, ""))
		return soap->error;
	if ((a->wsnt__NotificationMessageHolderType::Message).soap_out(soap, "wsnt:Message", -1, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__NotificationMessageHolderType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__NotificationMessageHolderType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_in_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, wsnt__NotificationMessageHolderType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__NotificationMessageHolderType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__NotificationMessageHolderType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__NotificationMessageHolderType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SubscriptionReference1 = 1;
	size_t soap_flag_Topic1 = 1;
	size_t soap_flag_ProducerReference1 = 1;
	size_t soap_flag_Message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->wsnt__NotificationMessageHolderType::SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference1--;
					continue;
				}
			}
			if (soap_flag_Topic1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionTypeCustom(soap, "wsnt:Topic", &a->wsnt__NotificationMessageHolderType::Topic, "wsnt:TopicExpressionTypeCustom"))
				{	soap_flag_Topic1--;
					continue;
				}
			}
			if (soap_flag_ProducerReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", &a->wsnt__NotificationMessageHolderType::ProducerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ProducerReference1--;
					continue;
				}
			}
			if (soap_flag_Message1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->wsnt__NotificationMessageHolderType::Message).soap_in(soap, "wsnt:Message", ""))
				{	soap_flag_Message1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__NotificationMessageHolderType * SOAP_FMAC2 soap_instantiate_wsnt__NotificationMessageHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__NotificationMessageHolderType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__NotificationMessageHolderType *p;
	size_t k = sizeof(wsnt__NotificationMessageHolderType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__NotificationMessageHolderType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__NotificationMessageHolderType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__NotificationMessageHolderType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__NotificationMessageHolderType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__NotificationMessageHolderType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__NotificationMessageHolderType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__NotificationMessageHolderType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_get_wsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__SubscriptionPolicyType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsnt__SubscriptionPolicyType::__any);
}

void wsnt__SubscriptionPolicyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsnt__SubscriptionPolicyType::__any);
#endif
}

int wsnt__SubscriptionPolicyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__SubscriptionPolicyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, const wsnt__SubscriptionPolicyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsnt__SubscriptionPolicyType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__SubscriptionPolicyType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__SubscriptionPolicyType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_in_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, wsnt__SubscriptionPolicyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__SubscriptionPolicyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(wsnt__SubscriptionPolicyType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__SubscriptionPolicyType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__SubscriptionPolicyType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsnt__SubscriptionPolicyType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnt__SubscriptionPolicyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscriptionPolicyType, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(wsnt__SubscriptionPolicyType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__SubscriptionPolicyType * SOAP_FMAC2 soap_instantiate_wsnt__SubscriptionPolicyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__SubscriptionPolicyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__SubscriptionPolicyType *p;
	size_t k = sizeof(wsnt__SubscriptionPolicyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__SubscriptionPolicyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__SubscriptionPolicyType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__SubscriptionPolicyType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__SubscriptionPolicyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__SubscriptionPolicyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__SubscriptionPolicyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__SubscriptionPolicyType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_get_wsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__FilterType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsnt__FilterType::__any);
}

void wsnt__FilterType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsnt__FilterType::__any);
#endif
}

int wsnt__FilterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__FilterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__FilterType(struct soap *soap, const char *tag, int id, const wsnt__FilterType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__FilterType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsnt__FilterType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__FilterType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__FilterType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__FilterType * SOAP_FMAC4 soap_in_wsnt__FilterType(struct soap *soap, const char *tag, wsnt__FilterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__FilterType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__FilterType, sizeof(wsnt__FilterType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__FilterType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__FilterType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsnt__FilterType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnt__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__FilterType, SOAP_TYPE_wsnt__FilterType, sizeof(wsnt__FilterType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__FilterType * SOAP_FMAC2 soap_instantiate_wsnt__FilterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__FilterType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tt:EventFilter"))
		return soap_instantiate_tt__EventFilter(soap, n, NULL, NULL, size);
	wsnt__FilterType *p;
	size_t k = sizeof(wsnt__FilterType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__FilterType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__FilterType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__FilterType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__FilterType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__FilterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__FilterType(soap, tag ? tag : "wsnt:FilterType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__FilterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__FilterType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__FilterType * SOAP_FMAC4 soap_get_wsnt__FilterType(struct soap *soap, wsnt__FilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__TopicExpressionTypeCustom::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__QName(soap, &this->wsnt__TopicExpressionTypeCustom::__any);
	soap_default_xsd__anyURI(soap, &this->wsnt__TopicExpressionTypeCustom::Dialect);
	soap_default_xsd__anyAttribute(soap, &this->wsnt__TopicExpressionTypeCustom::__anyAttribute);
	soap_default_xsd__anyType(soap, &this->wsnt__TopicExpressionTypeCustom::__mixed);
}

void wsnt__TopicExpressionTypeCustom::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsnt__TopicExpressionTypeCustom::__any, SOAP_TYPE_xsd__QName);
	soap_serialize_xsd__QName(soap, &this->wsnt__TopicExpressionTypeCustom::__any);
	soap_serialize_xsd__anyType(soap, &this->wsnt__TopicExpressionTypeCustom::__mixed);
#endif
}

int wsnt__TopicExpressionTypeCustom::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__TopicExpressionTypeCustom(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionTypeCustom(struct soap *soap, const char *tag, int id, const wsnt__TopicExpressionTypeCustom *a, const char *type)
{
	std::string soap_tmp___any(soap_QName2s(soap, a->__any.c_str()));
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((wsnt__TopicExpressionTypeCustom*)a)->Dialect), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsnt__TopicExpressionTypeCustom*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionTypeCustom), type))
		return soap->error;
	if (soap_out_xsd__QName(soap, "-any", -1, &soap_tmp___any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->wsnt__TopicExpressionTypeCustom::__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__TopicExpressionTypeCustom::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__TopicExpressionTypeCustom(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__TopicExpressionTypeCustom * SOAP_FMAC4 soap_in_wsnt__TopicExpressionTypeCustom(struct soap *soap, const char *tag, wsnt__TopicExpressionTypeCustom *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__TopicExpressionTypeCustom*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionTypeCustom, sizeof(wsnt__TopicExpressionTypeCustom), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__TopicExpressionTypeCustom)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__TopicExpressionTypeCustom *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &((wsnt__TopicExpressionTypeCustom*)a)->Dialect))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsnt__TopicExpressionTypeCustom*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__QName(soap, "-any", &a->wsnt__TopicExpressionTypeCustom::__any, "xsd:QName"))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->wsnt__TopicExpressionTypeCustom::__mixed, "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag___any1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__TopicExpressionTypeCustom *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionTypeCustom, SOAP_TYPE_wsnt__TopicExpressionTypeCustom, sizeof(wsnt__TopicExpressionTypeCustom), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__TopicExpressionTypeCustom * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionTypeCustom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__TopicExpressionTypeCustom(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__TopicExpressionTypeCustom *p;
	size_t k = sizeof(wsnt__TopicExpressionTypeCustom);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__TopicExpressionTypeCustom, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__TopicExpressionTypeCustom);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__TopicExpressionTypeCustom, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__TopicExpressionTypeCustom location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__TopicExpressionTypeCustom::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__TopicExpressionTypeCustom(soap, tag ? tag : "wsnt:TopicExpressionTypeCustom", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__TopicExpressionTypeCustom::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__TopicExpressionTypeCustom(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__TopicExpressionTypeCustom * SOAP_FMAC4 soap_get_wsnt__TopicExpressionTypeCustom(struct soap *soap, wsnt__TopicExpressionTypeCustom *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionTypeCustom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__QueryExpressionType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &this->wsnt__QueryExpressionType::__any);
	soap_default_xsd__anyURI(soap, &this->wsnt__QueryExpressionType::Dialect);
	soap_default_xsd__anyType(soap, &this->wsnt__QueryExpressionType::__mixed);
}

void wsnt__QueryExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyType(soap, &this->wsnt__QueryExpressionType::__any);
	soap_serialize_xsd__anyType(soap, &this->wsnt__QueryExpressionType::__mixed);
#endif
}

int wsnt__QueryExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__QueryExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__QueryExpressionType(struct soap *soap, const char *tag, int id, const wsnt__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((wsnt__QueryExpressionType*)a)->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__QueryExpressionType), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->wsnt__QueryExpressionType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->wsnt__QueryExpressionType::__mixed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__QueryExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsnt__QueryExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__QueryExpressionType * SOAP_FMAC4 soap_in_wsnt__QueryExpressionType(struct soap *soap, const char *tag, wsnt__QueryExpressionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__QueryExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(wsnt__QueryExpressionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__QueryExpressionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__QueryExpressionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &((wsnt__QueryExpressionType*)a)->Dialect))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->wsnt__QueryExpressionType::__any, "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->wsnt__QueryExpressionType::__mixed, "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnt__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__QueryExpressionType, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(wsnt__QueryExpressionType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__QueryExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__QueryExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__QueryExpressionType *p;
	size_t k = sizeof(wsnt__QueryExpressionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__QueryExpressionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__QueryExpressionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__QueryExpressionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__QueryExpressionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__QueryExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__QueryExpressionType(soap, tag ? tag : "wsnt:QueryExpressionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__QueryExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__QueryExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__QueryExpressionType * SOAP_FMAC4 soap_get_wsnt__QueryExpressionType(struct soap *soap, wsnt__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tt__Message::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tt__Message::Source = NULL;
	this->_tt__Message::Key = NULL;
	this->_tt__Message::Data = NULL;
	this->_tt__Message::Extension = NULL;
	soap_default_xsd__dateTime(soap, &this->_tt__Message::UtcTime);
	this->_tt__Message::PropertyOperation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->_tt__Message::__anyAttribute);
}

void _tt__Message::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemList(soap, &this->_tt__Message::Source);
	soap_serialize_PointerTott__ItemList(soap, &this->_tt__Message::Key);
	soap_serialize_PointerTott__ItemList(soap, &this->_tt__Message::Data);
	soap_serialize_PointerTott__MessageExtension(soap, &this->_tt__Message::Extension);
#endif
}

int _tt__Message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__Message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Message(struct soap *soap, const char *tag, int id, const _tt__Message *a, const char *type)
{
	soap_set_attr(soap, "UtcTime", soap_xsd__dateTime2s(soap, ((_tt__Message*)a)->UtcTime), 1);
	if (((_tt__Message*)a)->PropertyOperation)
	{	soap_set_attr(soap, "PropertyOperation", soap_tt__PropertyOperation2s(soap, *((_tt__Message*)a)->PropertyOperation), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_tt__Message*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Message), type))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Source", -1, &a->_tt__Message::Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Key", -1, &a->_tt__Message::Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Data", -1, &a->_tt__Message::Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageExtension(soap, "tt:Extension", -1, &a->_tt__Message::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__Message::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tt__Message(soap, tag, this, type);
}

SOAP_FMAC3 _tt__Message * SOAP_FMAC4 soap_in__tt__Message(struct soap *soap, const char *tag, _tt__Message *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__Message*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Message, sizeof(_tt__Message), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tt__Message)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tt__Message *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__dateTime(soap, soap_attr_value(soap, "UtcTime", 5, 1), &((_tt__Message*)a)->UtcTime))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "PropertyOperation", 5, 0);
		if (t)
		{
			if (!(((_tt__Message*)a)->PropertyOperation = (tt__PropertyOperation *)soap_malloc(soap, sizeof(tt__PropertyOperation))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__PropertyOperation(soap, t, ((_tt__Message*)a)->PropertyOperation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_tt__Message*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Source1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Data1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Source", &a->_tt__Message::Source, "tt:ItemList"))
				{	soap_flag_Source1--;
					continue;
				}
			}
			if (soap_flag_Key1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Key", &a->_tt__Message::Key, "tt:ItemList"))
				{	soap_flag_Key1--;
					continue;
				}
			}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Data", &a->_tt__Message::Data, "tt:ItemList"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageExtension(soap, "tt:Extension", &a->_tt__Message::Extension, "tt:MessageExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Message, SOAP_TYPE__tt__Message, sizeof(_tt__Message), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tt__Message * SOAP_FMAC2 soap_instantiate__tt__Message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tt__Message(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tt__Message *p;
	size_t k = sizeof(_tt__Message);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tt__Message, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tt__Message);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tt__Message, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tt__Message location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tt__Message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tt__Message(soap, tag ? tag : "tt:Message", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__Message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__Message(soap, this, tag, type);
}

SOAP_FMAC3 _tt__Message * SOAP_FMAC4 soap_get__tt__Message(struct soap *soap, _tt__Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LocationEntity::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__LocationEntity::GeoLocation = NULL;
	this->tt__LocationEntity::GeoOrientation = NULL;
	this->tt__LocationEntity::LocalLocation = NULL;
	this->tt__LocationEntity::LocalOrientation = NULL;
	this->tt__LocationEntity::Entity = NULL;
	this->tt__LocationEntity::Token = NULL;
	this->tt__LocationEntity::Fixed = NULL;
	this->tt__LocationEntity::GeoSource = NULL;
	this->tt__LocationEntity::AutoGeo = NULL;
}

void tt__LocationEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__GeoLocation(soap, &this->tt__LocationEntity::GeoLocation);
	soap_serialize_PointerTott__GeoOrientation(soap, &this->tt__LocationEntity::GeoOrientation);
	soap_serialize_PointerTott__LocalLocation(soap, &this->tt__LocationEntity::LocalLocation);
	soap_serialize_PointerTott__LocalOrientation(soap, &this->tt__LocationEntity::LocalOrientation);
#endif
}

int tt__LocationEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LocationEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LocationEntity(struct soap *soap, const char *tag, int id, const tt__LocationEntity *a, const char *type)
{
	if (((tt__LocationEntity*)a)->Entity)
	{	soap_set_attr(soap, "Entity", soap_std__string2s(soap, *((tt__LocationEntity*)a)->Entity), 1);
	}
	if (((tt__LocationEntity*)a)->Token)
	{	soap_set_attr(soap, "Token", soap_tt__ReferenceToken2s(soap, *((tt__LocationEntity*)a)->Token), 1);
	}
	if (((tt__LocationEntity*)a)->Fixed)
	{	soap_set_attr(soap, "Fixed", soap_bool2s(soap, *((tt__LocationEntity*)a)->Fixed), 1);
	}
	if (((tt__LocationEntity*)a)->GeoSource)
	{	soap_set_attr(soap, "GeoSource", soap_xsd__anyURI2s(soap, *((tt__LocationEntity*)a)->GeoSource), 1);
	}
	if (((tt__LocationEntity*)a)->AutoGeo)
	{	soap_set_attr(soap, "AutoGeo", soap_bool2s(soap, *((tt__LocationEntity*)a)->AutoGeo), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LocationEntity), type))
		return soap->error;
	if (soap_out_PointerTott__GeoLocation(soap, "tt:GeoLocation", -1, &a->tt__LocationEntity::GeoLocation, ""))
		return soap->error;
	if (soap_out_PointerTott__GeoOrientation(soap, "tt:GeoOrientation", -1, &a->tt__LocationEntity::GeoOrientation, ""))
		return soap->error;
	if (soap_out_PointerTott__LocalLocation(soap, "tt:LocalLocation", -1, &a->tt__LocationEntity::LocalLocation, ""))
		return soap->error;
	if (soap_out_PointerTott__LocalOrientation(soap, "tt:LocalOrientation", -1, &a->tt__LocationEntity::LocalOrientation, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LocationEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LocationEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__LocationEntity * SOAP_FMAC4 soap_in_tt__LocationEntity(struct soap *soap, const char *tag, tt__LocationEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LocationEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocationEntity, sizeof(tt__LocationEntity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LocationEntity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LocationEntity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "Entity", 1, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->Entity = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((tt__LocationEntity*)a)->Entity))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Token", 1, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->Token = soap_new_tt__ReferenceToken(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__ReferenceToken(soap, t, ((tt__LocationEntity*)a)->Token))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Fixed", 5, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->Fixed = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__LocationEntity*)a)->Fixed))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoSource", 4, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->GeoSource = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((tt__LocationEntity*)a)->GeoSource))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "AutoGeo", 5, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->AutoGeo = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__LocationEntity*)a)->AutoGeo))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_GeoLocation1 = 1;
	size_t soap_flag_GeoOrientation1 = 1;
	size_t soap_flag_LocalLocation1 = 1;
	size_t soap_flag_LocalOrientation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GeoLocation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoLocation(soap, "tt:GeoLocation", &a->tt__LocationEntity::GeoLocation, "tt:GeoLocation"))
				{	soap_flag_GeoLocation1--;
					continue;
				}
			}
			if (soap_flag_GeoOrientation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoOrientation(soap, "tt:GeoOrientation", &a->tt__LocationEntity::GeoOrientation, "tt:GeoOrientation"))
				{	soap_flag_GeoOrientation1--;
					continue;
				}
			}
			if (soap_flag_LocalLocation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LocalLocation(soap, "tt:LocalLocation", &a->tt__LocationEntity::LocalLocation, "tt:LocalLocation"))
				{	soap_flag_LocalLocation1--;
					continue;
				}
			}
			if (soap_flag_LocalOrientation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LocalOrientation(soap, "tt:LocalOrientation", &a->tt__LocationEntity::LocalOrientation, "tt:LocalOrientation"))
				{	soap_flag_LocalOrientation1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__LocationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LocationEntity, SOAP_TYPE_tt__LocationEntity, sizeof(tt__LocationEntity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LocationEntity * SOAP_FMAC2 soap_instantiate_tt__LocationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LocationEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LocationEntity *p;
	size_t k = sizeof(tt__LocationEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LocationEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LocationEntity);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LocationEntity, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LocationEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LocationEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LocationEntity(soap, tag ? tag : "tt:LocationEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LocationEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LocationEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__LocationEntity * SOAP_FMAC4 soap_get_tt__LocationEntity(struct soap *soap, tt__LocationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LocationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LocalOrientation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__LocalOrientation::__any);
	this->tt__LocalOrientation::pan = NULL;
	this->tt__LocalOrientation::tilt = NULL;
	this->tt__LocalOrientation::roll = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__LocalOrientation::__anyAttribute);
}

void tt__LocalOrientation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__LocalOrientation::__any);
#endif
}

int tt__LocalOrientation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LocalOrientation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LocalOrientation(struct soap *soap, const char *tag, int id, const tt__LocalOrientation *a, const char *type)
{
	if (((tt__LocalOrientation*)a)->pan)
	{	soap_set_attr(soap, "pan", soap_float2s(soap, *((tt__LocalOrientation*)a)->pan), 1);
	}
	if (((tt__LocalOrientation*)a)->tilt)
	{	soap_set_attr(soap, "tilt", soap_float2s(soap, *((tt__LocalOrientation*)a)->tilt), 1);
	}
	if (((tt__LocalOrientation*)a)->roll)
	{	soap_set_attr(soap, "roll", soap_float2s(soap, *((tt__LocalOrientation*)a)->roll), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__LocalOrientation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LocalOrientation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__LocalOrientation::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LocalOrientation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LocalOrientation(soap, tag, this, type);
}

SOAP_FMAC3 tt__LocalOrientation * SOAP_FMAC4 soap_in_tt__LocalOrientation(struct soap *soap, const char *tag, tt__LocalOrientation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LocalOrientation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocalOrientation, sizeof(tt__LocalOrientation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LocalOrientation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LocalOrientation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "pan", 5, 0);
		if (t)
		{
			if (!(((tt__LocalOrientation*)a)->pan = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__LocalOrientation*)a)->pan))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "tilt", 5, 0);
		if (t)
		{
			if (!(((tt__LocalOrientation*)a)->tilt = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__LocalOrientation*)a)->tilt))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "roll", 5, 0);
		if (t)
		{
			if (!(((tt__LocalOrientation*)a)->roll = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__LocalOrientation*)a)->roll))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__LocalOrientation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__LocalOrientation::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__LocalOrientation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LocalOrientation, SOAP_TYPE_tt__LocalOrientation, sizeof(tt__LocalOrientation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LocalOrientation * SOAP_FMAC2 soap_instantiate_tt__LocalOrientation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LocalOrientation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LocalOrientation *p;
	size_t k = sizeof(tt__LocalOrientation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LocalOrientation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LocalOrientation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LocalOrientation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LocalOrientation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LocalOrientation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LocalOrientation(soap, tag ? tag : "tt:LocalOrientation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LocalOrientation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LocalOrientation(soap, this, tag, type);
}

SOAP_FMAC3 tt__LocalOrientation * SOAP_FMAC4 soap_get_tt__LocalOrientation(struct soap *soap, tt__LocalOrientation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LocalOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LocalLocation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__LocalLocation::__any);
	this->tt__LocalLocation::x = NULL;
	this->tt__LocalLocation::y = NULL;
	this->tt__LocalLocation::z = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__LocalLocation::__anyAttribute);
}

void tt__LocalLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__LocalLocation::__any);
#endif
}

int tt__LocalLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LocalLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LocalLocation(struct soap *soap, const char *tag, int id, const tt__LocalLocation *a, const char *type)
{
	if (((tt__LocalLocation*)a)->x)
	{	soap_set_attr(soap, "x", soap_float2s(soap, *((tt__LocalLocation*)a)->x), 1);
	}
	if (((tt__LocalLocation*)a)->y)
	{	soap_set_attr(soap, "y", soap_float2s(soap, *((tt__LocalLocation*)a)->y), 1);
	}
	if (((tt__LocalLocation*)a)->z)
	{	soap_set_attr(soap, "z", soap_float2s(soap, *((tt__LocalLocation*)a)->z), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__LocalLocation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LocalLocation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__LocalLocation::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LocalLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LocalLocation(soap, tag, this, type);
}

SOAP_FMAC3 tt__LocalLocation * SOAP_FMAC4 soap_in_tt__LocalLocation(struct soap *soap, const char *tag, tt__LocalLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LocalLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocalLocation, sizeof(tt__LocalLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LocalLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LocalLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "x", 5, 0);
		if (t)
		{
			if (!(((tt__LocalLocation*)a)->x = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__LocalLocation*)a)->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "y", 5, 0);
		if (t)
		{
			if (!(((tt__LocalLocation*)a)->y = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__LocalLocation*)a)->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "z", 5, 0);
		if (t)
		{
			if (!(((tt__LocalLocation*)a)->z = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__LocalLocation*)a)->z))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__LocalLocation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__LocalLocation::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__LocalLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LocalLocation, SOAP_TYPE_tt__LocalLocation, sizeof(tt__LocalLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LocalLocation * SOAP_FMAC2 soap_instantiate_tt__LocalLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LocalLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LocalLocation *p;
	size_t k = sizeof(tt__LocalLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LocalLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LocalLocation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LocalLocation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LocalLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LocalLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LocalLocation(soap, tag ? tag : "tt:LocalLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LocalLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LocalLocation(soap, this, tag, type);
}

SOAP_FMAC3 tt__LocalLocation * SOAP_FMAC4 soap_get_tt__LocalLocation(struct soap *soap, tt__LocalLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LocalLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__GeoOrientation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__GeoOrientation::__any);
	this->tt__GeoOrientation::roll = NULL;
	this->tt__GeoOrientation::pitch = NULL;
	this->tt__GeoOrientation::yaw = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__GeoOrientation::__anyAttribute);
}

void tt__GeoOrientation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__GeoOrientation::__any);
#endif
}

int tt__GeoOrientation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__GeoOrientation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GeoOrientation(struct soap *soap, const char *tag, int id, const tt__GeoOrientation *a, const char *type)
{
	if (((tt__GeoOrientation*)a)->roll)
	{	soap_set_attr(soap, "roll", soap_float2s(soap, *((tt__GeoOrientation*)a)->roll), 1);
	}
	if (((tt__GeoOrientation*)a)->pitch)
	{	soap_set_attr(soap, "pitch", soap_float2s(soap, *((tt__GeoOrientation*)a)->pitch), 1);
	}
	if (((tt__GeoOrientation*)a)->yaw)
	{	soap_set_attr(soap, "yaw", soap_float2s(soap, *((tt__GeoOrientation*)a)->yaw), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__GeoOrientation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GeoOrientation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__GeoOrientation::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__GeoOrientation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__GeoOrientation(soap, tag, this, type);
}

SOAP_FMAC3 tt__GeoOrientation * SOAP_FMAC4 soap_in_tt__GeoOrientation(struct soap *soap, const char *tag, tt__GeoOrientation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__GeoOrientation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GeoOrientation, sizeof(tt__GeoOrientation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__GeoOrientation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__GeoOrientation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "roll", 5, 0);
		if (t)
		{
			if (!(((tt__GeoOrientation*)a)->roll = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__GeoOrientation*)a)->roll))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "pitch", 5, 0);
		if (t)
		{
			if (!(((tt__GeoOrientation*)a)->pitch = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__GeoOrientation*)a)->pitch))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "yaw", 5, 0);
		if (t)
		{
			if (!(((tt__GeoOrientation*)a)->yaw = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__GeoOrientation*)a)->yaw))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__GeoOrientation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__GeoOrientation::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__GeoOrientation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GeoOrientation, SOAP_TYPE_tt__GeoOrientation, sizeof(tt__GeoOrientation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__GeoOrientation * SOAP_FMAC2 soap_instantiate_tt__GeoOrientation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__GeoOrientation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__GeoOrientation *p;
	size_t k = sizeof(tt__GeoOrientation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__GeoOrientation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__GeoOrientation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__GeoOrientation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__GeoOrientation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__GeoOrientation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__GeoOrientation(soap, tag ? tag : "tt:GeoOrientation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__GeoOrientation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__GeoOrientation(soap, this, tag, type);
}

SOAP_FMAC3 tt__GeoOrientation * SOAP_FMAC4 soap_get_tt__GeoOrientation(struct soap *soap, tt__GeoOrientation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GeoOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__GeoLocation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__GeoLocation::__any);
	this->tt__GeoLocation::lon = NULL;
	this->tt__GeoLocation::lat = NULL;
	this->tt__GeoLocation::elevation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__GeoLocation::__anyAttribute);
}

void tt__GeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__GeoLocation::__any);
#endif
}

int tt__GeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__GeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GeoLocation(struct soap *soap, const char *tag, int id, const tt__GeoLocation *a, const char *type)
{
	if (((tt__GeoLocation*)a)->lon)
	{	soap_set_attr(soap, "lon", soap_double2s(soap, *((tt__GeoLocation*)a)->lon), 1);
	}
	if (((tt__GeoLocation*)a)->lat)
	{	soap_set_attr(soap, "lat", soap_double2s(soap, *((tt__GeoLocation*)a)->lat), 1);
	}
	if (((tt__GeoLocation*)a)->elevation)
	{	soap_set_attr(soap, "elevation", soap_float2s(soap, *((tt__GeoLocation*)a)->elevation), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__GeoLocation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GeoLocation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__GeoLocation::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__GeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__GeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 tt__GeoLocation * SOAP_FMAC4 soap_in_tt__GeoLocation(struct soap *soap, const char *tag, tt__GeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__GeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GeoLocation, sizeof(tt__GeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__GeoLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__GeoLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "lon", 5, 0);
		if (t)
		{
			if (!(((tt__GeoLocation*)a)->lon = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((tt__GeoLocation*)a)->lon))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "lat", 5, 0);
		if (t)
		{
			if (!(((tt__GeoLocation*)a)->lat = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((tt__GeoLocation*)a)->lat))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "elevation", 5, 0);
		if (t)
		{
			if (!(((tt__GeoLocation*)a)->elevation = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__GeoLocation*)a)->elevation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__GeoLocation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__GeoLocation::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__GeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GeoLocation, SOAP_TYPE_tt__GeoLocation, sizeof(tt__GeoLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__GeoLocation * SOAP_FMAC2 soap_instantiate_tt__GeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__GeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__GeoLocation *p;
	size_t k = sizeof(tt__GeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__GeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__GeoLocation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__GeoLocation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__GeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__GeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__GeoLocation(soap, tag ? tag : "tt:GeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__GeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__GeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 tt__GeoLocation * SOAP_FMAC4 soap_get_tt__GeoLocation(struct soap *soap, tt__GeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TransformationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__TransformationExtension::__any);
}

void tt__TransformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__TransformationExtension::__any);
#endif
}

int tt__TransformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TransformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TransformationExtension(struct soap *soap, const char *tag, int id, const tt__TransformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TransformationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__TransformationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__TransformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TransformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__TransformationExtension * SOAP_FMAC4 soap_in_tt__TransformationExtension(struct soap *soap, const char *tag, tt__TransformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TransformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransformationExtension, sizeof(tt__TransformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TransformationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__TransformationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__TransformationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__TransformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TransformationExtension, SOAP_TYPE_tt__TransformationExtension, sizeof(tt__TransformationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TransformationExtension * SOAP_FMAC2 soap_instantiate_tt__TransformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TransformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TransformationExtension *p;
	size_t k = sizeof(tt__TransformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TransformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TransformationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TransformationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TransformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TransformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TransformationExtension(soap, tag ? tag : "tt:TransformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TransformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TransformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__TransformationExtension * SOAP_FMAC4 soap_get_tt__TransformationExtension(struct soap *soap, tt__TransformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Transformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__Transformation::Translate = NULL;
	this->tt__Transformation::Scale = NULL;
	this->tt__Transformation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Transformation::__anyAttribute);
}

void tt__Transformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector(soap, &this->tt__Transformation::Translate);
	soap_serialize_PointerTott__Vector(soap, &this->tt__Transformation::Scale);
	soap_serialize_PointerTott__TransformationExtension(soap, &this->tt__Transformation::Extension);
#endif
}

int tt__Transformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Transformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Transformation(struct soap *soap, const char *tag, int id, const tt__Transformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Transformation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Transformation), type))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Translate", -1, &a->tt__Transformation::Translate, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Scale", -1, &a->tt__Transformation::Scale, ""))
		return soap->error;
	if (soap_out_PointerTott__TransformationExtension(soap, "tt:Extension", -1, &a->tt__Transformation::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Transformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Transformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__Transformation * SOAP_FMAC4 soap_in_tt__Transformation(struct soap *soap, const char *tag, tt__Transformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Transformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transformation, sizeof(tt__Transformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Transformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Transformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Transformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Translate1 = 1;
	size_t soap_flag_Scale1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Translate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector(soap, "tt:Translate", &a->tt__Transformation::Translate, "tt:Vector"))
				{	soap_flag_Translate1--;
					continue;
				}
			}
			if (soap_flag_Scale1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector(soap, "tt:Scale", &a->tt__Transformation::Scale, "tt:Vector"))
				{	soap_flag_Scale1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TransformationExtension(soap, "tt:Extension", &a->tt__Transformation::Extension, "tt:TransformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Transformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transformation, SOAP_TYPE_tt__Transformation, sizeof(tt__Transformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Transformation * SOAP_FMAC2 soap_instantiate_tt__Transformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Transformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Transformation *p;
	size_t k = sizeof(tt__Transformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Transformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Transformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Transformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Transformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Transformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Transformation(soap, tag ? tag : "tt:Transformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Transformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Transformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__Transformation * SOAP_FMAC4 soap_get_tt__Transformation(struct soap *soap, tt__Transformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ColorCovariance::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__ColorCovariance::XX);
	soap_default_float(soap, &this->tt__ColorCovariance::YY);
	soap_default_float(soap, &this->tt__ColorCovariance::ZZ);
	this->tt__ColorCovariance::XY = NULL;
	this->tt__ColorCovariance::XZ = NULL;
	this->tt__ColorCovariance::YZ = NULL;
	this->tt__ColorCovariance::Colorspace = NULL;
}

void tt__ColorCovariance::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__ColorCovariance::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ColorCovariance(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorCovariance(struct soap *soap, const char *tag, int id, const tt__ColorCovariance *a, const char *type)
{
	soap_set_attr(soap, "XX", soap_float2s(soap, ((tt__ColorCovariance*)a)->XX), 1);
	soap_set_attr(soap, "YY", soap_float2s(soap, ((tt__ColorCovariance*)a)->YY), 1);
	soap_set_attr(soap, "ZZ", soap_float2s(soap, ((tt__ColorCovariance*)a)->ZZ), 1);
	if (((tt__ColorCovariance*)a)->XY)
	{	soap_set_attr(soap, "XY", soap_float2s(soap, *((tt__ColorCovariance*)a)->XY), 1);
	}
	if (((tt__ColorCovariance*)a)->XZ)
	{	soap_set_attr(soap, "XZ", soap_float2s(soap, *((tt__ColorCovariance*)a)->XZ), 1);
	}
	if (((tt__ColorCovariance*)a)->YZ)
	{	soap_set_attr(soap, "YZ", soap_float2s(soap, *((tt__ColorCovariance*)a)->YZ), 1);
	}
	if (((tt__ColorCovariance*)a)->Colorspace)
	{	soap_set_attr(soap, "Colorspace", soap_xsd__anyURI2s(soap, *((tt__ColorCovariance*)a)->Colorspace), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorCovariance), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ColorCovariance::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ColorCovariance(soap, tag, this, type);
}

SOAP_FMAC3 tt__ColorCovariance * SOAP_FMAC4 soap_in_tt__ColorCovariance(struct soap *soap, const char *tag, tt__ColorCovariance *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ColorCovariance*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorCovariance, sizeof(tt__ColorCovariance), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ColorCovariance)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ColorCovariance *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2float(soap, soap_attr_value(soap, "XX", 5, 1), &((tt__ColorCovariance*)a)->XX))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "YY", 5, 1), &((tt__ColorCovariance*)a)->YY))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "ZZ", 5, 1), &((tt__ColorCovariance*)a)->ZZ))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "XY", 5, 0);
		if (t)
		{
			if (!(((tt__ColorCovariance*)a)->XY = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__ColorCovariance*)a)->XY))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "XZ", 5, 0);
		if (t)
		{
			if (!(((tt__ColorCovariance*)a)->XZ = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__ColorCovariance*)a)->XZ))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "YZ", 5, 0);
		if (t)
		{
			if (!(((tt__ColorCovariance*)a)->YZ = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__ColorCovariance*)a)->YZ))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Colorspace", 4, 0);
		if (t)
		{
			if (!(((tt__ColorCovariance*)a)->Colorspace = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((tt__ColorCovariance*)a)->Colorspace))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ColorCovariance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorCovariance, SOAP_TYPE_tt__ColorCovariance, sizeof(tt__ColorCovariance), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ColorCovariance * SOAP_FMAC2 soap_instantiate_tt__ColorCovariance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ColorCovariance(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ColorCovariance *p;
	size_t k = sizeof(tt__ColorCovariance);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ColorCovariance, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ColorCovariance);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ColorCovariance, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ColorCovariance location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ColorCovariance::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ColorCovariance(soap, tag ? tag : "tt:ColorCovariance", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ColorCovariance::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ColorCovariance(soap, this, tag, type);
}

SOAP_FMAC3 tt__ColorCovariance * SOAP_FMAC4 soap_get_tt__ColorCovariance(struct soap *soap, tt__ColorCovariance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorCovariance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Color::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__Color::X);
	soap_default_float(soap, &this->tt__Color::Y);
	soap_default_float(soap, &this->tt__Color::Z);
	this->tt__Color::Colorspace = NULL;
}

void tt__Color::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Color::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Color(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Color(struct soap *soap, const char *tag, int id, const tt__Color *a, const char *type)
{
	soap_set_attr(soap, "X", soap_float2s(soap, ((tt__Color*)a)->X), 1);
	soap_set_attr(soap, "Y", soap_float2s(soap, ((tt__Color*)a)->Y), 1);
	soap_set_attr(soap, "Z", soap_float2s(soap, ((tt__Color*)a)->Z), 1);
	if (((tt__Color*)a)->Colorspace)
	{	soap_set_attr(soap, "Colorspace", soap_xsd__anyURI2s(soap, *((tt__Color*)a)->Colorspace), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Color), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Color::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Color(soap, tag, this, type);
}

SOAP_FMAC3 tt__Color * SOAP_FMAC4 soap_in_tt__Color(struct soap *soap, const char *tag, tt__Color *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Color*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Color, sizeof(tt__Color), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Color)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Color *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2float(soap, soap_attr_value(soap, "X", 5, 1), &((tt__Color*)a)->X))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Y", 5, 1), &((tt__Color*)a)->Y))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Z", 5, 1), &((tt__Color*)a)->Z))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "Colorspace", 4, 0);
		if (t)
		{
			if (!(((tt__Color*)a)->Colorspace = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((tt__Color*)a)->Colorspace))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Color *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Color, SOAP_TYPE_tt__Color, sizeof(tt__Color), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Color * SOAP_FMAC2 soap_instantiate_tt__Color(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Color(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Color *p;
	size_t k = sizeof(tt__Color);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Color, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Color);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Color, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Color location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Color::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Color(soap, tag ? tag : "tt:Color", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Color::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Color(soap, this, tag, type);
}

SOAP_FMAC3 tt__Color * SOAP_FMAC4 soap_get_tt__Color(struct soap *soap, tt__Color *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Polygon::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polygon::Point);
}

void tt__Polygon::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polygon::Point);
#endif
}

int tt__Polygon::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Polygon(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polygon(struct soap *soap, const char *tag, int id, const tt__Polygon *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polygon), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", -1, &a->tt__Polygon::Point, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Polygon::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Polygon(soap, tag, this, type);
}

SOAP_FMAC3 tt__Polygon * SOAP_FMAC4 soap_in_tt__Polygon(struct soap *soap, const char *tag, tt__Polygon *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Polygon*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polygon, sizeof(tt__Polygon), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Polygon)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Polygon *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", &a->tt__Polygon::Point, "tt:Vector"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Polygon::Point.size() < 3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Polygon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polygon, SOAP_TYPE_tt__Polygon, sizeof(tt__Polygon), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Polygon * SOAP_FMAC2 soap_instantiate_tt__Polygon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Polygon(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Polygon *p;
	size_t k = sizeof(tt__Polygon);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Polygon, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Polygon);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Polygon, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Polygon location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Polygon::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Polygon(soap, tag ? tag : "tt:Polygon", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Polygon::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Polygon(soap, this, tag, type);
}

SOAP_FMAC3 tt__Polygon * SOAP_FMAC4 soap_get_tt__Polygon(struct soap *soap, tt__Polygon *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Rectangle::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__Rectangle::bottom = NULL;
	this->tt__Rectangle::top = NULL;
	this->tt__Rectangle::right = NULL;
	this->tt__Rectangle::left = NULL;
}

void tt__Rectangle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Rectangle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Rectangle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rectangle(struct soap *soap, const char *tag, int id, const tt__Rectangle *a, const char *type)
{
	if (((tt__Rectangle*)a)->bottom)
	{	soap_set_attr(soap, "bottom", soap_float2s(soap, *((tt__Rectangle*)a)->bottom), 1);
	}
	if (((tt__Rectangle*)a)->top)
	{	soap_set_attr(soap, "top", soap_float2s(soap, *((tt__Rectangle*)a)->top), 1);
	}
	if (((tt__Rectangle*)a)->right)
	{	soap_set_attr(soap, "right", soap_float2s(soap, *((tt__Rectangle*)a)->right), 1);
	}
	if (((tt__Rectangle*)a)->left)
	{	soap_set_attr(soap, "left", soap_float2s(soap, *((tt__Rectangle*)a)->left), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rectangle), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Rectangle::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Rectangle(soap, tag, this, type);
}

SOAP_FMAC3 tt__Rectangle * SOAP_FMAC4 soap_in_tt__Rectangle(struct soap *soap, const char *tag, tt__Rectangle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Rectangle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rectangle, sizeof(tt__Rectangle), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Rectangle)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Rectangle *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "bottom", 5, 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->bottom = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->bottom))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "top", 5, 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->top = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->top))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "right", 5, 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->right = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->right))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "left", 5, 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->left = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->left))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Rectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rectangle, SOAP_TYPE_tt__Rectangle, sizeof(tt__Rectangle), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Rectangle * SOAP_FMAC2 soap_instantiate_tt__Rectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Rectangle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Rectangle *p;
	size_t k = sizeof(tt__Rectangle);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Rectangle, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Rectangle);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Rectangle, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Rectangle location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Rectangle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Rectangle(soap, tag ? tag : "tt:Rectangle", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Rectangle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Rectangle(soap, this, tag, type);
}

SOAP_FMAC3 tt__Rectangle * SOAP_FMAC4 soap_get_tt__Rectangle(struct soap *soap, tt__Rectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Vector::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__Vector::x = NULL;
	this->tt__Vector::y = NULL;
}

void tt__Vector::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Vector::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector(struct soap *soap, const char *tag, int id, const tt__Vector *a, const char *type)
{
	if (((tt__Vector*)a)->x)
	{	soap_set_attr(soap, "x", soap_float2s(soap, *((tt__Vector*)a)->x), 1);
	}
	if (((tt__Vector*)a)->y)
	{	soap_set_attr(soap, "y", soap_float2s(soap, *((tt__Vector*)a)->y), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Vector::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Vector(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector * SOAP_FMAC4 soap_in_tt__Vector(struct soap *soap, const char *tag, tt__Vector *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Vector*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector, sizeof(tt__Vector), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Vector)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Vector *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "x", 5, 0);
		if (t)
		{
			if (!(((tt__Vector*)a)->x = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Vector*)a)->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "y", 5, 0);
		if (t)
		{
			if (!(((tt__Vector*)a)->y = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Vector*)a)->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Vector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector, SOAP_TYPE_tt__Vector, sizeof(tt__Vector), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Vector * SOAP_FMAC2 soap_instantiate_tt__Vector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Vector(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Vector *p;
	size_t k = sizeof(tt__Vector);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Vector, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Vector);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Vector, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Vector location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Vector::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Vector(soap, tag ? tag : "tt:Vector", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector * SOAP_FMAC4 soap_get_tt__Vector(struct soap *soap, tt__Vector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZMoveStatus::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTZMoveStatus::PanTilt = NULL;
	this->tt__PTZMoveStatus::Zoom = NULL;
}

void tt__PTZMoveStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MoveStatus(soap, &this->tt__PTZMoveStatus::PanTilt);
	soap_serialize_PointerTott__MoveStatus(soap, &this->tt__PTZMoveStatus::Zoom);
#endif
}

int tt__PTZMoveStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZMoveStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZMoveStatus(struct soap *soap, const char *tag, int id, const tt__PTZMoveStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZMoveStatus), type))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:PanTilt", -1, &a->tt__PTZMoveStatus::PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:Zoom", -1, &a->tt__PTZMoveStatus::Zoom, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZMoveStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZMoveStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZMoveStatus * SOAP_FMAC4 soap_in_tt__PTZMoveStatus(struct soap *soap, const char *tag, tt__PTZMoveStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZMoveStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(tt__PTZMoveStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZMoveStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZMoveStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_PanTilt1 = 1;
	size_t soap_flag_Zoom1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MoveStatus(soap, "tt:PanTilt", &a->tt__PTZMoveStatus::PanTilt, "tt:MoveStatus"))
				{	soap_flag_PanTilt1--;
					continue;
				}
			}
			if (soap_flag_Zoom1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MoveStatus(soap, "tt:Zoom", &a->tt__PTZMoveStatus::Zoom, "tt:MoveStatus"))
				{	soap_flag_Zoom1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZMoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZMoveStatus, SOAP_TYPE_tt__PTZMoveStatus, sizeof(tt__PTZMoveStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZMoveStatus * SOAP_FMAC2 soap_instantiate_tt__PTZMoveStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZMoveStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZMoveStatus *p;
	size_t k = sizeof(tt__PTZMoveStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZMoveStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZMoveStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZMoveStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZMoveStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZMoveStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZMoveStatus(soap, tag ? tag : "tt:PTZMoveStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZMoveStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZMoveStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZMoveStatus * SOAP_FMAC4 soap_get_tt__PTZMoveStatus(struct soap *soap, tt__PTZMoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZStatus::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTZStatus::Position = NULL;
	this->tt__PTZStatus::MoveStatus = NULL;
	this->tt__PTZStatus::Error = NULL;
	soap_default_xsd__dateTime(soap, &this->tt__PTZStatus::UtcTime);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZStatus::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZStatus::__anyAttribute);
}

void tt__PTZStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZVector(soap, &this->tt__PTZStatus::Position);
	soap_serialize_PointerTott__PTZMoveStatus(soap, &this->tt__PTZStatus::MoveStatus);
	soap_serialize_PointerTostd__string(soap, &this->tt__PTZStatus::Error);
	soap_embedded(soap, &this->tt__PTZStatus::UtcTime, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->tt__PTZStatus::UtcTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZStatus::__any);
#endif
}

int tt__PTZStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatus(struct soap *soap, const char *tag, int id, const tt__PTZStatus *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZStatus*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatus), type))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:Position", -1, &a->tt__PTZStatus::Position, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZMoveStatus(soap, "tt:MoveStatus", -1, &a->tt__PTZStatus::MoveStatus, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Error", -1, &a->tt__PTZStatus::Error, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tt:UtcTime", -1, &a->tt__PTZStatus::UtcTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZStatus::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZStatus * SOAP_FMAC4 soap_in_tt__PTZStatus(struct soap *soap, const char *tag, tt__PTZStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatus, sizeof(tt__PTZStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZStatus*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_MoveStatus1 = 1;
	size_t soap_flag_Error1 = 1;
	size_t soap_flag_UtcTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:Position", &a->tt__PTZStatus::Position, "tt:PTZVector"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_MoveStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZMoveStatus(soap, "tt:MoveStatus", &a->tt__PTZStatus::MoveStatus, "tt:PTZMoveStatus"))
				{	soap_flag_MoveStatus1--;
					continue;
				}
			}
			if (soap_flag_Error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Error", &a->tt__PTZStatus::Error, "xsd:string"))
				{	soap_flag_Error1--;
					continue;
				}
			}
			if (soap_flag_UtcTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tt:UtcTime", &a->tt__PTZStatus::UtcTime, "xsd:dateTime"))
				{	soap_flag_UtcTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZStatus::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatus, SOAP_TYPE_tt__PTZStatus, sizeof(tt__PTZStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZStatus * SOAP_FMAC2 soap_instantiate_tt__PTZStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZStatus *p;
	size_t k = sizeof(tt__PTZStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZStatus(soap, tag ? tag : "tt:PTZStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZStatus * SOAP_FMAC4 soap_get_tt__PTZStatus(struct soap *soap, tt__PTZStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZVector::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTZVector::PanTilt = NULL;
	this->tt__PTZVector::Zoom = NULL;
}

void tt__PTZVector::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector2D(soap, &this->tt__PTZVector::PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &this->tt__PTZVector::Zoom);
#endif
}

int tt__PTZVector::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZVector(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZVector(struct soap *soap, const char *tag, int id, const tt__PTZVector *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZVector), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->tt__PTZVector::PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->tt__PTZVector::Zoom, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZVector::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZVector(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZVector * SOAP_FMAC4 soap_in_tt__PTZVector(struct soap *soap, const char *tag, tt__PTZVector *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZVector*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZVector, sizeof(tt__PTZVector), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZVector)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZVector *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_PanTilt1 = 1;
	size_t soap_flag_Zoom1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->tt__PTZVector::PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt1--;
					continue;
				}
			}
			if (soap_flag_Zoom1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->tt__PTZVector::Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZVector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZVector, SOAP_TYPE_tt__PTZVector, sizeof(tt__PTZVector), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZVector * SOAP_FMAC2 soap_instantiate_tt__PTZVector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZVector(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZVector *p;
	size_t k = sizeof(tt__PTZVector);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZVector, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZVector);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZVector, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZVector location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZVector::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZVector(soap, tag ? tag : "tt:PTZVector", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZVector::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZVector(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZVector * SOAP_FMAC4 soap_get_tt__PTZVector(struct soap *soap, tt__PTZVector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Vector1D::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__Vector1D::x);
	this->tt__Vector1D::space = NULL;
}

void tt__Vector1D::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Vector1D::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector1D(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector1D(struct soap *soap, const char *tag, int id, const tt__Vector1D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, ((tt__Vector1D*)a)->x), 1);
	if (((tt__Vector1D*)a)->space)
	{	soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, *((tt__Vector1D*)a)->space), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector1D), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Vector1D::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Vector1D(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector1D * SOAP_FMAC4 soap_in_tt__Vector1D(struct soap *soap, const char *tag, tt__Vector1D *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Vector1D*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector1D, sizeof(tt__Vector1D), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Vector1D)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Vector1D *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 5, 1), &((tt__Vector1D*)a)->x))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "space", 4, 0);
		if (t)
		{
			if (!(((tt__Vector1D*)a)->space = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((tt__Vector1D*)a)->space))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Vector1D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector1D, SOAP_TYPE_tt__Vector1D, sizeof(tt__Vector1D), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 soap_instantiate_tt__Vector1D(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Vector1D(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Vector1D *p;
	size_t k = sizeof(tt__Vector1D);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Vector1D, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Vector1D);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Vector1D, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Vector1D location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Vector1D::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Vector1D(soap, tag ? tag : "tt:Vector1D", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector1D::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector1D(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector1D * SOAP_FMAC4 soap_get_tt__Vector1D(struct soap *soap, tt__Vector1D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Vector2D::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__Vector2D::x);
	soap_default_float(soap, &this->tt__Vector2D::y);
	this->tt__Vector2D::space = NULL;
}

void tt__Vector2D::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Vector2D::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector2D(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector2D(struct soap *soap, const char *tag, int id, const tt__Vector2D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, ((tt__Vector2D*)a)->x), 1);
	soap_set_attr(soap, "y", soap_float2s(soap, ((tt__Vector2D*)a)->y), 1);
	if (((tt__Vector2D*)a)->space)
	{	soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, *((tt__Vector2D*)a)->space), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector2D), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Vector2D::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Vector2D(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector2D * SOAP_FMAC4 soap_in_tt__Vector2D(struct soap *soap, const char *tag, tt__Vector2D *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Vector2D*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector2D, sizeof(tt__Vector2D), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Vector2D)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Vector2D *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 5, 1), &((tt__Vector2D*)a)->x))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "y", 5, 1), &((tt__Vector2D*)a)->y))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "space", 4, 0);
		if (t)
		{
			if (!(((tt__Vector2D*)a)->space = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((tt__Vector2D*)a)->space))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Vector2D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector2D, SOAP_TYPE_tt__Vector2D, sizeof(tt__Vector2D), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 soap_instantiate_tt__Vector2D(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Vector2D(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Vector2D *p;
	size_t k = sizeof(tt__Vector2D);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Vector2D, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Vector2D);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Vector2D, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Vector2D location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Vector2D::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Vector2D(soap, tag ? tag : "tt:Vector2D", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector2D::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector2D(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector2D * SOAP_FMAC4 soap_get_tt__Vector2D(struct soap *soap, tt__Vector2D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__StorageReferencePathExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__StorageReferencePathExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__StorageReferencePathExtension::__anyAttribute);
}

void tt__StorageReferencePathExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__StorageReferencePathExtension::__any);
#endif
}

int tt__StorageReferencePathExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__StorageReferencePathExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StorageReferencePathExtension(struct soap *soap, const char *tag, int id, const tt__StorageReferencePathExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__StorageReferencePathExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StorageReferencePathExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__StorageReferencePathExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__StorageReferencePathExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__StorageReferencePathExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__StorageReferencePathExtension * SOAP_FMAC4 soap_in_tt__StorageReferencePathExtension(struct soap *soap, const char *tag, tt__StorageReferencePathExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__StorageReferencePathExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StorageReferencePathExtension, sizeof(tt__StorageReferencePathExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__StorageReferencePathExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__StorageReferencePathExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__StorageReferencePathExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__StorageReferencePathExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__StorageReferencePathExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StorageReferencePathExtension, SOAP_TYPE_tt__StorageReferencePathExtension, sizeof(tt__StorageReferencePathExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__StorageReferencePathExtension * SOAP_FMAC2 soap_instantiate_tt__StorageReferencePathExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__StorageReferencePathExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__StorageReferencePathExtension *p;
	size_t k = sizeof(tt__StorageReferencePathExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__StorageReferencePathExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__StorageReferencePathExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__StorageReferencePathExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__StorageReferencePathExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__StorageReferencePathExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__StorageReferencePathExtension(soap, tag ? tag : "tt:StorageReferencePathExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__StorageReferencePathExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__StorageReferencePathExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__StorageReferencePathExtension * SOAP_FMAC4 soap_get_tt__StorageReferencePathExtension(struct soap *soap, tt__StorageReferencePathExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StorageReferencePathExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__StorageReferencePath::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &this->tt__StorageReferencePath::StorageToken);
	this->tt__StorageReferencePath::RelativePath = NULL;
	this->tt__StorageReferencePath::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__StorageReferencePath::__anyAttribute);
}

void tt__StorageReferencePath::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__StorageReferencePath::StorageToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__StorageReferencePath::StorageToken);
	soap_serialize_PointerTostd__string(soap, &this->tt__StorageReferencePath::RelativePath);
	soap_serialize_PointerTott__StorageReferencePathExtension(soap, &this->tt__StorageReferencePath::Extension);
#endif
}

int tt__StorageReferencePath::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__StorageReferencePath(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StorageReferencePath(struct soap *soap, const char *tag, int id, const tt__StorageReferencePath *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__StorageReferencePath*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StorageReferencePath), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:StorageToken", -1, &a->tt__StorageReferencePath::StorageToken, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:RelativePath", -1, &a->tt__StorageReferencePath::RelativePath, ""))
		return soap->error;
	if (soap_out_PointerTott__StorageReferencePathExtension(soap, "tt:Extension", -1, &a->tt__StorageReferencePath::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__StorageReferencePath::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__StorageReferencePath(soap, tag, this, type);
}

SOAP_FMAC3 tt__StorageReferencePath * SOAP_FMAC4 soap_in_tt__StorageReferencePath(struct soap *soap, const char *tag, tt__StorageReferencePath *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__StorageReferencePath*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StorageReferencePath, sizeof(tt__StorageReferencePath), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__StorageReferencePath)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__StorageReferencePath *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__StorageReferencePath*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_StorageToken1 = 1;
	size_t soap_flag_RelativePath1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:StorageToken", &a->tt__StorageReferencePath::StorageToken, "tt:ReferenceToken"))
				{	soap_flag_StorageToken1--;
					continue;
				}
			}
			if (soap_flag_RelativePath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:RelativePath", &a->tt__StorageReferencePath::RelativePath, "xsd:string"))
				{	soap_flag_RelativePath1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StorageReferencePathExtension(soap, "tt:Extension", &a->tt__StorageReferencePath::Extension, "tt:StorageReferencePathExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StorageToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__StorageReferencePath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StorageReferencePath, SOAP_TYPE_tt__StorageReferencePath, sizeof(tt__StorageReferencePath), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__StorageReferencePath * SOAP_FMAC2 soap_instantiate_tt__StorageReferencePath(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__StorageReferencePath(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__StorageReferencePath *p;
	size_t k = sizeof(tt__StorageReferencePath);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__StorageReferencePath, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__StorageReferencePath);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__StorageReferencePath, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__StorageReferencePath location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__StorageReferencePath::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__StorageReferencePath(soap, tag ? tag : "tt:StorageReferencePath", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__StorageReferencePath::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__StorageReferencePath(soap, this, tag, type);
}

SOAP_FMAC3 tt__StorageReferencePath * SOAP_FMAC4 soap_get_tt__StorageReferencePath(struct soap *soap, tt__StorageReferencePath *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StorageReferencePath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ArrayOfFileProgressExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ArrayOfFileProgressExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ArrayOfFileProgressExtension::__anyAttribute);
}

void tt__ArrayOfFileProgressExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ArrayOfFileProgressExtension::__any);
#endif
}

int tt__ArrayOfFileProgressExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ArrayOfFileProgressExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ArrayOfFileProgressExtension(struct soap *soap, const char *tag, int id, const tt__ArrayOfFileProgressExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ArrayOfFileProgressExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ArrayOfFileProgressExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ArrayOfFileProgressExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ArrayOfFileProgressExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ArrayOfFileProgressExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ArrayOfFileProgressExtension * SOAP_FMAC4 soap_in_tt__ArrayOfFileProgressExtension(struct soap *soap, const char *tag, tt__ArrayOfFileProgressExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ArrayOfFileProgressExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ArrayOfFileProgressExtension, sizeof(tt__ArrayOfFileProgressExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ArrayOfFileProgressExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ArrayOfFileProgressExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ArrayOfFileProgressExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ArrayOfFileProgressExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ArrayOfFileProgressExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ArrayOfFileProgressExtension, SOAP_TYPE_tt__ArrayOfFileProgressExtension, sizeof(tt__ArrayOfFileProgressExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ArrayOfFileProgressExtension * SOAP_FMAC2 soap_instantiate_tt__ArrayOfFileProgressExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ArrayOfFileProgressExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ArrayOfFileProgressExtension *p;
	size_t k = sizeof(tt__ArrayOfFileProgressExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ArrayOfFileProgressExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ArrayOfFileProgressExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ArrayOfFileProgressExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ArrayOfFileProgressExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ArrayOfFileProgressExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ArrayOfFileProgressExtension(soap, tag ? tag : "tt:ArrayOfFileProgressExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ArrayOfFileProgressExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ArrayOfFileProgressExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ArrayOfFileProgressExtension * SOAP_FMAC4 soap_get_tt__ArrayOfFileProgressExtension(struct soap *soap, tt__ArrayOfFileProgressExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ArrayOfFileProgressExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ArrayOfFileProgress::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__FileProgress(soap, &this->tt__ArrayOfFileProgress::FileProgress);
	this->tt__ArrayOfFileProgress::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ArrayOfFileProgress::__anyAttribute);
}

void tt__ArrayOfFileProgress::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__FileProgress(soap, &this->tt__ArrayOfFileProgress::FileProgress);
	soap_serialize_PointerTott__ArrayOfFileProgressExtension(soap, &this->tt__ArrayOfFileProgress::Extension);
#endif
}

int tt__ArrayOfFileProgress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ArrayOfFileProgress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ArrayOfFileProgress(struct soap *soap, const char *tag, int id, const tt__ArrayOfFileProgress *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ArrayOfFileProgress*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ArrayOfFileProgress), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__FileProgress(soap, "tt:FileProgress", -1, &a->tt__ArrayOfFileProgress::FileProgress, ""))
		return soap->error;
	if (soap_out_PointerTott__ArrayOfFileProgressExtension(soap, "tt:Extension", -1, &a->tt__ArrayOfFileProgress::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ArrayOfFileProgress::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ArrayOfFileProgress(soap, tag, this, type);
}

SOAP_FMAC3 tt__ArrayOfFileProgress * SOAP_FMAC4 soap_in_tt__ArrayOfFileProgress(struct soap *soap, const char *tag, tt__ArrayOfFileProgress *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ArrayOfFileProgress*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ArrayOfFileProgress, sizeof(tt__ArrayOfFileProgress), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ArrayOfFileProgress)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ArrayOfFileProgress *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ArrayOfFileProgress*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__FileProgress(soap, "tt:FileProgress", &a->tt__ArrayOfFileProgress::FileProgress, "tt:FileProgress"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ArrayOfFileProgressExtension(soap, "tt:Extension", &a->tt__ArrayOfFileProgress::Extension, "tt:ArrayOfFileProgressExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ArrayOfFileProgress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ArrayOfFileProgress, SOAP_TYPE_tt__ArrayOfFileProgress, sizeof(tt__ArrayOfFileProgress), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ArrayOfFileProgress * SOAP_FMAC2 soap_instantiate_tt__ArrayOfFileProgress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ArrayOfFileProgress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ArrayOfFileProgress *p;
	size_t k = sizeof(tt__ArrayOfFileProgress);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ArrayOfFileProgress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ArrayOfFileProgress);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ArrayOfFileProgress, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ArrayOfFileProgress location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ArrayOfFileProgress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ArrayOfFileProgress(soap, tag ? tag : "tt:ArrayOfFileProgress", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ArrayOfFileProgress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ArrayOfFileProgress(soap, this, tag, type);
}

SOAP_FMAC3 tt__ArrayOfFileProgress * SOAP_FMAC4 soap_get_tt__ArrayOfFileProgress(struct soap *soap, tt__ArrayOfFileProgress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ArrayOfFileProgress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FileProgress::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__FileProgress::FileName);
	soap_default_float(soap, &this->tt__FileProgress::Progress);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FileProgress::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__FileProgress::__anyAttribute);
}

void tt__FileProgress::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__FileProgress::FileName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__FileProgress::FileName);
	soap_embedded(soap, &this->tt__FileProgress::Progress, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FileProgress::__any);
#endif
}

int tt__FileProgress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FileProgress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FileProgress(struct soap *soap, const char *tag, int id, const tt__FileProgress *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__FileProgress*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FileProgress), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:FileName", -1, &a->tt__FileProgress::FileName, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Progress", -1, &a->tt__FileProgress::Progress, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__FileProgress::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FileProgress::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FileProgress(soap, tag, this, type);
}

SOAP_FMAC3 tt__FileProgress * SOAP_FMAC4 soap_in_tt__FileProgress(struct soap *soap, const char *tag, tt__FileProgress *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FileProgress*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FileProgress, sizeof(tt__FileProgress), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FileProgress)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FileProgress *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__FileProgress*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_FileName1 = 1;
	size_t soap_flag_Progress1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:FileName", &a->tt__FileProgress::FileName, "xsd:string"))
				{	soap_flag_FileName1--;
					continue;
				}
			}
			if (soap_flag_Progress1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Progress", &a->tt__FileProgress::Progress, "xsd:float"))
				{	soap_flag_Progress1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__FileProgress::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FileName1 > 0 || soap_flag_Progress1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FileProgress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FileProgress, SOAP_TYPE_tt__FileProgress, sizeof(tt__FileProgress), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FileProgress * SOAP_FMAC2 soap_instantiate_tt__FileProgress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FileProgress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FileProgress *p;
	size_t k = sizeof(tt__FileProgress);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FileProgress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FileProgress);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FileProgress, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FileProgress location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FileProgress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FileProgress(soap, tag ? tag : "tt:FileProgress", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FileProgress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FileProgress(soap, this, tag, type);
}

SOAP_FMAC3 tt__FileProgress * SOAP_FMAC4 soap_get_tt__FileProgress(struct soap *soap, tt__FileProgress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FileProgress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDConfigurationOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDConfigurationOptionsExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDConfigurationOptionsExtension::__anyAttribute);
}

void tt__OSDConfigurationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDConfigurationOptionsExtension::__any);
#endif
}

int tt__OSDConfigurationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDConfigurationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__OSDConfigurationOptionsExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDConfigurationOptionsExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__OSDConfigurationOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDConfigurationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDConfigurationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__OSDConfigurationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDConfigurationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(tt__OSDConfigurationOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDConfigurationOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDConfigurationOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDConfigurationOptionsExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__OSDConfigurationOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__OSDConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(tt__OSDConfigurationOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDConfigurationOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDConfigurationOptionsExtension *p;
	size_t k = sizeof(tt__OSDConfigurationOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDConfigurationOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDConfigurationOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDConfigurationOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDConfigurationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDConfigurationOptionsExtension(soap, tag ? tag : "tt:OSDConfigurationOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDConfigurationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDConfigurationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDConfigurationOptionsExtension(struct soap *soap, tt__OSDConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__OSDConfigurationOptions::MaximumNumberOfOSDs = NULL;
	soap_default_std__vectorTemplateOftt__OSDType(soap, &this->tt__OSDConfigurationOptions::Type);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__OSDConfigurationOptions::PositionOption);
	this->tt__OSDConfigurationOptions::TextOption = NULL;
	this->tt__OSDConfigurationOptions::ImageOption = NULL;
	this->tt__OSDConfigurationOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDConfigurationOptions::__anyAttribute);
}

void tt__OSDConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MaximumNumberOfOSDs(soap, &this->tt__OSDConfigurationOptions::MaximumNumberOfOSDs);
	soap_serialize_std__vectorTemplateOftt__OSDType(soap, &this->tt__OSDConfigurationOptions::Type);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__OSDConfigurationOptions::PositionOption);
	soap_serialize_PointerTott__OSDTextOptions(soap, &this->tt__OSDConfigurationOptions::TextOption);
	soap_serialize_PointerTott__OSDImgOptions(soap, &this->tt__OSDConfigurationOptions::ImageOption);
	soap_serialize_PointerTott__OSDConfigurationOptionsExtension(soap, &this->tt__OSDConfigurationOptions::Extension);
#endif
}

int tt__OSDConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__OSDConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfigurationOptions), type))
		return soap->error;
	if (!a->tt__OSDConfigurationOptions::MaximumNumberOfOSDs)
	{	if (soap_element_empty(soap, "tt:MaximumNumberOfOSDs"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MaximumNumberOfOSDs(soap, "tt:MaximumNumberOfOSDs", -1, &a->tt__OSDConfigurationOptions::MaximumNumberOfOSDs, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__OSDType(soap, "tt:Type", -1, &a->tt__OSDConfigurationOptions::Type, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:PositionOption", -1, &a->tt__OSDConfigurationOptions::PositionOption, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextOptions(soap, "tt:TextOption", -1, &a->tt__OSDConfigurationOptions::TextOption, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgOptions(soap, "tt:ImageOption", -1, &a->tt__OSDConfigurationOptions::ImageOption, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->tt__OSDConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDConfigurationOptions * SOAP_FMAC4 soap_in_tt__OSDConfigurationOptions(struct soap *soap, const char *tag, tt__OSDConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(tt__OSDConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_MaximumNumberOfOSDs1 = 1;
	size_t soap_flag_TextOption1 = 1;
	size_t soap_flag_ImageOption1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfOSDs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MaximumNumberOfOSDs(soap, "tt:MaximumNumberOfOSDs", &a->tt__OSDConfigurationOptions::MaximumNumberOfOSDs, "tt:MaximumNumberOfOSDs"))
				{	soap_flag_MaximumNumberOfOSDs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__OSDType(soap, "tt:Type", &a->tt__OSDConfigurationOptions::Type, "tt:OSDType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:PositionOption", &a->tt__OSDConfigurationOptions::PositionOption, "xsd:string"))
					continue;
			}
			if (soap_flag_TextOption1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextOptions(soap, "tt:TextOption", &a->tt__OSDConfigurationOptions::TextOption, "tt:OSDTextOptions"))
				{	soap_flag_TextOption1--;
					continue;
				}
			}
			if (soap_flag_ImageOption1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgOptions(soap, "tt:ImageOption", &a->tt__OSDConfigurationOptions::ImageOption, "tt:OSDImgOptions"))
				{	soap_flag_ImageOption1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDConfigurationOptionsExtension(soap, "tt:Extension", &a->tt__OSDConfigurationOptions::Extension, "tt:OSDConfigurationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__OSDConfigurationOptions::MaximumNumberOfOSDs || a->tt__OSDConfigurationOptions::Type.size() < 1 || a->tt__OSDConfigurationOptions::PositionOption.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationOptions, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(tt__OSDConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDConfigurationOptions *p;
	size_t k = sizeof(tt__OSDConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDConfigurationOptions(soap, tag ? tag : "tt:OSDConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDConfigurationOptions * SOAP_FMAC4 soap_get_tt__OSDConfigurationOptions(struct soap *soap, tt__OSDConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MaximumNumberOfOSDs::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__MaximumNumberOfOSDs::Total);
	this->tt__MaximumNumberOfOSDs::Image = NULL;
	this->tt__MaximumNumberOfOSDs::PlainText = NULL;
	this->tt__MaximumNumberOfOSDs::Date = NULL;
	this->tt__MaximumNumberOfOSDs::Time = NULL;
	this->tt__MaximumNumberOfOSDs::DateAndTime = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__MaximumNumberOfOSDs::__anyAttribute);
}

void tt__MaximumNumberOfOSDs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__MaximumNumberOfOSDs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MaximumNumberOfOSDs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MaximumNumberOfOSDs(struct soap *soap, const char *tag, int id, const tt__MaximumNumberOfOSDs *a, const char *type)
{
	soap_set_attr(soap, "Total", soap_int2s(soap, ((tt__MaximumNumberOfOSDs*)a)->Total), 1);
	if (((tt__MaximumNumberOfOSDs*)a)->Image)
	{	soap_set_attr(soap, "Image", soap_int2s(soap, *((tt__MaximumNumberOfOSDs*)a)->Image), 1);
	}
	if (((tt__MaximumNumberOfOSDs*)a)->PlainText)
	{	soap_set_attr(soap, "PlainText", soap_int2s(soap, *((tt__MaximumNumberOfOSDs*)a)->PlainText), 1);
	}
	if (((tt__MaximumNumberOfOSDs*)a)->Date)
	{	soap_set_attr(soap, "Date", soap_int2s(soap, *((tt__MaximumNumberOfOSDs*)a)->Date), 1);
	}
	if (((tt__MaximumNumberOfOSDs*)a)->Time)
	{	soap_set_attr(soap, "Time", soap_int2s(soap, *((tt__MaximumNumberOfOSDs*)a)->Time), 1);
	}
	if (((tt__MaximumNumberOfOSDs*)a)->DateAndTime)
	{	soap_set_attr(soap, "DateAndTime", soap_int2s(soap, *((tt__MaximumNumberOfOSDs*)a)->DateAndTime), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MaximumNumberOfOSDs*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MaximumNumberOfOSDs), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MaximumNumberOfOSDs::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MaximumNumberOfOSDs(soap, tag, this, type);
}

SOAP_FMAC3 tt__MaximumNumberOfOSDs * SOAP_FMAC4 soap_in_tt__MaximumNumberOfOSDs(struct soap *soap, const char *tag, tt__MaximumNumberOfOSDs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MaximumNumberOfOSDs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(tt__MaximumNumberOfOSDs), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MaximumNumberOfOSDs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MaximumNumberOfOSDs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2int(soap, soap_attr_value(soap, "Total", 5, 1), &((tt__MaximumNumberOfOSDs*)a)->Total))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "Image", 5, 0);
		if (t)
		{
			if (!(((tt__MaximumNumberOfOSDs*)a)->Image = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__MaximumNumberOfOSDs*)a)->Image))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PlainText", 5, 0);
		if (t)
		{
			if (!(((tt__MaximumNumberOfOSDs*)a)->PlainText = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__MaximumNumberOfOSDs*)a)->PlainText))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Date", 5, 0);
		if (t)
		{
			if (!(((tt__MaximumNumberOfOSDs*)a)->Date = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__MaximumNumberOfOSDs*)a)->Date))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Time", 5, 0);
		if (t)
		{
			if (!(((tt__MaximumNumberOfOSDs*)a)->Time = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__MaximumNumberOfOSDs*)a)->Time))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DateAndTime", 5, 0);
		if (t)
		{
			if (!(((tt__MaximumNumberOfOSDs*)a)->DateAndTime = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__MaximumNumberOfOSDs*)a)->DateAndTime))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MaximumNumberOfOSDs*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MaximumNumberOfOSDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MaximumNumberOfOSDs, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(tt__MaximumNumberOfOSDs), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MaximumNumberOfOSDs * SOAP_FMAC2 soap_instantiate_tt__MaximumNumberOfOSDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MaximumNumberOfOSDs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MaximumNumberOfOSDs *p;
	size_t k = sizeof(tt__MaximumNumberOfOSDs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MaximumNumberOfOSDs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MaximumNumberOfOSDs);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MaximumNumberOfOSDs, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MaximumNumberOfOSDs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MaximumNumberOfOSDs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MaximumNumberOfOSDs(soap, tag ? tag : "tt:MaximumNumberOfOSDs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MaximumNumberOfOSDs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MaximumNumberOfOSDs(soap, this, tag, type);
}

SOAP_FMAC3 tt__MaximumNumberOfOSDs * SOAP_FMAC4 soap_get_tt__MaximumNumberOfOSDs(struct soap *soap, tt__MaximumNumberOfOSDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MaximumNumberOfOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDConfigurationExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDConfigurationExtension::__anyAttribute);
}

void tt__OSDConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDConfigurationExtension::__any);
#endif
}

int tt__OSDConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__OSDConfigurationExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDConfigurationExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__OSDConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDConfigurationExtension(struct soap *soap, const char *tag, tt__OSDConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(tt__OSDConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDConfigurationExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__OSDConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__OSDConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationExtension, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(tt__OSDConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDConfigurationExtension *p;
	size_t k = sizeof(tt__OSDConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDConfigurationExtension(soap, tag ? tag : "tt:OSDConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDConfigurationExtension(struct soap *soap, tt__OSDConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__DeviceEntity::soap_default(soap);
	this->tt__OSDConfiguration::VideoSourceConfigurationToken = NULL;
	soap_default_tt__OSDType(soap, &this->tt__OSDConfiguration::Type);
	this->tt__OSDConfiguration::Position = NULL;
	this->tt__OSDConfiguration::TextString = NULL;
	this->tt__OSDConfiguration::Image = NULL;
	this->tt__OSDConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDConfiguration::__anyAttribute);
}

void tt__OSDConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDReference(soap, &this->tt__OSDConfiguration::VideoSourceConfigurationToken);
	soap_serialize_PointerTott__OSDPosConfiguration(soap, &this->tt__OSDConfiguration::Position);
	soap_serialize_PointerTott__OSDTextConfiguration(soap, &this->tt__OSDConfiguration::TextString);
	soap_serialize_PointerTott__OSDImgConfiguration(soap, &this->tt__OSDConfiguration::Image);
	soap_serialize_PointerTott__OSDConfigurationExtension(soap, &this->tt__OSDConfiguration::Extension);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__OSDConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfiguration(struct soap *soap, const char *tag, int id, const tt__OSDConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfiguration), type ? type : "tt:OSDConfiguration"))
		return soap->error;
	if (!a->tt__OSDConfiguration::VideoSourceConfigurationToken)
	{	if (soap_element_empty(soap, "tt:VideoSourceConfigurationToken"))
			return soap->error;
	}
	else if (soap_out_PointerTott__OSDReference(soap, "tt:VideoSourceConfigurationToken", -1, &a->tt__OSDConfiguration::VideoSourceConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__OSDType(soap, "tt:Type", -1, &a->tt__OSDConfiguration::Type, ""))
		return soap->error;
	if (!a->tt__OSDConfiguration::Position)
	{	if (soap_element_empty(soap, "tt:Position"))
			return soap->error;
	}
	else if (soap_out_PointerTott__OSDPosConfiguration(soap, "tt:Position", -1, &a->tt__OSDConfiguration::Position, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextConfiguration(soap, "tt:TextString", -1, &a->tt__OSDConfiguration::TextString, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgConfiguration(soap, "tt:Image", -1, &a->tt__OSDConfiguration::Image, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDConfigurationExtension(soap, "tt:Extension", -1, &a->tt__OSDConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDConfiguration * SOAP_FMAC4 soap_in_tt__OSDConfiguration(struct soap *soap, const char *tag, tt__OSDConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfiguration, sizeof(tt__OSDConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_VideoSourceConfigurationToken1 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_TextString1 = 1;
	size_t soap_flag_Image1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceConfigurationToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDReference(soap, "tt:VideoSourceConfigurationToken", &a->tt__OSDConfiguration::VideoSourceConfigurationToken, "tt:OSDReference"))
				{	soap_flag_VideoSourceConfigurationToken1--;
					continue;
				}
			}
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__OSDType(soap, "tt:Type", &a->tt__OSDConfiguration::Type, "tt:OSDType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDPosConfiguration(soap, "tt:Position", &a->tt__OSDConfiguration::Position, "tt:OSDPosConfiguration"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_TextString1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextConfiguration(soap, "tt:TextString", &a->tt__OSDConfiguration::TextString, "tt:OSDTextConfiguration"))
				{	soap_flag_TextString1--;
					continue;
				}
			}
			if (soap_flag_Image1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgConfiguration(soap, "tt:Image", &a->tt__OSDConfiguration::Image, "tt:OSDImgConfiguration"))
				{	soap_flag_Image1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDConfigurationExtension(soap, "tt:Extension", &a->tt__OSDConfiguration::Extension, "tt:OSDConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__OSDConfiguration::VideoSourceConfigurationToken || soap_flag_Type1 > 0 || !a->tt__OSDConfiguration::Position))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfiguration, SOAP_TYPE_tt__OSDConfiguration, sizeof(tt__OSDConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDConfiguration *p;
	size_t k = sizeof(tt__OSDConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDConfiguration(soap, tag ? tag : "tt:OSDConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDConfiguration * SOAP_FMAC4 soap_get_tt__OSDConfiguration(struct soap *soap, tt__OSDConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDImgOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDImgOptionsExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDImgOptionsExtension::__anyAttribute);
}

void tt__OSDImgOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDImgOptionsExtension::__any);
#endif
}

int tt__OSDImgOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDImgOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgOptionsExtension(struct soap *soap, const char *tag, int id, const tt__OSDImgOptionsExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDImgOptionsExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__OSDImgOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDImgOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDImgOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDImgOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDImgOptionsExtension(struct soap *soap, const char *tag, tt__OSDImgOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDImgOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(tt__OSDImgOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDImgOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDImgOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDImgOptionsExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__OSDImgOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__OSDImgOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgOptionsExtension, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(tt__OSDImgOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDImgOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDImgOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDImgOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDImgOptionsExtension *p;
	size_t k = sizeof(tt__OSDImgOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDImgOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDImgOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDImgOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDImgOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDImgOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDImgOptionsExtension(soap, tag ? tag : "tt:OSDImgOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDImgOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDImgOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDImgOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDImgOptionsExtension(struct soap *soap, tt__OSDImgOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDImgOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__OSDImgOptions::ImagePath);
	this->tt__OSDImgOptions::Extension = NULL;
	this->tt__OSDImgOptions::FormatsSupported = NULL;
	this->tt__OSDImgOptions::MaxSize = NULL;
	this->tt__OSDImgOptions::MaxWidth = NULL;
	this->tt__OSDImgOptions::MaxHeight = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDImgOptions::__anyAttribute);
}

void tt__OSDImgOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__OSDImgOptions::ImagePath);
	soap_serialize_PointerTott__OSDImgOptionsExtension(soap, &this->tt__OSDImgOptions::Extension);
#endif
}

int tt__OSDImgOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDImgOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgOptions(struct soap *soap, const char *tag, int id, const tt__OSDImgOptions *a, const char *type)
{
	if (((tt__OSDImgOptions*)a)->FormatsSupported)
	{	soap_set_attr(soap, "FormatsSupported", soap_tt__StringAttrList2s(soap, *((tt__OSDImgOptions*)a)->FormatsSupported), 1);
	}
	if (((tt__OSDImgOptions*)a)->MaxSize)
	{	soap_set_attr(soap, "MaxSize", soap_int2s(soap, *((tt__OSDImgOptions*)a)->MaxSize), 1);
	}
	if (((tt__OSDImgOptions*)a)->MaxWidth)
	{	soap_set_attr(soap, "MaxWidth", soap_int2s(soap, *((tt__OSDImgOptions*)a)->MaxWidth), 1);
	}
	if (((tt__OSDImgOptions*)a)->MaxHeight)
	{	soap_set_attr(soap, "MaxHeight", soap_int2s(soap, *((tt__OSDImgOptions*)a)->MaxHeight), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDImgOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tt:ImagePath", -1, &a->tt__OSDImgOptions::ImagePath, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgOptionsExtension(soap, "tt:Extension", -1, &a->tt__OSDImgOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDImgOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDImgOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDImgOptions * SOAP_FMAC4 soap_in_tt__OSDImgOptions(struct soap *soap, const char *tag, tt__OSDImgOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDImgOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgOptions, sizeof(tt__OSDImgOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDImgOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDImgOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "FormatsSupported", 1, 0);
		if (t)
		{
			if (!(((tt__OSDImgOptions*)a)->FormatsSupported = soap_new_tt__StringAttrList(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__StringAttrList(soap, t, ((tt__OSDImgOptions*)a)->FormatsSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxSize", 5, 0);
		if (t)
		{
			if (!(((tt__OSDImgOptions*)a)->MaxSize = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__OSDImgOptions*)a)->MaxSize))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxWidth", 5, 0);
		if (t)
		{
			if (!(((tt__OSDImgOptions*)a)->MaxWidth = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__OSDImgOptions*)a)->MaxWidth))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxHeight", 5, 0);
		if (t)
		{
			if (!(((tt__OSDImgOptions*)a)->MaxHeight = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__OSDImgOptions*)a)->MaxHeight))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDImgOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tt:ImagePath", &a->tt__OSDImgOptions::ImagePath, "xsd:anyURI"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgOptionsExtension(soap, "tt:Extension", &a->tt__OSDImgOptions::Extension, "tt:OSDImgOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__OSDImgOptions::ImagePath.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDImgOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgOptions, SOAP_TYPE_tt__OSDImgOptions, sizeof(tt__OSDImgOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDImgOptions * SOAP_FMAC2 soap_instantiate_tt__OSDImgOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDImgOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDImgOptions *p;
	size_t k = sizeof(tt__OSDImgOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDImgOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDImgOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDImgOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDImgOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDImgOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDImgOptions(soap, tag ? tag : "tt:OSDImgOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDImgOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDImgOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDImgOptions * SOAP_FMAC4 soap_get_tt__OSDImgOptions(struct soap *soap, tt__OSDImgOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDTextOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDTextOptionsExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDTextOptionsExtension::__anyAttribute);
}

void tt__OSDTextOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDTextOptionsExtension::__any);
#endif
}

int tt__OSDTextOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDTextOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextOptionsExtension(struct soap *soap, const char *tag, int id, const tt__OSDTextOptionsExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDTextOptionsExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__OSDTextOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDTextOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDTextOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDTextOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDTextOptionsExtension(struct soap *soap, const char *tag, tt__OSDTextOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDTextOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(tt__OSDTextOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDTextOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDTextOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDTextOptionsExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__OSDTextOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__OSDTextOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextOptionsExtension, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(tt__OSDTextOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDTextOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDTextOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDTextOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDTextOptionsExtension *p;
	size_t k = sizeof(tt__OSDTextOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDTextOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDTextOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDTextOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDTextOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDTextOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDTextOptionsExtension(soap, tag ? tag : "tt:OSDTextOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDTextOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDTextOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDTextOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDTextOptionsExtension(struct soap *soap, tt__OSDTextOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDTextOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__OSDTextOptions::Type);
	this->tt__OSDTextOptions::FontSizeRange = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__OSDTextOptions::DateFormat);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__OSDTextOptions::TimeFormat);
	this->tt__OSDTextOptions::FontColor = NULL;
	this->tt__OSDTextOptions::BackgroundColor = NULL;
	this->tt__OSDTextOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDTextOptions::__anyAttribute);
}

void tt__OSDTextOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__OSDTextOptions::Type);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__OSDTextOptions::FontSizeRange);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__OSDTextOptions::DateFormat);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__OSDTextOptions::TimeFormat);
	soap_serialize_PointerTott__OSDColorOptions(soap, &this->tt__OSDTextOptions::FontColor);
	soap_serialize_PointerTott__OSDColorOptions(soap, &this->tt__OSDTextOptions::BackgroundColor);
	soap_serialize_PointerTott__OSDTextOptionsExtension(soap, &this->tt__OSDTextOptions::Extension);
#endif
}

int tt__OSDTextOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDTextOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextOptions(struct soap *soap, const char *tag, int id, const tt__OSDTextOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDTextOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:Type", -1, &a->tt__OSDTextOptions::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:FontSizeRange", -1, &a->tt__OSDTextOptions::FontSizeRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:DateFormat", -1, &a->tt__OSDTextOptions::DateFormat, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:TimeFormat", -1, &a->tt__OSDTextOptions::TimeFormat, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColorOptions(soap, "tt:FontColor", -1, &a->tt__OSDTextOptions::FontColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColorOptions(soap, "tt:BackgroundColor", -1, &a->tt__OSDTextOptions::BackgroundColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextOptionsExtension(soap, "tt:Extension", -1, &a->tt__OSDTextOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDTextOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDTextOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDTextOptions * SOAP_FMAC4 soap_in_tt__OSDTextOptions(struct soap *soap, const char *tag, tt__OSDTextOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDTextOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextOptions, sizeof(tt__OSDTextOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDTextOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDTextOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDTextOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_FontSizeRange1 = 1;
	size_t soap_flag_FontColor1 = 1;
	size_t soap_flag_BackgroundColor1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:Type", &a->tt__OSDTextOptions::Type, "xsd:string"))
					continue;
			}
			if (soap_flag_FontSizeRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FontSizeRange", &a->tt__OSDTextOptions::FontSizeRange, "tt:IntRange"))
				{	soap_flag_FontSizeRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:DateFormat", &a->tt__OSDTextOptions::DateFormat, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:TimeFormat", &a->tt__OSDTextOptions::TimeFormat, "xsd:string"))
					continue;
			}
			if (soap_flag_FontColor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColorOptions(soap, "tt:FontColor", &a->tt__OSDTextOptions::FontColor, "tt:OSDColorOptions"))
				{	soap_flag_FontColor1--;
					continue;
				}
			}
			if (soap_flag_BackgroundColor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColorOptions(soap, "tt:BackgroundColor", &a->tt__OSDTextOptions::BackgroundColor, "tt:OSDColorOptions"))
				{	soap_flag_BackgroundColor1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextOptionsExtension(soap, "tt:Extension", &a->tt__OSDTextOptions::Extension, "tt:OSDTextOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__OSDTextOptions::Type.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDTextOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextOptions, SOAP_TYPE_tt__OSDTextOptions, sizeof(tt__OSDTextOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDTextOptions * SOAP_FMAC2 soap_instantiate_tt__OSDTextOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDTextOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDTextOptions *p;
	size_t k = sizeof(tt__OSDTextOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDTextOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDTextOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDTextOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDTextOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDTextOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDTextOptions(soap, tag ? tag : "tt:OSDTextOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDTextOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDTextOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDTextOptions * SOAP_FMAC4 soap_get_tt__OSDTextOptions(struct soap *soap, tt__OSDTextOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDColorOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDColorOptionsExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDColorOptionsExtension::__anyAttribute);
}

void tt__OSDColorOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDColorOptionsExtension::__any);
#endif
}

int tt__OSDColorOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDColorOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColorOptionsExtension(struct soap *soap, const char *tag, int id, const tt__OSDColorOptionsExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDColorOptionsExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColorOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__OSDColorOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDColorOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDColorOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDColorOptionsExtension(struct soap *soap, const char *tag, tt__OSDColorOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDColorOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(tt__OSDColorOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDColorOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDColorOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDColorOptionsExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__OSDColorOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__OSDColorOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColorOptionsExtension, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(tt__OSDColorOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDColorOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDColorOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDColorOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDColorOptionsExtension *p;
	size_t k = sizeof(tt__OSDColorOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDColorOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDColorOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDColorOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDColorOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDColorOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDColorOptionsExtension(soap, tag ? tag : "tt:OSDColorOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDColorOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDColorOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDColorOptionsExtension(struct soap *soap, tt__OSDColorOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColorOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDColorOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__OSDColorOptions::Color = NULL;
	this->tt__OSDColorOptions::Transparent = NULL;
	this->tt__OSDColorOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDColorOptions::__anyAttribute);
}

void tt__OSDColorOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ColorOptions(soap, &this->tt__OSDColorOptions::Color);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__OSDColorOptions::Transparent);
	soap_serialize_PointerTott__OSDColorOptionsExtension(soap, &this->tt__OSDColorOptions::Extension);
#endif
}

int tt__OSDColorOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDColorOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColorOptions(struct soap *soap, const char *tag, int id, const tt__OSDColorOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDColorOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColorOptions), type))
		return soap->error;
	if (soap_out_PointerTott__ColorOptions(soap, "tt:Color", -1, &a->tt__OSDColorOptions::Color, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:Transparent", -1, &a->tt__OSDColorOptions::Transparent, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColorOptionsExtension(soap, "tt:Extension", -1, &a->tt__OSDColorOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDColorOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDColorOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDColorOptions * SOAP_FMAC4 soap_in_tt__OSDColorOptions(struct soap *soap, const char *tag, tt__OSDColorOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDColorOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColorOptions, sizeof(tt__OSDColorOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDColorOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDColorOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDColorOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Color1 = 1;
	size_t soap_flag_Transparent1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorOptions(soap, "tt:Color", &a->tt__OSDColorOptions::Color, "tt:ColorOptions"))
				{	soap_flag_Color1--;
					continue;
				}
			}
			if (soap_flag_Transparent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:Transparent", &a->tt__OSDColorOptions::Transparent, "tt:IntRange"))
				{	soap_flag_Transparent1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColorOptionsExtension(soap, "tt:Extension", &a->tt__OSDColorOptions::Extension, "tt:OSDColorOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__OSDColorOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColorOptions, SOAP_TYPE_tt__OSDColorOptions, sizeof(tt__OSDColorOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDColorOptions * SOAP_FMAC2 soap_instantiate_tt__OSDColorOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDColorOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDColorOptions *p;
	size_t k = sizeof(tt__OSDColorOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDColorOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDColorOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDColorOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDColorOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDColorOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDColorOptions(soap, tag ? tag : "tt:OSDColorOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDColorOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDColorOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDColorOptions * SOAP_FMAC4 soap_get_tt__OSDColorOptions(struct soap *soap, tt__OSDColorOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ColorOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ColorOptions::__union_ColorOptions = 0;
	soap_default_xsd__anyAttribute(soap, &this->tt__ColorOptions::__anyAttribute);
}

void tt__ColorOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_ColorOptions(soap, this->tt__ColorOptions::__union_ColorOptions, &this->tt__ColorOptions::union_ColorOptions);
#endif
}

int tt__ColorOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ColorOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorOptions(struct soap *soap, const char *tag, int id, const tt__ColorOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ColorOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorOptions), type))
		return soap->error;
	if (soap_out__tt__union_ColorOptions(soap, a->tt__ColorOptions::__union_ColorOptions, &a->tt__ColorOptions::union_ColorOptions))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ColorOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ColorOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ColorOptions * SOAP_FMAC4 soap_in_tt__ColorOptions(struct soap *soap, const char *tag, tt__ColorOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ColorOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorOptions, sizeof(tt__ColorOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ColorOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ColorOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ColorOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_union_ColorOptions1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_ColorOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__tt__union_ColorOptions(soap, &a->tt__ColorOptions::__union_ColorOptions, &a->tt__ColorOptions::union_ColorOptions))
				{	soap_flag_union_ColorOptions1 = 0;
					continue;
				}
		}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ColorOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorOptions, SOAP_TYPE_tt__ColorOptions, sizeof(tt__ColorOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ColorOptions * SOAP_FMAC2 soap_instantiate_tt__ColorOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ColorOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ColorOptions *p;
	size_t k = sizeof(tt__ColorOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ColorOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ColorOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ColorOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ColorOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ColorOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ColorOptions(soap, tag ? tag : "tt:ColorOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ColorOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ColorOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ColorOptions * SOAP_FMAC4 soap_get_tt__ColorOptions(struct soap *soap, tt__ColorOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ColorspaceRange::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ColorspaceRange::X = NULL;
	this->tt__ColorspaceRange::Y = NULL;
	this->tt__ColorspaceRange::Z = NULL;
	soap_default_xsd__anyURI(soap, &this->tt__ColorspaceRange::Colorspace);
	soap_default_xsd__anyAttribute(soap, &this->tt__ColorspaceRange::__anyAttribute);
}

void tt__ColorspaceRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ColorspaceRange::X);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ColorspaceRange::Y);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ColorspaceRange::Z);
	soap_embedded(soap, &this->tt__ColorspaceRange::Colorspace, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ColorspaceRange::Colorspace);
#endif
}

int tt__ColorspaceRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ColorspaceRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorspaceRange(struct soap *soap, const char *tag, int id, const tt__ColorspaceRange *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ColorspaceRange*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorspaceRange), type))
		return soap->error;
	if (!a->tt__ColorspaceRange::X)
	{	if (soap_element_empty(soap, "tt:X"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:X", -1, &a->tt__ColorspaceRange::X, ""))
		return soap->error;
	if (!a->tt__ColorspaceRange::Y)
	{	if (soap_element_empty(soap, "tt:Y"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Y", -1, &a->tt__ColorspaceRange::Y, ""))
		return soap->error;
	if (!a->tt__ColorspaceRange::Z)
	{	if (soap_element_empty(soap, "tt:Z"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Z", -1, &a->tt__ColorspaceRange::Z, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:Colorspace", -1, &a->tt__ColorspaceRange::Colorspace, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ColorspaceRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ColorspaceRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__ColorspaceRange * SOAP_FMAC4 soap_in_tt__ColorspaceRange(struct soap *soap, const char *tag, tt__ColorspaceRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ColorspaceRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorspaceRange, sizeof(tt__ColorspaceRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ColorspaceRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ColorspaceRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ColorspaceRange*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_X1 = 1;
	size_t soap_flag_Y1 = 1;
	size_t soap_flag_Z1 = 1;
	size_t soap_flag_Colorspace1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:X", &a->tt__ColorspaceRange::X, "tt:FloatRange"))
				{	soap_flag_X1--;
					continue;
				}
			}
			if (soap_flag_Y1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Y", &a->tt__ColorspaceRange::Y, "tt:FloatRange"))
				{	soap_flag_Y1--;
					continue;
				}
			}
			if (soap_flag_Z1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Z", &a->tt__ColorspaceRange::Z, "tt:FloatRange"))
				{	soap_flag_Z1--;
					continue;
				}
			}
			if (soap_flag_Colorspace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Colorspace", &a->tt__ColorspaceRange::Colorspace, "xsd:anyURI"))
				{	soap_flag_Colorspace1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__ColorspaceRange::X || !a->tt__ColorspaceRange::Y || !a->tt__ColorspaceRange::Z || soap_flag_Colorspace1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ColorspaceRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorspaceRange, SOAP_TYPE_tt__ColorspaceRange, sizeof(tt__ColorspaceRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ColorspaceRange * SOAP_FMAC2 soap_instantiate_tt__ColorspaceRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ColorspaceRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ColorspaceRange *p;
	size_t k = sizeof(tt__ColorspaceRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ColorspaceRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ColorspaceRange);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ColorspaceRange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ColorspaceRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ColorspaceRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ColorspaceRange(soap, tag ? tag : "tt:ColorspaceRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ColorspaceRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ColorspaceRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__ColorspaceRange * SOAP_FMAC4 soap_get_tt__ColorspaceRange(struct soap *soap, tt__ColorspaceRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorspaceRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDImgConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDImgConfigurationExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDImgConfigurationExtension::__anyAttribute);
}

void tt__OSDImgConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDImgConfigurationExtension::__any);
#endif
}

int tt__OSDImgConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDImgConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__OSDImgConfigurationExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDImgConfigurationExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__OSDImgConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDImgConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDImgConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDImgConfigurationExtension(struct soap *soap, const char *tag, tt__OSDImgConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDImgConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(tt__OSDImgConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDImgConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDImgConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDImgConfigurationExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__OSDImgConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__OSDImgConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgConfigurationExtension, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(tt__OSDImgConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDImgConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDImgConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDImgConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDImgConfigurationExtension *p;
	size_t k = sizeof(tt__OSDImgConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDImgConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDImgConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDImgConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDImgConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDImgConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDImgConfigurationExtension(soap, tag ? tag : "tt:OSDImgConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDImgConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDImgConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDImgConfigurationExtension(struct soap *soap, tt__OSDImgConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDImgConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__OSDImgConfiguration::ImgPath);
	this->tt__OSDImgConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDImgConfiguration::__anyAttribute);
}

void tt__OSDImgConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__OSDImgConfiguration::ImgPath, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__OSDImgConfiguration::ImgPath);
	soap_serialize_PointerTott__OSDImgConfigurationExtension(soap, &this->tt__OSDImgConfiguration::Extension);
#endif
}

int tt__OSDImgConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDImgConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgConfiguration(struct soap *soap, const char *tag, int id, const tt__OSDImgConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDImgConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgConfiguration), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:ImgPath", -1, &a->tt__OSDImgConfiguration::ImgPath, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgConfigurationExtension(soap, "tt:Extension", -1, &a->tt__OSDImgConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDImgConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDImgConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDImgConfiguration * SOAP_FMAC4 soap_in_tt__OSDImgConfiguration(struct soap *soap, const char *tag, tt__OSDImgConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDImgConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(tt__OSDImgConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDImgConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDImgConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDImgConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ImgPath1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImgPath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:ImgPath", &a->tt__OSDImgConfiguration::ImgPath, "xsd:anyURI"))
				{	soap_flag_ImgPath1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgConfigurationExtension(soap, "tt:Extension", &a->tt__OSDImgConfiguration::Extension, "tt:OSDImgConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ImgPath1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDImgConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgConfiguration, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(tt__OSDImgConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDImgConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDImgConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDImgConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDImgConfiguration *p;
	size_t k = sizeof(tt__OSDImgConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDImgConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDImgConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDImgConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDImgConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDImgConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDImgConfiguration(soap, tag ? tag : "tt:OSDImgConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDImgConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDImgConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDImgConfiguration * SOAP_FMAC4 soap_get_tt__OSDImgConfiguration(struct soap *soap, tt__OSDImgConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDTextConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDTextConfigurationExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDTextConfigurationExtension::__anyAttribute);
}

void tt__OSDTextConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDTextConfigurationExtension::__any);
#endif
}

int tt__OSDTextConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDTextConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__OSDTextConfigurationExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDTextConfigurationExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__OSDTextConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDTextConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDTextConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDTextConfigurationExtension(struct soap *soap, const char *tag, tt__OSDTextConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDTextConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(tt__OSDTextConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDTextConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDTextConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDTextConfigurationExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__OSDTextConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__OSDTextConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextConfigurationExtension, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(tt__OSDTextConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDTextConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDTextConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDTextConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDTextConfigurationExtension *p;
	size_t k = sizeof(tt__OSDTextConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDTextConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDTextConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDTextConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDTextConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDTextConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDTextConfigurationExtension(soap, tag ? tag : "tt:OSDTextConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDTextConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDTextConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDTextConfigurationExtension(struct soap *soap, tt__OSDTextConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDTextConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__OSDTextConfiguration::Type);
	this->tt__OSDTextConfiguration::DateFormat = NULL;
	this->tt__OSDTextConfiguration::TimeFormat = NULL;
	this->tt__OSDTextConfiguration::FontSize = NULL;
	this->tt__OSDTextConfiguration::FontColor = NULL;
	this->tt__OSDTextConfiguration::BackgroundColor = NULL;
	this->tt__OSDTextConfiguration::PlainText = NULL;
	this->tt__OSDTextConfiguration::Extension = NULL;
	this->tt__OSDTextConfiguration::IsPersistentText = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDTextConfiguration::__anyAttribute);
}

void tt__OSDTextConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__OSDTextConfiguration::Type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__OSDTextConfiguration::Type);
	soap_serialize_PointerTostd__string(soap, &this->tt__OSDTextConfiguration::DateFormat);
	soap_serialize_PointerTostd__string(soap, &this->tt__OSDTextConfiguration::TimeFormat);
	soap_serialize_PointerToint(soap, &this->tt__OSDTextConfiguration::FontSize);
	soap_serialize_PointerTott__OSDColor(soap, &this->tt__OSDTextConfiguration::FontColor);
	soap_serialize_PointerTott__OSDColor(soap, &this->tt__OSDTextConfiguration::BackgroundColor);
	soap_serialize_PointerTostd__string(soap, &this->tt__OSDTextConfiguration::PlainText);
	soap_serialize_PointerTott__OSDTextConfigurationExtension(soap, &this->tt__OSDTextConfiguration::Extension);
#endif
}

int tt__OSDTextConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDTextConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextConfiguration(struct soap *soap, const char *tag, int id, const tt__OSDTextConfiguration *a, const char *type)
{
	if (((tt__OSDTextConfiguration*)a)->IsPersistentText)
	{	soap_set_attr(soap, "IsPersistentText", soap_bool2s(soap, *((tt__OSDTextConfiguration*)a)->IsPersistentText), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDTextConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextConfiguration), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Type", -1, &a->tt__OSDTextConfiguration::Type, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:DateFormat", -1, &a->tt__OSDTextConfiguration::DateFormat, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:TimeFormat", -1, &a->tt__OSDTextConfiguration::TimeFormat, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:FontSize", -1, &a->tt__OSDTextConfiguration::FontSize, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColor(soap, "tt:FontColor", -1, &a->tt__OSDTextConfiguration::FontColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColor(soap, "tt:BackgroundColor", -1, &a->tt__OSDTextConfiguration::BackgroundColor, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:PlainText", -1, &a->tt__OSDTextConfiguration::PlainText, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextConfigurationExtension(soap, "tt:Extension", -1, &a->tt__OSDTextConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDTextConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDTextConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDTextConfiguration * SOAP_FMAC4 soap_in_tt__OSDTextConfiguration(struct soap *soap, const char *tag, tt__OSDTextConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDTextConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(tt__OSDTextConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDTextConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDTextConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "IsPersistentText", 5, 0);
		if (t)
		{
			if (!(((tt__OSDTextConfiguration*)a)->IsPersistentText = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__OSDTextConfiguration*)a)->IsPersistentText))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDTextConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_DateFormat1 = 1;
	size_t soap_flag_TimeFormat1 = 1;
	size_t soap_flag_FontSize1 = 1;
	size_t soap_flag_FontColor1 = 1;
	size_t soap_flag_BackgroundColor1 = 1;
	size_t soap_flag_PlainText1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Type", &a->tt__OSDTextConfiguration::Type, "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_DateFormat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:DateFormat", &a->tt__OSDTextConfiguration::DateFormat, "xsd:string"))
				{	soap_flag_DateFormat1--;
					continue;
				}
			}
			if (soap_flag_TimeFormat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:TimeFormat", &a->tt__OSDTextConfiguration::TimeFormat, "xsd:string"))
				{	soap_flag_TimeFormat1--;
					continue;
				}
			}
			if (soap_flag_FontSize1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:FontSize", &a->tt__OSDTextConfiguration::FontSize, "xsd:int"))
				{	soap_flag_FontSize1--;
					continue;
				}
			}
			if (soap_flag_FontColor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColor(soap, "tt:FontColor", &a->tt__OSDTextConfiguration::FontColor, "tt:OSDColor"))
				{	soap_flag_FontColor1--;
					continue;
				}
			}
			if (soap_flag_BackgroundColor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColor(soap, "tt:BackgroundColor", &a->tt__OSDTextConfiguration::BackgroundColor, "tt:OSDColor"))
				{	soap_flag_BackgroundColor1--;
					continue;
				}
			}
			if (soap_flag_PlainText1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:PlainText", &a->tt__OSDTextConfiguration::PlainText, "xsd:string"))
				{	soap_flag_PlainText1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextConfigurationExtension(soap, "tt:Extension", &a->tt__OSDTextConfiguration::Extension, "tt:OSDTextConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDTextConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextConfiguration, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(tt__OSDTextConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDTextConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDTextConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDTextConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDTextConfiguration *p;
	size_t k = sizeof(tt__OSDTextConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDTextConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDTextConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDTextConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDTextConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDTextConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDTextConfiguration(soap, tag ? tag : "tt:OSDTextConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDTextConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDTextConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDTextConfiguration * SOAP_FMAC4 soap_get_tt__OSDTextConfiguration(struct soap *soap, tt__OSDTextConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDColor::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__OSDColor::Color = NULL;
	this->tt__OSDColor::Transparent = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDColor::__anyAttribute);
}

void tt__OSDColor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Color(soap, &this->tt__OSDColor::Color);
#endif
}

int tt__OSDColor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDColor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColor(struct soap *soap, const char *tag, int id, const tt__OSDColor *a, const char *type)
{
	if (((tt__OSDColor*)a)->Transparent)
	{	soap_set_attr(soap, "Transparent", soap_int2s(soap, *((tt__OSDColor*)a)->Transparent), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDColor*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColor), type))
		return soap->error;
	if (!a->tt__OSDColor::Color)
	{	if (soap_element_empty(soap, "tt:Color"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Color(soap, "tt:Color", -1, &a->tt__OSDColor::Color, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDColor::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDColor(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDColor * SOAP_FMAC4 soap_in_tt__OSDColor(struct soap *soap, const char *tag, tt__OSDColor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDColor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColor, sizeof(tt__OSDColor), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDColor)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDColor *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "Transparent", 5, 0);
		if (t)
		{
			if (!(((tt__OSDColor*)a)->Transparent = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__OSDColor*)a)->Transparent))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDColor*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Color1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Color(soap, "tt:Color", &a->tt__OSDColor::Color, "tt:Color"))
				{	soap_flag_Color1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__OSDColor::Color))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDColor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColor, SOAP_TYPE_tt__OSDColor, sizeof(tt__OSDColor), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDColor * SOAP_FMAC2 soap_instantiate_tt__OSDColor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDColor(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDColor *p;
	size_t k = sizeof(tt__OSDColor);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDColor, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDColor);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDColor, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDColor location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDColor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDColor(soap, tag ? tag : "tt:OSDColor", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDColor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDColor(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDColor * SOAP_FMAC4 soap_get_tt__OSDColor(struct soap *soap, tt__OSDColor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDPosConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDPosConfigurationExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDPosConfigurationExtension::__anyAttribute);
}

void tt__OSDPosConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__OSDPosConfigurationExtension::__any);
#endif
}

int tt__OSDPosConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDPosConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDPosConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__OSDPosConfigurationExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDPosConfigurationExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDPosConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__OSDPosConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDPosConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDPosConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDPosConfigurationExtension(struct soap *soap, const char *tag, tt__OSDPosConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDPosConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(tt__OSDPosConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDPosConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDPosConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDPosConfigurationExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__OSDPosConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__OSDPosConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDPosConfigurationExtension, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(tt__OSDPosConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDPosConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDPosConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDPosConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDPosConfigurationExtension *p;
	size_t k = sizeof(tt__OSDPosConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDPosConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDPosConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDPosConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDPosConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDPosConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDPosConfigurationExtension(soap, tag ? tag : "tt:OSDPosConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDPosConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDPosConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDPosConfigurationExtension(struct soap *soap, tt__OSDPosConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDPosConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDPosConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__OSDPosConfiguration::Type);
	this->tt__OSDPosConfiguration::Pos = NULL;
	this->tt__OSDPosConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDPosConfiguration::__anyAttribute);
}

void tt__OSDPosConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__OSDPosConfiguration::Type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__OSDPosConfiguration::Type);
	soap_serialize_PointerTott__Vector(soap, &this->tt__OSDPosConfiguration::Pos);
	soap_serialize_PointerTott__OSDPosConfigurationExtension(soap, &this->tt__OSDPosConfiguration::Extension);
#endif
}

int tt__OSDPosConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDPosConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDPosConfiguration(struct soap *soap, const char *tag, int id, const tt__OSDPosConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDPosConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDPosConfiguration), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Type", -1, &a->tt__OSDPosConfiguration::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Pos", -1, &a->tt__OSDPosConfiguration::Pos, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDPosConfigurationExtension(soap, "tt:Extension", -1, &a->tt__OSDPosConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDPosConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDPosConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDPosConfiguration * SOAP_FMAC4 soap_in_tt__OSDPosConfiguration(struct soap *soap, const char *tag, tt__OSDPosConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDPosConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(tt__OSDPosConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDPosConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDPosConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDPosConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Pos1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Type", &a->tt__OSDPosConfiguration::Type, "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Pos1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector(soap, "tt:Pos", &a->tt__OSDPosConfiguration::Pos, "tt:Vector"))
				{	soap_flag_Pos1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDPosConfigurationExtension(soap, "tt:Extension", &a->tt__OSDPosConfiguration::Extension, "tt:OSDPosConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDPosConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDPosConfiguration, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(tt__OSDPosConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDPosConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDPosConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDPosConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDPosConfiguration *p;
	size_t k = sizeof(tt__OSDPosConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDPosConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDPosConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDPosConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDPosConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDPosConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDPosConfiguration(soap, tag ? tag : "tt:OSDPosConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDPosConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDPosConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDPosConfiguration * SOAP_FMAC4 soap_get_tt__OSDPosConfiguration(struct soap *soap, tt__OSDPosConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDPosConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDReference::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &this->tt__OSDReference::__item);
	soap_default_xsd__anyAttribute(soap, &this->tt__OSDReference::__anyAttribute);
}

void tt__OSDReference::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__OSDReference::__item, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__OSDReference::__item);
#endif
}

int tt__OSDReference::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDReference(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDReference(struct soap *soap, const char *tag, int id, const tt__OSDReference *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__OSDReference*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ReferenceToken(soap, tag, id, &a->tt__OSDReference::__item, "");
}

void *tt__OSDReference::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDReference(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDReference * SOAP_FMAC4 soap_in_tt__OSDReference(struct soap *soap, const char *tag, tt__OSDReference *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__OSDReference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDReference, sizeof(tt__OSDReference), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDReference)
		return (tt__OSDReference *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__OSDReference*)a)->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_tt__ReferenceToken(soap, tag, &a->tt__OSDReference::__item, "tt:OSDReference"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__OSDReference * SOAP_FMAC2 soap_instantiate_tt__OSDReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDReference *p;
	size_t k = sizeof(tt__OSDReference);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDReference);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDReference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDReference location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDReference::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDReference(soap, tag ? tag : "tt:OSDReference", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDReference::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDReference(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDReference * SOAP_FMAC4 soap_get_tt__OSDReference(struct soap *soap, tt__OSDReference *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ProfileStatusExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ProfileStatusExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ProfileStatusExtension::__anyAttribute);
}

void tt__ProfileStatusExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ProfileStatusExtension::__any);
#endif
}

int tt__ProfileStatusExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileStatusExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileStatusExtension(struct soap *soap, const char *tag, int id, const tt__ProfileStatusExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ProfileStatusExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileStatusExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ProfileStatusExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ProfileStatusExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ProfileStatusExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileStatusExtension * SOAP_FMAC4 soap_in_tt__ProfileStatusExtension(struct soap *soap, const char *tag, tt__ProfileStatusExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ProfileStatusExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(tt__ProfileStatusExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ProfileStatusExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ProfileStatusExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ProfileStatusExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ProfileStatusExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ProfileStatusExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileStatusExtension, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(tt__ProfileStatusExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ProfileStatusExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileStatusExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileStatusExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ProfileStatusExtension *p;
	size_t k = sizeof(tt__ProfileStatusExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ProfileStatusExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ProfileStatusExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ProfileStatusExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ProfileStatusExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ProfileStatusExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ProfileStatusExtension(soap, tag ? tag : "tt:ProfileStatusExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileStatusExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileStatusExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileStatusExtension * SOAP_FMAC4 soap_get_tt__ProfileStatusExtension(struct soap *soap, tt__ProfileStatusExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ProfileStatus::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__ActiveConnection(soap, &this->tt__ProfileStatus::ActiveConnections);
	this->tt__ProfileStatus::Extension = NULL;
}

void tt__ProfileStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__ActiveConnection(soap, &this->tt__ProfileStatus::ActiveConnections);
	soap_serialize_PointerTott__ProfileStatusExtension(soap, &this->tt__ProfileStatus::Extension);
#endif
}

int tt__ProfileStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileStatus(struct soap *soap, const char *tag, int id, const tt__ProfileStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileStatus), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__ActiveConnection(soap, "tt:ActiveConnections", -1, &a->tt__ProfileStatus::ActiveConnections, ""))
		return soap->error;
	if (soap_out_PointerTott__ProfileStatusExtension(soap, "tt:Extension", -1, &a->tt__ProfileStatus::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ProfileStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ProfileStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileStatus * SOAP_FMAC4 soap_in_tt__ProfileStatus(struct soap *soap, const char *tag, tt__ProfileStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ProfileStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileStatus, sizeof(tt__ProfileStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ProfileStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ProfileStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__ActiveConnection(soap, "tt:ActiveConnections", &a->tt__ProfileStatus::ActiveConnections, "tt:ActiveConnection"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ProfileStatusExtension(soap, "tt:Extension", &a->tt__ProfileStatus::Extension, "tt:ProfileStatusExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ProfileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileStatus, SOAP_TYPE_tt__ProfileStatus, sizeof(tt__ProfileStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ProfileStatus * SOAP_FMAC2 soap_instantiate_tt__ProfileStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ProfileStatus *p;
	size_t k = sizeof(tt__ProfileStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ProfileStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ProfileStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ProfileStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ProfileStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ProfileStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ProfileStatus(soap, tag ? tag : "tt:ProfileStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileStatus * SOAP_FMAC4 soap_get_tt__ProfileStatus(struct soap *soap, tt__ProfileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ActiveConnection::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__ActiveConnection::CurrentBitrate);
	soap_default_float(soap, &this->tt__ActiveConnection::CurrentFps);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ActiveConnection::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ActiveConnection::__anyAttribute);
}

void tt__ActiveConnection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ActiveConnection::CurrentBitrate, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__ActiveConnection::CurrentFps, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ActiveConnection::__any);
#endif
}

int tt__ActiveConnection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ActiveConnection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ActiveConnection(struct soap *soap, const char *tag, int id, const tt__ActiveConnection *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ActiveConnection*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ActiveConnection), type))
		return soap->error;
	if (soap_out_float(soap, "tt:CurrentBitrate", -1, &a->tt__ActiveConnection::CurrentBitrate, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CurrentFps", -1, &a->tt__ActiveConnection::CurrentFps, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ActiveConnection::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ActiveConnection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ActiveConnection(soap, tag, this, type);
}

SOAP_FMAC3 tt__ActiveConnection * SOAP_FMAC4 soap_in_tt__ActiveConnection(struct soap *soap, const char *tag, tt__ActiveConnection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ActiveConnection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActiveConnection, sizeof(tt__ActiveConnection), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ActiveConnection)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ActiveConnection *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ActiveConnection*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_CurrentBitrate1 = 1;
	size_t soap_flag_CurrentFps1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CurrentBitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:CurrentBitrate", &a->tt__ActiveConnection::CurrentBitrate, "xsd:float"))
				{	soap_flag_CurrentBitrate1--;
					continue;
				}
			}
			if (soap_flag_CurrentFps1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:CurrentFps", &a->tt__ActiveConnection::CurrentFps, "xsd:float"))
				{	soap_flag_CurrentFps1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ActiveConnection::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentBitrate1 > 0 || soap_flag_CurrentFps1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ActiveConnection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActiveConnection, SOAP_TYPE_tt__ActiveConnection, sizeof(tt__ActiveConnection), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ActiveConnection * SOAP_FMAC2 soap_instantiate_tt__ActiveConnection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ActiveConnection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ActiveConnection *p;
	size_t k = sizeof(tt__ActiveConnection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ActiveConnection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ActiveConnection);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ActiveConnection, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ActiveConnection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ActiveConnection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ActiveConnection(soap, tag ? tag : "tt:ActiveConnection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ActiveConnection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ActiveConnection(soap, this, tag, type);
}

SOAP_FMAC3 tt__ActiveConnection * SOAP_FMAC4 soap_get_tt__ActiveConnection(struct soap *soap, tt__ActiveConnection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ActiveConnection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioClassDescriptorExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioClassDescriptorExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioClassDescriptorExtension::__anyAttribute);
}

void tt__AudioClassDescriptorExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioClassDescriptorExtension::__any);
#endif
}

int tt__AudioClassDescriptorExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioClassDescriptorExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassDescriptorExtension(struct soap *soap, const char *tag, int id, const tt__AudioClassDescriptorExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioClassDescriptorExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassDescriptorExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioClassDescriptorExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioClassDescriptorExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioClassDescriptorExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioClassDescriptorExtension * SOAP_FMAC4 soap_in_tt__AudioClassDescriptorExtension(struct soap *soap, const char *tag, tt__AudioClassDescriptorExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioClassDescriptorExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(tt__AudioClassDescriptorExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioClassDescriptorExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioClassDescriptorExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioClassDescriptorExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioClassDescriptorExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioClassDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassDescriptorExtension, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(tt__AudioClassDescriptorExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioClassDescriptorExtension * SOAP_FMAC2 soap_instantiate_tt__AudioClassDescriptorExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioClassDescriptorExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioClassDescriptorExtension *p;
	size_t k = sizeof(tt__AudioClassDescriptorExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioClassDescriptorExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioClassDescriptorExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioClassDescriptorExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioClassDescriptorExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioClassDescriptorExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioClassDescriptorExtension(soap, tag ? tag : "tt:AudioClassDescriptorExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioClassDescriptorExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioClassDescriptorExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioClassDescriptorExtension * SOAP_FMAC4 soap_get_tt__AudioClassDescriptorExtension(struct soap *soap, tt__AudioClassDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioClassDescriptor::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__AudioClassCandidate(soap, &this->tt__AudioClassDescriptor::ClassCandidate);
	this->tt__AudioClassDescriptor::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioClassDescriptor::__anyAttribute);
}

void tt__AudioClassDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__AudioClassCandidate(soap, &this->tt__AudioClassDescriptor::ClassCandidate);
	soap_serialize_PointerTott__AudioClassDescriptorExtension(soap, &this->tt__AudioClassDescriptor::Extension);
#endif
}

int tt__AudioClassDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioClassDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassDescriptor(struct soap *soap, const char *tag, int id, const tt__AudioClassDescriptor *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioClassDescriptor*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassDescriptor), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__AudioClassCandidate(soap, "tt:ClassCandidate", -1, &a->tt__AudioClassDescriptor::ClassCandidate, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioClassDescriptorExtension(soap, "tt:Extension", -1, &a->tt__AudioClassDescriptor::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioClassDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioClassDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioClassDescriptor * SOAP_FMAC4 soap_in_tt__AudioClassDescriptor(struct soap *soap, const char *tag, tt__AudioClassDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioClassDescriptor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassDescriptor, sizeof(tt__AudioClassDescriptor), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioClassDescriptor)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioClassDescriptor *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioClassDescriptor*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__AudioClassCandidate(soap, "tt:ClassCandidate", &a->tt__AudioClassDescriptor::ClassCandidate, "tt:AudioClassCandidate"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioClassDescriptorExtension(soap, "tt:Extension", &a->tt__AudioClassDescriptor::Extension, "tt:AudioClassDescriptorExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioClassDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassDescriptor, SOAP_TYPE_tt__AudioClassDescriptor, sizeof(tt__AudioClassDescriptor), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioClassDescriptor * SOAP_FMAC2 soap_instantiate_tt__AudioClassDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioClassDescriptor(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioClassDescriptor *p;
	size_t k = sizeof(tt__AudioClassDescriptor);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioClassDescriptor, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioClassDescriptor);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioClassDescriptor, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioClassDescriptor location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioClassDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioClassDescriptor(soap, tag ? tag : "tt:AudioClassDescriptor", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioClassDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioClassDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioClassDescriptor * SOAP_FMAC4 soap_get_tt__AudioClassDescriptor(struct soap *soap, tt__AudioClassDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioClassCandidate::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__AudioClassType(soap, &this->tt__AudioClassCandidate::Type);
	soap_default_float(soap, &this->tt__AudioClassCandidate::Likelihood);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioClassCandidate::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioClassCandidate::__anyAttribute);
}

void tt__AudioClassCandidate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__AudioClassType(soap, &this->tt__AudioClassCandidate::Type);
	soap_embedded(soap, &this->tt__AudioClassCandidate::Likelihood, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioClassCandidate::__any);
#endif
}

int tt__AudioClassCandidate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioClassCandidate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassCandidate(struct soap *soap, const char *tag, int id, const tt__AudioClassCandidate *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioClassCandidate*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassCandidate), type))
		return soap->error;
	if (soap_out_tt__AudioClassType(soap, "tt:Type", -1, &a->tt__AudioClassCandidate::Type, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Likelihood", -1, &a->tt__AudioClassCandidate::Likelihood, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioClassCandidate::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioClassCandidate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioClassCandidate(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioClassCandidate * SOAP_FMAC4 soap_in_tt__AudioClassCandidate(struct soap *soap, const char *tag, tt__AudioClassCandidate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioClassCandidate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassCandidate, sizeof(tt__AudioClassCandidate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioClassCandidate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioClassCandidate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioClassCandidate*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Likelihood1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__AudioClassType(soap, "tt:Type", &a->tt__AudioClassCandidate::Type, "tt:AudioClassType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Likelihood1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Likelihood", &a->tt__AudioClassCandidate::Likelihood, "xsd:float"))
				{	soap_flag_Likelihood1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioClassCandidate::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0 || soap_flag_Likelihood1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioClassCandidate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassCandidate, SOAP_TYPE_tt__AudioClassCandidate, sizeof(tt__AudioClassCandidate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioClassCandidate * SOAP_FMAC2 soap_instantiate_tt__AudioClassCandidate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioClassCandidate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioClassCandidate *p;
	size_t k = sizeof(tt__AudioClassCandidate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioClassCandidate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioClassCandidate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioClassCandidate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioClassCandidate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioClassCandidate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioClassCandidate(soap, tag ? tag : "tt:AudioClassCandidate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioClassCandidate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioClassCandidate(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioClassCandidate * SOAP_FMAC4 soap_get_tt__AudioClassCandidate(struct soap *soap, tt__AudioClassCandidate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ActionEngineEventPayloadExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ActionEngineEventPayloadExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ActionEngineEventPayloadExtension::__anyAttribute);
}

void tt__ActionEngineEventPayloadExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ActionEngineEventPayloadExtension::__any);
#endif
}

int tt__ActionEngineEventPayloadExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ActionEngineEventPayloadExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, int id, const tt__ActionEngineEventPayloadExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ActionEngineEventPayloadExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ActionEngineEventPayloadExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ActionEngineEventPayloadExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ActionEngineEventPayloadExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ActionEngineEventPayloadExtension * SOAP_FMAC4 soap_in_tt__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, tt__ActionEngineEventPayloadExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ActionEngineEventPayloadExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(tt__ActionEngineEventPayloadExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ActionEngineEventPayloadExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ActionEngineEventPayloadExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ActionEngineEventPayloadExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ActionEngineEventPayloadExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ActionEngineEventPayloadExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(tt__ActionEngineEventPayloadExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ActionEngineEventPayloadExtension * SOAP_FMAC2 soap_instantiate_tt__ActionEngineEventPayloadExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ActionEngineEventPayloadExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ActionEngineEventPayloadExtension *p;
	size_t k = sizeof(tt__ActionEngineEventPayloadExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ActionEngineEventPayloadExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ActionEngineEventPayloadExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ActionEngineEventPayloadExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ActionEngineEventPayloadExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ActionEngineEventPayloadExtension(soap, tag ? tag : "tt:ActionEngineEventPayloadExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ActionEngineEventPayloadExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ActionEngineEventPayloadExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ActionEngineEventPayloadExtension * SOAP_FMAC4 soap_get_tt__ActionEngineEventPayloadExtension(struct soap *soap, tt__ActionEngineEventPayloadExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ActionEngineEventPayloadExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ActionEngineEventPayload::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ActionEngineEventPayload::RequestInfo = NULL;
	this->tt__ActionEngineEventPayload::ResponseInfo = NULL;
	this->tt__ActionEngineEventPayload::Fault = NULL;
	this->tt__ActionEngineEventPayload::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ActionEngineEventPayload::__anyAttribute);
}

void tt__ActionEngineEventPayload::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSOAP_ENV__Envelope(soap, &this->tt__ActionEngineEventPayload::RequestInfo);
	soap_serialize_PointerToSOAP_ENV__Envelope(soap, &this->tt__ActionEngineEventPayload::ResponseInfo);
	soap_serialize_PointerToSOAP_ENV__Fault(soap, &this->tt__ActionEngineEventPayload::Fault);
	soap_serialize_PointerTott__ActionEngineEventPayloadExtension(soap, &this->tt__ActionEngineEventPayload::Extension);
#endif
}

int tt__ActionEngineEventPayload::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ActionEngineEventPayload(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ActionEngineEventPayload(struct soap *soap, const char *tag, int id, const tt__ActionEngineEventPayload *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ActionEngineEventPayload*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ActionEngineEventPayload), type))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, "tt:RequestInfo", -1, &a->tt__ActionEngineEventPayload::RequestInfo, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, "tt:ResponseInfo", -1, &a->tt__ActionEngineEventPayload::ResponseInfo, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Fault(soap, "tt:Fault", -1, &a->tt__ActionEngineEventPayload::Fault, ""))
		return soap->error;
	if (soap_out_PointerTott__ActionEngineEventPayloadExtension(soap, "tt:Extension", -1, &a->tt__ActionEngineEventPayload::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ActionEngineEventPayload::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ActionEngineEventPayload(soap, tag, this, type);
}

SOAP_FMAC3 tt__ActionEngineEventPayload * SOAP_FMAC4 soap_in_tt__ActionEngineEventPayload(struct soap *soap, const char *tag, tt__ActionEngineEventPayload *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ActionEngineEventPayload*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActionEngineEventPayload, sizeof(tt__ActionEngineEventPayload), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ActionEngineEventPayload)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ActionEngineEventPayload *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ActionEngineEventPayload*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RequestInfo1 = 1;
	size_t soap_flag_ResponseInfo1 = 1;
	size_t soap_flag_Fault1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RequestInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToSOAP_ENV__Envelope(soap, "tt:RequestInfo", &a->tt__ActionEngineEventPayload::RequestInfo, ""))
				{	soap_flag_RequestInfo1--;
					continue;
				}
			}
			if (soap_flag_ResponseInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToSOAP_ENV__Envelope(soap, "tt:ResponseInfo", &a->tt__ActionEngineEventPayload::ResponseInfo, ""))
				{	soap_flag_ResponseInfo1--;
					continue;
				}
			}
			if (soap_flag_Fault1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Fault(soap, "tt:Fault", &a->tt__ActionEngineEventPayload::Fault, ""))
				{	soap_flag_Fault1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ActionEngineEventPayloadExtension(soap, "tt:Extension", &a->tt__ActionEngineEventPayload::Extension, "tt:ActionEngineEventPayloadExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ActionEngineEventPayload *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActionEngineEventPayload, SOAP_TYPE_tt__ActionEngineEventPayload, sizeof(tt__ActionEngineEventPayload), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ActionEngineEventPayload * SOAP_FMAC2 soap_instantiate_tt__ActionEngineEventPayload(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ActionEngineEventPayload(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ActionEngineEventPayload *p;
	size_t k = sizeof(tt__ActionEngineEventPayload);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ActionEngineEventPayload, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ActionEngineEventPayload);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ActionEngineEventPayload, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ActionEngineEventPayload location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ActionEngineEventPayload::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ActionEngineEventPayload(soap, tag ? tag : "tt:ActionEngineEventPayload", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ActionEngineEventPayload::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ActionEngineEventPayload(soap, this, tag, type);
}

SOAP_FMAC3 tt__ActionEngineEventPayload * SOAP_FMAC4 soap_get_tt__ActionEngineEventPayload(struct soap *soap, tt__ActionEngineEventPayload *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ActionEngineEventPayload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsState::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__AnalyticsState::Error = NULL;
	soap_default_std__string(soap, &this->tt__AnalyticsState::State);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsState::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AnalyticsState::__anyAttribute);
}

void tt__AnalyticsState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->tt__AnalyticsState::Error);
	soap_embedded(soap, &this->tt__AnalyticsState::State, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__AnalyticsState::State);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsState::__any);
#endif
}

int tt__AnalyticsState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsState(struct soap *soap, const char *tag, int id, const tt__AnalyticsState *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnalyticsState*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsState), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Error", -1, &a->tt__AnalyticsState::Error, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:State", -1, &a->tt__AnalyticsState::State, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AnalyticsState::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsState::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsState(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsState * SOAP_FMAC4 soap_in_tt__AnalyticsState(struct soap *soap, const char *tag, tt__AnalyticsState *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsState, sizeof(tt__AnalyticsState), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsState)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsState *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnalyticsState*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Error1 = 1;
	size_t soap_flag_State1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Error", &a->tt__AnalyticsState::Error, "xsd:string"))
				{	soap_flag_Error1--;
					continue;
				}
			}
			if (soap_flag_State1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:State", &a->tt__AnalyticsState::State, "xsd:string"))
				{	soap_flag_State1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AnalyticsState::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AnalyticsState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsState, SOAP_TYPE_tt__AnalyticsState, sizeof(tt__AnalyticsState), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsState * SOAP_FMAC2 soap_instantiate_tt__AnalyticsState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsState *p;
	size_t k = sizeof(tt__AnalyticsState);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsState, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsState);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsState, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsState location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsState(soap, tag ? tag : "tt:AnalyticsState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsState(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsState * SOAP_FMAC4 soap_get_tt__AnalyticsState(struct soap *soap, tt__AnalyticsState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsStateInformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &this->tt__AnalyticsStateInformation::AnalyticsEngineControlToken);
	this->tt__AnalyticsStateInformation::State = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsStateInformation::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AnalyticsStateInformation::__anyAttribute);
}

void tt__AnalyticsStateInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AnalyticsStateInformation::AnalyticsEngineControlToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__AnalyticsStateInformation::AnalyticsEngineControlToken);
	soap_serialize_PointerTott__AnalyticsState(soap, &this->tt__AnalyticsStateInformation::State);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsStateInformation::__any);
#endif
}

int tt__AnalyticsStateInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsStateInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsStateInformation(struct soap *soap, const char *tag, int id, const tt__AnalyticsStateInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnalyticsStateInformation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsStateInformation), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:AnalyticsEngineControlToken", -1, &a->tt__AnalyticsStateInformation::AnalyticsEngineControlToken, ""))
		return soap->error;
	if (!a->tt__AnalyticsStateInformation::State)
	{	if (soap_element_empty(soap, "tt:State"))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsState(soap, "tt:State", -1, &a->tt__AnalyticsStateInformation::State, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AnalyticsStateInformation::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsStateInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsStateInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsStateInformation * SOAP_FMAC4 soap_in_tt__AnalyticsStateInformation(struct soap *soap, const char *tag, tt__AnalyticsStateInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsStateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(tt__AnalyticsStateInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsStateInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsStateInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnalyticsStateInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_AnalyticsEngineControlToken1 = 1;
	size_t soap_flag_State1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnalyticsEngineControlToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:AnalyticsEngineControlToken", &a->tt__AnalyticsStateInformation::AnalyticsEngineControlToken, "tt:ReferenceToken"))
				{	soap_flag_AnalyticsEngineControlToken1--;
					continue;
				}
			}
			if (soap_flag_State1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsState(soap, "tt:State", &a->tt__AnalyticsStateInformation::State, "tt:AnalyticsState"))
				{	soap_flag_State1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AnalyticsStateInformation::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AnalyticsEngineControlToken1 > 0 || !a->tt__AnalyticsStateInformation::State))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AnalyticsStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsStateInformation, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(tt__AnalyticsStateInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsStateInformation * SOAP_FMAC2 soap_instantiate_tt__AnalyticsStateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsStateInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsStateInformation *p;
	size_t k = sizeof(tt__AnalyticsStateInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsStateInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsStateInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsStateInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsStateInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsStateInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsStateInformation(soap, tag ? tag : "tt:AnalyticsStateInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsStateInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsStateInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsStateInformation * SOAP_FMAC4 soap_get_tt__AnalyticsStateInformation(struct soap *soap, tt__AnalyticsStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsEngineControl::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__AnalyticsEngineControl::EngineToken);
	soap_default_tt__ReferenceToken(soap, &this->tt__AnalyticsEngineControl::EngineConfigToken);
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AnalyticsEngineControl::InputToken);
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AnalyticsEngineControl::ReceiverToken);
	this->tt__AnalyticsEngineControl::Multicast = NULL;
	this->tt__AnalyticsEngineControl::Subscription = NULL;
	soap_default_tt__ModeOfOperation(soap, &this->tt__AnalyticsEngineControl::Mode);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsEngineControl::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AnalyticsEngineControl::__anyAttribute);
}

void tt__AnalyticsEngineControl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AnalyticsEngineControl::EngineToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__AnalyticsEngineControl::EngineToken);
	soap_embedded(soap, &this->tt__AnalyticsEngineControl::EngineConfigToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__AnalyticsEngineControl::EngineConfigToken);
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AnalyticsEngineControl::InputToken);
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AnalyticsEngineControl::ReceiverToken);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__AnalyticsEngineControl::Multicast);
	soap_serialize_PointerTott__Config(soap, &this->tt__AnalyticsEngineControl::Subscription);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsEngineControl::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AnalyticsEngineControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngineControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineControl(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngineControl *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnalyticsEngineControl*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineControl), type ? type : "tt:AnalyticsEngineControl"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:EngineToken", -1, &a->tt__AnalyticsEngineControl::EngineToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:EngineConfigToken", -1, &a->tt__AnalyticsEngineControl::EngineConfigToken, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:InputToken", -1, &a->tt__AnalyticsEngineControl::InputToken, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:ReceiverToken", -1, &a->tt__AnalyticsEngineControl::ReceiverToken, ""))
		return soap->error;
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__AnalyticsEngineControl::Multicast, ""))
		return soap->error;
	if (!a->tt__AnalyticsEngineControl::Subscription)
	{	if (soap_element_empty(soap, "tt:Subscription"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Config(soap, "tt:Subscription", -1, &a->tt__AnalyticsEngineControl::Subscription, ""))
		return soap->error;
	if (soap_out_tt__ModeOfOperation(soap, "tt:Mode", -1, &a->tt__AnalyticsEngineControl::Mode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AnalyticsEngineControl::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsEngineControl::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsEngineControl(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngineControl * SOAP_FMAC4 soap_in_tt__AnalyticsEngineControl(struct soap *soap, const char *tag, tt__AnalyticsEngineControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsEngineControl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(tt__AnalyticsEngineControl), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsEngineControl)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsEngineControl *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnalyticsEngineControl*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_EngineToken1 = 1;
	size_t soap_flag_EngineConfigToken1 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_Subscription1 = 1;
	size_t soap_flag_Mode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_EngineToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:EngineToken", &a->tt__AnalyticsEngineControl::EngineToken, "tt:ReferenceToken"))
				{	soap_flag_EngineToken1--;
					continue;
				}
			}
			if (soap_flag_EngineConfigToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:EngineConfigToken", &a->tt__AnalyticsEngineControl::EngineConfigToken, "tt:ReferenceToken"))
				{	soap_flag_EngineConfigToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:InputToken", &a->tt__AnalyticsEngineControl::InputToken, "tt:ReferenceToken"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:ReceiverToken", &a->tt__AnalyticsEngineControl::ReceiverToken, "tt:ReferenceToken"))
					continue;
			}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->tt__AnalyticsEngineControl::Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			}
			if (soap_flag_Subscription1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Config(soap, "tt:Subscription", &a->tt__AnalyticsEngineControl::Subscription, "tt:Config"))
				{	soap_flag_Subscription1--;
					continue;
				}
			}
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ModeOfOperation(soap, "tt:Mode", &a->tt__AnalyticsEngineControl::Mode, "tt:ModeOfOperation"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AnalyticsEngineControl::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_EngineToken1 > 0 || soap_flag_EngineConfigToken1 > 0 || a->tt__AnalyticsEngineControl::InputToken.size() < 1 || a->tt__AnalyticsEngineControl::ReceiverToken.size() < 1 || !a->tt__AnalyticsEngineControl::Subscription || soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineControl, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(tt__AnalyticsEngineControl), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngineControl * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsEngineControl(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsEngineControl *p;
	size_t k = sizeof(tt__AnalyticsEngineControl);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsEngineControl, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsEngineControl);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsEngineControl, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsEngineControl location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsEngineControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsEngineControl(soap, tag ? tag : "tt:AnalyticsEngineControl", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngineControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngineControl(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngineControl * SOAP_FMAC4 soap_get_tt__AnalyticsEngineControl(struct soap *soap, tt__AnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataInputExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataInputExtension::__any);
}

void tt__MetadataInputExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataInputExtension::__any);
#endif
}

int tt__MetadataInputExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataInputExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataInputExtension(struct soap *soap, const char *tag, int id, const tt__MetadataInputExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataInputExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MetadataInputExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataInputExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataInputExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataInputExtension * SOAP_FMAC4 soap_in_tt__MetadataInputExtension(struct soap *soap, const char *tag, tt__MetadataInputExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataInputExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataInputExtension, sizeof(tt__MetadataInputExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataInputExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataInputExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MetadataInputExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MetadataInputExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataInputExtension, SOAP_TYPE_tt__MetadataInputExtension, sizeof(tt__MetadataInputExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataInputExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataInputExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataInputExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataInputExtension *p;
	size_t k = sizeof(tt__MetadataInputExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataInputExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataInputExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataInputExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataInputExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataInputExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataInputExtension(soap, tag ? tag : "tt:MetadataInputExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataInputExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataInputExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataInputExtension * SOAP_FMAC4 soap_get_tt__MetadataInputExtension(struct soap *soap, tt__MetadataInputExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataInputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataInput::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__MetadataInput::MetadataConfig);
	this->tt__MetadataInput::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__MetadataInput::__anyAttribute);
}

void tt__MetadataInput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__MetadataInput::MetadataConfig);
	soap_serialize_PointerTott__MetadataInputExtension(soap, &this->tt__MetadataInput::Extension);
#endif
}

int tt__MetadataInput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataInput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataInput(struct soap *soap, const char *tag, int id, const tt__MetadataInput *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MetadataInput*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataInput), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tt:MetadataConfig", -1, &a->tt__MetadataInput::MetadataConfig, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataInputExtension(soap, "tt:Extension", -1, &a->tt__MetadataInput::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataInput::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataInput(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataInput * SOAP_FMAC4 soap_in_tt__MetadataInput(struct soap *soap, const char *tag, tt__MetadataInput *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataInput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataInput, sizeof(tt__MetadataInput), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataInput)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataInput *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MetadataInput*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tt:MetadataConfig", &a->tt__MetadataInput::MetadataConfig, "tt:Config"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataInputExtension(soap, "tt:Extension", &a->tt__MetadataInput::Extension, "tt:MetadataInputExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MetadataInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataInput, SOAP_TYPE_tt__MetadataInput, sizeof(tt__MetadataInput), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataInput * SOAP_FMAC2 soap_instantiate_tt__MetadataInput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataInput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataInput *p;
	size_t k = sizeof(tt__MetadataInput);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataInput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataInput);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataInput, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataInput location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataInput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataInput(soap, tag ? tag : "tt:MetadataInput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataInput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataInput(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataInput * SOAP_FMAC4 soap_get_tt__MetadataInput(struct soap *soap, tt__MetadataInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SourceIdentificationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SourceIdentificationExtension::__any);
}

void tt__SourceIdentificationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SourceIdentificationExtension::__any);
#endif
}

int tt__SourceIdentificationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SourceIdentificationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceIdentificationExtension(struct soap *soap, const char *tag, int id, const tt__SourceIdentificationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceIdentificationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__SourceIdentificationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SourceIdentificationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SourceIdentificationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SourceIdentificationExtension * SOAP_FMAC4 soap_in_tt__SourceIdentificationExtension(struct soap *soap, const char *tag, tt__SourceIdentificationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SourceIdentificationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(tt__SourceIdentificationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SourceIdentificationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SourceIdentificationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__SourceIdentificationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SourceIdentificationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceIdentificationExtension, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(tt__SourceIdentificationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SourceIdentificationExtension * SOAP_FMAC2 soap_instantiate_tt__SourceIdentificationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SourceIdentificationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SourceIdentificationExtension *p;
	size_t k = sizeof(tt__SourceIdentificationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SourceIdentificationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SourceIdentificationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SourceIdentificationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SourceIdentificationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SourceIdentificationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SourceIdentificationExtension(soap, tag ? tag : "tt:SourceIdentificationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SourceIdentificationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SourceIdentificationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SourceIdentificationExtension * SOAP_FMAC4 soap_get_tt__SourceIdentificationExtension(struct soap *soap, tt__SourceIdentificationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceIdentificationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SourceIdentification::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__SourceIdentification::Name);
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__SourceIdentification::Token);
	this->tt__SourceIdentification::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__SourceIdentification::__anyAttribute);
}

void tt__SourceIdentification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SourceIdentification::Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__SourceIdentification::Name);
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__SourceIdentification::Token);
	soap_serialize_PointerTott__SourceIdentificationExtension(soap, &this->tt__SourceIdentification::Extension);
#endif
}

int tt__SourceIdentification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SourceIdentification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceIdentification(struct soap *soap, const char *tag, int id, const tt__SourceIdentification *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SourceIdentification*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceIdentification), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Name", -1, &a->tt__SourceIdentification::Name, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:Token", -1, &a->tt__SourceIdentification::Token, ""))
		return soap->error;
	if (soap_out_PointerTott__SourceIdentificationExtension(soap, "tt:Extension", -1, &a->tt__SourceIdentification::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SourceIdentification::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SourceIdentification(soap, tag, this, type);
}

SOAP_FMAC3 tt__SourceIdentification * SOAP_FMAC4 soap_in_tt__SourceIdentification(struct soap *soap, const char *tag, tt__SourceIdentification *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SourceIdentification*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceIdentification, sizeof(tt__SourceIdentification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SourceIdentification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SourceIdentification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SourceIdentification*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Name", &a->tt__SourceIdentification::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:Token", &a->tt__SourceIdentification::Token, "tt:ReferenceToken"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SourceIdentificationExtension(soap, "tt:Extension", &a->tt__SourceIdentification::Extension, "tt:SourceIdentificationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || a->tt__SourceIdentification::Token.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SourceIdentification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceIdentification, SOAP_TYPE_tt__SourceIdentification, sizeof(tt__SourceIdentification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SourceIdentification * SOAP_FMAC2 soap_instantiate_tt__SourceIdentification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SourceIdentification(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SourceIdentification *p;
	size_t k = sizeof(tt__SourceIdentification);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SourceIdentification, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SourceIdentification);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SourceIdentification, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SourceIdentification location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SourceIdentification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SourceIdentification(soap, tag ? tag : "tt:SourceIdentification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SourceIdentification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SourceIdentification(soap, this, tag, type);
}

SOAP_FMAC3 tt__SourceIdentification * SOAP_FMAC4 soap_get_tt__SourceIdentification(struct soap *soap, tt__SourceIdentification *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsEngineInput::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	this->tt__AnalyticsEngineInput::SourceIdentification = NULL;
	this->tt__AnalyticsEngineInput::VideoInput = NULL;
	this->tt__AnalyticsEngineInput::MetadataInput = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsEngineInput::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AnalyticsEngineInput::__anyAttribute);
}

void tt__AnalyticsEngineInput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SourceIdentification(soap, &this->tt__AnalyticsEngineInput::SourceIdentification);
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &this->tt__AnalyticsEngineInput::VideoInput);
	soap_serialize_PointerTott__MetadataInput(soap, &this->tt__AnalyticsEngineInput::MetadataInput);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsEngineInput::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AnalyticsEngineInput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngineInput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInput(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngineInput *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnalyticsEngineInput*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInput), type ? type : "tt:AnalyticsEngineInput"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (!a->tt__AnalyticsEngineInput::SourceIdentification)
	{	if (soap_element_empty(soap, "tt:SourceIdentification"))
			return soap->error;
	}
	else if (soap_out_PointerTott__SourceIdentification(soap, "tt:SourceIdentification", -1, &a->tt__AnalyticsEngineInput::SourceIdentification, ""))
		return soap->error;
	if (!a->tt__AnalyticsEngineInput::VideoInput)
	{	if (soap_element_empty(soap, "tt:VideoInput"))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoInput", -1, &a->tt__AnalyticsEngineInput::VideoInput, ""))
		return soap->error;
	if (!a->tt__AnalyticsEngineInput::MetadataInput)
	{	if (soap_element_empty(soap, "tt:MetadataInput"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MetadataInput(soap, "tt:MetadataInput", -1, &a->tt__AnalyticsEngineInput::MetadataInput, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AnalyticsEngineInput::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsEngineInput::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsEngineInput(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngineInput * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInput(struct soap *soap, const char *tag, tt__AnalyticsEngineInput *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsEngineInput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(tt__AnalyticsEngineInput), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsEngineInput)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsEngineInput *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnalyticsEngineInput*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_SourceIdentification1 = 1;
	size_t soap_flag_VideoInput1 = 1;
	size_t soap_flag_MetadataInput1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_SourceIdentification1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SourceIdentification(soap, "tt:SourceIdentification", &a->tt__AnalyticsEngineInput::SourceIdentification, "tt:SourceIdentification"))
				{	soap_flag_SourceIdentification1--;
					continue;
				}
			}
			if (soap_flag_VideoInput1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoInput", &a->tt__AnalyticsEngineInput::VideoInput, "tt:VideoEncoderConfiguration"))
				{	soap_flag_VideoInput1--;
					continue;
				}
			}
			if (soap_flag_MetadataInput1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataInput(soap, "tt:MetadataInput", &a->tt__AnalyticsEngineInput::MetadataInput, "tt:MetadataInput"))
				{	soap_flag_MetadataInput1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AnalyticsEngineInput::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || !a->tt__AnalyticsEngineInput::SourceIdentification || !a->tt__AnalyticsEngineInput::VideoInput || !a->tt__AnalyticsEngineInput::MetadataInput))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AnalyticsEngineInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInput, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(tt__AnalyticsEngineInput), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngineInput * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsEngineInput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsEngineInput *p;
	size_t k = sizeof(tt__AnalyticsEngineInput);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsEngineInput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsEngineInput);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsEngineInput, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsEngineInput location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsEngineInput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsEngineInput(soap, tag ? tag : "tt:AnalyticsEngineInput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngineInput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngineInput(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngineInput * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInput(struct soap *soap, tt__AnalyticsEngineInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsEngineInputInfoExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsEngineInputInfoExtension::__any);
}

void tt__AnalyticsEngineInputInfoExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsEngineInputInfoExtension::__any);
#endif
}

int tt__AnalyticsEngineInputInfoExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngineInputInfoExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngineInputInfoExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AnalyticsEngineInputInfoExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsEngineInputInfoExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsEngineInputInfoExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, tt__AnalyticsEngineInputInfoExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsEngineInputInfoExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(tt__AnalyticsEngineInputInfoExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsEngineInputInfoExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AnalyticsEngineInputInfoExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsEngineInputInfoExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(tt__AnalyticsEngineInputInfoExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsEngineInputInfoExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsEngineInputInfoExtension *p;
	size_t k = sizeof(tt__AnalyticsEngineInputInfoExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsEngineInputInfoExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsEngineInputInfoExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsEngineInputInfoExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsEngineInputInfoExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsEngineInputInfoExtension(soap, tag ? tag : "tt:AnalyticsEngineInputInfoExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngineInputInfoExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngineInputInfoExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, tt__AnalyticsEngineInputInfoExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInputInfoExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsEngineInputInfo::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__AnalyticsEngineInputInfo::InputInfo = NULL;
	this->tt__AnalyticsEngineInputInfo::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__AnalyticsEngineInputInfo::__anyAttribute);
}

void tt__AnalyticsEngineInputInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Config(soap, &this->tt__AnalyticsEngineInputInfo::InputInfo);
	soap_serialize_PointerTott__AnalyticsEngineInputInfoExtension(soap, &this->tt__AnalyticsEngineInputInfo::Extension);
#endif
}

int tt__AnalyticsEngineInputInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngineInputInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngineInputInfo *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnalyticsEngineInputInfo*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfo), type))
		return soap->error;
	if (soap_out_PointerTott__Config(soap, "tt:InputInfo", -1, &a->tt__AnalyticsEngineInputInfo::InputInfo, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineInputInfoExtension(soap, "tt:Extension", -1, &a->tt__AnalyticsEngineInputInfo::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsEngineInputInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsEngineInputInfo(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, tt__AnalyticsEngineInputInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsEngineInputInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(tt__AnalyticsEngineInputInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsEngineInputInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsEngineInputInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnalyticsEngineInputInfo*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_InputInfo1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputInfo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Config(soap, "tt:InputInfo", &a->tt__AnalyticsEngineInputInfo::InputInfo, "tt:Config"))
				{	soap_flag_InputInfo1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineInputInfoExtension(soap, "tt:Extension", &a->tt__AnalyticsEngineInputInfo::Extension, "tt:AnalyticsEngineInputInfoExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsEngineInputInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInputInfo, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(tt__AnalyticsEngineInputInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngineInputInfo * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInputInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsEngineInputInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsEngineInputInfo *p;
	size_t k = sizeof(tt__AnalyticsEngineInputInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsEngineInputInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsEngineInputInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsEngineInputInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsEngineInputInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsEngineInputInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsEngineInputInfo(soap, tag ? tag : "tt:AnalyticsEngineInputInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngineInputInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngineInputInfo(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInputInfo(struct soap *soap, tt__AnalyticsEngineInputInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EngineConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__EngineConfiguration::VideoAnalyticsConfiguration = NULL;
	this->tt__EngineConfiguration::AnalyticsEngineInputInfo = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EngineConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__EngineConfiguration::__anyAttribute);
}

void tt__EngineConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &this->tt__EngineConfiguration::VideoAnalyticsConfiguration);
	soap_serialize_PointerTott__AnalyticsEngineInputInfo(soap, &this->tt__EngineConfiguration::AnalyticsEngineInputInfo);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EngineConfiguration::__any);
#endif
}

int tt__EngineConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EngineConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EngineConfiguration(struct soap *soap, const char *tag, int id, const tt__EngineConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__EngineConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EngineConfiguration), type))
		return soap->error;
	if (!a->tt__EngineConfiguration::VideoAnalyticsConfiguration)
	{	if (soap_element_empty(soap, "tt:VideoAnalyticsConfiguration"))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", -1, &a->tt__EngineConfiguration::VideoAnalyticsConfiguration, ""))
		return soap->error;
	if (!a->tt__EngineConfiguration::AnalyticsEngineInputInfo)
	{	if (soap_element_empty(soap, "tt:AnalyticsEngineInputInfo"))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsEngineInputInfo(soap, "tt:AnalyticsEngineInputInfo", -1, &a->tt__EngineConfiguration::AnalyticsEngineInputInfo, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__EngineConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EngineConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EngineConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__EngineConfiguration * SOAP_FMAC4 soap_in_tt__EngineConfiguration(struct soap *soap, const char *tag, tt__EngineConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EngineConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EngineConfiguration, sizeof(tt__EngineConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EngineConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EngineConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__EngineConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_VideoAnalyticsConfiguration1 = 1;
	size_t soap_flag_AnalyticsEngineInputInfo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoAnalyticsConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", &a->tt__EngineConfiguration::VideoAnalyticsConfiguration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_VideoAnalyticsConfiguration1--;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineInputInfo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineInputInfo(soap, "tt:AnalyticsEngineInputInfo", &a->tt__EngineConfiguration::AnalyticsEngineInputInfo, "tt:AnalyticsEngineInputInfo"))
				{	soap_flag_AnalyticsEngineInputInfo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__EngineConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__EngineConfiguration::VideoAnalyticsConfiguration || !a->tt__EngineConfiguration::AnalyticsEngineInputInfo))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__EngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EngineConfiguration, SOAP_TYPE_tt__EngineConfiguration, sizeof(tt__EngineConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__EngineConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EngineConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EngineConfiguration *p;
	size_t k = sizeof(tt__EngineConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EngineConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EngineConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EngineConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EngineConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EngineConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EngineConfiguration(soap, tag ? tag : "tt:EngineConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EngineConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EngineConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__EngineConfiguration * SOAP_FMAC4 soap_get_tt__EngineConfiguration(struct soap *soap, tt__EngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsDeviceEngineConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsDeviceEngineConfigurationExtension::__any);
}

void tt__AnalyticsDeviceEngineConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsDeviceEngineConfigurationExtension::__any);
#endif
}

int tt__AnalyticsDeviceEngineConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__AnalyticsDeviceEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AnalyticsDeviceEngineConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsDeviceEngineConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, tt__AnalyticsDeviceEngineConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsDeviceEngineConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(tt__AnalyticsDeviceEngineConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsDeviceEngineConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AnalyticsDeviceEngineConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsDeviceEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(tt__AnalyticsDeviceEngineConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsDeviceEngineConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsDeviceEngineConfigurationExtension *p;
	size_t k = sizeof(tt__AnalyticsDeviceEngineConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsDeviceEngineConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsDeviceEngineConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsDeviceEngineConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsDeviceEngineConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsDeviceEngineConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsDeviceEngineConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsDeviceEngineConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, tt__AnalyticsDeviceEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsDeviceEngineConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__EngineConfiguration(soap, &this->tt__AnalyticsDeviceEngineConfiguration::EngineConfiguration);
	this->tt__AnalyticsDeviceEngineConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__AnalyticsDeviceEngineConfiguration::__anyAttribute);
}

void tt__AnalyticsDeviceEngineConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__EngineConfiguration(soap, &this->tt__AnalyticsDeviceEngineConfiguration::EngineConfiguration);
	soap_serialize_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, &this->tt__AnalyticsDeviceEngineConfiguration::Extension);
#endif
}

int tt__AnalyticsDeviceEngineConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsDeviceEngineConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, int id, const tt__AnalyticsDeviceEngineConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnalyticsDeviceEngineConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__EngineConfiguration(soap, "tt:EngineConfiguration", -1, &a->tt__AnalyticsDeviceEngineConfiguration::EngineConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, "tt:Extension", -1, &a->tt__AnalyticsDeviceEngineConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsDeviceEngineConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsDeviceEngineConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, tt__AnalyticsDeviceEngineConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsDeviceEngineConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(tt__AnalyticsDeviceEngineConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsDeviceEngineConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnalyticsDeviceEngineConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__EngineConfiguration(soap, "tt:EngineConfiguration", &a->tt__AnalyticsDeviceEngineConfiguration::EngineConfiguration, "tt:EngineConfiguration"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, "tt:Extension", &a->tt__AnalyticsDeviceEngineConfiguration::Extension, "tt:AnalyticsDeviceEngineConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__AnalyticsDeviceEngineConfiguration::EngineConfiguration.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AnalyticsDeviceEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(tt__AnalyticsDeviceEngineConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsDeviceEngineConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsDeviceEngineConfiguration *p;
	size_t k = sizeof(tt__AnalyticsDeviceEngineConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsDeviceEngineConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsDeviceEngineConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsDeviceEngineConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsDeviceEngineConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsDeviceEngineConfiguration(soap, tag ? tag : "tt:AnalyticsDeviceEngineConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsDeviceEngineConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsDeviceEngineConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, tt__AnalyticsDeviceEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsEngine::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	this->tt__AnalyticsEngine::AnalyticsEngineConfiguration = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsEngine::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AnalyticsEngine::__anyAttribute);
}

void tt__AnalyticsEngine::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsDeviceEngineConfiguration(soap, &this->tt__AnalyticsEngine::AnalyticsEngineConfiguration);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsEngine::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AnalyticsEngine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngine(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngine *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnalyticsEngine*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngine), type ? type : "tt:AnalyticsEngine"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (!a->tt__AnalyticsEngine::AnalyticsEngineConfiguration)
	{	if (soap_element_empty(soap, "tt:AnalyticsEngineConfiguration"))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->tt__AnalyticsEngine::AnalyticsEngineConfiguration, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AnalyticsEngine::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsEngine::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsEngine(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngine * SOAP_FMAC4 soap_in_tt__AnalyticsEngine(struct soap *soap, const char *tag, tt__AnalyticsEngine *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsEngine*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngine, sizeof(tt__AnalyticsEngine), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsEngine)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsEngine *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnalyticsEngine*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_AnalyticsEngineConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->tt__AnalyticsEngine::AnalyticsEngineConfiguration, "tt:AnalyticsDeviceEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AnalyticsEngine::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || !a->tt__AnalyticsEngine::AnalyticsEngineConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AnalyticsEngine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngine, SOAP_TYPE_tt__AnalyticsEngine, sizeof(tt__AnalyticsEngine), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngine * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsEngine(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsEngine *p;
	size_t k = sizeof(tt__AnalyticsEngine);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsEngine, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsEngine);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsEngine, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsEngine location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsEngine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsEngine(soap, tag ? tag : "tt:AnalyticsEngine", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngine(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngine * SOAP_FMAC4 soap_get_tt__AnalyticsEngine(struct soap *soap, tt__AnalyticsEngine *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReplayConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &this->tt__ReplayConfiguration::SessionTimeout);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ReplayConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ReplayConfiguration::__anyAttribute);
}

void tt__ReplayConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ReplayConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__ReplayConfiguration::SessionTimeout);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ReplayConfiguration::__any);
#endif
}

int tt__ReplayConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReplayConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReplayConfiguration(struct soap *soap, const char *tag, int id, const tt__ReplayConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ReplayConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReplayConfiguration), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->tt__ReplayConfiguration::SessionTimeout, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ReplayConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReplayConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReplayConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReplayConfiguration * SOAP_FMAC4 soap_in_tt__ReplayConfiguration(struct soap *soap, const char *tag, tt__ReplayConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReplayConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReplayConfiguration, sizeof(tt__ReplayConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReplayConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReplayConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ReplayConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SessionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->tt__ReplayConfiguration::SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ReplayConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SessionTimeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReplayConfiguration, SOAP_TYPE_tt__ReplayConfiguration, sizeof(tt__ReplayConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReplayConfiguration * SOAP_FMAC2 soap_instantiate_tt__ReplayConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReplayConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReplayConfiguration *p;
	size_t k = sizeof(tt__ReplayConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReplayConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReplayConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReplayConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReplayConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReplayConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReplayConfiguration(soap, tag ? tag : "tt:ReplayConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReplayConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReplayConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReplayConfiguration * SOAP_FMAC4 soap_get_tt__ReplayConfiguration(struct soap *soap, tt__ReplayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__GetRecordingJobsResponseItem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &this->tt__GetRecordingJobsResponseItem::JobToken);
	this->tt__GetRecordingJobsResponseItem::JobConfiguration = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__GetRecordingJobsResponseItem::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__GetRecordingJobsResponseItem::__anyAttribute);
}

void tt__GetRecordingJobsResponseItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, &this->tt__GetRecordingJobsResponseItem::JobToken);
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &this->tt__GetRecordingJobsResponseItem::JobConfiguration);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__GetRecordingJobsResponseItem::__any);
#endif
}

int tt__GetRecordingJobsResponseItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__GetRecordingJobsResponseItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, int id, const tt__GetRecordingJobsResponseItem *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__GetRecordingJobsResponseItem*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetRecordingJobsResponseItem), type))
		return soap->error;
	if (soap_out_tt__RecordingJobReference(soap, "tt:JobToken", -1, &a->tt__GetRecordingJobsResponseItem::JobToken, ""))
		return soap->error;
	if (!a->tt__GetRecordingJobsResponseItem::JobConfiguration)
	{	if (soap_element_empty(soap, "tt:JobConfiguration"))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingJobConfiguration(soap, "tt:JobConfiguration", -1, &a->tt__GetRecordingJobsResponseItem::JobConfiguration, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__GetRecordingJobsResponseItem::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__GetRecordingJobsResponseItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__GetRecordingJobsResponseItem(soap, tag, this, type);
}

SOAP_FMAC3 tt__GetRecordingJobsResponseItem * SOAP_FMAC4 soap_in_tt__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, tt__GetRecordingJobsResponseItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__GetRecordingJobsResponseItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetRecordingJobsResponseItem, sizeof(tt__GetRecordingJobsResponseItem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__GetRecordingJobsResponseItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__GetRecordingJobsResponseItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__GetRecordingJobsResponseItem*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_JobToken1 = 1;
	size_t soap_flag_JobConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobReference(soap, "tt:JobToken", &a->tt__GetRecordingJobsResponseItem::JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken1--;
					continue;
				}
			}
			if (soap_flag_JobConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobConfiguration(soap, "tt:JobConfiguration", &a->tt__GetRecordingJobsResponseItem::JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__GetRecordingJobsResponseItem::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken1 > 0 || !a->tt__GetRecordingJobsResponseItem::JobConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__GetRecordingJobsResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetRecordingJobsResponseItem, SOAP_TYPE_tt__GetRecordingJobsResponseItem, sizeof(tt__GetRecordingJobsResponseItem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__GetRecordingJobsResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetRecordingJobsResponseItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__GetRecordingJobsResponseItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__GetRecordingJobsResponseItem *p;
	size_t k = sizeof(tt__GetRecordingJobsResponseItem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__GetRecordingJobsResponseItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__GetRecordingJobsResponseItem);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__GetRecordingJobsResponseItem, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__GetRecordingJobsResponseItem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__GetRecordingJobsResponseItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__GetRecordingJobsResponseItem(soap, tag ? tag : "tt:GetRecordingJobsResponseItem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__GetRecordingJobsResponseItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__GetRecordingJobsResponseItem(soap, this, tag, type);
}

SOAP_FMAC3 tt__GetRecordingJobsResponseItem * SOAP_FMAC4 soap_get_tt__GetRecordingJobsResponseItem(struct soap *soap, tt__GetRecordingJobsResponseItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetRecordingJobsResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingJobStateTrack::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__RecordingJobStateTrack::SourceTag);
	soap_default_tt__TrackReference(soap, &this->tt__RecordingJobStateTrack::Destination);
	this->tt__RecordingJobStateTrack::Error = NULL;
	soap_default_tt__RecordingJobState(soap, &this->tt__RecordingJobStateTrack::State);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingJobStateTrack::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__RecordingJobStateTrack::__anyAttribute);
}

void tt__RecordingJobStateTrack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RecordingJobStateTrack::SourceTag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__RecordingJobStateTrack::SourceTag);
	soap_serialize_tt__TrackReference(soap, &this->tt__RecordingJobStateTrack::Destination);
	soap_serialize_PointerTostd__string(soap, &this->tt__RecordingJobStateTrack::Error);
	soap_serialize_tt__RecordingJobState(soap, &this->tt__RecordingJobStateTrack::State);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingJobStateTrack::__any);
#endif
}

int tt__RecordingJobStateTrack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingJobStateTrack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateTrack(struct soap *soap, const char *tag, int id, const tt__RecordingJobStateTrack *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RecordingJobStateTrack*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateTrack), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:SourceTag", -1, &a->tt__RecordingJobStateTrack::SourceTag, ""))
		return soap->error;
	if (soap_out_tt__TrackReference(soap, "tt:Destination", -1, &a->tt__RecordingJobStateTrack::Destination, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Error", -1, &a->tt__RecordingJobStateTrack::Error, ""))
		return soap->error;
	if (soap_out_tt__RecordingJobState(soap, "tt:State", -1, &a->tt__RecordingJobStateTrack::State, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RecordingJobStateTrack::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingJobStateTrack::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingJobStateTrack(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingJobStateTrack * SOAP_FMAC4 soap_in_tt__RecordingJobStateTrack(struct soap *soap, const char *tag, tt__RecordingJobStateTrack *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingJobStateTrack*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(tt__RecordingJobStateTrack), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingJobStateTrack)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingJobStateTrack *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RecordingJobStateTrack*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SourceTag1 = 1;
	size_t soap_flag_Destination1 = 1;
	size_t soap_flag_Error1 = 1;
	size_t soap_flag_State1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceTag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:SourceTag", &a->tt__RecordingJobStateTrack::SourceTag, "xsd:string"))
				{	soap_flag_SourceTag1--;
					continue;
				}
			}
			if (soap_flag_Destination1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:Destination", &a->tt__RecordingJobStateTrack::Destination, "tt:TrackReference"))
				{	soap_flag_Destination1--;
					continue;
				}
			}
			if (soap_flag_Error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Error", &a->tt__RecordingJobStateTrack::Error, "xsd:string"))
				{	soap_flag_Error1--;
					continue;
				}
			}
			if (soap_flag_State1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobState(soap, "tt:State", &a->tt__RecordingJobStateTrack::State, "tt:RecordingJobState"))
				{	soap_flag_State1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RecordingJobStateTrack::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SourceTag1 > 0 || soap_flag_Destination1 > 0 || soap_flag_State1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RecordingJobStateTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateTrack, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(tt__RecordingJobStateTrack), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingJobStateTrack * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateTrack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingJobStateTrack(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingJobStateTrack *p;
	size_t k = sizeof(tt__RecordingJobStateTrack);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingJobStateTrack, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingJobStateTrack);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingJobStateTrack, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingJobStateTrack location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingJobStateTrack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingJobStateTrack(soap, tag ? tag : "tt:RecordingJobStateTrack", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingJobStateTrack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingJobStateTrack(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingJobStateTrack * SOAP_FMAC4 soap_get_tt__RecordingJobStateTrack(struct soap *soap, tt__RecordingJobStateTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingJobStateTracks::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(soap, &this->tt__RecordingJobStateTracks::Track);
	soap_default_xsd__anyAttribute(soap, &this->tt__RecordingJobStateTracks::__anyAttribute);
}

void tt__RecordingJobStateTracks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(soap, &this->tt__RecordingJobStateTracks::Track);
#endif
}

int tt__RecordingJobStateTracks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingJobStateTracks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateTracks(struct soap *soap, const char *tag, int id, const tt__RecordingJobStateTracks *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RecordingJobStateTracks*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateTracks), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(soap, "tt:Track", -1, &a->tt__RecordingJobStateTracks::Track, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingJobStateTracks::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingJobStateTracks(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingJobStateTracks * SOAP_FMAC4 soap_in_tt__RecordingJobStateTracks(struct soap *soap, const char *tag, tt__RecordingJobStateTracks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingJobStateTracks*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(tt__RecordingJobStateTracks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingJobStateTracks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingJobStateTracks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RecordingJobStateTracks*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(soap, "tt:Track", &a->tt__RecordingJobStateTracks::Track, "tt:RecordingJobStateTrack"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RecordingJobStateTracks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateTracks, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(tt__RecordingJobStateTracks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingJobStateTracks * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateTracks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingJobStateTracks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingJobStateTracks *p;
	size_t k = sizeof(tt__RecordingJobStateTracks);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingJobStateTracks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingJobStateTracks);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingJobStateTracks, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingJobStateTracks location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingJobStateTracks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingJobStateTracks(soap, tag ? tag : "tt:RecordingJobStateTracks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingJobStateTracks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingJobStateTracks(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingJobStateTracks * SOAP_FMAC4 soap_get_tt__RecordingJobStateTracks(struct soap *soap, tt__RecordingJobStateTracks *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateTracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingJobStateSource::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__RecordingJobStateSource::SourceToken = NULL;
	soap_default_tt__RecordingJobState(soap, &this->tt__RecordingJobStateSource::State);
	this->tt__RecordingJobStateSource::Tracks = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingJobStateSource::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__RecordingJobStateSource::__anyAttribute);
}

void tt__RecordingJobStateSource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SourceReference(soap, &this->tt__RecordingJobStateSource::SourceToken);
	soap_serialize_tt__RecordingJobState(soap, &this->tt__RecordingJobStateSource::State);
	soap_serialize_PointerTott__RecordingJobStateTracks(soap, &this->tt__RecordingJobStateSource::Tracks);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingJobStateSource::__any);
#endif
}

int tt__RecordingJobStateSource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingJobStateSource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateSource(struct soap *soap, const char *tag, int id, const tt__RecordingJobStateSource *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RecordingJobStateSource*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateSource), type))
		return soap->error;
	if (!a->tt__RecordingJobStateSource::SourceToken)
	{	if (soap_element_empty(soap, "tt:SourceToken"))
			return soap->error;
	}
	else if (soap_out_PointerTott__SourceReference(soap, "tt:SourceToken", -1, &a->tt__RecordingJobStateSource::SourceToken, ""))
		return soap->error;
	if (soap_out_tt__RecordingJobState(soap, "tt:State", -1, &a->tt__RecordingJobStateSource::State, ""))
		return soap->error;
	if (!a->tt__RecordingJobStateSource::Tracks)
	{	if (soap_element_empty(soap, "tt:Tracks"))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingJobStateTracks(soap, "tt:Tracks", -1, &a->tt__RecordingJobStateSource::Tracks, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RecordingJobStateSource::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingJobStateSource::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingJobStateSource(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingJobStateSource * SOAP_FMAC4 soap_in_tt__RecordingJobStateSource(struct soap *soap, const char *tag, tt__RecordingJobStateSource *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingJobStateSource*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(tt__RecordingJobStateSource), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingJobStateSource)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingJobStateSource *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RecordingJobStateSource*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SourceToken1 = 1;
	size_t soap_flag_State1 = 1;
	size_t soap_flag_Tracks1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SourceReference(soap, "tt:SourceToken", &a->tt__RecordingJobStateSource::SourceToken, "tt:SourceReference"))
				{	soap_flag_SourceToken1--;
					continue;
				}
			}
			if (soap_flag_State1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobState(soap, "tt:State", &a->tt__RecordingJobStateSource::State, "tt:RecordingJobState"))
				{	soap_flag_State1--;
					continue;
				}
			}
			if (soap_flag_Tracks1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobStateTracks(soap, "tt:Tracks", &a->tt__RecordingJobStateSource::Tracks, "tt:RecordingJobStateTracks"))
				{	soap_flag_Tracks1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RecordingJobStateSource::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__RecordingJobStateSource::SourceToken || soap_flag_State1 > 0 || !a->tt__RecordingJobStateSource::Tracks))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RecordingJobStateSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateSource, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(tt__RecordingJobStateSource), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingJobStateSource * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingJobStateSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingJobStateSource *p;
	size_t k = sizeof(tt__RecordingJobStateSource);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingJobStateSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingJobStateSource);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingJobStateSource, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingJobStateSource location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingJobStateSource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingJobStateSource(soap, tag ? tag : "tt:RecordingJobStateSource", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingJobStateSource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingJobStateSource(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingJobStateSource * SOAP_FMAC4 soap_get_tt__RecordingJobStateSource(struct soap *soap, tt__RecordingJobStateSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingJobStateInformationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingJobStateInformationExtension::__any);
}

void tt__RecordingJobStateInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingJobStateInformationExtension::__any);
#endif
}

int tt__RecordingJobStateInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingJobStateInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, int id, const tt__RecordingJobStateInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateInformationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RecordingJobStateInformationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingJobStateInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingJobStateInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingJobStateInformationExtension * SOAP_FMAC4 soap_in_tt__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, tt__RecordingJobStateInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingJobStateInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(tt__RecordingJobStateInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingJobStateInformationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingJobStateInformationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RecordingJobStateInformationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RecordingJobStateInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateInformationExtension, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(tt__RecordingJobStateInformationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingJobStateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingJobStateInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingJobStateInformationExtension *p;
	size_t k = sizeof(tt__RecordingJobStateInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingJobStateInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingJobStateInformationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingJobStateInformationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingJobStateInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingJobStateInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingJobStateInformationExtension(soap, tag ? tag : "tt:RecordingJobStateInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingJobStateInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingJobStateInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingJobStateInformationExtension * SOAP_FMAC4 soap_get_tt__RecordingJobStateInformationExtension(struct soap *soap, tt__RecordingJobStateInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingJobStateInformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &this->tt__RecordingJobStateInformation::RecordingToken);
	soap_default_tt__RecordingJobState(soap, &this->tt__RecordingJobStateInformation::State);
	soap_default_std__vectorTemplateOfPointerTott__RecordingJobStateSource(soap, &this->tt__RecordingJobStateInformation::Sources);
	this->tt__RecordingJobStateInformation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__RecordingJobStateInformation::__anyAttribute);
}

void tt__RecordingJobStateInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, &this->tt__RecordingJobStateInformation::RecordingToken);
	soap_serialize_tt__RecordingJobState(soap, &this->tt__RecordingJobStateInformation::State);
	soap_serialize_std__vectorTemplateOfPointerTott__RecordingJobStateSource(soap, &this->tt__RecordingJobStateInformation::Sources);
	soap_serialize_PointerTott__RecordingJobStateInformationExtension(soap, &this->tt__RecordingJobStateInformation::Extension);
#endif
}

int tt__RecordingJobStateInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingJobStateInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateInformation(struct soap *soap, const char *tag, int id, const tt__RecordingJobStateInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RecordingJobStateInformation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateInformation), type))
		return soap->error;
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->tt__RecordingJobStateInformation::RecordingToken, ""))
		return soap->error;
	if (soap_out_tt__RecordingJobState(soap, "tt:State", -1, &a->tt__RecordingJobStateInformation::State, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__RecordingJobStateSource(soap, "tt:Sources", -1, &a->tt__RecordingJobStateInformation::Sources, ""))
		return soap->error;
	if (soap_out_PointerTott__RecordingJobStateInformationExtension(soap, "tt:Extension", -1, &a->tt__RecordingJobStateInformation::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingJobStateInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingJobStateInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingJobStateInformation * SOAP_FMAC4 soap_in_tt__RecordingJobStateInformation(struct soap *soap, const char *tag, tt__RecordingJobStateInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingJobStateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateInformation, sizeof(tt__RecordingJobStateInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingJobStateInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingJobStateInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RecordingJobStateInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RecordingToken1 = 1;
	size_t soap_flag_State1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->tt__RecordingJobStateInformation::RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken1--;
					continue;
				}
			}
			if (soap_flag_State1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobState(soap, "tt:State", &a->tt__RecordingJobStateInformation::State, "tt:RecordingJobState"))
				{	soap_flag_State1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__RecordingJobStateSource(soap, "tt:Sources", &a->tt__RecordingJobStateInformation::Sources, "tt:RecordingJobStateSource"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobStateInformationExtension(soap, "tt:Extension", &a->tt__RecordingJobStateInformation::Extension, "tt:RecordingJobStateInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken1 > 0 || soap_flag_State1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RecordingJobStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateInformation, SOAP_TYPE_tt__RecordingJobStateInformation, sizeof(tt__RecordingJobStateInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingJobStateInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingJobStateInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingJobStateInformation *p;
	size_t k = sizeof(tt__RecordingJobStateInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingJobStateInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingJobStateInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingJobStateInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingJobStateInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingJobStateInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingJobStateInformation(soap, tag ? tag : "tt:RecordingJobStateInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingJobStateInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingJobStateInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingJobStateInformation * SOAP_FMAC4 soap_get_tt__RecordingJobStateInformation(struct soap *soap, tt__RecordingJobStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingJobTrack::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__RecordingJobTrack::SourceTag);
	soap_default_tt__TrackReference(soap, &this->tt__RecordingJobTrack::Destination);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingJobTrack::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__RecordingJobTrack::__anyAttribute);
}

void tt__RecordingJobTrack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RecordingJobTrack::SourceTag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__RecordingJobTrack::SourceTag);
	soap_serialize_tt__TrackReference(soap, &this->tt__RecordingJobTrack::Destination);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingJobTrack::__any);
#endif
}

int tt__RecordingJobTrack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingJobTrack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobTrack(struct soap *soap, const char *tag, int id, const tt__RecordingJobTrack *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RecordingJobTrack*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobTrack), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:SourceTag", -1, &a->tt__RecordingJobTrack::SourceTag, ""))
		return soap->error;
	if (soap_out_tt__TrackReference(soap, "tt:Destination", -1, &a->tt__RecordingJobTrack::Destination, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RecordingJobTrack::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingJobTrack::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingJobTrack(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingJobTrack * SOAP_FMAC4 soap_in_tt__RecordingJobTrack(struct soap *soap, const char *tag, tt__RecordingJobTrack *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingJobTrack*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobTrack, sizeof(tt__RecordingJobTrack), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingJobTrack)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingJobTrack *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RecordingJobTrack*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SourceTag1 = 1;
	size_t soap_flag_Destination1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceTag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:SourceTag", &a->tt__RecordingJobTrack::SourceTag, "xsd:string"))
				{	soap_flag_SourceTag1--;
					continue;
				}
			}
			if (soap_flag_Destination1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:Destination", &a->tt__RecordingJobTrack::Destination, "tt:TrackReference"))
				{	soap_flag_Destination1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RecordingJobTrack::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SourceTag1 > 0 || soap_flag_Destination1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RecordingJobTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobTrack, SOAP_TYPE_tt__RecordingJobTrack, sizeof(tt__RecordingJobTrack), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingJobTrack * SOAP_FMAC2 soap_instantiate_tt__RecordingJobTrack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingJobTrack(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingJobTrack *p;
	size_t k = sizeof(tt__RecordingJobTrack);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingJobTrack, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingJobTrack);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingJobTrack, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingJobTrack location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingJobTrack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingJobTrack(soap, tag ? tag : "tt:RecordingJobTrack", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingJobTrack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingJobTrack(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingJobTrack * SOAP_FMAC4 soap_get_tt__RecordingJobTrack(struct soap *soap, tt__RecordingJobTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingJobSourceExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingJobSourceExtension::__any);
}

void tt__RecordingJobSourceExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingJobSourceExtension::__any);
#endif
}

int tt__RecordingJobSourceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingJobSourceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobSourceExtension(struct soap *soap, const char *tag, int id, const tt__RecordingJobSourceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobSourceExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RecordingJobSourceExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingJobSourceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingJobSourceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingJobSourceExtension * SOAP_FMAC4 soap_in_tt__RecordingJobSourceExtension(struct soap *soap, const char *tag, tt__RecordingJobSourceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingJobSourceExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(tt__RecordingJobSourceExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingJobSourceExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingJobSourceExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RecordingJobSourceExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RecordingJobSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobSourceExtension, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(tt__RecordingJobSourceExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingJobSourceExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobSourceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingJobSourceExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingJobSourceExtension *p;
	size_t k = sizeof(tt__RecordingJobSourceExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingJobSourceExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingJobSourceExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingJobSourceExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingJobSourceExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingJobSourceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingJobSourceExtension(soap, tag ? tag : "tt:RecordingJobSourceExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingJobSourceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingJobSourceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingJobSourceExtension * SOAP_FMAC4 soap_get_tt__RecordingJobSourceExtension(struct soap *soap, tt__RecordingJobSourceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingJobSource::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__RecordingJobSource::SourceToken = NULL;
	this->tt__RecordingJobSource::AutoCreateReceiver = NULL;
	soap_default_std__vectorTemplateOfPointerTott__RecordingJobTrack(soap, &this->tt__RecordingJobSource::Tracks);
	this->tt__RecordingJobSource::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__RecordingJobSource::__anyAttribute);
}

void tt__RecordingJobSource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SourceReference(soap, &this->tt__RecordingJobSource::SourceToken);
	soap_serialize_PointerTobool(soap, &this->tt__RecordingJobSource::AutoCreateReceiver);
	soap_serialize_std__vectorTemplateOfPointerTott__RecordingJobTrack(soap, &this->tt__RecordingJobSource::Tracks);
	soap_serialize_PointerTott__RecordingJobSourceExtension(soap, &this->tt__RecordingJobSource::Extension);
#endif
}

int tt__RecordingJobSource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingJobSource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobSource(struct soap *soap, const char *tag, int id, const tt__RecordingJobSource *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RecordingJobSource*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobSource), type))
		return soap->error;
	if (soap_out_PointerTott__SourceReference(soap, "tt:SourceToken", -1, &a->tt__RecordingJobSource::SourceToken, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:AutoCreateReceiver", -1, &a->tt__RecordingJobSource::AutoCreateReceiver, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__RecordingJobTrack(soap, "tt:Tracks", -1, &a->tt__RecordingJobSource::Tracks, ""))
		return soap->error;
	if (soap_out_PointerTott__RecordingJobSourceExtension(soap, "tt:Extension", -1, &a->tt__RecordingJobSource::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingJobSource::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingJobSource(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingJobSource * SOAP_FMAC4 soap_in_tt__RecordingJobSource(struct soap *soap, const char *tag, tt__RecordingJobSource *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingJobSource*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobSource, sizeof(tt__RecordingJobSource), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingJobSource)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingJobSource *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RecordingJobSource*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SourceToken1 = 1;
	size_t soap_flag_AutoCreateReceiver1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SourceReference(soap, "tt:SourceToken", &a->tt__RecordingJobSource::SourceToken, "tt:SourceReference"))
				{	soap_flag_SourceToken1--;
					continue;
				}
			}
			if (soap_flag_AutoCreateReceiver1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:AutoCreateReceiver", &a->tt__RecordingJobSource::AutoCreateReceiver, "xsd:boolean"))
				{	soap_flag_AutoCreateReceiver1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__RecordingJobTrack(soap, "tt:Tracks", &a->tt__RecordingJobSource::Tracks, "tt:RecordingJobTrack"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobSourceExtension(soap, "tt:Extension", &a->tt__RecordingJobSource::Extension, "tt:RecordingJobSourceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RecordingJobSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobSource, SOAP_TYPE_tt__RecordingJobSource, sizeof(tt__RecordingJobSource), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingJobSource * SOAP_FMAC2 soap_instantiate_tt__RecordingJobSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingJobSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingJobSource *p;
	size_t k = sizeof(tt__RecordingJobSource);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingJobSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingJobSource);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingJobSource, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingJobSource location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingJobSource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingJobSource(soap, tag ? tag : "tt:RecordingJobSource", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingJobSource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingJobSource(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingJobSource * SOAP_FMAC4 soap_get_tt__RecordingJobSource(struct soap *soap, tt__RecordingJobSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingJobConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingJobConfigurationExtension::__any);
}

void tt__RecordingJobConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingJobConfigurationExtension::__any);
#endif
}

int tt__RecordingJobConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingJobConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__RecordingJobConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RecordingJobConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingJobConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingJobConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingJobConfigurationExtension * SOAP_FMAC4 soap_in_tt__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, tt__RecordingJobConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingJobConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(tt__RecordingJobConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingJobConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingJobConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RecordingJobConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RecordingJobConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobConfigurationExtension, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(tt__RecordingJobConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingJobConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingJobConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingJobConfigurationExtension *p;
	size_t k = sizeof(tt__RecordingJobConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingJobConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingJobConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingJobConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingJobConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingJobConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingJobConfigurationExtension(soap, tag ? tag : "tt:RecordingJobConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingJobConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingJobConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingJobConfigurationExtension * SOAP_FMAC4 soap_get_tt__RecordingJobConfigurationExtension(struct soap *soap, tt__RecordingJobConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingJobConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &this->tt__RecordingJobConfiguration::RecordingToken);
	soap_default_tt__RecordingJobMode(soap, &this->tt__RecordingJobConfiguration::Mode);
	soap_default_int(soap, &this->tt__RecordingJobConfiguration::Priority);
	soap_default_std__vectorTemplateOfPointerTott__RecordingJobSource(soap, &this->tt__RecordingJobConfiguration::Source);
	this->tt__RecordingJobConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__RecordingJobConfiguration::__anyAttribute);
}

void tt__RecordingJobConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, &this->tt__RecordingJobConfiguration::RecordingToken);
	soap_serialize_tt__RecordingJobMode(soap, &this->tt__RecordingJobConfiguration::Mode);
	soap_embedded(soap, &this->tt__RecordingJobConfiguration::Priority, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfPointerTott__RecordingJobSource(soap, &this->tt__RecordingJobConfiguration::Source);
	soap_serialize_PointerTott__RecordingJobConfigurationExtension(soap, &this->tt__RecordingJobConfiguration::Extension);
#endif
}

int tt__RecordingJobConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingJobConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobConfiguration(struct soap *soap, const char *tag, int id, const tt__RecordingJobConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RecordingJobConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobConfiguration), type))
		return soap->error;
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->tt__RecordingJobConfiguration::RecordingToken, ""))
		return soap->error;
	if (soap_out_tt__RecordingJobMode(soap, "tt:Mode", -1, &a->tt__RecordingJobConfiguration::Mode, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Priority", -1, &a->tt__RecordingJobConfiguration::Priority, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__RecordingJobSource(soap, "tt:Source", -1, &a->tt__RecordingJobConfiguration::Source, ""))
		return soap->error;
	if (soap_out_PointerTott__RecordingJobConfigurationExtension(soap, "tt:Extension", -1, &a->tt__RecordingJobConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingJobConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingJobConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingJobConfiguration * SOAP_FMAC4 soap_in_tt__RecordingJobConfiguration(struct soap *soap, const char *tag, tt__RecordingJobConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingJobConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(tt__RecordingJobConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingJobConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingJobConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RecordingJobConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RecordingToken1 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Priority1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->tt__RecordingJobConfiguration::RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken1--;
					continue;
				}
			}
			if (soap_flag_Mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobMode(soap, "tt:Mode", &a->tt__RecordingJobConfiguration::Mode, "tt:RecordingJobMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Priority1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Priority", &a->tt__RecordingJobConfiguration::Priority, "xsd:int"))
				{	soap_flag_Priority1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__RecordingJobSource(soap, "tt:Source", &a->tt__RecordingJobConfiguration::Source, "tt:RecordingJobSource"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobConfigurationExtension(soap, "tt:Extension", &a->tt__RecordingJobConfiguration::Extension, "tt:RecordingJobConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken1 > 0 || soap_flag_Mode1 > 0 || soap_flag_Priority1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobConfiguration, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(tt__RecordingJobConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingJobConfiguration * SOAP_FMAC2 soap_instantiate_tt__RecordingJobConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingJobConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingJobConfiguration *p;
	size_t k = sizeof(tt__RecordingJobConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingJobConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingJobConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingJobConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingJobConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingJobConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingJobConfiguration(soap, tag ? tag : "tt:RecordingJobConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingJobConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingJobConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingJobConfiguration * SOAP_FMAC4 soap_get_tt__RecordingJobConfiguration(struct soap *soap, tt__RecordingJobConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__GetTracksResponseItem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__TrackReference(soap, &this->tt__GetTracksResponseItem::TrackToken);
	this->tt__GetTracksResponseItem::Configuration = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__GetTracksResponseItem::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__GetTracksResponseItem::__anyAttribute);
}

void tt__GetTracksResponseItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__TrackReference(soap, &this->tt__GetTracksResponseItem::TrackToken);
	soap_serialize_PointerTott__TrackConfiguration(soap, &this->tt__GetTracksResponseItem::Configuration);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__GetTracksResponseItem::__any);
#endif
}

int tt__GetTracksResponseItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__GetTracksResponseItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetTracksResponseItem(struct soap *soap, const char *tag, int id, const tt__GetTracksResponseItem *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__GetTracksResponseItem*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetTracksResponseItem), type))
		return soap->error;
	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, &a->tt__GetTracksResponseItem::TrackToken, ""))
		return soap->error;
	if (!a->tt__GetTracksResponseItem::Configuration)
	{	if (soap_element_empty(soap, "tt:Configuration"))
			return soap->error;
	}
	else if (soap_out_PointerTott__TrackConfiguration(soap, "tt:Configuration", -1, &a->tt__GetTracksResponseItem::Configuration, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__GetTracksResponseItem::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__GetTracksResponseItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__GetTracksResponseItem(soap, tag, this, type);
}

SOAP_FMAC3 tt__GetTracksResponseItem * SOAP_FMAC4 soap_in_tt__GetTracksResponseItem(struct soap *soap, const char *tag, tt__GetTracksResponseItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__GetTracksResponseItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(tt__GetTracksResponseItem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__GetTracksResponseItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__GetTracksResponseItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__GetTracksResponseItem*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_TrackToken1 = 1;
	size_t soap_flag_Configuration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:TrackToken", &a->tt__GetTracksResponseItem::TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken1--;
					continue;
				}
			}
			if (soap_flag_Configuration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TrackConfiguration(soap, "tt:Configuration", &a->tt__GetTracksResponseItem::Configuration, "tt:TrackConfiguration"))
				{	soap_flag_Configuration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__GetTracksResponseItem::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackToken1 > 0 || !a->tt__GetTracksResponseItem::Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__GetTracksResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetTracksResponseItem, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(tt__GetTracksResponseItem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__GetTracksResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetTracksResponseItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__GetTracksResponseItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__GetTracksResponseItem *p;
	size_t k = sizeof(tt__GetTracksResponseItem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__GetTracksResponseItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__GetTracksResponseItem);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__GetTracksResponseItem, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__GetTracksResponseItem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__GetTracksResponseItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__GetTracksResponseItem(soap, tag ? tag : "tt:GetTracksResponseItem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__GetTracksResponseItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__GetTracksResponseItem(soap, this, tag, type);
}

SOAP_FMAC3 tt__GetTracksResponseItem * SOAP_FMAC4 soap_get_tt__GetTracksResponseItem(struct soap *soap, tt__GetTracksResponseItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetTracksResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__GetTracksResponseList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__GetTracksResponseItem(soap, &this->tt__GetTracksResponseList::Track);
	soap_default_xsd__anyAttribute(soap, &this->tt__GetTracksResponseList::__anyAttribute);
}

void tt__GetTracksResponseList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__GetTracksResponseItem(soap, &this->tt__GetTracksResponseList::Track);
#endif
}

int tt__GetTracksResponseList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__GetTracksResponseList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetTracksResponseList(struct soap *soap, const char *tag, int id, const tt__GetTracksResponseList *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__GetTracksResponseList*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetTracksResponseList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__GetTracksResponseItem(soap, "tt:Track", -1, &a->tt__GetTracksResponseList::Track, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__GetTracksResponseList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__GetTracksResponseList(soap, tag, this, type);
}

SOAP_FMAC3 tt__GetTracksResponseList * SOAP_FMAC4 soap_in_tt__GetTracksResponseList(struct soap *soap, const char *tag, tt__GetTracksResponseList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__GetTracksResponseList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetTracksResponseList, sizeof(tt__GetTracksResponseList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__GetTracksResponseList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__GetTracksResponseList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__GetTracksResponseList*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__GetTracksResponseItem(soap, "tt:Track", &a->tt__GetTracksResponseList::Track, "tt:GetTracksResponseItem"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__GetTracksResponseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetTracksResponseList, SOAP_TYPE_tt__GetTracksResponseList, sizeof(tt__GetTracksResponseList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__GetTracksResponseList * SOAP_FMAC2 soap_instantiate_tt__GetTracksResponseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__GetTracksResponseList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__GetTracksResponseList *p;
	size_t k = sizeof(tt__GetTracksResponseList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__GetTracksResponseList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__GetTracksResponseList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__GetTracksResponseList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__GetTracksResponseList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__GetTracksResponseList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__GetTracksResponseList(soap, tag ? tag : "tt:GetTracksResponseList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__GetTracksResponseList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__GetTracksResponseList(soap, this, tag, type);
}

SOAP_FMAC3 tt__GetTracksResponseList * SOAP_FMAC4 soap_get_tt__GetTracksResponseList(struct soap *soap, tt__GetTracksResponseList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetTracksResponseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__GetRecordingsResponseItem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &this->tt__GetRecordingsResponseItem::RecordingToken);
	this->tt__GetRecordingsResponseItem::Configuration = NULL;
	this->tt__GetRecordingsResponseItem::Tracks = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__GetRecordingsResponseItem::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__GetRecordingsResponseItem::__anyAttribute);
}

void tt__GetRecordingsResponseItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, &this->tt__GetRecordingsResponseItem::RecordingToken);
	soap_serialize_PointerTott__RecordingConfiguration(soap, &this->tt__GetRecordingsResponseItem::Configuration);
	soap_serialize_PointerTott__GetTracksResponseList(soap, &this->tt__GetRecordingsResponseItem::Tracks);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__GetRecordingsResponseItem::__any);
#endif
}

int tt__GetRecordingsResponseItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__GetRecordingsResponseItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetRecordingsResponseItem(struct soap *soap, const char *tag, int id, const tt__GetRecordingsResponseItem *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__GetRecordingsResponseItem*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetRecordingsResponseItem), type))
		return soap->error;
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->tt__GetRecordingsResponseItem::RecordingToken, ""))
		return soap->error;
	if (!a->tt__GetRecordingsResponseItem::Configuration)
	{	if (soap_element_empty(soap, "tt:Configuration"))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingConfiguration(soap, "tt:Configuration", -1, &a->tt__GetRecordingsResponseItem::Configuration, ""))
		return soap->error;
	if (!a->tt__GetRecordingsResponseItem::Tracks)
	{	if (soap_element_empty(soap, "tt:Tracks"))
			return soap->error;
	}
	else if (soap_out_PointerTott__GetTracksResponseList(soap, "tt:Tracks", -1, &a->tt__GetRecordingsResponseItem::Tracks, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__GetRecordingsResponseItem::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__GetRecordingsResponseItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__GetRecordingsResponseItem(soap, tag, this, type);
}

SOAP_FMAC3 tt__GetRecordingsResponseItem * SOAP_FMAC4 soap_in_tt__GetRecordingsResponseItem(struct soap *soap, const char *tag, tt__GetRecordingsResponseItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__GetRecordingsResponseItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetRecordingsResponseItem, sizeof(tt__GetRecordingsResponseItem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__GetRecordingsResponseItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__GetRecordingsResponseItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__GetRecordingsResponseItem*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RecordingToken1 = 1;
	size_t soap_flag_Configuration1 = 1;
	size_t soap_flag_Tracks1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->tt__GetRecordingsResponseItem::RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken1--;
					continue;
				}
			}
			if (soap_flag_Configuration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingConfiguration(soap, "tt:Configuration", &a->tt__GetRecordingsResponseItem::Configuration, "tt:RecordingConfiguration"))
				{	soap_flag_Configuration1--;
					continue;
				}
			}
			if (soap_flag_Tracks1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GetTracksResponseList(soap, "tt:Tracks", &a->tt__GetRecordingsResponseItem::Tracks, "tt:GetTracksResponseList"))
				{	soap_flag_Tracks1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__GetRecordingsResponseItem::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken1 > 0 || !a->tt__GetRecordingsResponseItem::Configuration || !a->tt__GetRecordingsResponseItem::Tracks))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__GetRecordingsResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetRecordingsResponseItem, SOAP_TYPE_tt__GetRecordingsResponseItem, sizeof(tt__GetRecordingsResponseItem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__GetRecordingsResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetRecordingsResponseItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__GetRecordingsResponseItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__GetRecordingsResponseItem *p;
	size_t k = sizeof(tt__GetRecordingsResponseItem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__GetRecordingsResponseItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__GetRecordingsResponseItem);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__GetRecordingsResponseItem, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__GetRecordingsResponseItem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__GetRecordingsResponseItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__GetRecordingsResponseItem(soap, tag ? tag : "tt:GetRecordingsResponseItem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__GetRecordingsResponseItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__GetRecordingsResponseItem(soap, this, tag, type);
}

SOAP_FMAC3 tt__GetRecordingsResponseItem * SOAP_FMAC4 soap_get_tt__GetRecordingsResponseItem(struct soap *soap, tt__GetRecordingsResponseItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetRecordingsResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TrackConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__TrackType(soap, &this->tt__TrackConfiguration::TrackType);
	soap_default_tt__Description(soap, &this->tt__TrackConfiguration::Description);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__TrackConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__TrackConfiguration::__anyAttribute);
}

void tt__TrackConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Description(soap, &this->tt__TrackConfiguration::Description);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__TrackConfiguration::__any);
#endif
}

int tt__TrackConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TrackConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackConfiguration(struct soap *soap, const char *tag, int id, const tt__TrackConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__TrackConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackConfiguration), type))
		return soap->error;
	if (soap_out_tt__TrackType(soap, "tt:TrackType", -1, &a->tt__TrackConfiguration::TrackType, ""))
		return soap->error;
	if (soap_out_tt__Description(soap, "tt:Description", -1, &a->tt__TrackConfiguration::Description, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__TrackConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__TrackConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TrackConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__TrackConfiguration * SOAP_FMAC4 soap_in_tt__TrackConfiguration(struct soap *soap, const char *tag, tt__TrackConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TrackConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackConfiguration, sizeof(tt__TrackConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TrackConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__TrackConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__TrackConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_TrackType1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__TrackType(soap, "tt:TrackType", &a->tt__TrackConfiguration::TrackType, "tt:TrackType"))
				{	soap_flag_TrackType1--;
					continue;
				}
			}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "tt:Description", &a->tt__TrackConfiguration::Description, "tt:Description"))
				{	soap_flag_Description1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__TrackConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackType1 > 0 || soap_flag_Description1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__TrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackConfiguration, SOAP_TYPE_tt__TrackConfiguration, sizeof(tt__TrackConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TrackConfiguration * SOAP_FMAC2 soap_instantiate_tt__TrackConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TrackConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TrackConfiguration *p;
	size_t k = sizeof(tt__TrackConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TrackConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TrackConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TrackConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TrackConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TrackConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TrackConfiguration(soap, tag ? tag : "tt:TrackConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TrackConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TrackConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__TrackConfiguration * SOAP_FMAC4 soap_get_tt__TrackConfiguration(struct soap *soap, tt__TrackConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__RecordingConfiguration::Source = NULL;
	soap_default_tt__Description(soap, &this->tt__RecordingConfiguration::Content);
	soap_default_xsd__duration(soap, &this->tt__RecordingConfiguration::MaximumRetentionTime);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__RecordingConfiguration::__anyAttribute);
}

void tt__RecordingConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingSourceInformation(soap, &this->tt__RecordingConfiguration::Source);
	soap_serialize_tt__Description(soap, &this->tt__RecordingConfiguration::Content);
	soap_embedded(soap, &this->tt__RecordingConfiguration::MaximumRetentionTime, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__RecordingConfiguration::MaximumRetentionTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingConfiguration::__any);
#endif
}

int tt__RecordingConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingConfiguration(struct soap *soap, const char *tag, int id, const tt__RecordingConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RecordingConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingConfiguration), type))
		return soap->error;
	if (!a->tt__RecordingConfiguration::Source)
	{	if (soap_element_empty(soap, "tt:Source"))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingSourceInformation(soap, "tt:Source", -1, &a->tt__RecordingConfiguration::Source, ""))
		return soap->error;
	if (soap_out_tt__Description(soap, "tt:Content", -1, &a->tt__RecordingConfiguration::Content, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:MaximumRetentionTime", -1, &a->tt__RecordingConfiguration::MaximumRetentionTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RecordingConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingConfiguration * SOAP_FMAC4 soap_in_tt__RecordingConfiguration(struct soap *soap, const char *tag, tt__RecordingConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingConfiguration, sizeof(tt__RecordingConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RecordingConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Source1 = 1;
	size_t soap_flag_Content1 = 1;
	size_t soap_flag_MaximumRetentionTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingSourceInformation(soap, "tt:Source", &a->tt__RecordingConfiguration::Source, "tt:RecordingSourceInformation"))
				{	soap_flag_Source1--;
					continue;
				}
			}
			if (soap_flag_Content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "tt:Content", &a->tt__RecordingConfiguration::Content, "tt:Description"))
				{	soap_flag_Content1--;
					continue;
				}
			}
			if (soap_flag_MaximumRetentionTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:MaximumRetentionTime", &a->tt__RecordingConfiguration::MaximumRetentionTime, "xsd:duration"))
				{	soap_flag_MaximumRetentionTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RecordingConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__RecordingConfiguration::Source || soap_flag_Content1 > 0 || soap_flag_MaximumRetentionTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingConfiguration, SOAP_TYPE_tt__RecordingConfiguration, sizeof(tt__RecordingConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingConfiguration * SOAP_FMAC2 soap_instantiate_tt__RecordingConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingConfiguration *p;
	size_t k = sizeof(tt__RecordingConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingConfiguration(soap, tag ? tag : "tt:RecordingConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingConfiguration * SOAP_FMAC4 soap_get_tt__RecordingConfiguration(struct soap *soap, tt__RecordingConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataAttributes::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__MetadataAttributes::CanContainPTZ);
	soap_default_bool(soap, &this->tt__MetadataAttributes::CanContainAnalytics);
	soap_default_bool(soap, &this->tt__MetadataAttributes::CanContainNotifications);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataAttributes::__any);
	this->tt__MetadataAttributes::PtzSpaces = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__MetadataAttributes::__anyAttribute);
}

void tt__MetadataAttributes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__MetadataAttributes::CanContainPTZ, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__MetadataAttributes::CanContainAnalytics, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__MetadataAttributes::CanContainNotifications, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataAttributes::__any);
#endif
}

int tt__MetadataAttributes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataAttributes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataAttributes(struct soap *soap, const char *tag, int id, const tt__MetadataAttributes *a, const char *type)
{
	if (((tt__MetadataAttributes*)a)->PtzSpaces)
	{	soap_set_attr(soap, "PtzSpaces", soap_tt__StringAttrList2s(soap, *((tt__MetadataAttributes*)a)->PtzSpaces), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MetadataAttributes*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataAttributes), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:CanContainPTZ", -1, &a->tt__MetadataAttributes::CanContainPTZ, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:CanContainAnalytics", -1, &a->tt__MetadataAttributes::CanContainAnalytics, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:CanContainNotifications", -1, &a->tt__MetadataAttributes::CanContainNotifications, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MetadataAttributes::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataAttributes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataAttributes(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataAttributes * SOAP_FMAC4 soap_in_tt__MetadataAttributes(struct soap *soap, const char *tag, tt__MetadataAttributes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataAttributes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataAttributes, sizeof(tt__MetadataAttributes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataAttributes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataAttributes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "PtzSpaces", 1, 0);
		if (t)
		{
			if (!(((tt__MetadataAttributes*)a)->PtzSpaces = soap_new_tt__StringAttrList(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__StringAttrList(soap, t, ((tt__MetadataAttributes*)a)->PtzSpaces))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MetadataAttributes*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_CanContainPTZ1 = 1;
	size_t soap_flag_CanContainAnalytics1 = 1;
	size_t soap_flag_CanContainNotifications1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanContainPTZ1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:CanContainPTZ", &a->tt__MetadataAttributes::CanContainPTZ, "xsd:boolean"))
				{	soap_flag_CanContainPTZ1--;
					continue;
				}
			}
			if (soap_flag_CanContainAnalytics1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:CanContainAnalytics", &a->tt__MetadataAttributes::CanContainAnalytics, "xsd:boolean"))
				{	soap_flag_CanContainAnalytics1--;
					continue;
				}
			}
			if (soap_flag_CanContainNotifications1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:CanContainNotifications", &a->tt__MetadataAttributes::CanContainNotifications, "xsd:boolean"))
				{	soap_flag_CanContainNotifications1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MetadataAttributes::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanContainPTZ1 > 0 || soap_flag_CanContainAnalytics1 > 0 || soap_flag_CanContainNotifications1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MetadataAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataAttributes, SOAP_TYPE_tt__MetadataAttributes, sizeof(tt__MetadataAttributes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataAttributes * SOAP_FMAC2 soap_instantiate_tt__MetadataAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataAttributes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataAttributes *p;
	size_t k = sizeof(tt__MetadataAttributes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataAttributes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataAttributes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataAttributes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataAttributes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataAttributes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataAttributes(soap, tag ? tag : "tt:MetadataAttributes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataAttributes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataAttributes(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataAttributes * SOAP_FMAC4 soap_get_tt__MetadataAttributes(struct soap *soap, tt__MetadataAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioAttributes::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__AudioAttributes::Bitrate = NULL;
	soap_default_std__string(soap, &this->tt__AudioAttributes::Encoding);
	soap_default_int(soap, &this->tt__AudioAttributes::Samplerate);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioAttributes::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioAttributes::__anyAttribute);
}

void tt__AudioAttributes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->tt__AudioAttributes::Bitrate);
	soap_embedded(soap, &this->tt__AudioAttributes::Encoding, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__AudioAttributes::Encoding);
	soap_embedded(soap, &this->tt__AudioAttributes::Samplerate, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioAttributes::__any);
#endif
}

int tt__AudioAttributes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioAttributes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioAttributes(struct soap *soap, const char *tag, int id, const tt__AudioAttributes *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioAttributes*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioAttributes), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Bitrate", -1, &a->tt__AudioAttributes::Bitrate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Encoding", -1, &a->tt__AudioAttributes::Encoding, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Samplerate", -1, &a->tt__AudioAttributes::Samplerate, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioAttributes::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioAttributes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioAttributes(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioAttributes * SOAP_FMAC4 soap_in_tt__AudioAttributes(struct soap *soap, const char *tag, tt__AudioAttributes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioAttributes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioAttributes, sizeof(tt__AudioAttributes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioAttributes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioAttributes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioAttributes*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Samplerate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:Bitrate", &a->tt__AudioAttributes::Bitrate, "xsd:int"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			}
			if (soap_flag_Encoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Encoding", &a->tt__AudioAttributes::Encoding, "xsd:string"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_Samplerate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Samplerate", &a->tt__AudioAttributes::Samplerate, "xsd:int"))
				{	soap_flag_Samplerate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioAttributes::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding1 > 0 || soap_flag_Samplerate1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioAttributes, SOAP_TYPE_tt__AudioAttributes, sizeof(tt__AudioAttributes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioAttributes * SOAP_FMAC2 soap_instantiate_tt__AudioAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioAttributes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioAttributes *p;
	size_t k = sizeof(tt__AudioAttributes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioAttributes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioAttributes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioAttributes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioAttributes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioAttributes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioAttributes(soap, tag ? tag : "tt:AudioAttributes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioAttributes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioAttributes(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioAttributes * SOAP_FMAC4 soap_get_tt__AudioAttributes(struct soap *soap, tt__AudioAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoAttributes::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__VideoAttributes::Bitrate = NULL;
	soap_default_int(soap, &this->tt__VideoAttributes::Width);
	soap_default_int(soap, &this->tt__VideoAttributes::Height);
	soap_default_std__string(soap, &this->tt__VideoAttributes::Encoding);
	soap_default_float(soap, &this->tt__VideoAttributes::Framerate);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoAttributes::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoAttributes::__anyAttribute);
}

void tt__VideoAttributes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->tt__VideoAttributes::Bitrate);
	soap_embedded(soap, &this->tt__VideoAttributes::Width, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoAttributes::Height, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoAttributes::Encoding, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__VideoAttributes::Encoding);
	soap_embedded(soap, &this->tt__VideoAttributes::Framerate, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoAttributes::__any);
#endif
}

int tt__VideoAttributes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoAttributes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAttributes(struct soap *soap, const char *tag, int id, const tt__VideoAttributes *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoAttributes*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAttributes), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Bitrate", -1, &a->tt__VideoAttributes::Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &a->tt__VideoAttributes::Width, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &a->tt__VideoAttributes::Height, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Encoding", -1, &a->tt__VideoAttributes::Encoding, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Framerate", -1, &a->tt__VideoAttributes::Framerate, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoAttributes::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoAttributes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoAttributes(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoAttributes * SOAP_FMAC4 soap_in_tt__VideoAttributes(struct soap *soap, const char *tag, tt__VideoAttributes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoAttributes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAttributes, sizeof(tt__VideoAttributes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoAttributes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoAttributes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoAttributes*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_Width1 = 1;
	size_t soap_flag_Height1 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Framerate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:Bitrate", &a->tt__VideoAttributes::Bitrate, "xsd:int"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			}
			if (soap_flag_Width1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Width", &a->tt__VideoAttributes::Width, "xsd:int"))
				{	soap_flag_Width1--;
					continue;
				}
			}
			if (soap_flag_Height1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Height", &a->tt__VideoAttributes::Height, "xsd:int"))
				{	soap_flag_Height1--;
					continue;
				}
			}
			if (soap_flag_Encoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Encoding", &a->tt__VideoAttributes::Encoding, "xsd:string"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_Framerate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Framerate", &a->tt__VideoAttributes::Framerate, "xsd:float"))
				{	soap_flag_Framerate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoAttributes::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width1 > 0 || soap_flag_Height1 > 0 || soap_flag_Encoding1 > 0 || soap_flag_Framerate1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAttributes, SOAP_TYPE_tt__VideoAttributes, sizeof(tt__VideoAttributes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoAttributes * SOAP_FMAC2 soap_instantiate_tt__VideoAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoAttributes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoAttributes *p;
	size_t k = sizeof(tt__VideoAttributes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoAttributes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoAttributes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoAttributes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoAttributes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoAttributes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoAttributes(soap, tag ? tag : "tt:VideoAttributes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoAttributes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoAttributes(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoAttributes * SOAP_FMAC4 soap_get_tt__VideoAttributes(struct soap *soap, tt__VideoAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TrackAttributesExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__TrackAttributesExtension::__any);
}

void tt__TrackAttributesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__TrackAttributesExtension::__any);
#endif
}

int tt__TrackAttributesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TrackAttributesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackAttributesExtension(struct soap *soap, const char *tag, int id, const tt__TrackAttributesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackAttributesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__TrackAttributesExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__TrackAttributesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TrackAttributesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__TrackAttributesExtension * SOAP_FMAC4 soap_in_tt__TrackAttributesExtension(struct soap *soap, const char *tag, tt__TrackAttributesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TrackAttributesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(tt__TrackAttributesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TrackAttributesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__TrackAttributesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__TrackAttributesExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__TrackAttributesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackAttributesExtension, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(tt__TrackAttributesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TrackAttributesExtension * SOAP_FMAC2 soap_instantiate_tt__TrackAttributesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TrackAttributesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TrackAttributesExtension *p;
	size_t k = sizeof(tt__TrackAttributesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TrackAttributesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TrackAttributesExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TrackAttributesExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TrackAttributesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TrackAttributesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TrackAttributesExtension(soap, tag ? tag : "tt:TrackAttributesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TrackAttributesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TrackAttributesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__TrackAttributesExtension * SOAP_FMAC4 soap_get_tt__TrackAttributesExtension(struct soap *soap, tt__TrackAttributesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackAttributesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TrackAttributes::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__TrackAttributes::TrackInformation = NULL;
	this->tt__TrackAttributes::VideoAttributes = NULL;
	this->tt__TrackAttributes::AudioAttributes = NULL;
	this->tt__TrackAttributes::MetadataAttributes = NULL;
	this->tt__TrackAttributes::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__TrackAttributes::__anyAttribute);
}

void tt__TrackAttributes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__TrackInformation(soap, &this->tt__TrackAttributes::TrackInformation);
	soap_serialize_PointerTott__VideoAttributes(soap, &this->tt__TrackAttributes::VideoAttributes);
	soap_serialize_PointerTott__AudioAttributes(soap, &this->tt__TrackAttributes::AudioAttributes);
	soap_serialize_PointerTott__MetadataAttributes(soap, &this->tt__TrackAttributes::MetadataAttributes);
	soap_serialize_PointerTott__TrackAttributesExtension(soap, &this->tt__TrackAttributes::Extension);
#endif
}

int tt__TrackAttributes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TrackAttributes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackAttributes(struct soap *soap, const char *tag, int id, const tt__TrackAttributes *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__TrackAttributes*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackAttributes), type))
		return soap->error;
	if (!a->tt__TrackAttributes::TrackInformation)
	{	if (soap_element_empty(soap, "tt:TrackInformation"))
			return soap->error;
	}
	else if (soap_out_PointerTott__TrackInformation(soap, "tt:TrackInformation", -1, &a->tt__TrackAttributes::TrackInformation, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoAttributes(soap, "tt:VideoAttributes", -1, &a->tt__TrackAttributes::VideoAttributes, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioAttributes(soap, "tt:AudioAttributes", -1, &a->tt__TrackAttributes::AudioAttributes, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataAttributes(soap, "tt:MetadataAttributes", -1, &a->tt__TrackAttributes::MetadataAttributes, ""))
		return soap->error;
	if (soap_out_PointerTott__TrackAttributesExtension(soap, "tt:Extension", -1, &a->tt__TrackAttributes::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__TrackAttributes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TrackAttributes(soap, tag, this, type);
}

SOAP_FMAC3 tt__TrackAttributes * SOAP_FMAC4 soap_in_tt__TrackAttributes(struct soap *soap, const char *tag, tt__TrackAttributes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TrackAttributes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackAttributes, sizeof(tt__TrackAttributes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TrackAttributes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__TrackAttributes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__TrackAttributes*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_TrackInformation1 = 1;
	size_t soap_flag_VideoAttributes1 = 1;
	size_t soap_flag_AudioAttributes1 = 1;
	size_t soap_flag_MetadataAttributes1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TrackInformation(soap, "tt:TrackInformation", &a->tt__TrackAttributes::TrackInformation, "tt:TrackInformation"))
				{	soap_flag_TrackInformation1--;
					continue;
				}
			}
			if (soap_flag_VideoAttributes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoAttributes(soap, "tt:VideoAttributes", &a->tt__TrackAttributes::VideoAttributes, "tt:VideoAttributes"))
				{	soap_flag_VideoAttributes1--;
					continue;
				}
			}
			if (soap_flag_AudioAttributes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioAttributes(soap, "tt:AudioAttributes", &a->tt__TrackAttributes::AudioAttributes, "tt:AudioAttributes"))
				{	soap_flag_AudioAttributes1--;
					continue;
				}
			}
			if (soap_flag_MetadataAttributes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataAttributes(soap, "tt:MetadataAttributes", &a->tt__TrackAttributes::MetadataAttributes, "tt:MetadataAttributes"))
				{	soap_flag_MetadataAttributes1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TrackAttributesExtension(soap, "tt:Extension", &a->tt__TrackAttributes::Extension, "tt:TrackAttributesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__TrackAttributes::TrackInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__TrackAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackAttributes, SOAP_TYPE_tt__TrackAttributes, sizeof(tt__TrackAttributes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TrackAttributes * SOAP_FMAC2 soap_instantiate_tt__TrackAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TrackAttributes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TrackAttributes *p;
	size_t k = sizeof(tt__TrackAttributes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TrackAttributes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TrackAttributes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TrackAttributes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TrackAttributes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TrackAttributes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TrackAttributes(soap, tag ? tag : "tt:TrackAttributes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TrackAttributes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TrackAttributes(soap, this, tag, type);
}

SOAP_FMAC3 tt__TrackAttributes * SOAP_FMAC4 soap_get_tt__TrackAttributes(struct soap *soap, tt__TrackAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MediaAttributes::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &this->tt__MediaAttributes::RecordingToken);
	soap_default_std__vectorTemplateOfPointerTott__TrackAttributes(soap, &this->tt__MediaAttributes::TrackAttributes);
	soap_default_xsd__dateTime(soap, &this->tt__MediaAttributes::From);
	soap_default_xsd__dateTime(soap, &this->tt__MediaAttributes::Until);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaAttributes::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__MediaAttributes::__anyAttribute);
}

void tt__MediaAttributes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, &this->tt__MediaAttributes::RecordingToken);
	soap_serialize_std__vectorTemplateOfPointerTott__TrackAttributes(soap, &this->tt__MediaAttributes::TrackAttributes);
	soap_embedded(soap, &this->tt__MediaAttributes::From, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->tt__MediaAttributes::From);
	soap_embedded(soap, &this->tt__MediaAttributes::Until, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->tt__MediaAttributes::Until);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaAttributes::__any);
#endif
}

int tt__MediaAttributes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaAttributes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaAttributes(struct soap *soap, const char *tag, int id, const tt__MediaAttributes *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MediaAttributes*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaAttributes), type))
		return soap->error;
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->tt__MediaAttributes::RecordingToken, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__TrackAttributes(soap, "tt:TrackAttributes", -1, &a->tt__MediaAttributes::TrackAttributes, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tt:From", -1, &a->tt__MediaAttributes::From, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tt:Until", -1, &a->tt__MediaAttributes::Until, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MediaAttributes::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MediaAttributes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MediaAttributes(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaAttributes * SOAP_FMAC4 soap_in_tt__MediaAttributes(struct soap *soap, const char *tag, tt__MediaAttributes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaAttributes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaAttributes, sizeof(tt__MediaAttributes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MediaAttributes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MediaAttributes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MediaAttributes*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RecordingToken1 = 1;
	size_t soap_flag_From1 = 1;
	size_t soap_flag_Until1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->tt__MediaAttributes::RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__TrackAttributes(soap, "tt:TrackAttributes", &a->tt__MediaAttributes::TrackAttributes, "tt:TrackAttributes"))
					continue;
			}
			if (soap_flag_From1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tt:From", &a->tt__MediaAttributes::From, "xsd:dateTime"))
				{	soap_flag_From1--;
					continue;
				}
			}
			if (soap_flag_Until1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tt:Until", &a->tt__MediaAttributes::Until, "xsd:dateTime"))
				{	soap_flag_Until1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MediaAttributes::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken1 > 0 || soap_flag_From1 > 0 || soap_flag_Until1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MediaAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaAttributes, SOAP_TYPE_tt__MediaAttributes, sizeof(tt__MediaAttributes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaAttributes * SOAP_FMAC2 soap_instantiate_tt__MediaAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaAttributes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MediaAttributes *p;
	size_t k = sizeof(tt__MediaAttributes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MediaAttributes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MediaAttributes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MediaAttributes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MediaAttributes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MediaAttributes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MediaAttributes(soap, tag ? tag : "tt:MediaAttributes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaAttributes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaAttributes(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaAttributes * SOAP_FMAC4 soap_get_tt__MediaAttributes(struct soap *soap, tt__MediaAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TrackInformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__TrackReference(soap, &this->tt__TrackInformation::TrackToken);
	soap_default_tt__TrackType(soap, &this->tt__TrackInformation::TrackType);
	soap_default_tt__Description(soap, &this->tt__TrackInformation::Description);
	soap_default_xsd__dateTime(soap, &this->tt__TrackInformation::DataFrom);
	soap_default_xsd__dateTime(soap, &this->tt__TrackInformation::DataTo);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__TrackInformation::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__TrackInformation::__anyAttribute);
}

void tt__TrackInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__TrackReference(soap, &this->tt__TrackInformation::TrackToken);
	soap_serialize_tt__Description(soap, &this->tt__TrackInformation::Description);
	soap_embedded(soap, &this->tt__TrackInformation::DataFrom, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->tt__TrackInformation::DataFrom);
	soap_embedded(soap, &this->tt__TrackInformation::DataTo, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->tt__TrackInformation::DataTo);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__TrackInformation::__any);
#endif
}

int tt__TrackInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TrackInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackInformation(struct soap *soap, const char *tag, int id, const tt__TrackInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__TrackInformation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackInformation), type))
		return soap->error;
	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, &a->tt__TrackInformation::TrackToken, ""))
		return soap->error;
	if (soap_out_tt__TrackType(soap, "tt:TrackType", -1, &a->tt__TrackInformation::TrackType, ""))
		return soap->error;
	if (soap_out_tt__Description(soap, "tt:Description", -1, &a->tt__TrackInformation::Description, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tt:DataFrom", -1, &a->tt__TrackInformation::DataFrom, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tt:DataTo", -1, &a->tt__TrackInformation::DataTo, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__TrackInformation::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__TrackInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TrackInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__TrackInformation * SOAP_FMAC4 soap_in_tt__TrackInformation(struct soap *soap, const char *tag, tt__TrackInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TrackInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackInformation, sizeof(tt__TrackInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TrackInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__TrackInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__TrackInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_TrackToken1 = 1;
	size_t soap_flag_TrackType1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_DataFrom1 = 1;
	size_t soap_flag_DataTo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:TrackToken", &a->tt__TrackInformation::TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken1--;
					continue;
				}
			}
			if (soap_flag_TrackType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__TrackType(soap, "tt:TrackType", &a->tt__TrackInformation::TrackType, "tt:TrackType"))
				{	soap_flag_TrackType1--;
					continue;
				}
			}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "tt:Description", &a->tt__TrackInformation::Description, "tt:Description"))
				{	soap_flag_Description1--;
					continue;
				}
			}
			if (soap_flag_DataFrom1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tt:DataFrom", &a->tt__TrackInformation::DataFrom, "xsd:dateTime"))
				{	soap_flag_DataFrom1--;
					continue;
				}
			}
			if (soap_flag_DataTo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tt:DataTo", &a->tt__TrackInformation::DataTo, "xsd:dateTime"))
				{	soap_flag_DataTo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__TrackInformation::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackToken1 > 0 || soap_flag_TrackType1 > 0 || soap_flag_Description1 > 0 || soap_flag_DataFrom1 > 0 || soap_flag_DataTo1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__TrackInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackInformation, SOAP_TYPE_tt__TrackInformation, sizeof(tt__TrackInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TrackInformation * SOAP_FMAC2 soap_instantiate_tt__TrackInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TrackInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TrackInformation *p;
	size_t k = sizeof(tt__TrackInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TrackInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TrackInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TrackInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TrackInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TrackInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TrackInformation(soap, tag ? tag : "tt:TrackInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TrackInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TrackInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__TrackInformation * SOAP_FMAC4 soap_get_tt__TrackInformation(struct soap *soap, tt__TrackInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingSourceInformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__RecordingSourceInformation::SourceId);
	soap_default_tt__Name(soap, &this->tt__RecordingSourceInformation::Name);
	soap_default_tt__Description(soap, &this->tt__RecordingSourceInformation::Location);
	soap_default_tt__Description(soap, &this->tt__RecordingSourceInformation::Description);
	soap_default_xsd__anyURI(soap, &this->tt__RecordingSourceInformation::Address);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingSourceInformation::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__RecordingSourceInformation::__anyAttribute);
}

void tt__RecordingSourceInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RecordingSourceInformation::SourceId, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__RecordingSourceInformation::SourceId);
	soap_embedded(soap, &this->tt__RecordingSourceInformation::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__RecordingSourceInformation::Name);
	soap_serialize_tt__Description(soap, &this->tt__RecordingSourceInformation::Location);
	soap_serialize_tt__Description(soap, &this->tt__RecordingSourceInformation::Description);
	soap_embedded(soap, &this->tt__RecordingSourceInformation::Address, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__RecordingSourceInformation::Address);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingSourceInformation::__any);
#endif
}

int tt__RecordingSourceInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingSourceInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingSourceInformation(struct soap *soap, const char *tag, int id, const tt__RecordingSourceInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RecordingSourceInformation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingSourceInformation), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:SourceId", -1, &a->tt__RecordingSourceInformation::SourceId, ""))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__RecordingSourceInformation::Name, ""))
		return soap->error;
	if (soap_out_tt__Description(soap, "tt:Location", -1, &a->tt__RecordingSourceInformation::Location, ""))
		return soap->error;
	if (soap_out_tt__Description(soap, "tt:Description", -1, &a->tt__RecordingSourceInformation::Description, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:Address", -1, &a->tt__RecordingSourceInformation::Address, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RecordingSourceInformation::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingSourceInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingSourceInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingSourceInformation * SOAP_FMAC4 soap_in_tt__RecordingSourceInformation(struct soap *soap, const char *tag, tt__RecordingSourceInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingSourceInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(tt__RecordingSourceInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingSourceInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingSourceInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RecordingSourceInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SourceId1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Location1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Address1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:SourceId", &a->tt__RecordingSourceInformation::SourceId, "xsd:anyURI"))
				{	soap_flag_SourceId1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__RecordingSourceInformation::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "tt:Location", &a->tt__RecordingSourceInformation::Location, "tt:Description"))
				{	soap_flag_Location1--;
					continue;
				}
			}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "tt:Description", &a->tt__RecordingSourceInformation::Description, "tt:Description"))
				{	soap_flag_Description1--;
					continue;
				}
			}
			if (soap_flag_Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Address", &a->tt__RecordingSourceInformation::Address, "xsd:anyURI"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RecordingSourceInformation::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SourceId1 > 0 || soap_flag_Name1 > 0 || soap_flag_Location1 > 0 || soap_flag_Description1 > 0 || soap_flag_Address1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RecordingSourceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingSourceInformation, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(tt__RecordingSourceInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingSourceInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingSourceInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingSourceInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingSourceInformation *p;
	size_t k = sizeof(tt__RecordingSourceInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingSourceInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingSourceInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingSourceInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingSourceInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingSourceInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingSourceInformation(soap, tag ? tag : "tt:RecordingSourceInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingSourceInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingSourceInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingSourceInformation * SOAP_FMAC4 soap_get_tt__RecordingSourceInformation(struct soap *soap, tt__RecordingSourceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingSourceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingInformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &this->tt__RecordingInformation::RecordingToken);
	this->tt__RecordingInformation::Source = NULL;
	this->tt__RecordingInformation::EarliestRecording = NULL;
	this->tt__RecordingInformation::LatestRecording = NULL;
	soap_default_tt__Description(soap, &this->tt__RecordingInformation::Content);
	soap_default_std__vectorTemplateOfPointerTott__TrackInformation(soap, &this->tt__RecordingInformation::Track);
	soap_default_tt__RecordingStatus(soap, &this->tt__RecordingInformation::RecordingStatus);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingInformation::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__RecordingInformation::__anyAttribute);
}

void tt__RecordingInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, &this->tt__RecordingInformation::RecordingToken);
	soap_serialize_PointerTott__RecordingSourceInformation(soap, &this->tt__RecordingInformation::Source);
	soap_serialize_PointerToxsd__dateTime(soap, &this->tt__RecordingInformation::EarliestRecording);
	soap_serialize_PointerToxsd__dateTime(soap, &this->tt__RecordingInformation::LatestRecording);
	soap_serialize_tt__Description(soap, &this->tt__RecordingInformation::Content);
	soap_serialize_std__vectorTemplateOfPointerTott__TrackInformation(soap, &this->tt__RecordingInformation::Track);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingInformation::__any);
#endif
}

int tt__RecordingInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingInformation(struct soap *soap, const char *tag, int id, const tt__RecordingInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RecordingInformation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingInformation), type))
		return soap->error;
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->tt__RecordingInformation::RecordingToken, ""))
		return soap->error;
	if (!a->tt__RecordingInformation::Source)
	{	if (soap_element_empty(soap, "tt:Source"))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingSourceInformation(soap, "tt:Source", -1, &a->tt__RecordingInformation::Source, ""))
		return soap->error;
	if (soap_out_PointerToxsd__dateTime(soap, "tt:EarliestRecording", -1, &a->tt__RecordingInformation::EarliestRecording, ""))
		return soap->error;
	if (soap_out_PointerToxsd__dateTime(soap, "tt:LatestRecording", -1, &a->tt__RecordingInformation::LatestRecording, ""))
		return soap->error;
	if (soap_out_tt__Description(soap, "tt:Content", -1, &a->tt__RecordingInformation::Content, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__TrackInformation(soap, "tt:Track", -1, &a->tt__RecordingInformation::Track, ""))
		return soap->error;
	if (soap_out_tt__RecordingStatus(soap, "tt:RecordingStatus", -1, &a->tt__RecordingInformation::RecordingStatus, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RecordingInformation::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingInformation * SOAP_FMAC4 soap_in_tt__RecordingInformation(struct soap *soap, const char *tag, tt__RecordingInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingInformation, sizeof(tt__RecordingInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RecordingInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RecordingToken1 = 1;
	size_t soap_flag_Source1 = 1;
	size_t soap_flag_EarliestRecording1 = 1;
	size_t soap_flag_LatestRecording1 = 1;
	size_t soap_flag_Content1 = 1;
	size_t soap_flag_RecordingStatus1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->tt__RecordingInformation::RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken1--;
					continue;
				}
			}
			if (soap_flag_Source1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingSourceInformation(soap, "tt:Source", &a->tt__RecordingInformation::Source, "tt:RecordingSourceInformation"))
				{	soap_flag_Source1--;
					continue;
				}
			}
			if (soap_flag_EarliestRecording1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__dateTime(soap, "tt:EarliestRecording", &a->tt__RecordingInformation::EarliestRecording, "xsd:dateTime"))
				{	soap_flag_EarliestRecording1--;
					continue;
				}
			}
			if (soap_flag_LatestRecording1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__dateTime(soap, "tt:LatestRecording", &a->tt__RecordingInformation::LatestRecording, "xsd:dateTime"))
				{	soap_flag_LatestRecording1--;
					continue;
				}
			}
			if (soap_flag_Content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "tt:Content", &a->tt__RecordingInformation::Content, "tt:Description"))
				{	soap_flag_Content1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__TrackInformation(soap, "tt:Track", &a->tt__RecordingInformation::Track, "tt:TrackInformation"))
					continue;
			}
			if (soap_flag_RecordingStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RecordingStatus(soap, "tt:RecordingStatus", &a->tt__RecordingInformation::RecordingStatus, "tt:RecordingStatus"))
				{	soap_flag_RecordingStatus1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RecordingInformation::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken1 > 0 || !a->tt__RecordingInformation::Source || soap_flag_Content1 > 0 || soap_flag_RecordingStatus1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RecordingInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingInformation, SOAP_TYPE_tt__RecordingInformation, sizeof(tt__RecordingInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingInformation *p;
	size_t k = sizeof(tt__RecordingInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingInformation(soap, tag ? tag : "tt:RecordingInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingInformation * SOAP_FMAC4 soap_get_tt__RecordingInformation(struct soap *soap, tt__RecordingInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FindMetadataResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &this->tt__FindMetadataResult::RecordingToken);
	soap_default_tt__TrackReference(soap, &this->tt__FindMetadataResult::TrackToken);
	soap_default_xsd__dateTime(soap, &this->tt__FindMetadataResult::Time);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FindMetadataResult::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__FindMetadataResult::__anyAttribute);
}

void tt__FindMetadataResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, &this->tt__FindMetadataResult::RecordingToken);
	soap_serialize_tt__TrackReference(soap, &this->tt__FindMetadataResult::TrackToken);
	soap_embedded(soap, &this->tt__FindMetadataResult::Time, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->tt__FindMetadataResult::Time);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FindMetadataResult::__any);
#endif
}

int tt__FindMetadataResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FindMetadataResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindMetadataResult(struct soap *soap, const char *tag, int id, const tt__FindMetadataResult *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__FindMetadataResult*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindMetadataResult), type))
		return soap->error;
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->tt__FindMetadataResult::RecordingToken, ""))
		return soap->error;
	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, &a->tt__FindMetadataResult::TrackToken, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tt:Time", -1, &a->tt__FindMetadataResult::Time, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__FindMetadataResult::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FindMetadataResult::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FindMetadataResult(soap, tag, this, type);
}

SOAP_FMAC3 tt__FindMetadataResult * SOAP_FMAC4 soap_in_tt__FindMetadataResult(struct soap *soap, const char *tag, tt__FindMetadataResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FindMetadataResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindMetadataResult, sizeof(tt__FindMetadataResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FindMetadataResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FindMetadataResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__FindMetadataResult*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RecordingToken1 = 1;
	size_t soap_flag_TrackToken1 = 1;
	size_t soap_flag_Time1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->tt__FindMetadataResult::RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken1--;
					continue;
				}
			}
			if (soap_flag_TrackToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:TrackToken", &a->tt__FindMetadataResult::TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken1--;
					continue;
				}
			}
			if (soap_flag_Time1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tt:Time", &a->tt__FindMetadataResult::Time, "xsd:dateTime"))
				{	soap_flag_Time1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__FindMetadataResult::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken1 > 0 || soap_flag_TrackToken1 > 0 || soap_flag_Time1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FindMetadataResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindMetadataResult, SOAP_TYPE_tt__FindMetadataResult, sizeof(tt__FindMetadataResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FindMetadataResult * SOAP_FMAC2 soap_instantiate_tt__FindMetadataResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FindMetadataResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FindMetadataResult *p;
	size_t k = sizeof(tt__FindMetadataResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FindMetadataResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FindMetadataResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FindMetadataResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FindMetadataResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FindMetadataResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FindMetadataResult(soap, tag ? tag : "tt:FindMetadataResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FindMetadataResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FindMetadataResult(soap, this, tag, type);
}

SOAP_FMAC3 tt__FindMetadataResult * SOAP_FMAC4 soap_get_tt__FindMetadataResult(struct soap *soap, tt__FindMetadataResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FindMetadataResultList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &this->tt__FindMetadataResultList::SearchState);
	soap_default_std__vectorTemplateOfPointerTott__FindMetadataResult(soap, &this->tt__FindMetadataResultList::Result);
}

void tt__FindMetadataResultList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__FindMetadataResult(soap, &this->tt__FindMetadataResultList::Result);
#endif
}

int tt__FindMetadataResultList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FindMetadataResultList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindMetadataResultList(struct soap *soap, const char *tag, int id, const tt__FindMetadataResultList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindMetadataResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->tt__FindMetadataResultList::SearchState, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__FindMetadataResult(soap, "tt:Result", -1, &a->tt__FindMetadataResultList::Result, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FindMetadataResultList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FindMetadataResultList(soap, tag, this, type);
}

SOAP_FMAC3 tt__FindMetadataResultList * SOAP_FMAC4 soap_in_tt__FindMetadataResultList(struct soap *soap, const char *tag, tt__FindMetadataResultList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FindMetadataResultList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindMetadataResultList, sizeof(tt__FindMetadataResultList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FindMetadataResultList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FindMetadataResultList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SearchState1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->tt__FindMetadataResultList::SearchState, "tt:SearchState"))
				{	soap_flag_SearchState1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__FindMetadataResult(soap, "tt:Result", &a->tt__FindMetadataResultList::Result, "tt:FindMetadataResult"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FindMetadataResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindMetadataResultList, SOAP_TYPE_tt__FindMetadataResultList, sizeof(tt__FindMetadataResultList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FindMetadataResultList * SOAP_FMAC2 soap_instantiate_tt__FindMetadataResultList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FindMetadataResultList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FindMetadataResultList *p;
	size_t k = sizeof(tt__FindMetadataResultList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FindMetadataResultList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FindMetadataResultList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FindMetadataResultList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FindMetadataResultList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FindMetadataResultList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FindMetadataResultList(soap, tag ? tag : "tt:FindMetadataResultList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FindMetadataResultList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FindMetadataResultList(soap, this, tag, type);
}

SOAP_FMAC3 tt__FindMetadataResultList * SOAP_FMAC4 soap_get_tt__FindMetadataResultList(struct soap *soap, tt__FindMetadataResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindMetadataResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FindPTZPositionResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &this->tt__FindPTZPositionResult::RecordingToken);
	soap_default_tt__TrackReference(soap, &this->tt__FindPTZPositionResult::TrackToken);
	soap_default_xsd__dateTime(soap, &this->tt__FindPTZPositionResult::Time);
	this->tt__FindPTZPositionResult::Position = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FindPTZPositionResult::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__FindPTZPositionResult::__anyAttribute);
}

void tt__FindPTZPositionResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, &this->tt__FindPTZPositionResult::RecordingToken);
	soap_serialize_tt__TrackReference(soap, &this->tt__FindPTZPositionResult::TrackToken);
	soap_embedded(soap, &this->tt__FindPTZPositionResult::Time, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->tt__FindPTZPositionResult::Time);
	soap_serialize_PointerTott__PTZVector(soap, &this->tt__FindPTZPositionResult::Position);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FindPTZPositionResult::__any);
#endif
}

int tt__FindPTZPositionResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FindPTZPositionResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindPTZPositionResult(struct soap *soap, const char *tag, int id, const tt__FindPTZPositionResult *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__FindPTZPositionResult*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindPTZPositionResult), type))
		return soap->error;
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->tt__FindPTZPositionResult::RecordingToken, ""))
		return soap->error;
	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, &a->tt__FindPTZPositionResult::TrackToken, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tt:Time", -1, &a->tt__FindPTZPositionResult::Time, ""))
		return soap->error;
	if (!a->tt__FindPTZPositionResult::Position)
	{	if (soap_element_empty(soap, "tt:Position"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZVector(soap, "tt:Position", -1, &a->tt__FindPTZPositionResult::Position, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__FindPTZPositionResult::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FindPTZPositionResult::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FindPTZPositionResult(soap, tag, this, type);
}

SOAP_FMAC3 tt__FindPTZPositionResult * SOAP_FMAC4 soap_in_tt__FindPTZPositionResult(struct soap *soap, const char *tag, tt__FindPTZPositionResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FindPTZPositionResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(tt__FindPTZPositionResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FindPTZPositionResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FindPTZPositionResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__FindPTZPositionResult*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RecordingToken1 = 1;
	size_t soap_flag_TrackToken1 = 1;
	size_t soap_flag_Time1 = 1;
	size_t soap_flag_Position1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->tt__FindPTZPositionResult::RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken1--;
					continue;
				}
			}
			if (soap_flag_TrackToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:TrackToken", &a->tt__FindPTZPositionResult::TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken1--;
					continue;
				}
			}
			if (soap_flag_Time1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tt:Time", &a->tt__FindPTZPositionResult::Time, "xsd:dateTime"))
				{	soap_flag_Time1--;
					continue;
				}
			}
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:Position", &a->tt__FindPTZPositionResult::Position, "tt:PTZVector"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__FindPTZPositionResult::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken1 > 0 || soap_flag_TrackToken1 > 0 || soap_flag_Time1 > 0 || !a->tt__FindPTZPositionResult::Position))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FindPTZPositionResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindPTZPositionResult, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(tt__FindPTZPositionResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FindPTZPositionResult * SOAP_FMAC2 soap_instantiate_tt__FindPTZPositionResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FindPTZPositionResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FindPTZPositionResult *p;
	size_t k = sizeof(tt__FindPTZPositionResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FindPTZPositionResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FindPTZPositionResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FindPTZPositionResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FindPTZPositionResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FindPTZPositionResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FindPTZPositionResult(soap, tag ? tag : "tt:FindPTZPositionResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FindPTZPositionResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FindPTZPositionResult(soap, this, tag, type);
}

SOAP_FMAC3 tt__FindPTZPositionResult * SOAP_FMAC4 soap_get_tt__FindPTZPositionResult(struct soap *soap, tt__FindPTZPositionResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindPTZPositionResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FindPTZPositionResultList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &this->tt__FindPTZPositionResultList::SearchState);
	soap_default_std__vectorTemplateOfPointerTott__FindPTZPositionResult(soap, &this->tt__FindPTZPositionResultList::Result);
}

void tt__FindPTZPositionResultList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__FindPTZPositionResult(soap, &this->tt__FindPTZPositionResultList::Result);
#endif
}

int tt__FindPTZPositionResultList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FindPTZPositionResultList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindPTZPositionResultList(struct soap *soap, const char *tag, int id, const tt__FindPTZPositionResultList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindPTZPositionResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->tt__FindPTZPositionResultList::SearchState, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__FindPTZPositionResult(soap, "tt:Result", -1, &a->tt__FindPTZPositionResultList::Result, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FindPTZPositionResultList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FindPTZPositionResultList(soap, tag, this, type);
}

SOAP_FMAC3 tt__FindPTZPositionResultList * SOAP_FMAC4 soap_in_tt__FindPTZPositionResultList(struct soap *soap, const char *tag, tt__FindPTZPositionResultList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FindPTZPositionResultList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindPTZPositionResultList, sizeof(tt__FindPTZPositionResultList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FindPTZPositionResultList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FindPTZPositionResultList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SearchState1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->tt__FindPTZPositionResultList::SearchState, "tt:SearchState"))
				{	soap_flag_SearchState1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__FindPTZPositionResult(soap, "tt:Result", &a->tt__FindPTZPositionResultList::Result, "tt:FindPTZPositionResult"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FindPTZPositionResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindPTZPositionResultList, SOAP_TYPE_tt__FindPTZPositionResultList, sizeof(tt__FindPTZPositionResultList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FindPTZPositionResultList * SOAP_FMAC2 soap_instantiate_tt__FindPTZPositionResultList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FindPTZPositionResultList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FindPTZPositionResultList *p;
	size_t k = sizeof(tt__FindPTZPositionResultList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FindPTZPositionResultList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FindPTZPositionResultList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FindPTZPositionResultList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FindPTZPositionResultList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FindPTZPositionResultList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FindPTZPositionResultList(soap, tag ? tag : "tt:FindPTZPositionResultList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FindPTZPositionResultList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FindPTZPositionResultList(soap, this, tag, type);
}

SOAP_FMAC3 tt__FindPTZPositionResultList * SOAP_FMAC4 soap_get_tt__FindPTZPositionResultList(struct soap *soap, tt__FindPTZPositionResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindPTZPositionResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FindEventResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &this->tt__FindEventResult::RecordingToken);
	soap_default_tt__TrackReference(soap, &this->tt__FindEventResult::TrackToken);
	soap_default_xsd__dateTime(soap, &this->tt__FindEventResult::Time);
	this->tt__FindEventResult::Event = NULL;
	soap_default_bool(soap, &this->tt__FindEventResult::StartStateEvent);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FindEventResult::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__FindEventResult::__anyAttribute);
}

void tt__FindEventResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, &this->tt__FindEventResult::RecordingToken);
	soap_serialize_tt__TrackReference(soap, &this->tt__FindEventResult::TrackToken);
	soap_embedded(soap, &this->tt__FindEventResult::Time, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->tt__FindEventResult::Time);
	soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &this->tt__FindEventResult::Event);
	soap_embedded(soap, &this->tt__FindEventResult::StartStateEvent, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FindEventResult::__any);
#endif
}

int tt__FindEventResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FindEventResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindEventResult(struct soap *soap, const char *tag, int id, const tt__FindEventResult *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__FindEventResult*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindEventResult), type))
		return soap->error;
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->tt__FindEventResult::RecordingToken, ""))
		return soap->error;
	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, &a->tt__FindEventResult::TrackToken, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tt:Time", -1, &a->tt__FindEventResult::Time, ""))
		return soap->error;
	if (!a->tt__FindEventResult::Event)
	{	if (soap_element_empty(soap, "tt:Event"))
			return soap->error;
	}
	else if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, "tt:Event", -1, &a->tt__FindEventResult::Event, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:StartStateEvent", -1, &a->tt__FindEventResult::StartStateEvent, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__FindEventResult::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FindEventResult::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FindEventResult(soap, tag, this, type);
}

SOAP_FMAC3 tt__FindEventResult * SOAP_FMAC4 soap_in_tt__FindEventResult(struct soap *soap, const char *tag, tt__FindEventResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FindEventResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindEventResult, sizeof(tt__FindEventResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FindEventResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FindEventResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__FindEventResult*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RecordingToken1 = 1;
	size_t soap_flag_TrackToken1 = 1;
	size_t soap_flag_Time1 = 1;
	size_t soap_flag_Event1 = 1;
	size_t soap_flag_StartStateEvent1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->tt__FindEventResult::RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken1--;
					continue;
				}
			}
			if (soap_flag_TrackToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:TrackToken", &a->tt__FindEventResult::TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken1--;
					continue;
				}
			}
			if (soap_flag_Time1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tt:Time", &a->tt__FindEventResult::Time, "xsd:dateTime"))
				{	soap_flag_Time1--;
					continue;
				}
			}
			if (soap_flag_Event1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__NotificationMessageHolderType(soap, "tt:Event", &a->tt__FindEventResult::Event, "wsnt:NotificationMessageHolderType"))
				{	soap_flag_Event1--;
					continue;
				}
			}
			if (soap_flag_StartStateEvent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:StartStateEvent", &a->tt__FindEventResult::StartStateEvent, "xsd:boolean"))
				{	soap_flag_StartStateEvent1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__FindEventResult::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken1 > 0 || soap_flag_TrackToken1 > 0 || soap_flag_Time1 > 0 || !a->tt__FindEventResult::Event || soap_flag_StartStateEvent1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FindEventResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindEventResult, SOAP_TYPE_tt__FindEventResult, sizeof(tt__FindEventResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FindEventResult * SOAP_FMAC2 soap_instantiate_tt__FindEventResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FindEventResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FindEventResult *p;
	size_t k = sizeof(tt__FindEventResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FindEventResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FindEventResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FindEventResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FindEventResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FindEventResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FindEventResult(soap, tag ? tag : "tt:FindEventResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FindEventResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FindEventResult(soap, this, tag, type);
}

SOAP_FMAC3 tt__FindEventResult * SOAP_FMAC4 soap_get_tt__FindEventResult(struct soap *soap, tt__FindEventResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindEventResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FindEventResultList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &this->tt__FindEventResultList::SearchState);
	soap_default_std__vectorTemplateOfPointerTott__FindEventResult(soap, &this->tt__FindEventResultList::Result);
}

void tt__FindEventResultList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__FindEventResult(soap, &this->tt__FindEventResultList::Result);
#endif
}

int tt__FindEventResultList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FindEventResultList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindEventResultList(struct soap *soap, const char *tag, int id, const tt__FindEventResultList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindEventResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->tt__FindEventResultList::SearchState, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__FindEventResult(soap, "tt:Result", -1, &a->tt__FindEventResultList::Result, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FindEventResultList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FindEventResultList(soap, tag, this, type);
}

SOAP_FMAC3 tt__FindEventResultList * SOAP_FMAC4 soap_in_tt__FindEventResultList(struct soap *soap, const char *tag, tt__FindEventResultList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FindEventResultList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindEventResultList, sizeof(tt__FindEventResultList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FindEventResultList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FindEventResultList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SearchState1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->tt__FindEventResultList::SearchState, "tt:SearchState"))
				{	soap_flag_SearchState1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__FindEventResult(soap, "tt:Result", &a->tt__FindEventResultList::Result, "tt:FindEventResult"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FindEventResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindEventResultList, SOAP_TYPE_tt__FindEventResultList, sizeof(tt__FindEventResultList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FindEventResultList * SOAP_FMAC2 soap_instantiate_tt__FindEventResultList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FindEventResultList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FindEventResultList *p;
	size_t k = sizeof(tt__FindEventResultList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FindEventResultList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FindEventResultList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FindEventResultList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FindEventResultList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FindEventResultList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FindEventResultList(soap, tag ? tag : "tt:FindEventResultList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FindEventResultList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FindEventResultList(soap, this, tag, type);
}

SOAP_FMAC3 tt__FindEventResultList * SOAP_FMAC4 soap_get_tt__FindEventResultList(struct soap *soap, tt__FindEventResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindEventResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FindRecordingResultList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &this->tt__FindRecordingResultList::SearchState);
	soap_default_std__vectorTemplateOfPointerTott__RecordingInformation(soap, &this->tt__FindRecordingResultList::RecordingInformation);
}

void tt__FindRecordingResultList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__RecordingInformation(soap, &this->tt__FindRecordingResultList::RecordingInformation);
#endif
}

int tt__FindRecordingResultList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FindRecordingResultList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindRecordingResultList(struct soap *soap, const char *tag, int id, const tt__FindRecordingResultList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindRecordingResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->tt__FindRecordingResultList::SearchState, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__RecordingInformation(soap, "tt:RecordingInformation", -1, &a->tt__FindRecordingResultList::RecordingInformation, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FindRecordingResultList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FindRecordingResultList(soap, tag, this, type);
}

SOAP_FMAC3 tt__FindRecordingResultList * SOAP_FMAC4 soap_in_tt__FindRecordingResultList(struct soap *soap, const char *tag, tt__FindRecordingResultList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FindRecordingResultList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindRecordingResultList, sizeof(tt__FindRecordingResultList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FindRecordingResultList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FindRecordingResultList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SearchState1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->tt__FindRecordingResultList::SearchState, "tt:SearchState"))
				{	soap_flag_SearchState1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__RecordingInformation(soap, "tt:RecordingInformation", &a->tt__FindRecordingResultList::RecordingInformation, "tt:RecordingInformation"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FindRecordingResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindRecordingResultList, SOAP_TYPE_tt__FindRecordingResultList, sizeof(tt__FindRecordingResultList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FindRecordingResultList * SOAP_FMAC2 soap_instantiate_tt__FindRecordingResultList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FindRecordingResultList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FindRecordingResultList *p;
	size_t k = sizeof(tt__FindRecordingResultList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FindRecordingResultList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FindRecordingResultList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FindRecordingResultList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FindRecordingResultList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FindRecordingResultList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FindRecordingResultList(soap, tag ? tag : "tt:FindRecordingResultList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FindRecordingResultList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FindRecordingResultList(soap, this, tag, type);
}

SOAP_FMAC3 tt__FindRecordingResultList * SOAP_FMAC4 soap_get_tt__FindRecordingResultList(struct soap *soap, tt__FindRecordingResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindRecordingResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataFilter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__XPathExpression(soap, &this->tt__MetadataFilter::MetadataStreamFilter);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataFilter::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__MetadataFilter::__anyAttribute);
}

void tt__MetadataFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__MetadataFilter::MetadataStreamFilter, SOAP_TYPE_tt__XPathExpression);
	soap_serialize_tt__XPathExpression(soap, &this->tt__MetadataFilter::MetadataStreamFilter);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataFilter::__any);
#endif
}

int tt__MetadataFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataFilter(struct soap *soap, const char *tag, int id, const tt__MetadataFilter *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MetadataFilter*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataFilter), type))
		return soap->error;
	if (soap_out_tt__XPathExpression(soap, "tt:MetadataStreamFilter", -1, &a->tt__MetadataFilter::MetadataStreamFilter, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MetadataFilter::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataFilter(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataFilter * SOAP_FMAC4 soap_in_tt__MetadataFilter(struct soap *soap, const char *tag, tt__MetadataFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataFilter, sizeof(tt__MetadataFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MetadataFilter*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_MetadataStreamFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MetadataStreamFilter1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__XPathExpression(soap, "tt:MetadataStreamFilter", &a->tt__MetadataFilter::MetadataStreamFilter, "tt:XPathExpression"))
				{	soap_flag_MetadataStreamFilter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MetadataFilter::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MetadataStreamFilter1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MetadataFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataFilter, SOAP_TYPE_tt__MetadataFilter, sizeof(tt__MetadataFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataFilter * SOAP_FMAC2 soap_instantiate_tt__MetadataFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataFilter *p;
	size_t k = sizeof(tt__MetadataFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataFilter(soap, tag ? tag : "tt:MetadataFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataFilter(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataFilter * SOAP_FMAC4 soap_get_tt__MetadataFilter(struct soap *soap, tt__MetadataFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPositionFilter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTZPositionFilter::MinPosition = NULL;
	this->tt__PTZPositionFilter::MaxPosition = NULL;
	soap_default_bool(soap, &this->tt__PTZPositionFilter::EnterOrExit);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPositionFilter::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZPositionFilter::__anyAttribute);
}

void tt__PTZPositionFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZVector(soap, &this->tt__PTZPositionFilter::MinPosition);
	soap_serialize_PointerTott__PTZVector(soap, &this->tt__PTZPositionFilter::MaxPosition);
	soap_embedded(soap, &this->tt__PTZPositionFilter::EnterOrExit, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPositionFilter::__any);
#endif
}

int tt__PTZPositionFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPositionFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPositionFilter(struct soap *soap, const char *tag, int id, const tt__PTZPositionFilter *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZPositionFilter*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPositionFilter), type))
		return soap->error;
	if (!a->tt__PTZPositionFilter::MinPosition)
	{	if (soap_element_empty(soap, "tt:MinPosition"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZVector(soap, "tt:MinPosition", -1, &a->tt__PTZPositionFilter::MinPosition, ""))
		return soap->error;
	if (!a->tt__PTZPositionFilter::MaxPosition)
	{	if (soap_element_empty(soap, "tt:MaxPosition"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZVector(soap, "tt:MaxPosition", -1, &a->tt__PTZPositionFilter::MaxPosition, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:EnterOrExit", -1, &a->tt__PTZPositionFilter::EnterOrExit, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZPositionFilter::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPositionFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPositionFilter(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPositionFilter * SOAP_FMAC4 soap_in_tt__PTZPositionFilter(struct soap *soap, const char *tag, tt__PTZPositionFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPositionFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPositionFilter, sizeof(tt__PTZPositionFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPositionFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPositionFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZPositionFilter*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_MinPosition1 = 1;
	size_t soap_flag_MaxPosition1 = 1;
	size_t soap_flag_EnterOrExit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MinPosition1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:MinPosition", &a->tt__PTZPositionFilter::MinPosition, "tt:PTZVector"))
				{	soap_flag_MinPosition1--;
					continue;
				}
			}
			if (soap_flag_MaxPosition1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:MaxPosition", &a->tt__PTZPositionFilter::MaxPosition, "tt:PTZVector"))
				{	soap_flag_MaxPosition1--;
					continue;
				}
			}
			if (soap_flag_EnterOrExit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:EnterOrExit", &a->tt__PTZPositionFilter::EnterOrExit, "xsd:boolean"))
				{	soap_flag_EnterOrExit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZPositionFilter::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PTZPositionFilter::MinPosition || !a->tt__PTZPositionFilter::MaxPosition || soap_flag_EnterOrExit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZPositionFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPositionFilter, SOAP_TYPE_tt__PTZPositionFilter, sizeof(tt__PTZPositionFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPositionFilter * SOAP_FMAC2 soap_instantiate_tt__PTZPositionFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPositionFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPositionFilter *p;
	size_t k = sizeof(tt__PTZPositionFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPositionFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPositionFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPositionFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPositionFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPositionFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPositionFilter(soap, tag ? tag : "tt:PTZPositionFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPositionFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPositionFilter(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPositionFilter * SOAP_FMAC4 soap_get_tt__PTZPositionFilter(struct soap *soap, tt__PTZPositionFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPositionFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EventFilter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsnt__FilterType::soap_default(soap);
	soap_default_xsd__anyAttribute(soap, &this->tt__EventFilter::__anyAttribute);
}

void tt__EventFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsnt__FilterType::soap_serialize(soap);
#endif
}

int tt__EventFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EventFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventFilter(struct soap *soap, const char *tag, int id, const tt__EventFilter *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__EventFilter*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventFilter), type ? type : "tt:EventFilter"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->wsnt__FilterType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EventFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EventFilter(soap, tag, this, type);
}

SOAP_FMAC3 tt__EventFilter * SOAP_FMAC4 soap_in_tt__EventFilter(struct soap *soap, const char *tag, tt__EventFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EventFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventFilter, sizeof(tt__EventFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EventFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EventFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__EventFilter*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->wsnt__FilterType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EventFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventFilter, SOAP_TYPE_tt__EventFilter, sizeof(tt__EventFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EventFilter * SOAP_FMAC2 soap_instantiate_tt__EventFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EventFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EventFilter *p;
	size_t k = sizeof(tt__EventFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EventFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EventFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EventFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EventFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EventFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EventFilter(soap, tag ? tag : "tt:EventFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EventFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EventFilter(soap, this, tag, type);
}

SOAP_FMAC3 tt__EventFilter * SOAP_FMAC4 soap_get_tt__EventFilter(struct soap *soap, tt__EventFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SearchScopeExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SearchScopeExtension::__any);
}

void tt__SearchScopeExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SearchScopeExtension::__any);
#endif
}

int tt__SearchScopeExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SearchScopeExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchScopeExtension(struct soap *soap, const char *tag, int id, const tt__SearchScopeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchScopeExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__SearchScopeExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SearchScopeExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SearchScopeExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SearchScopeExtension * SOAP_FMAC4 soap_in_tt__SearchScopeExtension(struct soap *soap, const char *tag, tt__SearchScopeExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SearchScopeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchScopeExtension, sizeof(tt__SearchScopeExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SearchScopeExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SearchScopeExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__SearchScopeExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SearchScopeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchScopeExtension, SOAP_TYPE_tt__SearchScopeExtension, sizeof(tt__SearchScopeExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SearchScopeExtension * SOAP_FMAC2 soap_instantiate_tt__SearchScopeExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SearchScopeExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SearchScopeExtension *p;
	size_t k = sizeof(tt__SearchScopeExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SearchScopeExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SearchScopeExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SearchScopeExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SearchScopeExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SearchScopeExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SearchScopeExtension(soap, tag ? tag : "tt:SearchScopeExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SearchScopeExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SearchScopeExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SearchScopeExtension * SOAP_FMAC4 soap_get_tt__SearchScopeExtension(struct soap *soap, tt__SearchScopeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchScopeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SearchScope::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__SourceReference(soap, &this->tt__SearchScope::IncludedSources);
	soap_default_std__vectorTemplateOftt__RecordingReference(soap, &this->tt__SearchScope::IncludedRecordings);
	this->tt__SearchScope::RecordingInformationFilter = NULL;
	this->tt__SearchScope::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__SearchScope::__anyAttribute);
}

void tt__SearchScope::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__SourceReference(soap, &this->tt__SearchScope::IncludedSources);
	soap_serialize_std__vectorTemplateOftt__RecordingReference(soap, &this->tt__SearchScope::IncludedRecordings);
	soap_serialize_PointerTott__XPathExpression(soap, &this->tt__SearchScope::RecordingInformationFilter);
	soap_serialize_PointerTott__SearchScopeExtension(soap, &this->tt__SearchScope::Extension);
#endif
}

int tt__SearchScope::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SearchScope(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchScope(struct soap *soap, const char *tag, int id, const tt__SearchScope *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SearchScope*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchScope), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__SourceReference(soap, "tt:IncludedSources", -1, &a->tt__SearchScope::IncludedSources, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__RecordingReference(soap, "tt:IncludedRecordings", -1, &a->tt__SearchScope::IncludedRecordings, ""))
		return soap->error;
	if (soap_out_PointerTott__XPathExpression(soap, "tt:RecordingInformationFilter", -1, &a->tt__SearchScope::RecordingInformationFilter, ""))
		return soap->error;
	if (soap_out_PointerTott__SearchScopeExtension(soap, "tt:Extension", -1, &a->tt__SearchScope::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SearchScope::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SearchScope(soap, tag, this, type);
}

SOAP_FMAC3 tt__SearchScope * SOAP_FMAC4 soap_in_tt__SearchScope(struct soap *soap, const char *tag, tt__SearchScope *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SearchScope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchScope, sizeof(tt__SearchScope), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SearchScope)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SearchScope *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SearchScope*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RecordingInformationFilter1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__SourceReference(soap, "tt:IncludedSources", &a->tt__SearchScope::IncludedSources, "tt:SourceReference"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__RecordingReference(soap, "tt:IncludedRecordings", &a->tt__SearchScope::IncludedRecordings, "tt:RecordingReference"))
					continue;
			}
			if (soap_flag_RecordingInformationFilter1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__XPathExpression(soap, "tt:RecordingInformationFilter", &a->tt__SearchScope::RecordingInformationFilter, "tt:XPathExpression"))
				{	soap_flag_RecordingInformationFilter1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SearchScopeExtension(soap, "tt:Extension", &a->tt__SearchScope::Extension, "tt:SearchScopeExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SearchScope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchScope, SOAP_TYPE_tt__SearchScope, sizeof(tt__SearchScope), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SearchScope * SOAP_FMAC2 soap_instantiate_tt__SearchScope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SearchScope(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SearchScope *p;
	size_t k = sizeof(tt__SearchScope);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SearchScope, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SearchScope);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SearchScope, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SearchScope location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SearchScope::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SearchScope(soap, tag ? tag : "tt:SearchScope", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SearchScope::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SearchScope(soap, this, tag, type);
}

SOAP_FMAC3 tt__SearchScope * SOAP_FMAC4 soap_get_tt__SearchScope(struct soap *soap, tt__SearchScope *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchScope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingSummary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__dateTime(soap, &this->tt__RecordingSummary::DataFrom);
	soap_default_xsd__dateTime(soap, &this->tt__RecordingSummary::DataUntil);
	soap_default_int(soap, &this->tt__RecordingSummary::NumberRecordings);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingSummary::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__RecordingSummary::__anyAttribute);
}

void tt__RecordingSummary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RecordingSummary::DataFrom, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->tt__RecordingSummary::DataFrom);
	soap_embedded(soap, &this->tt__RecordingSummary::DataUntil, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->tt__RecordingSummary::DataUntil);
	soap_embedded(soap, &this->tt__RecordingSummary::NumberRecordings, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingSummary::__any);
#endif
}

int tt__RecordingSummary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingSummary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingSummary(struct soap *soap, const char *tag, int id, const tt__RecordingSummary *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RecordingSummary*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingSummary), type))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tt:DataFrom", -1, &a->tt__RecordingSummary::DataFrom, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tt:DataUntil", -1, &a->tt__RecordingSummary::DataUntil, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:NumberRecordings", -1, &a->tt__RecordingSummary::NumberRecordings, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RecordingSummary::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingSummary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingSummary(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingSummary * SOAP_FMAC4 soap_in_tt__RecordingSummary(struct soap *soap, const char *tag, tt__RecordingSummary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingSummary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingSummary, sizeof(tt__RecordingSummary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingSummary)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingSummary *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RecordingSummary*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_DataFrom1 = 1;
	size_t soap_flag_DataUntil1 = 1;
	size_t soap_flag_NumberRecordings1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataFrom1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tt:DataFrom", &a->tt__RecordingSummary::DataFrom, "xsd:dateTime"))
				{	soap_flag_DataFrom1--;
					continue;
				}
			}
			if (soap_flag_DataUntil1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tt:DataUntil", &a->tt__RecordingSummary::DataUntil, "xsd:dateTime"))
				{	soap_flag_DataUntil1--;
					continue;
				}
			}
			if (soap_flag_NumberRecordings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:NumberRecordings", &a->tt__RecordingSummary::NumberRecordings, "xsd:int"))
				{	soap_flag_NumberRecordings1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RecordingSummary::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DataFrom1 > 0 || soap_flag_DataUntil1 > 0 || soap_flag_NumberRecordings1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RecordingSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingSummary, SOAP_TYPE_tt__RecordingSummary, sizeof(tt__RecordingSummary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingSummary * SOAP_FMAC2 soap_instantiate_tt__RecordingSummary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingSummary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingSummary *p;
	size_t k = sizeof(tt__RecordingSummary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingSummary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingSummary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingSummary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingSummary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingSummary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingSummary(soap, tag ? tag : "tt:RecordingSummary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingSummary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingSummary(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingSummary * SOAP_FMAC4 soap_get_tt__RecordingSummary(struct soap *soap, tt__RecordingSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DateTimeRange::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__dateTime(soap, &this->tt__DateTimeRange::From);
	soap_default_xsd__dateTime(soap, &this->tt__DateTimeRange::Until);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DateTimeRange::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__DateTimeRange::__anyAttribute);
}

void tt__DateTimeRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DateTimeRange::From, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->tt__DateTimeRange::From);
	soap_embedded(soap, &this->tt__DateTimeRange::Until, SOAP_TYPE_xsd__dateTime);
	soap_serialize_xsd__dateTime(soap, &this->tt__DateTimeRange::Until);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DateTimeRange::__any);
#endif
}

int tt__DateTimeRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DateTimeRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTimeRange(struct soap *soap, const char *tag, int id, const tt__DateTimeRange *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__DateTimeRange*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTimeRange), type))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tt:From", -1, &a->tt__DateTimeRange::From, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "tt:Until", -1, &a->tt__DateTimeRange::Until, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__DateTimeRange::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DateTimeRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DateTimeRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__DateTimeRange * SOAP_FMAC4 soap_in_tt__DateTimeRange(struct soap *soap, const char *tag, tt__DateTimeRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DateTimeRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTimeRange, sizeof(tt__DateTimeRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DateTimeRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DateTimeRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__DateTimeRange*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_From1 = 1;
	size_t soap_flag_Until1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_From1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tt:From", &a->tt__DateTimeRange::From, "xsd:dateTime"))
				{	soap_flag_From1--;
					continue;
				}
			}
			if (soap_flag_Until1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "tt:Until", &a->tt__DateTimeRange::Until, "xsd:dateTime"))
				{	soap_flag_Until1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__DateTimeRange::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_From1 > 0 || soap_flag_Until1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DateTimeRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTimeRange, SOAP_TYPE_tt__DateTimeRange, sizeof(tt__DateTimeRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DateTimeRange * SOAP_FMAC2 soap_instantiate_tt__DateTimeRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DateTimeRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DateTimeRange *p;
	size_t k = sizeof(tt__DateTimeRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DateTimeRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DateTimeRange);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DateTimeRange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DateTimeRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DateTimeRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DateTimeRange(soap, tag ? tag : "tt:DateTimeRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DateTimeRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DateTimeRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__DateTimeRange * SOAP_FMAC4 soap_get_tt__DateTimeRange(struct soap *soap, tt__DateTimeRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTimeRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SourceReference::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &this->tt__SourceReference::Token);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SourceReference::__any);
	this->tt__SourceReference::Type = "http://www.onvif.org/ver10/schema/Receiver";
	soap_default_xsd__anyAttribute(soap, &this->tt__SourceReference::__anyAttribute);
}

void tt__SourceReference::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SourceReference::Token, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__SourceReference::Token);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SourceReference::__any);
#endif
}

int tt__SourceReference::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SourceReference(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceReference(struct soap *soap, const char *tag, int id, const tt__SourceReference *a, const char *type)
{
	if (((tt__SourceReference*)a)->Type != "http://www.onvif.org/ver10/schema/Receiver")
	{	soap_set_attr(soap, "Type", soap_xsd__anyURI2s(soap, ((tt__SourceReference*)a)->Type), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SourceReference*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceReference), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, &a->tt__SourceReference::Token, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__SourceReference::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SourceReference::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SourceReference(soap, tag, this, type);
}

SOAP_FMAC3 tt__SourceReference * SOAP_FMAC4 soap_in_tt__SourceReference(struct soap *soap, const char *tag, tt__SourceReference *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SourceReference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceReference, sizeof(tt__SourceReference), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SourceReference)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SourceReference *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Type", 4, 0), &((tt__SourceReference*)a)->Type))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SourceReference*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Token1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:Token", &a->tt__SourceReference::Token, "tt:ReferenceToken"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__SourceReference::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SourceReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceReference, SOAP_TYPE_tt__SourceReference, sizeof(tt__SourceReference), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SourceReference * SOAP_FMAC2 soap_instantiate_tt__SourceReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SourceReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SourceReference *p;
	size_t k = sizeof(tt__SourceReference);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SourceReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SourceReference);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SourceReference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SourceReference location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SourceReference::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SourceReference(soap, tag ? tag : "tt:SourceReference", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SourceReference::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SourceReference(soap, this, tag, type);
}

SOAP_FMAC3 tt__SourceReference * SOAP_FMAC4 soap_get_tt__SourceReference(struct soap *soap, tt__SourceReference *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReceiverStateInformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReceiverState(soap, &this->tt__ReceiverStateInformation::State);
	soap_default_bool(soap, &this->tt__ReceiverStateInformation::AutoCreated);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ReceiverStateInformation::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ReceiverStateInformation::__anyAttribute);
}

void tt__ReceiverStateInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ReceiverStateInformation::AutoCreated, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ReceiverStateInformation::__any);
#endif
}

int tt__ReceiverStateInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReceiverStateInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverStateInformation(struct soap *soap, const char *tag, int id, const tt__ReceiverStateInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ReceiverStateInformation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverStateInformation), type))
		return soap->error;
	if (soap_out_tt__ReceiverState(soap, "tt:State", -1, &a->tt__ReceiverStateInformation::State, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoCreated", -1, &a->tt__ReceiverStateInformation::AutoCreated, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ReceiverStateInformation::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReceiverStateInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReceiverStateInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReceiverStateInformation * SOAP_FMAC4 soap_in_tt__ReceiverStateInformation(struct soap *soap, const char *tag, tt__ReceiverStateInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReceiverStateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverStateInformation, sizeof(tt__ReceiverStateInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReceiverStateInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReceiverStateInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ReceiverStateInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_State1 = 1;
	size_t soap_flag_AutoCreated1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ReceiverState(soap, "tt:State", &a->tt__ReceiverStateInformation::State, "tt:ReceiverState"))
				{	soap_flag_State1--;
					continue;
				}
			}
			if (soap_flag_AutoCreated1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AutoCreated", &a->tt__ReceiverStateInformation::AutoCreated, "xsd:boolean"))
				{	soap_flag_AutoCreated1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ReceiverStateInformation::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State1 > 0 || soap_flag_AutoCreated1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ReceiverStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverStateInformation, SOAP_TYPE_tt__ReceiverStateInformation, sizeof(tt__ReceiverStateInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReceiverStateInformation * SOAP_FMAC2 soap_instantiate_tt__ReceiverStateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReceiverStateInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReceiverStateInformation *p;
	size_t k = sizeof(tt__ReceiverStateInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReceiverStateInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReceiverStateInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReceiverStateInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReceiverStateInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReceiverStateInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReceiverStateInformation(soap, tag ? tag : "tt:ReceiverStateInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReceiverStateInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReceiverStateInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReceiverStateInformation * SOAP_FMAC4 soap_get_tt__ReceiverStateInformation(struct soap *soap, tt__ReceiverStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReceiverConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReceiverMode(soap, &this->tt__ReceiverConfiguration::Mode);
	soap_default_xsd__anyURI(soap, &this->tt__ReceiverConfiguration::MediaUri);
	this->tt__ReceiverConfiguration::StreamSetup = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ReceiverConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ReceiverConfiguration::__anyAttribute);
}

void tt__ReceiverConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ReceiverConfiguration::MediaUri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ReceiverConfiguration::MediaUri);
	soap_serialize_PointerTott__StreamSetup(soap, &this->tt__ReceiverConfiguration::StreamSetup);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ReceiverConfiguration::__any);
#endif
}

int tt__ReceiverConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReceiverConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverConfiguration(struct soap *soap, const char *tag, int id, const tt__ReceiverConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ReceiverConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReceiverMode(soap, "tt:Mode", -1, &a->tt__ReceiverConfiguration::Mode, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:MediaUri", -1, &a->tt__ReceiverConfiguration::MediaUri, ""))
		return soap->error;
	if (!a->tt__ReceiverConfiguration::StreamSetup)
	{	if (soap_element_empty(soap, "tt:StreamSetup"))
			return soap->error;
	}
	else if (soap_out_PointerTott__StreamSetup(soap, "tt:StreamSetup", -1, &a->tt__ReceiverConfiguration::StreamSetup, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ReceiverConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReceiverConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReceiverConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReceiverConfiguration * SOAP_FMAC4 soap_in_tt__ReceiverConfiguration(struct soap *soap, const char *tag, tt__ReceiverConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReceiverConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(tt__ReceiverConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReceiverConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReceiverConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ReceiverConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_MediaUri1 = 1;
	size_t soap_flag_StreamSetup1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ReceiverMode(soap, "tt:Mode", &a->tt__ReceiverConfiguration::Mode, "tt:ReceiverMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_MediaUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:MediaUri", &a->tt__ReceiverConfiguration::MediaUri, "xsd:anyURI"))
				{	soap_flag_MediaUri1--;
					continue;
				}
			}
			if (soap_flag_StreamSetup1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StreamSetup(soap, "tt:StreamSetup", &a->tt__ReceiverConfiguration::StreamSetup, "tt:StreamSetup"))
				{	soap_flag_StreamSetup1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ReceiverConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0 || soap_flag_MediaUri1 > 0 || !a->tt__ReceiverConfiguration::StreamSetup))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ReceiverConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverConfiguration, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(tt__ReceiverConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReceiverConfiguration * SOAP_FMAC2 soap_instantiate_tt__ReceiverConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReceiverConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReceiverConfiguration *p;
	size_t k = sizeof(tt__ReceiverConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReceiverConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReceiverConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReceiverConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReceiverConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReceiverConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReceiverConfiguration(soap, tag ? tag : "tt:ReceiverConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReceiverConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReceiverConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReceiverConfiguration * SOAP_FMAC4 soap_get_tt__ReceiverConfiguration(struct soap *soap, tt__ReceiverConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Receiver::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &this->tt__Receiver::Token);
	this->tt__Receiver::Configuration = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Receiver::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__Receiver::__anyAttribute);
}

void tt__Receiver::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Receiver::Token, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__Receiver::Token);
	soap_serialize_PointerTott__ReceiverConfiguration(soap, &this->tt__Receiver::Configuration);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Receiver::__any);
#endif
}

int tt__Receiver::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Receiver(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Receiver(struct soap *soap, const char *tag, int id, const tt__Receiver *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Receiver*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Receiver), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, &a->tt__Receiver::Token, ""))
		return soap->error;
	if (!a->tt__Receiver::Configuration)
	{	if (soap_element_empty(soap, "tt:Configuration"))
			return soap->error;
	}
	else if (soap_out_PointerTott__ReceiverConfiguration(soap, "tt:Configuration", -1, &a->tt__Receiver::Configuration, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__Receiver::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Receiver::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Receiver(soap, tag, this, type);
}

SOAP_FMAC3 tt__Receiver * SOAP_FMAC4 soap_in_tt__Receiver(struct soap *soap, const char *tag, tt__Receiver *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Receiver*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Receiver, sizeof(tt__Receiver), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Receiver)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Receiver *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Receiver*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Configuration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:Token", &a->tt__Receiver::Token, "tt:ReferenceToken"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			if (soap_flag_Configuration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReceiverConfiguration(soap, "tt:Configuration", &a->tt__Receiver::Configuration, "tt:ReceiverConfiguration"))
				{	soap_flag_Configuration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__Receiver::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token1 > 0 || !a->tt__Receiver::Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Receiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Receiver, SOAP_TYPE_tt__Receiver, sizeof(tt__Receiver), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Receiver * SOAP_FMAC2 soap_instantiate_tt__Receiver(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Receiver(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Receiver *p;
	size_t k = sizeof(tt__Receiver);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Receiver, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Receiver);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Receiver, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Receiver location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Receiver::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Receiver(soap, tag ? tag : "tt:Receiver", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Receiver::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Receiver(soap, this, tag, type);
}

SOAP_FMAC3 tt__Receiver * SOAP_FMAC4 soap_get_tt__Receiver(struct soap *soap, tt__Receiver *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Receiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PaneOptionExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PaneOptionExtension::__any);
}

void tt__PaneOptionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PaneOptionExtension::__any);
#endif
}

int tt__PaneOptionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PaneOptionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneOptionExtension(struct soap *soap, const char *tag, int id, const tt__PaneOptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneOptionExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PaneOptionExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PaneOptionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PaneOptionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PaneOptionExtension * SOAP_FMAC4 soap_in_tt__PaneOptionExtension(struct soap *soap, const char *tag, tt__PaneOptionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PaneOptionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneOptionExtension, sizeof(tt__PaneOptionExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PaneOptionExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PaneOptionExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PaneOptionExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PaneOptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneOptionExtension, SOAP_TYPE_tt__PaneOptionExtension, sizeof(tt__PaneOptionExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PaneOptionExtension * SOAP_FMAC2 soap_instantiate_tt__PaneOptionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PaneOptionExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PaneOptionExtension *p;
	size_t k = sizeof(tt__PaneOptionExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PaneOptionExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PaneOptionExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PaneOptionExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PaneOptionExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PaneOptionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PaneOptionExtension(soap, tag ? tag : "tt:PaneOptionExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PaneOptionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PaneOptionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PaneOptionExtension * SOAP_FMAC4 soap_get_tt__PaneOptionExtension(struct soap *soap, tt__PaneOptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneOptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PaneLayoutOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__Rectangle(soap, &this->tt__PaneLayoutOptions::Area);
	this->tt__PaneLayoutOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PaneLayoutOptions::__anyAttribute);
}

void tt__PaneLayoutOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Rectangle(soap, &this->tt__PaneLayoutOptions::Area);
	soap_serialize_PointerTott__PaneOptionExtension(soap, &this->tt__PaneLayoutOptions::Extension);
#endif
}

int tt__PaneLayoutOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PaneLayoutOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneLayoutOptions(struct soap *soap, const char *tag, int id, const tt__PaneLayoutOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PaneLayoutOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneLayoutOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Rectangle(soap, "tt:Area", -1, &a->tt__PaneLayoutOptions::Area, ""))
		return soap->error;
	if (soap_out_PointerTott__PaneOptionExtension(soap, "tt:Extension", -1, &a->tt__PaneLayoutOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PaneLayoutOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PaneLayoutOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PaneLayoutOptions * SOAP_FMAC4 soap_in_tt__PaneLayoutOptions(struct soap *soap, const char *tag, tt__PaneLayoutOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PaneLayoutOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(tt__PaneLayoutOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PaneLayoutOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PaneLayoutOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PaneLayoutOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Rectangle(soap, "tt:Area", &a->tt__PaneLayoutOptions::Area, "tt:Rectangle"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PaneOptionExtension(soap, "tt:Extension", &a->tt__PaneLayoutOptions::Extension, "tt:PaneOptionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__PaneLayoutOptions::Area.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PaneLayoutOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneLayoutOptions, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(tt__PaneLayoutOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PaneLayoutOptions * SOAP_FMAC2 soap_instantiate_tt__PaneLayoutOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PaneLayoutOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PaneLayoutOptions *p;
	size_t k = sizeof(tt__PaneLayoutOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PaneLayoutOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PaneLayoutOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PaneLayoutOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PaneLayoutOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PaneLayoutOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PaneLayoutOptions(soap, tag ? tag : "tt:PaneLayoutOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PaneLayoutOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PaneLayoutOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PaneLayoutOptions * SOAP_FMAC4 soap_get_tt__PaneLayoutOptions(struct soap *soap, tt__PaneLayoutOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneLayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LayoutOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__LayoutOptionsExtension::__any);
}

void tt__LayoutOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__LayoutOptionsExtension::__any);
#endif
}

int tt__LayoutOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LayoutOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LayoutOptionsExtension(struct soap *soap, const char *tag, int id, const tt__LayoutOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LayoutOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__LayoutOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LayoutOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LayoutOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__LayoutOptionsExtension * SOAP_FMAC4 soap_in_tt__LayoutOptionsExtension(struct soap *soap, const char *tag, tt__LayoutOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LayoutOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(tt__LayoutOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LayoutOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LayoutOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__LayoutOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__LayoutOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutOptionsExtension, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(tt__LayoutOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LayoutOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__LayoutOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LayoutOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LayoutOptionsExtension *p;
	size_t k = sizeof(tt__LayoutOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LayoutOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LayoutOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LayoutOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LayoutOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LayoutOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LayoutOptionsExtension(soap, tag ? tag : "tt:LayoutOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LayoutOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LayoutOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__LayoutOptionsExtension * SOAP_FMAC4 soap_get_tt__LayoutOptionsExtension(struct soap *soap, tt__LayoutOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LayoutOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LayoutOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__PaneLayoutOptions(soap, &this->tt__LayoutOptions::PaneLayoutOptions);
	this->tt__LayoutOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__LayoutOptions::__anyAttribute);
}

void tt__LayoutOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PaneLayoutOptions(soap, &this->tt__LayoutOptions::PaneLayoutOptions);
	soap_serialize_PointerTott__LayoutOptionsExtension(soap, &this->tt__LayoutOptions::Extension);
#endif
}

int tt__LayoutOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LayoutOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LayoutOptions(struct soap *soap, const char *tag, int id, const tt__LayoutOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__LayoutOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LayoutOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PaneLayoutOptions(soap, "tt:PaneLayoutOptions", -1, &a->tt__LayoutOptions::PaneLayoutOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__LayoutOptionsExtension(soap, "tt:Extension", -1, &a->tt__LayoutOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LayoutOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LayoutOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__LayoutOptions * SOAP_FMAC4 soap_in_tt__LayoutOptions(struct soap *soap, const char *tag, tt__LayoutOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LayoutOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutOptions, sizeof(tt__LayoutOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LayoutOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LayoutOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__LayoutOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PaneLayoutOptions(soap, "tt:PaneLayoutOptions", &a->tt__LayoutOptions::PaneLayoutOptions, "tt:PaneLayoutOptions"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LayoutOptionsExtension(soap, "tt:Extension", &a->tt__LayoutOptions::Extension, "tt:LayoutOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__LayoutOptions::PaneLayoutOptions.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__LayoutOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutOptions, SOAP_TYPE_tt__LayoutOptions, sizeof(tt__LayoutOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LayoutOptions * SOAP_FMAC2 soap_instantiate_tt__LayoutOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LayoutOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LayoutOptions *p;
	size_t k = sizeof(tt__LayoutOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LayoutOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LayoutOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LayoutOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LayoutOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LayoutOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LayoutOptions(soap, tag ? tag : "tt:LayoutOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LayoutOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LayoutOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__LayoutOptions * SOAP_FMAC4 soap_get_tt__LayoutOptions(struct soap *soap, tt__LayoutOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CodingCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__CodingCapabilities::AudioEncodingCapabilities = NULL;
	this->tt__CodingCapabilities::AudioDecodingCapabilities = NULL;
	this->tt__CodingCapabilities::VideoDecodingCapabilities = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CodingCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__CodingCapabilities::__anyAttribute);
}

void tt__CodingCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioEncoderConfigurationOptions(soap, &this->tt__CodingCapabilities::AudioEncodingCapabilities);
	soap_serialize_PointerTott__AudioDecoderConfigurationOptions(soap, &this->tt__CodingCapabilities::AudioDecodingCapabilities);
	soap_serialize_PointerTott__VideoDecoderConfigurationOptions(soap, &this->tt__CodingCapabilities::VideoDecodingCapabilities);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CodingCapabilities::__any);
#endif
}

int tt__CodingCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CodingCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CodingCapabilities(struct soap *soap, const char *tag, int id, const tt__CodingCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__CodingCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CodingCapabilities), type))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfigurationOptions(soap, "tt:AudioEncodingCapabilities", -1, &a->tt__CodingCapabilities::AudioEncodingCapabilities, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfigurationOptions(soap, "tt:AudioDecodingCapabilities", -1, &a->tt__CodingCapabilities::AudioDecodingCapabilities, ""))
		return soap->error;
	if (!a->tt__CodingCapabilities::VideoDecodingCapabilities)
	{	if (soap_element_empty(soap, "tt:VideoDecodingCapabilities"))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoDecoderConfigurationOptions(soap, "tt:VideoDecodingCapabilities", -1, &a->tt__CodingCapabilities::VideoDecodingCapabilities, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__CodingCapabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CodingCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CodingCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__CodingCapabilities * SOAP_FMAC4 soap_in_tt__CodingCapabilities(struct soap *soap, const char *tag, tt__CodingCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CodingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CodingCapabilities, sizeof(tt__CodingCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CodingCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CodingCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__CodingCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_AudioEncodingCapabilities1 = 1;
	size_t soap_flag_AudioDecodingCapabilities1 = 1;
	size_t soap_flag_VideoDecodingCapabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioEncodingCapabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioEncoderConfigurationOptions(soap, "tt:AudioEncodingCapabilities", &a->tt__CodingCapabilities::AudioEncodingCapabilities, "tt:AudioEncoderConfigurationOptions"))
				{	soap_flag_AudioEncodingCapabilities1--;
					continue;
				}
			}
			if (soap_flag_AudioDecodingCapabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioDecoderConfigurationOptions(soap, "tt:AudioDecodingCapabilities", &a->tt__CodingCapabilities::AudioDecodingCapabilities, "tt:AudioDecoderConfigurationOptions"))
				{	soap_flag_AudioDecodingCapabilities1--;
					continue;
				}
			}
			if (soap_flag_VideoDecodingCapabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoDecoderConfigurationOptions(soap, "tt:VideoDecodingCapabilities", &a->tt__CodingCapabilities::VideoDecodingCapabilities, "tt:VideoDecoderConfigurationOptions"))
				{	soap_flag_VideoDecodingCapabilities1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__CodingCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__CodingCapabilities::VideoDecodingCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__CodingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CodingCapabilities, SOAP_TYPE_tt__CodingCapabilities, sizeof(tt__CodingCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CodingCapabilities * SOAP_FMAC2 soap_instantiate_tt__CodingCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CodingCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CodingCapabilities *p;
	size_t k = sizeof(tt__CodingCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CodingCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CodingCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CodingCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CodingCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CodingCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CodingCapabilities(soap, tag ? tag : "tt:CodingCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CodingCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CodingCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__CodingCapabilities * SOAP_FMAC4 soap_get_tt__CodingCapabilities(struct soap *soap, tt__CodingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CodingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LayoutExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__LayoutExtension::__any);
}

void tt__LayoutExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__LayoutExtension::__any);
#endif
}

int tt__LayoutExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LayoutExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LayoutExtension(struct soap *soap, const char *tag, int id, const tt__LayoutExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LayoutExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__LayoutExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LayoutExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LayoutExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__LayoutExtension * SOAP_FMAC4 soap_in_tt__LayoutExtension(struct soap *soap, const char *tag, tt__LayoutExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LayoutExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutExtension, sizeof(tt__LayoutExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LayoutExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LayoutExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__LayoutExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__LayoutExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutExtension, SOAP_TYPE_tt__LayoutExtension, sizeof(tt__LayoutExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LayoutExtension * SOAP_FMAC2 soap_instantiate_tt__LayoutExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LayoutExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LayoutExtension *p;
	size_t k = sizeof(tt__LayoutExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LayoutExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LayoutExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LayoutExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LayoutExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LayoutExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LayoutExtension(soap, tag ? tag : "tt:LayoutExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LayoutExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LayoutExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__LayoutExtension * SOAP_FMAC4 soap_get_tt__LayoutExtension(struct soap *soap, tt__LayoutExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LayoutExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Layout::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__PaneLayout(soap, &this->tt__Layout::PaneLayout);
	this->tt__Layout::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Layout::__anyAttribute);
}

void tt__Layout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PaneLayout(soap, &this->tt__Layout::PaneLayout);
	soap_serialize_PointerTott__LayoutExtension(soap, &this->tt__Layout::Extension);
#endif
}

int tt__Layout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Layout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Layout(struct soap *soap, const char *tag, int id, const tt__Layout *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Layout*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Layout), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PaneLayout(soap, "tt:PaneLayout", -1, &a->tt__Layout::PaneLayout, ""))
		return soap->error;
	if (soap_out_PointerTott__LayoutExtension(soap, "tt:Extension", -1, &a->tt__Layout::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Layout::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Layout(soap, tag, this, type);
}

SOAP_FMAC3 tt__Layout * SOAP_FMAC4 soap_in_tt__Layout(struct soap *soap, const char *tag, tt__Layout *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Layout*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Layout, sizeof(tt__Layout), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Layout)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Layout *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Layout*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PaneLayout(soap, "tt:PaneLayout", &a->tt__Layout::PaneLayout, "tt:PaneLayout"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LayoutExtension(soap, "tt:Extension", &a->tt__Layout::Extension, "tt:LayoutExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Layout::PaneLayout.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Layout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Layout, SOAP_TYPE_tt__Layout, sizeof(tt__Layout), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Layout * SOAP_FMAC2 soap_instantiate_tt__Layout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Layout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Layout *p;
	size_t k = sizeof(tt__Layout);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Layout, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Layout);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Layout, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Layout location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Layout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Layout(soap, tag ? tag : "tt:Layout", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Layout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Layout(soap, this, tag, type);
}

SOAP_FMAC3 tt__Layout * SOAP_FMAC4 soap_get_tt__Layout(struct soap *soap, tt__Layout *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Layout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PaneLayout::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &this->tt__PaneLayout::Pane);
	this->tt__PaneLayout::Area = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PaneLayout::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PaneLayout::__anyAttribute);
}

void tt__PaneLayout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PaneLayout::Pane, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__PaneLayout::Pane);
	soap_serialize_PointerTott__Rectangle(soap, &this->tt__PaneLayout::Area);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PaneLayout::__any);
#endif
}

int tt__PaneLayout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PaneLayout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneLayout(struct soap *soap, const char *tag, int id, const tt__PaneLayout *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PaneLayout*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneLayout), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:Pane", -1, &a->tt__PaneLayout::Pane, ""))
		return soap->error;
	if (!a->tt__PaneLayout::Area)
	{	if (soap_element_empty(soap, "tt:Area"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Rectangle(soap, "tt:Area", -1, &a->tt__PaneLayout::Area, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PaneLayout::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PaneLayout::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PaneLayout(soap, tag, this, type);
}

SOAP_FMAC3 tt__PaneLayout * SOAP_FMAC4 soap_in_tt__PaneLayout(struct soap *soap, const char *tag, tt__PaneLayout *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PaneLayout*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneLayout, sizeof(tt__PaneLayout), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PaneLayout)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PaneLayout *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PaneLayout*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Pane1 = 1;
	size_t soap_flag_Area1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Pane1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:Pane", &a->tt__PaneLayout::Pane, "tt:ReferenceToken"))
				{	soap_flag_Pane1--;
					continue;
				}
			}
			if (soap_flag_Area1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rectangle(soap, "tt:Area", &a->tt__PaneLayout::Area, "tt:Rectangle"))
				{	soap_flag_Area1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PaneLayout::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Pane1 > 0 || !a->tt__PaneLayout::Area))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PaneLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneLayout, SOAP_TYPE_tt__PaneLayout, sizeof(tt__PaneLayout), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PaneLayout * SOAP_FMAC2 soap_instantiate_tt__PaneLayout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PaneLayout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PaneLayout *p;
	size_t k = sizeof(tt__PaneLayout);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PaneLayout, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PaneLayout);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PaneLayout, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PaneLayout location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PaneLayout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PaneLayout(soap, tag ? tag : "tt:PaneLayout", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PaneLayout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PaneLayout(soap, this, tag, type);
}

SOAP_FMAC3 tt__PaneLayout * SOAP_FMAC4 soap_get_tt__PaneLayout(struct soap *soap, tt__PaneLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PaneConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PaneConfiguration::PaneName = NULL;
	this->tt__PaneConfiguration::AudioOutputToken = NULL;
	this->tt__PaneConfiguration::AudioSourceToken = NULL;
	this->tt__PaneConfiguration::AudioEncoderConfiguration = NULL;
	this->tt__PaneConfiguration::ReceiverToken = NULL;
	soap_default_tt__ReferenceToken(soap, &this->tt__PaneConfiguration::Token);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PaneConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PaneConfiguration::__anyAttribute);
}

void tt__PaneConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->tt__PaneConfiguration::PaneName);
	soap_serialize_PointerTott__ReferenceToken(soap, &this->tt__PaneConfiguration::AudioOutputToken);
	soap_serialize_PointerTott__ReferenceToken(soap, &this->tt__PaneConfiguration::AudioSourceToken);
	soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &this->tt__PaneConfiguration::AudioEncoderConfiguration);
	soap_serialize_PointerTott__ReferenceToken(soap, &this->tt__PaneConfiguration::ReceiverToken);
	soap_embedded(soap, &this->tt__PaneConfiguration::Token, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__PaneConfiguration::Token);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PaneConfiguration::__any);
#endif
}

int tt__PaneConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PaneConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneConfiguration(struct soap *soap, const char *tag, int id, const tt__PaneConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PaneConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneConfiguration), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:PaneName", -1, &a->tt__PaneConfiguration::PaneName, ""))
		return soap->error;
	if (soap_out_PointerTott__ReferenceToken(soap, "tt:AudioOutputToken", -1, &a->tt__PaneConfiguration::AudioOutputToken, ""))
		return soap->error;
	if (soap_out_PointerTott__ReferenceToken(soap, "tt:AudioSourceToken", -1, &a->tt__PaneConfiguration::AudioSourceToken, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", -1, &a->tt__PaneConfiguration::AudioEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__ReferenceToken(soap, "tt:ReceiverToken", -1, &a->tt__PaneConfiguration::ReceiverToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, &a->tt__PaneConfiguration::Token, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PaneConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PaneConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PaneConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__PaneConfiguration * SOAP_FMAC4 soap_in_tt__PaneConfiguration(struct soap *soap, const char *tag, tt__PaneConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PaneConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneConfiguration, sizeof(tt__PaneConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PaneConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PaneConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PaneConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_PaneName1 = 1;
	size_t soap_flag_AudioOutputToken1 = 1;
	size_t soap_flag_AudioSourceToken1 = 1;
	size_t soap_flag_AudioEncoderConfiguration1 = 1;
	size_t soap_flag_ReceiverToken1 = 1;
	size_t soap_flag_Token1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PaneName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:PaneName", &a->tt__PaneConfiguration::PaneName, "xsd:string"))
				{	soap_flag_PaneName1--;
					continue;
				}
			}
			if (soap_flag_AudioOutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__ReferenceToken(soap, "tt:AudioOutputToken", &a->tt__PaneConfiguration::AudioOutputToken, "tt:ReferenceToken"))
				{	soap_flag_AudioOutputToken1--;
					continue;
				}
			}
			if (soap_flag_AudioSourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__ReferenceToken(soap, "tt:AudioSourceToken", &a->tt__PaneConfiguration::AudioSourceToken, "tt:ReferenceToken"))
				{	soap_flag_AudioSourceToken1--;
					continue;
				}
			}
			if (soap_flag_AudioEncoderConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", &a->tt__PaneConfiguration::AudioEncoderConfiguration, "tt:AudioEncoderConfiguration"))
				{	soap_flag_AudioEncoderConfiguration1--;
					continue;
				}
			}
			if (soap_flag_ReceiverToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__ReferenceToken(soap, "tt:ReceiverToken", &a->tt__PaneConfiguration::ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken1--;
					continue;
				}
			}
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:Token", &a->tt__PaneConfiguration::Token, "tt:ReferenceToken"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PaneConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneConfiguration, SOAP_TYPE_tt__PaneConfiguration, sizeof(tt__PaneConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PaneConfiguration * SOAP_FMAC2 soap_instantiate_tt__PaneConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PaneConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PaneConfiguration *p;
	size_t k = sizeof(tt__PaneConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PaneConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PaneConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PaneConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PaneConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PaneConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PaneConfiguration(soap, tag ? tag : "tt:PaneConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PaneConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PaneConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__PaneConfiguration * SOAP_FMAC4 soap_get_tt__PaneConfiguration(struct soap *soap, tt__PaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CellLayout::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__CellLayout::Transformation = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CellLayout::__any);
	soap_default_xsd__integer(soap, &this->tt__CellLayout::Columns);
	soap_default_xsd__integer(soap, &this->tt__CellLayout::Rows);
	soap_default_xsd__anyAttribute(soap, &this->tt__CellLayout::__anyAttribute);
}

void tt__CellLayout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Transformation(soap, &this->tt__CellLayout::Transformation);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CellLayout::__any);
#endif
}

int tt__CellLayout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CellLayout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CellLayout(struct soap *soap, const char *tag, int id, const tt__CellLayout *a, const char *type)
{
	soap_set_attr(soap, "Columns", soap_xsd__integer2s(soap, ((tt__CellLayout*)a)->Columns), 1);
	soap_set_attr(soap, "Rows", soap_xsd__integer2s(soap, ((tt__CellLayout*)a)->Rows), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__CellLayout*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CellLayout), type))
		return soap->error;
	if (!a->tt__CellLayout::Transformation)
	{	if (soap_element_empty(soap, "tt:Transformation"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Transformation(soap, "tt:Transformation", -1, &a->tt__CellLayout::Transformation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__CellLayout::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CellLayout::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CellLayout(soap, tag, this, type);
}

SOAP_FMAC3 tt__CellLayout * SOAP_FMAC4 soap_in_tt__CellLayout(struct soap *soap, const char *tag, tt__CellLayout *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CellLayout*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CellLayout, sizeof(tt__CellLayout), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CellLayout)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CellLayout *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "Columns", 5, 1), &((tt__CellLayout*)a)->Columns))
		return NULL;
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "Rows", 5, 1), &((tt__CellLayout*)a)->Rows))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__CellLayout*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Transformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Transformation(soap, "tt:Transformation", &a->tt__CellLayout::Transformation, "tt:Transformation"))
				{	soap_flag_Transformation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__CellLayout::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__CellLayout::Transformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__CellLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CellLayout, SOAP_TYPE_tt__CellLayout, sizeof(tt__CellLayout), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CellLayout * SOAP_FMAC2 soap_instantiate_tt__CellLayout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CellLayout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CellLayout *p;
	size_t k = sizeof(tt__CellLayout);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CellLayout, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CellLayout);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CellLayout, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CellLayout location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CellLayout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CellLayout(soap, tag ? tag : "tt:CellLayout", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CellLayout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CellLayout(soap, this, tag, type);
}

SOAP_FMAC3 tt__CellLayout * SOAP_FMAC4 soap_get_tt__CellLayout(struct soap *soap, tt__CellLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CellLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MotionExpressionConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__MotionExpressionConfiguration::MotionExpression = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MotionExpressionConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__MotionExpressionConfiguration::__anyAttribute);
}

void tt__MotionExpressionConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MotionExpression(soap, &this->tt__MotionExpressionConfiguration::MotionExpression);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MotionExpressionConfiguration::__any);
#endif
}

int tt__MotionExpressionConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MotionExpressionConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MotionExpressionConfiguration(struct soap *soap, const char *tag, int id, const tt__MotionExpressionConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MotionExpressionConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MotionExpressionConfiguration), type))
		return soap->error;
	if (!a->tt__MotionExpressionConfiguration::MotionExpression)
	{	if (soap_element_empty(soap, "tt:MotionExpression"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MotionExpression(soap, "tt:MotionExpression", -1, &a->tt__MotionExpressionConfiguration::MotionExpression, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MotionExpressionConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MotionExpressionConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MotionExpressionConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__MotionExpressionConfiguration * SOAP_FMAC4 soap_in_tt__MotionExpressionConfiguration(struct soap *soap, const char *tag, tt__MotionExpressionConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MotionExpressionConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MotionExpressionConfiguration, sizeof(tt__MotionExpressionConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MotionExpressionConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MotionExpressionConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MotionExpressionConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_MotionExpression1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MotionExpression1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MotionExpression(soap, "tt:MotionExpression", &a->tt__MotionExpressionConfiguration::MotionExpression, "tt:MotionExpression"))
				{	soap_flag_MotionExpression1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MotionExpressionConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__MotionExpressionConfiguration::MotionExpression))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MotionExpressionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MotionExpressionConfiguration, SOAP_TYPE_tt__MotionExpressionConfiguration, sizeof(tt__MotionExpressionConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MotionExpressionConfiguration * SOAP_FMAC2 soap_instantiate_tt__MotionExpressionConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MotionExpressionConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MotionExpressionConfiguration *p;
	size_t k = sizeof(tt__MotionExpressionConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MotionExpressionConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MotionExpressionConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MotionExpressionConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MotionExpressionConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MotionExpressionConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MotionExpressionConfiguration(soap, tag ? tag : "tt:MotionExpressionConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MotionExpressionConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MotionExpressionConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__MotionExpressionConfiguration * SOAP_FMAC4 soap_get_tt__MotionExpressionConfiguration(struct soap *soap, tt__MotionExpressionConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MotionExpressionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MotionExpression::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__MotionExpression::Expression);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MotionExpression::__any);
	this->tt__MotionExpression::Type = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__MotionExpression::__anyAttribute);
}

void tt__MotionExpression::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__MotionExpression::Expression, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__MotionExpression::Expression);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MotionExpression::__any);
#endif
}

int tt__MotionExpression::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MotionExpression(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MotionExpression(struct soap *soap, const char *tag, int id, const tt__MotionExpression *a, const char *type)
{
	if (((tt__MotionExpression*)a)->Type)
	{	soap_set_attr(soap, "Type", soap_std__string2s(soap, *((tt__MotionExpression*)a)->Type), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MotionExpression*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MotionExpression), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Expression", -1, &a->tt__MotionExpression::Expression, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MotionExpression::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MotionExpression::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MotionExpression(soap, tag, this, type);
}

SOAP_FMAC3 tt__MotionExpression * SOAP_FMAC4 soap_in_tt__MotionExpression(struct soap *soap, const char *tag, tt__MotionExpression *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MotionExpression*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MotionExpression, sizeof(tt__MotionExpression), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MotionExpression)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MotionExpression *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "Type", 1, 0);
		if (t)
		{
			if (!(((tt__MotionExpression*)a)->Type = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((tt__MotionExpression*)a)->Type))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MotionExpression*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Expression1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Expression1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Expression", &a->tt__MotionExpression::Expression, "xsd:string"))
				{	soap_flag_Expression1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MotionExpression::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Expression1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MotionExpression *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MotionExpression, SOAP_TYPE_tt__MotionExpression, sizeof(tt__MotionExpression), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MotionExpression * SOAP_FMAC2 soap_instantiate_tt__MotionExpression(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MotionExpression(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MotionExpression *p;
	size_t k = sizeof(tt__MotionExpression);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MotionExpression, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MotionExpression);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MotionExpression, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MotionExpression location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MotionExpression::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MotionExpression(soap, tag ? tag : "tt:MotionExpression", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MotionExpression::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MotionExpression(soap, this, tag, type);
}

SOAP_FMAC3 tt__MotionExpression * SOAP_FMAC4 soap_get_tt__MotionExpression(struct soap *soap, tt__MotionExpression *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MotionExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PolylineArrayConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PolylineArrayConfiguration::PolylineArray = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PolylineArrayConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PolylineArrayConfiguration::__anyAttribute);
}

void tt__PolylineArrayConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PolylineArray(soap, &this->tt__PolylineArrayConfiguration::PolylineArray);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PolylineArrayConfiguration::__any);
#endif
}

int tt__PolylineArrayConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PolylineArrayConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolylineArrayConfiguration(struct soap *soap, const char *tag, int id, const tt__PolylineArrayConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PolylineArrayConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolylineArrayConfiguration), type))
		return soap->error;
	if (!a->tt__PolylineArrayConfiguration::PolylineArray)
	{	if (soap_element_empty(soap, "tt:PolylineArray"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PolylineArray(soap, "tt:PolylineArray", -1, &a->tt__PolylineArrayConfiguration::PolylineArray, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PolylineArrayConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PolylineArrayConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PolylineArrayConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__PolylineArrayConfiguration * SOAP_FMAC4 soap_in_tt__PolylineArrayConfiguration(struct soap *soap, const char *tag, tt__PolylineArrayConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PolylineArrayConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolylineArrayConfiguration, sizeof(tt__PolylineArrayConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PolylineArrayConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PolylineArrayConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PolylineArrayConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_PolylineArray1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolylineArray1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PolylineArray(soap, "tt:PolylineArray", &a->tt__PolylineArrayConfiguration::PolylineArray, "tt:PolylineArray"))
				{	soap_flag_PolylineArray1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PolylineArrayConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PolylineArrayConfiguration::PolylineArray))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PolylineArrayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolylineArrayConfiguration, SOAP_TYPE_tt__PolylineArrayConfiguration, sizeof(tt__PolylineArrayConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PolylineArrayConfiguration * SOAP_FMAC2 soap_instantiate_tt__PolylineArrayConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PolylineArrayConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PolylineArrayConfiguration *p;
	size_t k = sizeof(tt__PolylineArrayConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PolylineArrayConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PolylineArrayConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PolylineArrayConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PolylineArrayConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PolylineArrayConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PolylineArrayConfiguration(soap, tag ? tag : "tt:PolylineArrayConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PolylineArrayConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PolylineArrayConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__PolylineArrayConfiguration * SOAP_FMAC4 soap_get_tt__PolylineArrayConfiguration(struct soap *soap, tt__PolylineArrayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolylineArrayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PolylineArrayExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PolylineArrayExtension::__any);
}

void tt__PolylineArrayExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PolylineArrayExtension::__any);
#endif
}

int tt__PolylineArrayExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PolylineArrayExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolylineArrayExtension(struct soap *soap, const char *tag, int id, const tt__PolylineArrayExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolylineArrayExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PolylineArrayExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PolylineArrayExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PolylineArrayExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PolylineArrayExtension * SOAP_FMAC4 soap_in_tt__PolylineArrayExtension(struct soap *soap, const char *tag, tt__PolylineArrayExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PolylineArrayExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(tt__PolylineArrayExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PolylineArrayExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PolylineArrayExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PolylineArrayExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PolylineArrayExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolylineArrayExtension, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(tt__PolylineArrayExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PolylineArrayExtension * SOAP_FMAC2 soap_instantiate_tt__PolylineArrayExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PolylineArrayExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PolylineArrayExtension *p;
	size_t k = sizeof(tt__PolylineArrayExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PolylineArrayExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PolylineArrayExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PolylineArrayExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PolylineArrayExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PolylineArrayExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PolylineArrayExtension(soap, tag ? tag : "tt:PolylineArrayExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PolylineArrayExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PolylineArrayExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PolylineArrayExtension * SOAP_FMAC4 soap_get_tt__PolylineArrayExtension(struct soap *soap, tt__PolylineArrayExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolylineArrayExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PolylineArray::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__Polyline(soap, &this->tt__PolylineArray::Segment);
	this->tt__PolylineArray::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PolylineArray::__anyAttribute);
}

void tt__PolylineArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Polyline(soap, &this->tt__PolylineArray::Segment);
	soap_serialize_PointerTott__PolylineArrayExtension(soap, &this->tt__PolylineArray::Extension);
#endif
}

int tt__PolylineArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PolylineArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolylineArray(struct soap *soap, const char *tag, int id, const tt__PolylineArray *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PolylineArray*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolylineArray), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Polyline(soap, "tt:Segment", -1, &a->tt__PolylineArray::Segment, ""))
		return soap->error;
	if (soap_out_PointerTott__PolylineArrayExtension(soap, "tt:Extension", -1, &a->tt__PolylineArray::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PolylineArray::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PolylineArray(soap, tag, this, type);
}

SOAP_FMAC3 tt__PolylineArray * SOAP_FMAC4 soap_in_tt__PolylineArray(struct soap *soap, const char *tag, tt__PolylineArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PolylineArray*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolylineArray, sizeof(tt__PolylineArray), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PolylineArray)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PolylineArray *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PolylineArray*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Polyline(soap, "tt:Segment", &a->tt__PolylineArray::Segment, "tt:Polyline"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PolylineArrayExtension(soap, "tt:Extension", &a->tt__PolylineArray::Extension, "tt:PolylineArrayExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__PolylineArray::Segment.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PolylineArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolylineArray, SOAP_TYPE_tt__PolylineArray, sizeof(tt__PolylineArray), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PolylineArray * SOAP_FMAC2 soap_instantiate_tt__PolylineArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PolylineArray(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PolylineArray *p;
	size_t k = sizeof(tt__PolylineArray);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PolylineArray, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PolylineArray);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PolylineArray, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PolylineArray location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PolylineArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PolylineArray(soap, tag ? tag : "tt:PolylineArray", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PolylineArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PolylineArray(soap, this, tag, type);
}

SOAP_FMAC3 tt__PolylineArray * SOAP_FMAC4 soap_get_tt__PolylineArray(struct soap *soap, tt__PolylineArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolylineArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PolygonConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PolygonConfiguration::Polygon = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PolygonConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PolygonConfiguration::__anyAttribute);
}

void tt__PolygonConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Polygon(soap, &this->tt__PolygonConfiguration::Polygon);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PolygonConfiguration::__any);
#endif
}

int tt__PolygonConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PolygonConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolygonConfiguration(struct soap *soap, const char *tag, int id, const tt__PolygonConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PolygonConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolygonConfiguration), type))
		return soap->error;
	if (!a->tt__PolygonConfiguration::Polygon)
	{	if (soap_element_empty(soap, "tt:Polygon"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Polygon(soap, "tt:Polygon", -1, &a->tt__PolygonConfiguration::Polygon, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PolygonConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PolygonConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PolygonConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__PolygonConfiguration * SOAP_FMAC4 soap_in_tt__PolygonConfiguration(struct soap *soap, const char *tag, tt__PolygonConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PolygonConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolygonConfiguration, sizeof(tt__PolygonConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PolygonConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PolygonConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PolygonConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Polygon1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Polygon1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Polygon(soap, "tt:Polygon", &a->tt__PolygonConfiguration::Polygon, "tt:Polygon"))
				{	soap_flag_Polygon1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PolygonConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PolygonConfiguration::Polygon))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PolygonConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolygonConfiguration, SOAP_TYPE_tt__PolygonConfiguration, sizeof(tt__PolygonConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PolygonConfiguration * SOAP_FMAC2 soap_instantiate_tt__PolygonConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PolygonConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PolygonConfiguration *p;
	size_t k = sizeof(tt__PolygonConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PolygonConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PolygonConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PolygonConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PolygonConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PolygonConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PolygonConfiguration(soap, tag ? tag : "tt:PolygonConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PolygonConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PolygonConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__PolygonConfiguration * SOAP_FMAC4 soap_get_tt__PolygonConfiguration(struct soap *soap, tt__PolygonConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolygonConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SupportedAnalyticsModulesExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SupportedAnalyticsModulesExtension::__any);
}

void tt__SupportedAnalyticsModulesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SupportedAnalyticsModulesExtension::__any);
#endif
}

int tt__SupportedAnalyticsModulesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SupportedAnalyticsModulesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, int id, const tt__SupportedAnalyticsModulesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__SupportedAnalyticsModulesExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SupportedAnalyticsModulesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SupportedAnalyticsModulesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_in_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, tt__SupportedAnalyticsModulesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SupportedAnalyticsModulesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(tt__SupportedAnalyticsModulesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SupportedAnalyticsModulesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SupportedAnalyticsModulesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__SupportedAnalyticsModulesExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SupportedAnalyticsModulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(tt__SupportedAnalyticsModulesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SupportedAnalyticsModulesExtension * SOAP_FMAC2 soap_instantiate_tt__SupportedAnalyticsModulesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SupportedAnalyticsModulesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SupportedAnalyticsModulesExtension *p;
	size_t k = sizeof(tt__SupportedAnalyticsModulesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SupportedAnalyticsModulesExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SupportedAnalyticsModulesExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SupportedAnalyticsModulesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SupportedAnalyticsModulesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SupportedAnalyticsModulesExtension(soap, tag ? tag : "tt:SupportedAnalyticsModulesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SupportedAnalyticsModulesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SupportedAnalyticsModulesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_get_tt__SupportedAnalyticsModulesExtension(struct soap *soap, tt__SupportedAnalyticsModulesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedAnalyticsModulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SupportedAnalyticsModules::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__SupportedAnalyticsModules::AnalyticsModuleContentSchemaLocation);
	soap_default_std__vectorTemplateOfPointerTott__ConfigDescription(soap, &this->tt__SupportedAnalyticsModules::AnalyticsModuleDescription);
	this->tt__SupportedAnalyticsModules::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__SupportedAnalyticsModules::__anyAttribute);
}

void tt__SupportedAnalyticsModules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__SupportedAnalyticsModules::AnalyticsModuleContentSchemaLocation);
	soap_serialize_std__vectorTemplateOfPointerTott__ConfigDescription(soap, &this->tt__SupportedAnalyticsModules::AnalyticsModuleDescription);
	soap_serialize_PointerTott__SupportedAnalyticsModulesExtension(soap, &this->tt__SupportedAnalyticsModules::Extension);
#endif
}

int tt__SupportedAnalyticsModules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SupportedAnalyticsModules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedAnalyticsModules(struct soap *soap, const char *tag, int id, const tt__SupportedAnalyticsModules *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SupportedAnalyticsModules*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedAnalyticsModules), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tt:AnalyticsModuleContentSchemaLocation", -1, &a->tt__SupportedAnalyticsModules::AnalyticsModuleContentSchemaLocation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__ConfigDescription(soap, "tt:AnalyticsModuleDescription", -1, &a->tt__SupportedAnalyticsModules::AnalyticsModuleDescription, ""))
		return soap->error;
	if (soap_out_PointerTott__SupportedAnalyticsModulesExtension(soap, "tt:Extension", -1, &a->tt__SupportedAnalyticsModules::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SupportedAnalyticsModules::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SupportedAnalyticsModules(soap, tag, this, type);
}

SOAP_FMAC3 tt__SupportedAnalyticsModules * SOAP_FMAC4 soap_in_tt__SupportedAnalyticsModules(struct soap *soap, const char *tag, tt__SupportedAnalyticsModules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SupportedAnalyticsModules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(tt__SupportedAnalyticsModules), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SupportedAnalyticsModules)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SupportedAnalyticsModules *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SupportedAnalyticsModules*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tt:AnalyticsModuleContentSchemaLocation", &a->tt__SupportedAnalyticsModules::AnalyticsModuleContentSchemaLocation, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__ConfigDescription(soap, "tt:AnalyticsModuleDescription", &a->tt__SupportedAnalyticsModules::AnalyticsModuleDescription, "tt:ConfigDescription"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SupportedAnalyticsModulesExtension(soap, "tt:Extension", &a->tt__SupportedAnalyticsModules::Extension, "tt:SupportedAnalyticsModulesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SupportedAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedAnalyticsModules, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(tt__SupportedAnalyticsModules), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SupportedAnalyticsModules * SOAP_FMAC2 soap_instantiate_tt__SupportedAnalyticsModules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SupportedAnalyticsModules(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SupportedAnalyticsModules *p;
	size_t k = sizeof(tt__SupportedAnalyticsModules);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SupportedAnalyticsModules, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SupportedAnalyticsModules);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SupportedAnalyticsModules, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SupportedAnalyticsModules location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SupportedAnalyticsModules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SupportedAnalyticsModules(soap, tag ? tag : "tt:SupportedAnalyticsModules", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SupportedAnalyticsModules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SupportedAnalyticsModules(soap, this, tag, type);
}

SOAP_FMAC3 tt__SupportedAnalyticsModules * SOAP_FMAC4 soap_get_tt__SupportedAnalyticsModules(struct soap *soap, tt__SupportedAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SupportedRulesExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SupportedRulesExtension::__any);
}

void tt__SupportedRulesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SupportedRulesExtension::__any);
#endif
}

int tt__SupportedRulesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SupportedRulesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedRulesExtension(struct soap *soap, const char *tag, int id, const tt__SupportedRulesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedRulesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__SupportedRulesExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SupportedRulesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SupportedRulesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SupportedRulesExtension * SOAP_FMAC4 soap_in_tt__SupportedRulesExtension(struct soap *soap, const char *tag, tt__SupportedRulesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SupportedRulesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(tt__SupportedRulesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SupportedRulesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SupportedRulesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__SupportedRulesExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SupportedRulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedRulesExtension, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(tt__SupportedRulesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SupportedRulesExtension * SOAP_FMAC2 soap_instantiate_tt__SupportedRulesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SupportedRulesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SupportedRulesExtension *p;
	size_t k = sizeof(tt__SupportedRulesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SupportedRulesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SupportedRulesExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SupportedRulesExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SupportedRulesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SupportedRulesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SupportedRulesExtension(soap, tag ? tag : "tt:SupportedRulesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SupportedRulesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SupportedRulesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SupportedRulesExtension * SOAP_FMAC4 soap_get_tt__SupportedRulesExtension(struct soap *soap, tt__SupportedRulesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedRulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SupportedRules::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__SupportedRules::RuleContentSchemaLocation);
	soap_default_std__vectorTemplateOfPointerTott__ConfigDescription(soap, &this->tt__SupportedRules::RuleDescription);
	this->tt__SupportedRules::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__SupportedRules::__anyAttribute);
}

void tt__SupportedRules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__SupportedRules::RuleContentSchemaLocation);
	soap_serialize_std__vectorTemplateOfPointerTott__ConfigDescription(soap, &this->tt__SupportedRules::RuleDescription);
	soap_serialize_PointerTott__SupportedRulesExtension(soap, &this->tt__SupportedRules::Extension);
#endif
}

int tt__SupportedRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SupportedRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedRules(struct soap *soap, const char *tag, int id, const tt__SupportedRules *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SupportedRules*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedRules), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tt:RuleContentSchemaLocation", -1, &a->tt__SupportedRules::RuleContentSchemaLocation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__ConfigDescription(soap, "tt:RuleDescription", -1, &a->tt__SupportedRules::RuleDescription, ""))
		return soap->error;
	if (soap_out_PointerTott__SupportedRulesExtension(soap, "tt:Extension", -1, &a->tt__SupportedRules::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SupportedRules::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SupportedRules(soap, tag, this, type);
}

SOAP_FMAC3 tt__SupportedRules * SOAP_FMAC4 soap_in_tt__SupportedRules(struct soap *soap, const char *tag, tt__SupportedRules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SupportedRules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedRules, sizeof(tt__SupportedRules), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SupportedRules)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SupportedRules *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SupportedRules*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tt:RuleContentSchemaLocation", &a->tt__SupportedRules::RuleContentSchemaLocation, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__ConfigDescription(soap, "tt:RuleDescription", &a->tt__SupportedRules::RuleDescription, "tt:ConfigDescription"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SupportedRulesExtension(soap, "tt:Extension", &a->tt__SupportedRules::Extension, "tt:SupportedRulesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SupportedRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedRules, SOAP_TYPE_tt__SupportedRules, sizeof(tt__SupportedRules), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SupportedRules * SOAP_FMAC2 soap_instantiate_tt__SupportedRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SupportedRules(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SupportedRules *p;
	size_t k = sizeof(tt__SupportedRules);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SupportedRules, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SupportedRules);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SupportedRules, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SupportedRules location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SupportedRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SupportedRules(soap, tag ? tag : "tt:SupportedRules", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SupportedRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SupportedRules(soap, this, tag, type);
}

SOAP_FMAC3 tt__SupportedRules * SOAP_FMAC4 soap_get_tt__SupportedRules(struct soap *soap, tt__SupportedRules *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ConfigDescriptionExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ConfigDescriptionExtension::__any);
}

void tt__ConfigDescriptionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ConfigDescriptionExtension::__any);
#endif
}

int tt__ConfigDescriptionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ConfigDescriptionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigDescriptionExtension(struct soap *soap, const char *tag, int id, const tt__ConfigDescriptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigDescriptionExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ConfigDescriptionExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ConfigDescriptionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ConfigDescriptionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ConfigDescriptionExtension * SOAP_FMAC4 soap_in_tt__ConfigDescriptionExtension(struct soap *soap, const char *tag, tt__ConfigDescriptionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ConfigDescriptionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(tt__ConfigDescriptionExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ConfigDescriptionExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ConfigDescriptionExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ConfigDescriptionExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ConfigDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigDescriptionExtension, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(tt__ConfigDescriptionExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ConfigDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__ConfigDescriptionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ConfigDescriptionExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ConfigDescriptionExtension *p;
	size_t k = sizeof(tt__ConfigDescriptionExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ConfigDescriptionExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ConfigDescriptionExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ConfigDescriptionExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ConfigDescriptionExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ConfigDescriptionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ConfigDescriptionExtension(soap, tag ? tag : "tt:ConfigDescriptionExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ConfigDescriptionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ConfigDescriptionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ConfigDescriptionExtension * SOAP_FMAC4 soap_get_tt__ConfigDescriptionExtension(struct soap *soap, tt__ConfigDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ConfigDescription::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigDescription::Parameters = NULL;
	soap_default_std__vectorTemplateOf_tt__ConfigDescription_Messages(soap, &this->tt__ConfigDescription::Messages);
	this->tt__ConfigDescription::Extension = NULL;
	soap_default_xsd__QName(soap, &this->tt__ConfigDescription::Name);
	this->tt__ConfigDescription::fixed = NULL;
	this->tt__ConfigDescription::maxInstances = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ConfigDescription::__anyAttribute);
}

void tt__ConfigDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemListDescription(soap, &this->tt__ConfigDescription::Parameters);
	soap_serialize_std__vectorTemplateOf_tt__ConfigDescription_Messages(soap, &this->tt__ConfigDescription::Messages);
	soap_serialize_PointerTott__ConfigDescriptionExtension(soap, &this->tt__ConfigDescription::Extension);
#endif
}

int tt__ConfigDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ConfigDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigDescription(struct soap *soap, const char *tag, int id, const tt__ConfigDescription *a, const char *type)
{
	soap_set_attr(soap, "Name", soap_xsd__QName2s(soap, ((tt__ConfigDescription*)a)->Name), 1);
	if (((tt__ConfigDescription*)a)->fixed)
	{	soap_set_attr(soap, "fixed", soap_bool2s(soap, *((tt__ConfigDescription*)a)->fixed), 1);
	}
	if (((tt__ConfigDescription*)a)->maxInstances)
	{	soap_set_attr(soap, "maxInstances", soap_xsd__integer2s(soap, *((tt__ConfigDescription*)a)->maxInstances), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ConfigDescription*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigDescription), type))
		return soap->error;
	if (!a->tt__ConfigDescription::Parameters)
	{	if (soap_element_empty(soap, "tt:Parameters"))
			return soap->error;
	}
	else if (soap_out_PointerTott__ItemListDescription(soap, "tt:Parameters", -1, &a->tt__ConfigDescription::Parameters, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_tt__ConfigDescription_Messages(soap, "tt:Messages", -1, &a->tt__ConfigDescription::Messages, ""))
		return soap->error;
	if (soap_out_PointerTott__ConfigDescriptionExtension(soap, "tt:Extension", -1, &a->tt__ConfigDescription::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ConfigDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ConfigDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__ConfigDescription * SOAP_FMAC4 soap_in_tt__ConfigDescription(struct soap *soap, const char *tag, tt__ConfigDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ConfigDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigDescription, sizeof(tt__ConfigDescription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ConfigDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ConfigDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "Name", 2, 1), &((tt__ConfigDescription*)a)->Name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "fixed", 5, 0);
		if (t)
		{
			if (!(((tt__ConfigDescription*)a)->fixed = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__ConfigDescription*)a)->fixed))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "maxInstances", 5, 0);
		if (t)
		{
			if (!(((tt__ConfigDescription*)a)->maxInstances = soap_new_xsd__integer(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__integer(soap, t, ((tt__ConfigDescription*)a)->maxInstances))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ConfigDescription*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Parameters1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Parameters", &a->tt__ConfigDescription::Parameters, "tt:ItemListDescription"))
				{	soap_flag_Parameters1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_tt__ConfigDescription_Messages(soap, "tt:Messages", &a->tt__ConfigDescription::Messages, ""))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ConfigDescriptionExtension(soap, "tt:Extension", &a->tt__ConfigDescription::Extension, "tt:ConfigDescriptionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__ConfigDescription::Parameters))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ConfigDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigDescription, SOAP_TYPE_tt__ConfigDescription, sizeof(tt__ConfigDescription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ConfigDescription * SOAP_FMAC2 soap_instantiate_tt__ConfigDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ConfigDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ConfigDescription *p;
	size_t k = sizeof(tt__ConfigDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ConfigDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ConfigDescription);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ConfigDescription, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ConfigDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ConfigDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ConfigDescription(soap, tag ? tag : "tt:ConfigDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ConfigDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ConfigDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__ConfigDescription * SOAP_FMAC4 soap_get_tt__ConfigDescription(struct soap *soap, tt__ConfigDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Config::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__Config::Parameters = NULL;
	soap_default_std__string(soap, &this->tt__Config::Name);
	soap_default_xsd__QName(soap, &this->tt__Config::Type);
}

void tt__Config::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemList(soap, &this->tt__Config::Parameters);
#endif
}

int tt__Config::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Config(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Config(struct soap *soap, const char *tag, int id, const tt__Config *a, const char *type)
{
	soap_set_attr(soap, "Name", soap_std__string2s(soap, ((tt__Config*)a)->Name), 1);
	soap_set_attr(soap, "Type", soap_xsd__QName2s(soap, ((tt__Config*)a)->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Config), type))
		return soap->error;
	if (!a->tt__Config::Parameters)
	{	if (soap_element_empty(soap, "tt:Parameters"))
			return soap->error;
	}
	else if (soap_out_PointerTott__ItemList(soap, "tt:Parameters", -1, &a->tt__Config::Parameters, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Config::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Config(soap, tag, this, type);
}

SOAP_FMAC3 tt__Config * SOAP_FMAC4 soap_in_tt__Config(struct soap *soap, const char *tag, tt__Config *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Config*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Config, sizeof(tt__Config), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Config)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Config *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__string(soap, soap_attr_value(soap, "Name", 1, 1), &((tt__Config*)a)->Name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "Type", 2, 1), &((tt__Config*)a)->Type))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Parameters", &a->tt__Config::Parameters, "tt:ItemList"))
				{	soap_flag_Parameters1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__Config::Parameters))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Config *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Config, SOAP_TYPE_tt__Config, sizeof(tt__Config), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Config * SOAP_FMAC2 soap_instantiate_tt__Config(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Config(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Config *p;
	size_t k = sizeof(tt__Config);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Config, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Config);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Config, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Config location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Config::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Config(soap, tag ? tag : "tt:Config", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Config::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Config(soap, this, tag, type);
}

SOAP_FMAC3 tt__Config * SOAP_FMAC4 soap_get_tt__Config(struct soap *soap, tt__Config *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RuleEngineConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RuleEngineConfigurationExtension::__any);
}

void tt__RuleEngineConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RuleEngineConfigurationExtension::__any);
#endif
}

int tt__RuleEngineConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RuleEngineConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__RuleEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RuleEngineConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RuleEngineConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RuleEngineConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, tt__RuleEngineConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RuleEngineConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(tt__RuleEngineConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RuleEngineConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RuleEngineConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RuleEngineConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RuleEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfigurationExtension, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(tt__RuleEngineConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RuleEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RuleEngineConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RuleEngineConfigurationExtension *p;
	size_t k = sizeof(tt__RuleEngineConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RuleEngineConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RuleEngineConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RuleEngineConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RuleEngineConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RuleEngineConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RuleEngineConfigurationExtension(soap, tag ? tag : "tt:RuleEngineConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RuleEngineConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RuleEngineConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RuleEngineConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__RuleEngineConfiguration::Rule);
	this->tt__RuleEngineConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__RuleEngineConfiguration::__anyAttribute);
}

void tt__RuleEngineConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__RuleEngineConfiguration::Rule);
	soap_serialize_PointerTott__RuleEngineConfigurationExtension(soap, &this->tt__RuleEngineConfiguration::Extension);
#endif
}

int tt__RuleEngineConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RuleEngineConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, const tt__RuleEngineConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RuleEngineConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfiguration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tt:Rule", -1, &a->tt__RuleEngineConfiguration::Rule, ""))
		return soap->error;
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", -1, &a->tt__RuleEngineConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RuleEngineConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RuleEngineConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__RuleEngineConfiguration * SOAP_FMAC4 soap_in_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, tt__RuleEngineConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RuleEngineConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(tt__RuleEngineConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RuleEngineConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RuleEngineConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RuleEngineConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tt:Rule", &a->tt__RuleEngineConfiguration::Rule, "tt:Config"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", &a->tt__RuleEngineConfiguration::Extension, "tt:RuleEngineConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RuleEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfiguration, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(tt__RuleEngineConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RuleEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RuleEngineConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RuleEngineConfiguration *p;
	size_t k = sizeof(tt__RuleEngineConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RuleEngineConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RuleEngineConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RuleEngineConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RuleEngineConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RuleEngineConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RuleEngineConfiguration(soap, tag ? tag : "tt:RuleEngineConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RuleEngineConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RuleEngineConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__RuleEngineConfiguration * SOAP_FMAC4 soap_get_tt__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsEngineConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsEngineConfigurationExtension::__any);
}

void tt__AnalyticsEngineConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsEngineConfigurationExtension::__any);
#endif
}

int tt__AnalyticsEngineConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AnalyticsEngineConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsEngineConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsEngineConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(tt__AnalyticsEngineConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsEngineConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AnalyticsEngineConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(tt__AnalyticsEngineConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsEngineConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsEngineConfigurationExtension *p;
	size_t k = sizeof(tt__AnalyticsEngineConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsEngineConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsEngineConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsEngineConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsEngineConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsEngineConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngineConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngineConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsEngineConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__AnalyticsEngineConfiguration::AnalyticsModule);
	this->tt__AnalyticsEngineConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__AnalyticsEngineConfiguration::__anyAttribute);
}

void tt__AnalyticsEngineConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__AnalyticsEngineConfiguration::AnalyticsModule);
	soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(soap, &this->tt__AnalyticsEngineConfiguration::Extension);
#endif
}

int tt__AnalyticsEngineConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngineConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngineConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnalyticsEngineConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tt:AnalyticsModule", -1, &a->tt__AnalyticsEngineConfiguration::AnalyticsModule, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", -1, &a->tt__AnalyticsEngineConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsEngineConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsEngineConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, tt__AnalyticsEngineConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsEngineConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(tt__AnalyticsEngineConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsEngineConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsEngineConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnalyticsEngineConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tt:AnalyticsModule", &a->tt__AnalyticsEngineConfiguration::AnalyticsModule, "tt:Config"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", &a->tt__AnalyticsEngineConfiguration::Extension, "tt:AnalyticsEngineConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfiguration, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(tt__AnalyticsEngineConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsEngineConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsEngineConfiguration *p;
	size_t k = sizeof(tt__AnalyticsEngineConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsEngineConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsEngineConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsEngineConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsEngineConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsEngineConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsEngineConfiguration(soap, tag ? tag : "tt:AnalyticsEngineConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngineConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngineConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Polyline::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polyline::Point);
}

void tt__Polyline::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polyline::Point);
#endif
}

int tt__Polyline::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Polyline(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polyline(struct soap *soap, const char *tag, int id, const tt__Polyline *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polyline), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", -1, &a->tt__Polyline::Point, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Polyline::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Polyline(soap, tag, this, type);
}

SOAP_FMAC3 tt__Polyline * SOAP_FMAC4 soap_in_tt__Polyline(struct soap *soap, const char *tag, tt__Polyline *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Polyline*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polyline, sizeof(tt__Polyline), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Polyline)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Polyline *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", &a->tt__Polyline::Point, "tt:Vector"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Polyline::Point.size() < 2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Polyline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polyline, SOAP_TYPE_tt__Polyline, sizeof(tt__Polyline), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Polyline * SOAP_FMAC2 soap_instantiate_tt__Polyline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Polyline(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Polyline *p;
	size_t k = sizeof(tt__Polyline);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Polyline, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Polyline);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Polyline, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Polyline location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Polyline::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Polyline(soap, tag ? tag : "tt:Polyline", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Polyline::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Polyline(soap, this, tag, type);
}

SOAP_FMAC3 tt__Polyline * SOAP_FMAC4 soap_get_tt__Polyline(struct soap *soap, tt__Polyline *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polyline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ItemListDescriptionExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ItemListDescriptionExtension::__any);
}

void tt__ItemListDescriptionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ItemListDescriptionExtension::__any);
#endif
}

int tt__ItemListDescriptionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ItemListDescriptionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, const tt__ItemListDescriptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListDescriptionExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ItemListDescriptionExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ItemListDescriptionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ItemListDescriptionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_in_tt__ItemListDescriptionExtension(struct soap *soap, const char *tag, tt__ItemListDescriptionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ItemListDescriptionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(tt__ItemListDescriptionExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ItemListDescriptionExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ItemListDescriptionExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ItemListDescriptionExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ItemListDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescriptionExtension, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(tt__ItemListDescriptionExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ItemListDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListDescriptionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ItemListDescriptionExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ItemListDescriptionExtension *p;
	size_t k = sizeof(tt__ItemListDescriptionExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ItemListDescriptionExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ItemListDescriptionExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ItemListDescriptionExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ItemListDescriptionExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ItemListDescriptionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ItemListDescriptionExtension(soap, tag ? tag : "tt:ItemListDescriptionExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ItemListDescriptionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ItemListDescriptionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_get_tt__ItemListDescriptionExtension(struct soap *soap, tt__ItemListDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ItemListDescription::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(soap, &this->tt__ItemListDescription::SimpleItemDescription);
	soap_default_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(soap, &this->tt__ItemListDescription::ElementItemDescription);
	this->tt__ItemListDescription::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ItemListDescription::__anyAttribute);
}

void tt__ItemListDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(soap, &this->tt__ItemListDescription::SimpleItemDescription);
	soap_serialize_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(soap, &this->tt__ItemListDescription::ElementItemDescription);
	soap_serialize_PointerTott__ItemListDescriptionExtension(soap, &this->tt__ItemListDescription::Extension);
#endif
}

int tt__ItemListDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ItemListDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListDescription(struct soap *soap, const char *tag, int id, const tt__ItemListDescription *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ItemListDescription*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListDescription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(soap, "tt:SimpleItemDescription", -1, &a->tt__ItemListDescription::SimpleItemDescription, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(soap, "tt:ElementItemDescription", -1, &a->tt__ItemListDescription::ElementItemDescription, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescriptionExtension(soap, "tt:Extension", -1, &a->tt__ItemListDescription::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ItemListDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ItemListDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__ItemListDescription * SOAP_FMAC4 soap_in_tt__ItemListDescription(struct soap *soap, const char *tag, tt__ItemListDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ItemListDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescription, sizeof(tt__ItemListDescription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ItemListDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ItemListDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ItemListDescription*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(soap, "tt:SimpleItemDescription", &a->tt__ItemListDescription::SimpleItemDescription, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(soap, "tt:ElementItemDescription", &a->tt__ItemListDescription::ElementItemDescription, ""))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescriptionExtension(soap, "tt:Extension", &a->tt__ItemListDescription::Extension, "tt:ItemListDescriptionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ItemListDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescription, SOAP_TYPE_tt__ItemListDescription, sizeof(tt__ItemListDescription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ItemListDescription * SOAP_FMAC2 soap_instantiate_tt__ItemListDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ItemListDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ItemListDescription *p;
	size_t k = sizeof(tt__ItemListDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ItemListDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ItemListDescription);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ItemListDescription, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ItemListDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ItemListDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ItemListDescription(soap, tag ? tag : "tt:ItemListDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ItemListDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ItemListDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__ItemListDescription * SOAP_FMAC4 soap_get_tt__ItemListDescription(struct soap *soap, tt__ItemListDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MessageDescriptionExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MessageDescriptionExtension::__any);
}

void tt__MessageDescriptionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MessageDescriptionExtension::__any);
#endif
}

int tt__MessageDescriptionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MessageDescriptionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, const tt__MessageDescriptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageDescriptionExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MessageDescriptionExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MessageDescriptionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MessageDescriptionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MessageDescriptionExtension * SOAP_FMAC4 soap_in_tt__MessageDescriptionExtension(struct soap *soap, const char *tag, tt__MessageDescriptionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MessageDescriptionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(tt__MessageDescriptionExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MessageDescriptionExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MessageDescriptionExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MessageDescriptionExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MessageDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescriptionExtension, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(tt__MessageDescriptionExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MessageDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__MessageDescriptionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MessageDescriptionExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MessageDescriptionExtension *p;
	size_t k = sizeof(tt__MessageDescriptionExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MessageDescriptionExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MessageDescriptionExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MessageDescriptionExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MessageDescriptionExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MessageDescriptionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MessageDescriptionExtension(soap, tag ? tag : "tt:MessageDescriptionExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MessageDescriptionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MessageDescriptionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MessageDescriptionExtension * SOAP_FMAC4 soap_get_tt__MessageDescriptionExtension(struct soap *soap, tt__MessageDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MessageDescription::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__MessageDescription::Source = NULL;
	this->tt__MessageDescription::Key = NULL;
	this->tt__MessageDescription::Data = NULL;
	this->tt__MessageDescription::Extension = NULL;
	this->tt__MessageDescription::IsProperty = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__MessageDescription::__anyAttribute);
}

void tt__MessageDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemListDescription(soap, &this->tt__MessageDescription::Source);
	soap_serialize_PointerTott__ItemListDescription(soap, &this->tt__MessageDescription::Key);
	soap_serialize_PointerTott__ItemListDescription(soap, &this->tt__MessageDescription::Data);
	soap_serialize_PointerTott__MessageDescriptionExtension(soap, &this->tt__MessageDescription::Extension);
#endif
}

int tt__MessageDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MessageDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageDescription(struct soap *soap, const char *tag, int id, const tt__MessageDescription *a, const char *type)
{
	if (((tt__MessageDescription*)a)->IsProperty)
	{	soap_set_attr(soap, "IsProperty", soap_bool2s(soap, *((tt__MessageDescription*)a)->IsProperty), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MessageDescription*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageDescription), type))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Source", -1, &a->tt__MessageDescription::Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Key", -1, &a->tt__MessageDescription::Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Data", -1, &a->tt__MessageDescription::Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", -1, &a->tt__MessageDescription::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MessageDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MessageDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__MessageDescription * SOAP_FMAC4 soap_in_tt__MessageDescription(struct soap *soap, const char *tag, tt__MessageDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MessageDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescription, sizeof(tt__MessageDescription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MessageDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MessageDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "IsProperty", 5, 0);
		if (t)
		{
			if (!(((tt__MessageDescription*)a)->IsProperty = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__MessageDescription*)a)->IsProperty))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MessageDescription*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Source1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Data1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Source", &a->tt__MessageDescription::Source, "tt:ItemListDescription"))
				{	soap_flag_Source1--;
					continue;
				}
			}
			if (soap_flag_Key1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Key", &a->tt__MessageDescription::Key, "tt:ItemListDescription"))
				{	soap_flag_Key1--;
					continue;
				}
			}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Data", &a->tt__MessageDescription::Data, "tt:ItemListDescription"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", &a->tt__MessageDescription::Extension, "tt:MessageDescriptionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MessageDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescription, SOAP_TYPE_tt__MessageDescription, sizeof(tt__MessageDescription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MessageDescription * SOAP_FMAC2 soap_instantiate_tt__MessageDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MessageDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MessageDescription *p;
	size_t k = sizeof(tt__MessageDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MessageDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MessageDescription);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MessageDescription, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MessageDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MessageDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MessageDescription(soap, tag ? tag : "tt:MessageDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MessageDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MessageDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__MessageDescription * SOAP_FMAC4 soap_get_tt__MessageDescription(struct soap *soap, tt__MessageDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ItemListExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ItemListExtension::__any);
}

void tt__ItemListExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ItemListExtension::__any);
#endif
}

int tt__ItemListExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ItemListExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListExtension(struct soap *soap, const char *tag, int id, const tt__ItemListExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ItemListExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ItemListExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ItemListExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ItemListExtension * SOAP_FMAC4 soap_in_tt__ItemListExtension(struct soap *soap, const char *tag, tt__ItemListExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ItemListExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListExtension, sizeof(tt__ItemListExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ItemListExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ItemListExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ItemListExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ItemListExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListExtension, SOAP_TYPE_tt__ItemListExtension, sizeof(tt__ItemListExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ItemListExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ItemListExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ItemListExtension *p;
	size_t k = sizeof(tt__ItemListExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ItemListExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ItemListExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ItemListExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ItemListExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ItemListExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ItemListExtension(soap, tag ? tag : "tt:ItemListExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ItemListExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ItemListExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ItemListExtension * SOAP_FMAC4 soap_get_tt__ItemListExtension(struct soap *soap, tt__ItemListExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ItemList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, &this->tt__ItemList::SimpleItem);
	soap_default_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, &this->tt__ItemList::ElementItem);
	this->tt__ItemList::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ItemList::__anyAttribute);
}

void tt__ItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, &this->tt__ItemList::SimpleItem);
	soap_serialize_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, &this->tt__ItemList::ElementItem);
	soap_serialize_PointerTott__ItemListExtension(soap, &this->tt__ItemList::Extension);
#endif
}

int tt__ItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemList(struct soap *soap, const char *tag, int id, const tt__ItemList *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ItemList*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, "tt:SimpleItem", -1, &a->tt__ItemList::SimpleItem, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, "tt:ElementItem", -1, &a->tt__ItemList::ElementItem, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListExtension(soap, "tt:Extension", -1, &a->tt__ItemList::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ItemList(soap, tag, this, type);
}

SOAP_FMAC3 tt__ItemList * SOAP_FMAC4 soap_in_tt__ItemList(struct soap *soap, const char *tag, tt__ItemList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ItemList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemList, sizeof(tt__ItemList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ItemList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ItemList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ItemList*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, "tt:SimpleItem", &a->tt__ItemList::SimpleItem, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, "tt:ElementItem", &a->tt__ItemList::ElementItem, ""))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListExtension(soap, "tt:Extension", &a->tt__ItemList::Extension, "tt:ItemListExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemList, SOAP_TYPE_tt__ItemList, sizeof(tt__ItemList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ItemList * SOAP_FMAC2 soap_instantiate_tt__ItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ItemList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ItemList *p;
	size_t k = sizeof(tt__ItemList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ItemList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ItemList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ItemList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ItemList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ItemList(soap, tag ? tag : "tt:ItemList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ItemList(soap, this, tag, type);
}

SOAP_FMAC3 tt__ItemList * SOAP_FMAC4 soap_get_tt__ItemList(struct soap *soap, tt__ItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MessageExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MessageExtension::__any);
}

void tt__MessageExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MessageExtension::__any);
#endif
}

int tt__MessageExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MessageExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageExtension(struct soap *soap, const char *tag, int id, const tt__MessageExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MessageExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MessageExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MessageExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MessageExtension * SOAP_FMAC4 soap_in_tt__MessageExtension(struct soap *soap, const char *tag, tt__MessageExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MessageExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageExtension, sizeof(tt__MessageExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MessageExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MessageExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MessageExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MessageExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageExtension, SOAP_TYPE_tt__MessageExtension, sizeof(tt__MessageExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MessageExtension * SOAP_FMAC2 soap_instantiate_tt__MessageExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MessageExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MessageExtension *p;
	size_t k = sizeof(tt__MessageExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MessageExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MessageExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MessageExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MessageExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MessageExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MessageExtension(soap, tag ? tag : "tt:MessageExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MessageExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MessageExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MessageExtension * SOAP_FMAC4 soap_get_tt__MessageExtension(struct soap *soap, tt__MessageExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NoiseReductionOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__NoiseReductionOptions::Level);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NoiseReductionOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__NoiseReductionOptions::__anyAttribute);
}

void tt__NoiseReductionOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NoiseReductionOptions::Level, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NoiseReductionOptions::__any);
#endif
}

int tt__NoiseReductionOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NoiseReductionOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NoiseReductionOptions(struct soap *soap, const char *tag, int id, const tt__NoiseReductionOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NoiseReductionOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NoiseReductionOptions), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:Level", -1, &a->tt__NoiseReductionOptions::Level, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NoiseReductionOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NoiseReductionOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NoiseReductionOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__NoiseReductionOptions * SOAP_FMAC4 soap_in_tt__NoiseReductionOptions(struct soap *soap, const char *tag, tt__NoiseReductionOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NoiseReductionOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(tt__NoiseReductionOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NoiseReductionOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NoiseReductionOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NoiseReductionOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Level", &a->tt__NoiseReductionOptions::Level, "xsd:boolean"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NoiseReductionOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NoiseReductionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NoiseReductionOptions, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(tt__NoiseReductionOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NoiseReductionOptions * SOAP_FMAC2 soap_instantiate_tt__NoiseReductionOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NoiseReductionOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NoiseReductionOptions *p;
	size_t k = sizeof(tt__NoiseReductionOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NoiseReductionOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NoiseReductionOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NoiseReductionOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NoiseReductionOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NoiseReductionOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NoiseReductionOptions(soap, tag ? tag : "tt:NoiseReductionOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NoiseReductionOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NoiseReductionOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__NoiseReductionOptions * SOAP_FMAC4 soap_get_tt__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NoiseReductionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DefoggingOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__DefoggingOptions::Mode);
	soap_default_bool(soap, &this->tt__DefoggingOptions::Level);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DefoggingOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__DefoggingOptions::__anyAttribute);
}

void tt__DefoggingOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__DefoggingOptions::Mode);
	soap_embedded(soap, &this->tt__DefoggingOptions::Level, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DefoggingOptions::__any);
#endif
}

int tt__DefoggingOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DefoggingOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingOptions(struct soap *soap, const char *tag, int id, const tt__DefoggingOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__DefoggingOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DefoggingOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:Mode", -1, &a->tt__DefoggingOptions::Mode, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Level", -1, &a->tt__DefoggingOptions::Level, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__DefoggingOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DefoggingOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DefoggingOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__DefoggingOptions * SOAP_FMAC4 soap_in_tt__DefoggingOptions(struct soap *soap, const char *tag, tt__DefoggingOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DefoggingOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingOptions, sizeof(tt__DefoggingOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DefoggingOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DefoggingOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__DefoggingOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:Mode", &a->tt__DefoggingOptions::Mode, "xsd:string"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Level", &a->tt__DefoggingOptions::Level, "xsd:boolean"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__DefoggingOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__DefoggingOptions::Mode.size() < 1 || soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DefoggingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingOptions, SOAP_TYPE_tt__DefoggingOptions, sizeof(tt__DefoggingOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DefoggingOptions * SOAP_FMAC2 soap_instantiate_tt__DefoggingOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DefoggingOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DefoggingOptions *p;
	size_t k = sizeof(tt__DefoggingOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DefoggingOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DefoggingOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DefoggingOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DefoggingOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DefoggingOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DefoggingOptions(soap, tag ? tag : "tt:DefoggingOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DefoggingOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DefoggingOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__DefoggingOptions * SOAP_FMAC4 soap_get_tt__DefoggingOptions(struct soap *soap, tt__DefoggingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DefoggingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ToneCompensationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__ToneCompensationOptions::Mode);
	soap_default_bool(soap, &this->tt__ToneCompensationOptions::Level);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ToneCompensationOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ToneCompensationOptions::__anyAttribute);
}

void tt__ToneCompensationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__ToneCompensationOptions::Mode);
	soap_embedded(soap, &this->tt__ToneCompensationOptions::Level, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ToneCompensationOptions::__any);
#endif
}

int tt__ToneCompensationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ToneCompensationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationOptions(struct soap *soap, const char *tag, int id, const tt__ToneCompensationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ToneCompensationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensationOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:Mode", -1, &a->tt__ToneCompensationOptions::Mode, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Level", -1, &a->tt__ToneCompensationOptions::Level, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ToneCompensationOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ToneCompensationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ToneCompensationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ToneCompensationOptions * SOAP_FMAC4 soap_in_tt__ToneCompensationOptions(struct soap *soap, const char *tag, tt__ToneCompensationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ToneCompensationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(tt__ToneCompensationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ToneCompensationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ToneCompensationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ToneCompensationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:Mode", &a->tt__ToneCompensationOptions::Mode, "xsd:string"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Level", &a->tt__ToneCompensationOptions::Level, "xsd:boolean"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ToneCompensationOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__ToneCompensationOptions::Mode.size() < 1 || soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ToneCompensationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationOptions, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(tt__ToneCompensationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ToneCompensationOptions * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ToneCompensationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ToneCompensationOptions *p;
	size_t k = sizeof(tt__ToneCompensationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ToneCompensationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ToneCompensationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ToneCompensationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ToneCompensationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ToneCompensationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ToneCompensationOptions(soap, tag ? tag : "tt:ToneCompensationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ToneCompensationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ToneCompensationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ToneCompensationOptions * SOAP_FMAC4 soap_get_tt__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusOptions20Extension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusOptions20Extension::__any);
}

void tt__FocusOptions20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusOptions20Extension::__any);
#endif
}

int tt__FocusOptions20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusOptions20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20Extension(struct soap *soap, const char *tag, int id, const tt__FocusOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__FocusOptions20Extension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusOptions20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusOptions20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusOptions20Extension * SOAP_FMAC4 soap_in_tt__FocusOptions20Extension(struct soap *soap, const char *tag, tt__FocusOptions20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusOptions20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(tt__FocusOptions20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusOptions20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusOptions20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__FocusOptions20Extension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20Extension, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(tt__FocusOptions20Extension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusOptions20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusOptions20Extension *p;
	size_t k = sizeof(tt__FocusOptions20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusOptions20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusOptions20Extension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusOptions20Extension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusOptions20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusOptions20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusOptions20Extension(soap, tag ? tag : "tt:FocusOptions20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusOptions20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusOptions20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusOptions20Extension * SOAP_FMAC4 soap_get_tt__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusOptions20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__AutoFocusMode(soap, &this->tt__FocusOptions20::AutoFocusModes);
	this->tt__FocusOptions20::DefaultSpeed = NULL;
	this->tt__FocusOptions20::NearLimit = NULL;
	this->tt__FocusOptions20::FarLimit = NULL;
	this->tt__FocusOptions20::Extension = NULL;
}

void tt__FocusOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__AutoFocusMode(soap, &this->tt__FocusOptions20::AutoFocusModes);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions20::DefaultSpeed);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions20::NearLimit);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions20::FarLimit);
	soap_serialize_PointerTott__FocusOptions20Extension(soap, &this->tt__FocusOptions20::Extension);
#endif
}

int tt__FocusOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20(struct soap *soap, const char *tag, int id, const tt__FocusOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__AutoFocusMode(soap, "tt:AutoFocusModes", -1, &a->tt__FocusOptions20::AutoFocusModes, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:DefaultSpeed", -1, &a->tt__FocusOptions20::DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:NearLimit", -1, &a->tt__FocusOptions20::NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:FarLimit", -1, &a->tt__FocusOptions20::FarLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20Extension(soap, "tt:Extension", -1, &a->tt__FocusOptions20::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusOptions20 * SOAP_FMAC4 soap_in_tt__FocusOptions20(struct soap *soap, const char *tag, tt__FocusOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20, sizeof(tt__FocusOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__AutoFocusMode(soap, "tt:AutoFocusModes", &a->tt__FocusOptions20::AutoFocusModes, "tt:AutoFocusMode"))
					continue;
			}
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:DefaultSpeed", &a->tt__FocusOptions20::DefaultSpeed, "tt:FloatRange"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:NearLimit", &a->tt__FocusOptions20::NearLimit, "tt:FloatRange"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:FarLimit", &a->tt__FocusOptions20::FarLimit, "tt:FloatRange"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusOptions20Extension(soap, "tt:Extension", &a->tt__FocusOptions20::Extension, "tt:FocusOptions20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20, SOAP_TYPE_tt__FocusOptions20, sizeof(tt__FocusOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusOptions20 *p;
	size_t k = sizeof(tt__FocusOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusOptions20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusOptions20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusOptions20(soap, tag ? tag : "tt:FocusOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusOptions20 * SOAP_FMAC4 soap_get_tt__FocusOptions20(struct soap *soap, tt__FocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalanceOptions20Extension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__WhiteBalanceOptions20Extension::__any);
}

void tt__WhiteBalanceOptions20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__WhiteBalanceOptions20Extension::__any);
#endif
}

int tt__WhiteBalanceOptions20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalanceOptions20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, const tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__WhiteBalanceOptions20Extension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalanceOptions20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalanceOptions20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(tt__WhiteBalanceOptions20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalanceOptions20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalanceOptions20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__WhiteBalanceOptions20Extension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WhiteBalanceOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(tt__WhiteBalanceOptions20Extension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalanceOptions20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalanceOptions20Extension *p;
	size_t k = sizeof(tt__WhiteBalanceOptions20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalanceOptions20Extension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalanceOptions20Extension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalanceOptions20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalanceOptions20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalanceOptions20Extension(soap, tag ? tag : "tt:WhiteBalanceOptions20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalanceOptions20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalanceOptions20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalanceOptions20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceOptions20::Mode);
	this->tt__WhiteBalanceOptions20::YrGain = NULL;
	this->tt__WhiteBalanceOptions20::YbGain = NULL;
	this->tt__WhiteBalanceOptions20::Extension = NULL;
}

void tt__WhiteBalanceOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceOptions20::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WhiteBalanceOptions20::YrGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WhiteBalanceOptions20::YbGain);
	soap_serialize_PointerTott__WhiteBalanceOptions20Extension(soap, &this->tt__WhiteBalanceOptions20::Extension);
#endif
}

int tt__WhiteBalanceOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalanceOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, const tt__WhiteBalanceOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->tt__WhiteBalanceOptions20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:YrGain", -1, &a->tt__WhiteBalanceOptions20::YrGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:YbGain", -1, &a->tt__WhiteBalanceOptions20::YbGain, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", -1, &a->tt__WhiteBalanceOptions20::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalanceOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalanceOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalanceOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(tt__WhiteBalanceOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalanceOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalanceOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_YrGain1 = 1;
	size_t soap_flag_YbGain1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__WhiteBalanceMode(soap, "tt:Mode", &a->tt__WhiteBalanceOptions20::Mode, "tt:WhiteBalanceMode"))
					continue;
			}
			if (soap_flag_YrGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YrGain", &a->tt__WhiteBalanceOptions20::YrGain, "tt:FloatRange"))
				{	soap_flag_YrGain1--;
					continue;
				}
			}
			if (soap_flag_YbGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YbGain", &a->tt__WhiteBalanceOptions20::YbGain, "tt:FloatRange"))
				{	soap_flag_YbGain1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", &a->tt__WhiteBalanceOptions20::Extension, "tt:WhiteBalanceOptions20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__WhiteBalanceOptions20::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WhiteBalanceOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(tt__WhiteBalanceOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalanceOptions20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalanceOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalanceOptions20 *p;
	size_t k = sizeof(tt__WhiteBalanceOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalanceOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalanceOptions20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalanceOptions20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalanceOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalanceOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalanceOptions20(soap, tag ? tag : "tt:WhiteBalanceOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalanceOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalanceOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusConfiguration20Extension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusConfiguration20Extension::__any);
}

void tt__FocusConfiguration20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusConfiguration20Extension::__any);
#endif
}

int tt__FocusConfiguration20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusConfiguration20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, const tt__FocusConfiguration20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__FocusConfiguration20Extension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusConfiguration20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusConfiguration20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_in_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, tt__FocusConfiguration20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusConfiguration20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(tt__FocusConfiguration20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusConfiguration20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusConfiguration20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__FocusConfiguration20Extension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusConfiguration20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20Extension, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(tt__FocusConfiguration20Extension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusConfiguration20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusConfiguration20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusConfiguration20Extension *p;
	size_t k = sizeof(tt__FocusConfiguration20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusConfiguration20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusConfiguration20Extension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusConfiguration20Extension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusConfiguration20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusConfiguration20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusConfiguration20Extension(soap, tag ? tag : "tt:FocusConfiguration20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusConfiguration20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusConfiguration20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_get_tt__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusConfiguration20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__AutoFocusMode(soap, &this->tt__FocusConfiguration20::AutoFocusMode);
	this->tt__FocusConfiguration20::DefaultSpeed = NULL;
	this->tt__FocusConfiguration20::NearLimit = NULL;
	this->tt__FocusConfiguration20::FarLimit = NULL;
	this->tt__FocusConfiguration20::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__FocusConfiguration20::__anyAttribute);
}

void tt__FocusConfiguration20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__FocusConfiguration20::DefaultSpeed);
	soap_serialize_PointerTofloat(soap, &this->tt__FocusConfiguration20::NearLimit);
	soap_serialize_PointerTofloat(soap, &this->tt__FocusConfiguration20::FarLimit);
	soap_serialize_PointerTott__FocusConfiguration20Extension(soap, &this->tt__FocusConfiguration20::Extension);
#endif
}

int tt__FocusConfiguration20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusConfiguration20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20(struct soap *soap, const char *tag, int id, const tt__FocusConfiguration20 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__FocusConfiguration20*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20), type))
		return soap->error;
	if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusMode", -1, &a->tt__FocusConfiguration20::AutoFocusMode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:DefaultSpeed", -1, &a->tt__FocusConfiguration20::DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:NearLimit", -1, &a->tt__FocusConfiguration20::NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:FarLimit", -1, &a->tt__FocusConfiguration20::FarLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", -1, &a->tt__FocusConfiguration20::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusConfiguration20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusConfiguration20(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusConfiguration20 * SOAP_FMAC4 soap_in_tt__FocusConfiguration20(struct soap *soap, const char *tag, tt__FocusConfiguration20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusConfiguration20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(tt__FocusConfiguration20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusConfiguration20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusConfiguration20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__FocusConfiguration20*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_AutoFocusMode1 = 1;
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusMode", &a->tt__FocusConfiguration20::AutoFocusMode, "tt:AutoFocusMode"))
				{	soap_flag_AutoFocusMode1--;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:DefaultSpeed", &a->tt__FocusConfiguration20::DefaultSpeed, "xsd:float"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:NearLimit", &a->tt__FocusConfiguration20::NearLimit, "xsd:float"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:FarLimit", &a->tt__FocusConfiguration20::FarLimit, "xsd:float"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", &a->tt__FocusConfiguration20::Extension, "tt:FocusConfiguration20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FocusConfiguration20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20, SOAP_TYPE_tt__FocusConfiguration20, sizeof(tt__FocusConfiguration20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusConfiguration20 * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusConfiguration20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusConfiguration20 *p;
	size_t k = sizeof(tt__FocusConfiguration20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusConfiguration20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusConfiguration20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusConfiguration20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusConfiguration20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusConfiguration20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusConfiguration20(soap, tag ? tag : "tt:FocusConfiguration20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusConfiguration20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusConfiguration20(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusConfiguration20 * SOAP_FMAC4 soap_get_tt__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalance20Extension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__WhiteBalance20Extension::__any);
}

void tt__WhiteBalance20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__WhiteBalance20Extension::__any);
#endif
}

int tt__WhiteBalance20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalance20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, const tt__WhiteBalance20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__WhiteBalance20Extension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalance20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalance20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalance20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, tt__WhiteBalance20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalance20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(tt__WhiteBalance20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalance20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalance20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__WhiteBalance20Extension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WhiteBalance20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20Extension, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(tt__WhiteBalance20Extension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalance20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalance20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalance20Extension *p;
	size_t k = sizeof(tt__WhiteBalance20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalance20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalance20Extension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalance20Extension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalance20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalance20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalance20Extension(soap, tag ? tag : "tt:WhiteBalance20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalance20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalance20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalance20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalance20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__WhiteBalanceMode(soap, &this->tt__WhiteBalance20::Mode);
	this->tt__WhiteBalance20::CrGain = NULL;
	this->tt__WhiteBalance20::CbGain = NULL;
	this->tt__WhiteBalance20::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__WhiteBalance20::__anyAttribute);
}

void tt__WhiteBalance20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__WhiteBalance20::CrGain);
	soap_serialize_PointerTofloat(soap, &this->tt__WhiteBalance20::CbGain);
	soap_serialize_PointerTott__WhiteBalance20Extension(soap, &this->tt__WhiteBalance20::Extension);
#endif
}

int tt__WhiteBalance20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalance20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20(struct soap *soap, const char *tag, int id, const tt__WhiteBalance20 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__WhiteBalance20*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20), type))
		return soap->error;
	if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->tt__WhiteBalance20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:CrGain", -1, &a->tt__WhiteBalance20::CrGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:CbGain", -1, &a->tt__WhiteBalance20::CbGain, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", -1, &a->tt__WhiteBalance20::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalance20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalance20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalance20 * SOAP_FMAC4 soap_in_tt__WhiteBalance20(struct soap *soap, const char *tag, tt__WhiteBalance20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalance20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20, sizeof(tt__WhiteBalance20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalance20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalance20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__WhiteBalance20*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_CrGain1 = 1;
	size_t soap_flag_CbGain1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", &a->tt__WhiteBalance20::Mode, "tt:WhiteBalanceMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_CrGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:CrGain", &a->tt__WhiteBalance20::CrGain, "xsd:float"))
				{	soap_flag_CrGain1--;
					continue;
				}
			}
			if (soap_flag_CbGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:CbGain", &a->tt__WhiteBalance20::CbGain, "xsd:float"))
				{	soap_flag_CbGain1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", &a->tt__WhiteBalance20::Extension, "tt:WhiteBalance20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WhiteBalance20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20, SOAP_TYPE_tt__WhiteBalance20, sizeof(tt__WhiteBalance20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalance20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalance20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalance20 *p;
	size_t k = sizeof(tt__WhiteBalance20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalance20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalance20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalance20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalance20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalance20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalance20(soap, tag ? tag : "tt:WhiteBalance20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalance20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalance20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalance20 * SOAP_FMAC4 soap_get_tt__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelativeFocusOptions20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__RelativeFocusOptions20::Distance = NULL;
	this->tt__RelativeFocusOptions20::Speed = NULL;
}

void tt__RelativeFocusOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__RelativeFocusOptions20::Distance);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__RelativeFocusOptions20::Speed);
#endif
}

int tt__RelativeFocusOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelativeFocusOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, const tt__RelativeFocusOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocusOptions20), type))
		return soap->error;
	if (!a->tt__RelativeFocusOptions20::Distance)
	{	if (soap_element_empty(soap, "tt:Distance"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Distance", -1, &a->tt__RelativeFocusOptions20::Distance, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->tt__RelativeFocusOptions20::Speed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelativeFocusOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelativeFocusOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_in_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, tt__RelativeFocusOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelativeFocusOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(tt__RelativeFocusOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelativeFocusOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelativeFocusOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Distance1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Distance", &a->tt__RelativeFocusOptions20::Distance, "tt:FloatRange"))
				{	soap_flag_Distance1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->tt__RelativeFocusOptions20::Speed, "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__RelativeFocusOptions20::Distance))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelativeFocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions20, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(tt__RelativeFocusOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelativeFocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelativeFocusOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelativeFocusOptions20 *p;
	size_t k = sizeof(tt__RelativeFocusOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelativeFocusOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelativeFocusOptions20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelativeFocusOptions20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelativeFocusOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelativeFocusOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelativeFocusOptions20(soap, tag ? tag : "tt:RelativeFocusOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelativeFocusOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelativeFocusOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_get_tt__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MoveOptions20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__MoveOptions20::Absolute = NULL;
	this->tt__MoveOptions20::Relative = NULL;
	this->tt__MoveOptions20::Continuous = NULL;
}

void tt__MoveOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AbsoluteFocusOptions(soap, &this->tt__MoveOptions20::Absolute);
	soap_serialize_PointerTott__RelativeFocusOptions20(soap, &this->tt__MoveOptions20::Relative);
	soap_serialize_PointerTott__ContinuousFocusOptions(soap, &this->tt__MoveOptions20::Continuous);
#endif
}

int tt__MoveOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MoveOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveOptions20(struct soap *soap, const char *tag, int id, const tt__MoveOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveOptions20), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", -1, &a->tt__MoveOptions20::Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", -1, &a->tt__MoveOptions20::Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", -1, &a->tt__MoveOptions20::Continuous, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MoveOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MoveOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__MoveOptions20 * SOAP_FMAC4 soap_in_tt__MoveOptions20(struct soap *soap, const char *tag, tt__MoveOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MoveOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions20, sizeof(tt__MoveOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MoveOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MoveOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Absolute1 = 1;
	size_t soap_flag_Relative1 = 1;
	size_t soap_flag_Continuous1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", &a->tt__MoveOptions20::Absolute, "tt:AbsoluteFocusOptions"))
				{	soap_flag_Absolute1--;
					continue;
				}
			}
			if (soap_flag_Relative1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", &a->tt__MoveOptions20::Relative, "tt:RelativeFocusOptions20"))
				{	soap_flag_Relative1--;
					continue;
				}
			}
			if (soap_flag_Continuous1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", &a->tt__MoveOptions20::Continuous, "tt:ContinuousFocusOptions"))
				{	soap_flag_Continuous1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MoveOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions20, SOAP_TYPE_tt__MoveOptions20, sizeof(tt__MoveOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MoveOptions20 * SOAP_FMAC2 soap_instantiate_tt__MoveOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MoveOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MoveOptions20 *p;
	size_t k = sizeof(tt__MoveOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MoveOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MoveOptions20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MoveOptions20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MoveOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MoveOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MoveOptions20(soap, tag ? tag : "tt:MoveOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MoveOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MoveOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__MoveOptions20 * SOAP_FMAC4 soap_get_tt__MoveOptions20(struct soap *soap, tt__MoveOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ExposureOptions20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__ExposureMode(soap, &this->tt__ExposureOptions20::Mode);
	soap_default_std__vectorTemplateOftt__ExposurePriority(soap, &this->tt__ExposureOptions20::Priority);
	this->tt__ExposureOptions20::MinExposureTime = NULL;
	this->tt__ExposureOptions20::MaxExposureTime = NULL;
	this->tt__ExposureOptions20::MinGain = NULL;
	this->tt__ExposureOptions20::MaxGain = NULL;
	this->tt__ExposureOptions20::MinIris = NULL;
	this->tt__ExposureOptions20::MaxIris = NULL;
	this->tt__ExposureOptions20::ExposureTime = NULL;
	this->tt__ExposureOptions20::Gain = NULL;
	this->tt__ExposureOptions20::Iris = NULL;
}

void tt__ExposureOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ExposureMode(soap, &this->tt__ExposureOptions20::Mode);
	soap_serialize_std__vectorTemplateOftt__ExposurePriority(soap, &this->tt__ExposureOptions20::Priority);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MinExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MaxExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MinGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MaxGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MinIris);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MaxIris);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::ExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::Gain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::Iris);
#endif
}

int tt__ExposureOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ExposureOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureOptions20(struct soap *soap, const char *tag, int id, const tt__ExposureOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureOptions20), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ExposureMode(soap, "tt:Mode", -1, &a->tt__ExposureOptions20::Mode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ExposurePriority(soap, "tt:Priority", -1, &a->tt__ExposureOptions20::Priority, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinExposureTime", -1, &a->tt__ExposureOptions20::MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxExposureTime", -1, &a->tt__ExposureOptions20::MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinGain", -1, &a->tt__ExposureOptions20::MinGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxGain", -1, &a->tt__ExposureOptions20::MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinIris", -1, &a->tt__ExposureOptions20::MinIris, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxIris", -1, &a->tt__ExposureOptions20::MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ExposureTime", -1, &a->tt__ExposureOptions20::ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Gain", -1, &a->tt__ExposureOptions20::Gain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Iris", -1, &a->tt__ExposureOptions20::Iris, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ExposureOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ExposureOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ExposureOptions20 * SOAP_FMAC4 soap_in_tt__ExposureOptions20(struct soap *soap, const char *tag, tt__ExposureOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ExposureOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions20, sizeof(tt__ExposureOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ExposureOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ExposureOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ExposureMode(soap, "tt:Mode", &a->tt__ExposureOptions20::Mode, "tt:ExposureMode"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ExposurePriority(soap, "tt:Priority", &a->tt__ExposureOptions20::Priority, "tt:ExposurePriority"))
					continue;
			}
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinExposureTime", &a->tt__ExposureOptions20::MinExposureTime, "tt:FloatRange"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxExposureTime", &a->tt__ExposureOptions20::MaxExposureTime, "tt:FloatRange"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinGain", &a->tt__ExposureOptions20::MinGain, "tt:FloatRange"))
				{	soap_flag_MinGain1--;
					continue;
				}
			}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxGain", &a->tt__ExposureOptions20::MaxGain, "tt:FloatRange"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinIris", &a->tt__ExposureOptions20::MinIris, "tt:FloatRange"))
				{	soap_flag_MinIris1--;
					continue;
				}
			}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxIris", &a->tt__ExposureOptions20::MaxIris, "tt:FloatRange"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:ExposureTime", &a->tt__ExposureOptions20::ExposureTime, "tt:FloatRange"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Gain", &a->tt__ExposureOptions20::Gain, "tt:FloatRange"))
				{	soap_flag_Gain1--;
					continue;
				}
			}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Iris", &a->tt__ExposureOptions20::Iris, "tt:FloatRange"))
				{	soap_flag_Iris1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__ExposureOptions20::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ExposureOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions20, SOAP_TYPE_tt__ExposureOptions20, sizeof(tt__ExposureOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ExposureOptions20 * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ExposureOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ExposureOptions20 *p;
	size_t k = sizeof(tt__ExposureOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ExposureOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ExposureOptions20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ExposureOptions20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ExposureOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ExposureOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ExposureOptions20(soap, tag ? tag : "tt:ExposureOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ExposureOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ExposureOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ExposureOptions20 * SOAP_FMAC4 soap_get_tt__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BacklightCompensationOptions20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__BacklightCompensationMode(soap, &this->tt__BacklightCompensationOptions20::Mode);
	this->tt__BacklightCompensationOptions20::Level = NULL;
}

void tt__BacklightCompensationOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__BacklightCompensationMode(soap, &this->tt__BacklightCompensationOptions20::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__BacklightCompensationOptions20::Level);
#endif
}

int tt__BacklightCompensationOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensationOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, const tt__BacklightCompensationOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationOptions20), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->tt__BacklightCompensationOptions20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__BacklightCompensationOptions20::Level, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensationOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BacklightCompensationOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_in_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, tt__BacklightCompensationOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensationOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(tt__BacklightCompensationOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BacklightCompensationOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BacklightCompensationOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__BacklightCompensationMode(soap, "tt:Mode", &a->tt__BacklightCompensationOptions20::Mode, "tt:BacklightCompensationMode"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->tt__BacklightCompensationOptions20::Level, "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__BacklightCompensationOptions20::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BacklightCompensationOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions20, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(tt__BacklightCompensationOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BacklightCompensationOptions20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BacklightCompensationOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BacklightCompensationOptions20 *p;
	size_t k = sizeof(tt__BacklightCompensationOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BacklightCompensationOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BacklightCompensationOptions20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BacklightCompensationOptions20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BacklightCompensationOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BacklightCompensationOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BacklightCompensationOptions20(soap, tag ? tag : "tt:BacklightCompensationOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensationOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensationOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_get_tt__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WideDynamicRangeOptions20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__WideDynamicRangeOptions20::Mode);
	this->tt__WideDynamicRangeOptions20::Level = NULL;
}

void tt__WideDynamicRangeOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__WideDynamicRangeOptions20::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WideDynamicRangeOptions20::Level);
#endif
}

int tt__WideDynamicRangeOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRangeOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, const tt__WideDynamicRangeOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", -1, &a->tt__WideDynamicRangeOptions20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__WideDynamicRangeOptions20::Level, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRangeOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WideDynamicRangeOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_in_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, tt__WideDynamicRangeOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRangeOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(tt__WideDynamicRangeOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WideDynamicRangeOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WideDynamicRangeOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", &a->tt__WideDynamicRangeOptions20::Mode, "tt:WideDynamicMode"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->tt__WideDynamicRangeOptions20::Level, "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__WideDynamicRangeOptions20::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WideDynamicRangeOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions20, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(tt__WideDynamicRangeOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WideDynamicRangeOptions20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WideDynamicRangeOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WideDynamicRangeOptions20 *p;
	size_t k = sizeof(tt__WideDynamicRangeOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WideDynamicRangeOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WideDynamicRangeOptions20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WideDynamicRangeOptions20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WideDynamicRangeOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WideDynamicRangeOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WideDynamicRangeOptions20(soap, tag ? tag : "tt:WideDynamicRangeOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRangeOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRangeOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_get_tt__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IrCutFilterAutoAdjustmentOptionsExtension::__any);
}

void tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IrCutFilterAutoAdjustmentOptionsExtension::__any);
#endif
}

int tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoAdjustmentOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__IrCutFilterAutoAdjustmentOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IrCutFilterAutoAdjustmentOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IrCutFilterAutoAdjustmentOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__IrCutFilterAutoAdjustmentOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoAdjustmentOptionsExtension *p;
	size_t k = sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoAdjustmentOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoAdjustmentOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoAdjustmentOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoAdjustmentOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType);
	this->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset = NULL;
	this->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange = NULL;
	this->tt__IrCutFilterAutoAdjustmentOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::__anyAttribute);
}

void tt__IrCutFilterAutoAdjustmentOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType);
	soap_serialize_PointerTobool(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset);
	soap_serialize_PointerTott__DurationRange(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange);
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::Extension);
#endif
}

int tt__IrCutFilterAutoAdjustmentOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoAdjustmentOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__IrCutFilterAutoAdjustmentOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:BoundaryType", -1, &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:BoundaryOffset", -1, &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset, ""))
		return soap->error;
	if (soap_out_PointerTott__DurationRange(soap, "tt:ResponseTimeRange", -1, &a->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, "tt:Extension", -1, &a->tt__IrCutFilterAutoAdjustmentOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IrCutFilterAutoAdjustmentOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IrCutFilterAutoAdjustmentOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(tt__IrCutFilterAutoAdjustmentOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IrCutFilterAutoAdjustmentOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__IrCutFilterAutoAdjustmentOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_BoundaryOffset1 = 1;
	size_t soap_flag_ResponseTimeRange1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:BoundaryType", &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType, "xsd:string"))
					continue;
			}
			if (soap_flag_BoundaryOffset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:BoundaryOffset", &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset, "xsd:boolean"))
				{	soap_flag_BoundaryOffset1--;
					continue;
				}
			}
			if (soap_flag_ResponseTimeRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:ResponseTimeRange", &a->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange, "tt:DurationRange"))
				{	soap_flag_ResponseTimeRange1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, "tt:Extension", &a->tt__IrCutFilterAutoAdjustmentOptions::Extension, "tt:IrCutFilterAutoAdjustmentOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(tt__IrCutFilterAutoAdjustmentOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IrCutFilterAutoAdjustmentOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoAdjustmentOptions *p;
	size_t k = sizeof(tt__IrCutFilterAutoAdjustmentOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoAdjustmentOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoAdjustmentOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoAdjustmentOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoAdjustmentOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentOptions(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoAdjustmentOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoAdjustmentOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilizationOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImageStabilizationOptionsExtension::__any);
}

void tt__ImageStabilizationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImageStabilizationOptionsExtension::__any);
#endif
}

int tt__ImageStabilizationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilizationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__ImageStabilizationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ImageStabilizationOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImageStabilizationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_in_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, tt__ImageStabilizationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImageStabilizationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(tt__ImageStabilizationOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilizationOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImageStabilizationOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ImageStabilizationOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImageStabilizationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(tt__ImageStabilizationOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImageStabilizationOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilizationOptionsExtension *p;
	size_t k = sizeof(tt__ImageStabilizationOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilizationOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilizationOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilizationOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilizationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilizationOptionsExtension(soap, tag ? tag : "tt:ImageStabilizationOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilizationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilizationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_get_tt__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilizationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__ImageStabilizationMode(soap, &this->tt__ImageStabilizationOptions::Mode);
	this->tt__ImageStabilizationOptions::Level = NULL;
	this->tt__ImageStabilizationOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ImageStabilizationOptions::__anyAttribute);
}

void tt__ImageStabilizationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ImageStabilizationMode(soap, &this->tt__ImageStabilizationOptions::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImageStabilizationOptions::Level);
	soap_serialize_PointerTott__ImageStabilizationOptionsExtension(soap, &this->tt__ImageStabilizationOptions::Extension);
#endif
}

int tt__ImageStabilizationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilizationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationOptions(struct soap *soap, const char *tag, int id, const tt__ImageStabilizationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImageStabilizationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ImageStabilizationMode(soap, "tt:Mode", -1, &a->tt__ImageStabilizationOptions::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__ImageStabilizationOptions::Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationOptionsExtension(soap, "tt:Extension", -1, &a->tt__ImageStabilizationOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImageStabilizationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilizationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilizationOptions * SOAP_FMAC4 soap_in_tt__ImageStabilizationOptions(struct soap *soap, const char *tag, tt__ImageStabilizationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImageStabilizationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(tt__ImageStabilizationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilizationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImageStabilizationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImageStabilizationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ImageStabilizationMode(soap, "tt:Mode", &a->tt__ImageStabilizationOptions::Mode, "tt:ImageStabilizationMode"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->tt__ImageStabilizationOptions::Level, "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilizationOptionsExtension(soap, "tt:Extension", &a->tt__ImageStabilizationOptions::Extension, "tt:ImageStabilizationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__ImageStabilizationOptions::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ImageStabilizationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationOptions, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(tt__ImageStabilizationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationOptions * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImageStabilizationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilizationOptions *p;
	size_t k = sizeof(tt__ImageStabilizationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilizationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilizationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilizationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilizationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilizationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilizationOptions(soap, tag ? tag : "tt:ImageStabilizationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilizationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilizationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilizationOptions * SOAP_FMAC4 soap_get_tt__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20Extension4::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingOptions20Extension4::__any);
}

void tt__ImagingOptions20Extension4::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingOptions20Extension4::__any);
#endif
}

int tt__ImagingOptions20Extension4::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension4(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension4(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension4 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension4), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ImagingOptions20Extension4::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20Extension4::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20Extension4(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension4(struct soap *soap, const char *tag, tt__ImagingOptions20Extension4 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20Extension4*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(tt__ImagingOptions20Extension4), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20Extension4)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20Extension4 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ImagingOptions20Extension4::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20Extension4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension4, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(tt__ImagingOptions20Extension4), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension4 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions20Extension4(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20Extension4 *p;
	size_t k = sizeof(tt__ImagingOptions20Extension4);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20Extension4, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20Extension4);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20Extension4, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20Extension4 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20Extension4::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20Extension4(soap, tag ? tag : "tt:ImagingOptions20Extension4", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension4::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension4(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20Extension3::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ImagingOptions20Extension3::ToneCompensationOptions = NULL;
	this->tt__ImagingOptions20Extension3::DefoggingOptions = NULL;
	this->tt__ImagingOptions20Extension3::NoiseReductionOptions = NULL;
	this->tt__ImagingOptions20Extension3::Extension = NULL;
}

void tt__ImagingOptions20Extension3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ToneCompensationOptions(soap, &this->tt__ImagingOptions20Extension3::ToneCompensationOptions);
	soap_serialize_PointerTott__DefoggingOptions(soap, &this->tt__ImagingOptions20Extension3::DefoggingOptions);
	soap_serialize_PointerTott__NoiseReductionOptions(soap, &this->tt__ImagingOptions20Extension3::NoiseReductionOptions);
	soap_serialize_PointerTott__ImagingOptions20Extension4(soap, &this->tt__ImagingOptions20Extension3::Extension);
#endif
}

int tt__ImagingOptions20Extension3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension3(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension3), type))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensationOptions(soap, "tt:ToneCompensationOptions", -1, &a->tt__ImagingOptions20Extension3::ToneCompensationOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__DefoggingOptions(soap, "tt:DefoggingOptions", -1, &a->tt__ImagingOptions20Extension3::DefoggingOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__NoiseReductionOptions(soap, "tt:NoiseReductionOptions", -1, &a->tt__ImagingOptions20Extension3::NoiseReductionOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension4(soap, "tt:Extension", -1, &a->tt__ImagingOptions20Extension3::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20Extension3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20Extension3(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension3(struct soap *soap, const char *tag, tt__ImagingOptions20Extension3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20Extension3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(tt__ImagingOptions20Extension3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20Extension3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20Extension3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ToneCompensationOptions1 = 1;
	size_t soap_flag_DefoggingOptions1 = 1;
	size_t soap_flag_NoiseReductionOptions1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToneCompensationOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ToneCompensationOptions(soap, "tt:ToneCompensationOptions", &a->tt__ImagingOptions20Extension3::ToneCompensationOptions, "tt:ToneCompensationOptions"))
				{	soap_flag_ToneCompensationOptions1--;
					continue;
				}
			}
			if (soap_flag_DefoggingOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DefoggingOptions(soap, "tt:DefoggingOptions", &a->tt__ImagingOptions20Extension3::DefoggingOptions, "tt:DefoggingOptions"))
				{	soap_flag_DefoggingOptions1--;
					continue;
				}
			}
			if (soap_flag_NoiseReductionOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NoiseReductionOptions(soap, "tt:NoiseReductionOptions", &a->tt__ImagingOptions20Extension3::NoiseReductionOptions, "tt:NoiseReductionOptions"))
				{	soap_flag_NoiseReductionOptions1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension4(soap, "tt:Extension", &a->tt__ImagingOptions20Extension3::Extension, "tt:ImagingOptions20Extension4"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20Extension3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension3, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(tt__ImagingOptions20Extension3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension3 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions20Extension3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20Extension3 *p;
	size_t k = sizeof(tt__ImagingOptions20Extension3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20Extension3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20Extension3);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20Extension3, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20Extension3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20Extension3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20Extension3(soap, tag ? tag : "tt:ImagingOptions20Extension3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension3(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20Extension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment = NULL;
	this->tt__ImagingOptions20Extension2::Extension = NULL;
}

void tt__ImagingOptions20Extension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, &this->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment);
	soap_serialize_PointerTott__ImagingOptions20Extension3(soap, &this->tt__ImagingOptions20Extension2::Extension);
#endif
}

int tt__ImagingOptions20Extension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension2(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension2), type))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, "tt:IrCutFilterAutoAdjustment", -1, &a->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension3(soap, "tt:Extension", -1, &a->tt__ImagingOptions20Extension2::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20Extension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20Extension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension2(struct soap *soap, const char *tag, tt__ImagingOptions20Extension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20Extension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(tt__ImagingOptions20Extension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20Extension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20Extension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_IrCutFilterAutoAdjustment1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IrCutFilterAutoAdjustment1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, "tt:IrCutFilterAutoAdjustment", &a->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment, "tt:IrCutFilterAutoAdjustmentOptions"))
				{	soap_flag_IrCutFilterAutoAdjustment1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension3(soap, "tt:Extension", &a->tt__ImagingOptions20Extension2::Extension, "tt:ImagingOptions20Extension3"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20Extension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension2, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(tt__ImagingOptions20Extension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension2 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions20Extension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20Extension2 *p;
	size_t k = sizeof(tt__ImagingOptions20Extension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20Extension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20Extension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20Extension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20Extension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20Extension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20Extension2(soap, tag ? tag : "tt:ImagingOptions20Extension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20Extension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingOptions20Extension::__any);
	this->tt__ImagingOptions20Extension::ImageStabilization = NULL;
	this->tt__ImagingOptions20Extension::Extension = NULL;
}

void tt__ImagingOptions20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingOptions20Extension::__any);
	soap_serialize_PointerTott__ImageStabilizationOptions(soap, &this->tt__ImagingOptions20Extension::ImageStabilization);
	soap_serialize_PointerTott__ImagingOptions20Extension2(soap, &this->tt__ImagingOptions20Extension::Extension);
#endif
}

int tt__ImagingOptions20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ImagingOptions20Extension::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationOptions(soap, "tt:ImageStabilization", -1, &a->tt__ImagingOptions20Extension::ImageStabilization, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension2(soap, "tt:Extension", -1, &a->tt__ImagingOptions20Extension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, tt__ImagingOptions20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(tt__ImagingOptions20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ImageStabilization1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImageStabilization1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilizationOptions(soap, "tt:ImageStabilization", &a->tt__ImagingOptions20Extension::ImageStabilization, "tt:ImageStabilizationOptions"))
				{	soap_flag_ImageStabilization1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension2(soap, "tt:Extension", &a->tt__ImagingOptions20Extension::Extension, "tt:ImagingOptions20Extension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ImagingOptions20Extension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(tt__ImagingOptions20Extension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20Extension *p;
	size_t k = sizeof(tt__ImagingOptions20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20Extension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20Extension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20Extension(soap, tag ? tag : "tt:ImagingOptions20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ImagingOptions20::BacklightCompensation = NULL;
	this->tt__ImagingOptions20::Brightness = NULL;
	this->tt__ImagingOptions20::ColorSaturation = NULL;
	this->tt__ImagingOptions20::Contrast = NULL;
	this->tt__ImagingOptions20::Exposure = NULL;
	this->tt__ImagingOptions20::Focus = NULL;
	soap_default_std__vectorTemplateOftt__IrCutFilterMode(soap, &this->tt__ImagingOptions20::IrCutFilterModes);
	this->tt__ImagingOptions20::Sharpness = NULL;
	this->tt__ImagingOptions20::WideDynamicRange = NULL;
	this->tt__ImagingOptions20::WhiteBalance = NULL;
	this->tt__ImagingOptions20::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingOptions20::__anyAttribute);
}

void tt__ImagingOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensationOptions20(soap, &this->tt__ImagingOptions20::BacklightCompensation);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::Brightness);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::ColorSaturation);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::Contrast);
	soap_serialize_PointerTott__ExposureOptions20(soap, &this->tt__ImagingOptions20::Exposure);
	soap_serialize_PointerTott__FocusOptions20(soap, &this->tt__ImagingOptions20::Focus);
	soap_serialize_std__vectorTemplateOftt__IrCutFilterMode(soap, &this->tt__ImagingOptions20::IrCutFilterModes);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::Sharpness);
	soap_serialize_PointerTott__WideDynamicRangeOptions20(soap, &this->tt__ImagingOptions20::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalanceOptions20(soap, &this->tt__ImagingOptions20::WhiteBalance);
	soap_serialize_PointerTott__ImagingOptions20Extension(soap, &this->tt__ImagingOptions20::Extension);
#endif
}

int tt__ImagingOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingOptions20*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", -1, &a->tt__ImagingOptions20::BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Brightness", -1, &a->tt__ImagingOptions20::Brightness, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ColorSaturation", -1, &a->tt__ImagingOptions20::ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Contrast", -1, &a->tt__ImagingOptions20::Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__ExposureOptions20(soap, "tt:Exposure", -1, &a->tt__ImagingOptions20::Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20(soap, "tt:Focus", -1, &a->tt__ImagingOptions20::Focus, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IrCutFilterMode(soap, "tt:IrCutFilterModes", -1, &a->tt__ImagingOptions20::IrCutFilterModes, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Sharpness", -1, &a->tt__ImagingOptions20::Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", -1, &a->tt__ImagingOptions20::WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", -1, &a->tt__ImagingOptions20::WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", -1, &a->tt__ImagingOptions20::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20 * SOAP_FMAC4 soap_in_tt__ImagingOptions20(struct soap *soap, const char *tag, tt__ImagingOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20, sizeof(tt__ImagingOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingOptions20*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", &a->tt__ImagingOptions20::BacklightCompensation, "tt:BacklightCompensationOptions20"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Brightness", &a->tt__ImagingOptions20::Brightness, "tt:FloatRange"))
				{	soap_flag_Brightness1--;
					continue;
				}
			}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:ColorSaturation", &a->tt__ImagingOptions20::ColorSaturation, "tt:FloatRange"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Contrast", &a->tt__ImagingOptions20::Contrast, "tt:FloatRange"))
				{	soap_flag_Contrast1--;
					continue;
				}
			}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ExposureOptions20(soap, "tt:Exposure", &a->tt__ImagingOptions20::Exposure, "tt:ExposureOptions20"))
				{	soap_flag_Exposure1--;
					continue;
				}
			}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusOptions20(soap, "tt:Focus", &a->tt__ImagingOptions20::Focus, "tt:FocusOptions20"))
				{	soap_flag_Focus1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IrCutFilterMode(soap, "tt:IrCutFilterModes", &a->tt__ImagingOptions20::IrCutFilterModes, "tt:IrCutFilterMode"))
					continue;
			}
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Sharpness", &a->tt__ImagingOptions20::Sharpness, "tt:FloatRange"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", &a->tt__ImagingOptions20::WideDynamicRange, "tt:WideDynamicRangeOptions20"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", &a->tt__ImagingOptions20::WhiteBalance, "tt:WhiteBalanceOptions20"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", &a->tt__ImagingOptions20::Extension, "tt:ImagingOptions20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20, SOAP_TYPE_tt__ImagingOptions20, sizeof(tt__ImagingOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20 *p;
	size_t k = sizeof(tt__ImagingOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20(soap, tag ? tag : "tt:ImagingOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20 * SOAP_FMAC4 soap_get_tt__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NoiseReduction::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__NoiseReduction::Level);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NoiseReduction::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__NoiseReduction::__anyAttribute);
}

void tt__NoiseReduction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NoiseReduction::Level, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NoiseReduction::__any);
#endif
}

int tt__NoiseReduction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NoiseReduction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NoiseReduction(struct soap *soap, const char *tag, int id, const tt__NoiseReduction *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NoiseReduction*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NoiseReduction), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &a->tt__NoiseReduction::Level, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NoiseReduction::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NoiseReduction::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NoiseReduction(soap, tag, this, type);
}

SOAP_FMAC3 tt__NoiseReduction * SOAP_FMAC4 soap_in_tt__NoiseReduction(struct soap *soap, const char *tag, tt__NoiseReduction *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NoiseReduction*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NoiseReduction, sizeof(tt__NoiseReduction), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NoiseReduction)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NoiseReduction *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NoiseReduction*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Level", &a->tt__NoiseReduction::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NoiseReduction::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NoiseReduction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NoiseReduction, SOAP_TYPE_tt__NoiseReduction, sizeof(tt__NoiseReduction), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NoiseReduction * SOAP_FMAC2 soap_instantiate_tt__NoiseReduction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NoiseReduction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NoiseReduction *p;
	size_t k = sizeof(tt__NoiseReduction);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NoiseReduction, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NoiseReduction);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NoiseReduction, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NoiseReduction location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NoiseReduction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NoiseReduction(soap, tag ? tag : "tt:NoiseReduction", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NoiseReduction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NoiseReduction(soap, this, tag, type);
}

SOAP_FMAC3 tt__NoiseReduction * SOAP_FMAC4 soap_get_tt__NoiseReduction(struct soap *soap, tt__NoiseReduction *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NoiseReduction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DefoggingExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DefoggingExtension::__any);
}

void tt__DefoggingExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DefoggingExtension::__any);
#endif
}

int tt__DefoggingExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DefoggingExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingExtension(struct soap *soap, const char *tag, int id, const tt__DefoggingExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DefoggingExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__DefoggingExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DefoggingExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DefoggingExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DefoggingExtension * SOAP_FMAC4 soap_in_tt__DefoggingExtension(struct soap *soap, const char *tag, tt__DefoggingExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DefoggingExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingExtension, sizeof(tt__DefoggingExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DefoggingExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DefoggingExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__DefoggingExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DefoggingExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingExtension, SOAP_TYPE_tt__DefoggingExtension, sizeof(tt__DefoggingExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DefoggingExtension * SOAP_FMAC2 soap_instantiate_tt__DefoggingExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DefoggingExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DefoggingExtension *p;
	size_t k = sizeof(tt__DefoggingExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DefoggingExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DefoggingExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DefoggingExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DefoggingExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DefoggingExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DefoggingExtension(soap, tag ? tag : "tt:DefoggingExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DefoggingExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DefoggingExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DefoggingExtension * SOAP_FMAC4 soap_get_tt__DefoggingExtension(struct soap *soap, tt__DefoggingExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DefoggingExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Defogging::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__Defogging::Mode);
	this->tt__Defogging::Level = NULL;
	this->tt__Defogging::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Defogging::__anyAttribute);
}

void tt__Defogging::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Defogging::Mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__Defogging::Mode);
	soap_serialize_PointerTofloat(soap, &this->tt__Defogging::Level);
	soap_serialize_PointerTott__DefoggingExtension(soap, &this->tt__Defogging::Extension);
#endif
}

int tt__Defogging::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Defogging(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Defogging(struct soap *soap, const char *tag, int id, const tt__Defogging *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Defogging*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Defogging), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Mode", -1, &a->tt__Defogging::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__Defogging::Level, ""))
		return soap->error;
	if (soap_out_PointerTott__DefoggingExtension(soap, "tt:Extension", -1, &a->tt__Defogging::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Defogging::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Defogging(soap, tag, this, type);
}

SOAP_FMAC3 tt__Defogging * SOAP_FMAC4 soap_in_tt__Defogging(struct soap *soap, const char *tag, tt__Defogging *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Defogging*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Defogging, sizeof(tt__Defogging), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Defogging)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Defogging *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Defogging*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Mode", &a->tt__Defogging::Mode, "xsd:string"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__Defogging::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DefoggingExtension(soap, "tt:Extension", &a->tt__Defogging::Extension, "tt:DefoggingExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Defogging *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Defogging, SOAP_TYPE_tt__Defogging, sizeof(tt__Defogging), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Defogging * SOAP_FMAC2 soap_instantiate_tt__Defogging(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Defogging(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Defogging *p;
	size_t k = sizeof(tt__Defogging);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Defogging, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Defogging);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Defogging, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Defogging location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Defogging::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Defogging(soap, tag ? tag : "tt:Defogging", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Defogging::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Defogging(soap, this, tag, type);
}

SOAP_FMAC3 tt__Defogging * SOAP_FMAC4 soap_get_tt__Defogging(struct soap *soap, tt__Defogging *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Defogging(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ToneCompensationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ToneCompensationExtension::__any);
}

void tt__ToneCompensationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ToneCompensationExtension::__any);
#endif
}

int tt__ToneCompensationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ToneCompensationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationExtension(struct soap *soap, const char *tag, int id, const tt__ToneCompensationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ToneCompensationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ToneCompensationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ToneCompensationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ToneCompensationExtension * SOAP_FMAC4 soap_in_tt__ToneCompensationExtension(struct soap *soap, const char *tag, tt__ToneCompensationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ToneCompensationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(tt__ToneCompensationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ToneCompensationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ToneCompensationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ToneCompensationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ToneCompensationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationExtension, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(tt__ToneCompensationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ToneCompensationExtension * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ToneCompensationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ToneCompensationExtension *p;
	size_t k = sizeof(tt__ToneCompensationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ToneCompensationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ToneCompensationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ToneCompensationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ToneCompensationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ToneCompensationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ToneCompensationExtension(soap, tag ? tag : "tt:ToneCompensationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ToneCompensationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ToneCompensationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ToneCompensationExtension * SOAP_FMAC4 soap_get_tt__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ToneCompensation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__ToneCompensation::Mode);
	this->tt__ToneCompensation::Level = NULL;
	this->tt__ToneCompensation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ToneCompensation::__anyAttribute);
}

void tt__ToneCompensation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ToneCompensation::Mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__ToneCompensation::Mode);
	soap_serialize_PointerTofloat(soap, &this->tt__ToneCompensation::Level);
	soap_serialize_PointerTott__ToneCompensationExtension(soap, &this->tt__ToneCompensation::Extension);
#endif
}

int tt__ToneCompensation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ToneCompensation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensation(struct soap *soap, const char *tag, int id, const tt__ToneCompensation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ToneCompensation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensation), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Mode", -1, &a->tt__ToneCompensation::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__ToneCompensation::Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensationExtension(soap, "tt:Extension", -1, &a->tt__ToneCompensation::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ToneCompensation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ToneCompensation(soap, tag, this, type);
}

SOAP_FMAC3 tt__ToneCompensation * SOAP_FMAC4 soap_in_tt__ToneCompensation(struct soap *soap, const char *tag, tt__ToneCompensation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ToneCompensation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensation, sizeof(tt__ToneCompensation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ToneCompensation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ToneCompensation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ToneCompensation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Mode", &a->tt__ToneCompensation::Mode, "xsd:string"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__ToneCompensation::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ToneCompensationExtension(soap, "tt:Extension", &a->tt__ToneCompensation::Extension, "tt:ToneCompensationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ToneCompensation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensation, SOAP_TYPE_tt__ToneCompensation, sizeof(tt__ToneCompensation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ToneCompensation * SOAP_FMAC2 soap_instantiate_tt__ToneCompensation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ToneCompensation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ToneCompensation *p;
	size_t k = sizeof(tt__ToneCompensation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ToneCompensation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ToneCompensation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ToneCompensation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ToneCompensation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ToneCompensation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ToneCompensation(soap, tag ? tag : "tt:ToneCompensation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ToneCompensation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ToneCompensation(soap, this, tag, type);
}

SOAP_FMAC3 tt__ToneCompensation * SOAP_FMAC4 soap_get_tt__ToneCompensation(struct soap *soap, tt__ToneCompensation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Exposure20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ExposureMode(soap, &this->tt__Exposure20::Mode);
	this->tt__Exposure20::Priority = NULL;
	this->tt__Exposure20::Window = NULL;
	this->tt__Exposure20::MinExposureTime = NULL;
	this->tt__Exposure20::MaxExposureTime = NULL;
	this->tt__Exposure20::MinGain = NULL;
	this->tt__Exposure20::MaxGain = NULL;
	this->tt__Exposure20::MinIris = NULL;
	this->tt__Exposure20::MaxIris = NULL;
	this->tt__Exposure20::ExposureTime = NULL;
	this->tt__Exposure20::Gain = NULL;
	this->tt__Exposure20::Iris = NULL;
}

void tt__Exposure20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ExposurePriority(soap, &this->tt__Exposure20::Priority);
	soap_serialize_PointerTott__Rectangle(soap, &this->tt__Exposure20::Window);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MinExposureTime);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MaxExposureTime);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MinGain);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MaxGain);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MinIris);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MaxIris);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::ExposureTime);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::Gain);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::Iris);
#endif
}

int tt__Exposure20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Exposure20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure20(struct soap *soap, const char *tag, int id, const tt__Exposure20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Exposure20), type))
		return soap->error;
	if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, &a->tt__Exposure20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__ExposurePriority(soap, "tt:Priority", -1, &a->tt__Exposure20::Priority, ""))
		return soap->error;
	if (soap_out_PointerTott__Rectangle(soap, "tt:Window", -1, &a->tt__Exposure20::Window, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinExposureTime", -1, &a->tt__Exposure20::MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxExposureTime", -1, &a->tt__Exposure20::MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinGain", -1, &a->tt__Exposure20::MinGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxGain", -1, &a->tt__Exposure20::MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinIris", -1, &a->tt__Exposure20::MinIris, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxIris", -1, &a->tt__Exposure20::MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ExposureTime", -1, &a->tt__Exposure20::ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Gain", -1, &a->tt__Exposure20::Gain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Iris", -1, &a->tt__Exposure20::Iris, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Exposure20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Exposure20(soap, tag, this, type);
}

SOAP_FMAC3 tt__Exposure20 * SOAP_FMAC4 soap_in_tt__Exposure20(struct soap *soap, const char *tag, tt__Exposure20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Exposure20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure20, sizeof(tt__Exposure20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Exposure20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Exposure20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Priority1 = 1;
	size_t soap_flag_Window1 = 1;
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ExposureMode(soap, "tt:Mode", &a->tt__Exposure20::Mode, "tt:ExposureMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Priority1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ExposurePriority(soap, "tt:Priority", &a->tt__Exposure20::Priority, "tt:ExposurePriority"))
				{	soap_flag_Priority1--;
					continue;
				}
			}
			if (soap_flag_Window1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rectangle(soap, "tt:Window", &a->tt__Exposure20::Window, "tt:Rectangle"))
				{	soap_flag_Window1--;
					continue;
				}
			}
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MinExposureTime", &a->tt__Exposure20::MinExposureTime, "xsd:float"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MaxExposureTime", &a->tt__Exposure20::MaxExposureTime, "xsd:float"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MinGain", &a->tt__Exposure20::MinGain, "xsd:float"))
				{	soap_flag_MinGain1--;
					continue;
				}
			}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MaxGain", &a->tt__Exposure20::MaxGain, "xsd:float"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MinIris", &a->tt__Exposure20::MinIris, "xsd:float"))
				{	soap_flag_MinIris1--;
					continue;
				}
			}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MaxIris", &a->tt__Exposure20::MaxIris, "xsd:float"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:ExposureTime", &a->tt__Exposure20::ExposureTime, "xsd:float"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Gain", &a->tt__Exposure20::Gain, "xsd:float"))
				{	soap_flag_Gain1--;
					continue;
				}
			}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Iris", &a->tt__Exposure20::Iris, "xsd:float"))
				{	soap_flag_Iris1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Exposure20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure20, SOAP_TYPE_tt__Exposure20, sizeof(tt__Exposure20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Exposure20 * SOAP_FMAC2 soap_instantiate_tt__Exposure20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Exposure20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Exposure20 *p;
	size_t k = sizeof(tt__Exposure20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Exposure20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Exposure20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Exposure20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Exposure20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Exposure20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Exposure20(soap, tag ? tag : "tt:Exposure20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Exposure20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Exposure20(soap, this, tag, type);
}

SOAP_FMAC3 tt__Exposure20 * SOAP_FMAC4 soap_get_tt__Exposure20(struct soap *soap, tt__Exposure20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BacklightCompensation20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__BacklightCompensationMode(soap, &this->tt__BacklightCompensation20::Mode);
	this->tt__BacklightCompensation20::Level = NULL;
}

void tt__BacklightCompensation20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__BacklightCompensation20::Level);
#endif
}

int tt__BacklightCompensation20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensation20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation20(struct soap *soap, const char *tag, int id, const tt__BacklightCompensation20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensation20), type))
		return soap->error;
	if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->tt__BacklightCompensation20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__BacklightCompensation20::Level, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensation20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BacklightCompensation20(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensation20 * SOAP_FMAC4 soap_in_tt__BacklightCompensation20(struct soap *soap, const char *tag, tt__BacklightCompensation20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensation20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(tt__BacklightCompensation20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BacklightCompensation20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BacklightCompensation20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", &a->tt__BacklightCompensation20::Mode, "tt:BacklightCompensationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__BacklightCompensation20::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BacklightCompensation20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation20, SOAP_TYPE_tt__BacklightCompensation20, sizeof(tt__BacklightCompensation20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BacklightCompensation20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BacklightCompensation20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BacklightCompensation20 *p;
	size_t k = sizeof(tt__BacklightCompensation20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BacklightCompensation20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BacklightCompensation20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BacklightCompensation20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BacklightCompensation20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BacklightCompensation20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BacklightCompensation20(soap, tag ? tag : "tt:BacklightCompensation20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensation20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensation20(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensation20 * SOAP_FMAC4 soap_get_tt__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WideDynamicRange20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__WideDynamicMode(soap, &this->tt__WideDynamicRange20::Mode);
	this->tt__WideDynamicRange20::Level = NULL;
}

void tt__WideDynamicRange20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__WideDynamicRange20::Level);
#endif
}

int tt__WideDynamicRange20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRange20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange20(struct soap *soap, const char *tag, int id, const tt__WideDynamicRange20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRange20), type))
		return soap->error;
	if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, &a->tt__WideDynamicRange20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__WideDynamicRange20::Level, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRange20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WideDynamicRange20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRange20 * SOAP_FMAC4 soap_in_tt__WideDynamicRange20(struct soap *soap, const char *tag, tt__WideDynamicRange20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRange20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(tt__WideDynamicRange20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WideDynamicRange20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WideDynamicRange20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", &a->tt__WideDynamicRange20::Mode, "tt:WideDynamicMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__WideDynamicRange20::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WideDynamicRange20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange20, SOAP_TYPE_tt__WideDynamicRange20, sizeof(tt__WideDynamicRange20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WideDynamicRange20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WideDynamicRange20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WideDynamicRange20 *p;
	size_t k = sizeof(tt__WideDynamicRange20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WideDynamicRange20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WideDynamicRange20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WideDynamicRange20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WideDynamicRange20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WideDynamicRange20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WideDynamicRange20(soap, tag ? tag : "tt:WideDynamicRange20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRange20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRange20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRange20 * SOAP_FMAC4 soap_get_tt__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoAdjustmentExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IrCutFilterAutoAdjustmentExtension::__any);
}

void tt__IrCutFilterAutoAdjustmentExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IrCutFilterAutoAdjustmentExtension::__any);
#endif
}

int tt__IrCutFilterAutoAdjustmentExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoAdjustmentExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__IrCutFilterAutoAdjustmentExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IrCutFilterAutoAdjustmentExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IrCutFilterAutoAdjustmentExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(tt__IrCutFilterAutoAdjustmentExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IrCutFilterAutoAdjustmentExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__IrCutFilterAutoAdjustmentExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(tt__IrCutFilterAutoAdjustmentExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IrCutFilterAutoAdjustmentExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoAdjustmentExtension *p;
	size_t k = sizeof(tt__IrCutFilterAutoAdjustmentExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoAdjustmentExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoAdjustmentExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoAdjustmentExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoAdjustmentExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoAdjustmentExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoAdjustmentExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoAdjustment::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__IrCutFilterAutoAdjustment::BoundaryType);
	this->tt__IrCutFilterAutoAdjustment::BoundaryOffset = NULL;
	this->tt__IrCutFilterAutoAdjustment::ResponseTime = NULL;
	this->tt__IrCutFilterAutoAdjustment::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__IrCutFilterAutoAdjustment::__anyAttribute);
}

void tt__IrCutFilterAutoAdjustment::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IrCutFilterAutoAdjustment::BoundaryType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__IrCutFilterAutoAdjustment::BoundaryType);
	soap_serialize_PointerTofloat(soap, &this->tt__IrCutFilterAutoAdjustment::BoundaryOffset);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__IrCutFilterAutoAdjustment::ResponseTime);
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, &this->tt__IrCutFilterAutoAdjustment::Extension);
#endif
}

int tt__IrCutFilterAutoAdjustment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoAdjustment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoAdjustment *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__IrCutFilterAutoAdjustment*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:BoundaryType", -1, &a->tt__IrCutFilterAutoAdjustment::BoundaryType, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:BoundaryOffset", -1, &a->tt__IrCutFilterAutoAdjustment::BoundaryOffset, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:ResponseTime", -1, &a->tt__IrCutFilterAutoAdjustment::ResponseTime, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, "tt:Extension", -1, &a->tt__IrCutFilterAutoAdjustment::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IrCutFilterAutoAdjustment::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoAdjustment(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustment * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IrCutFilterAutoAdjustment*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(tt__IrCutFilterAutoAdjustment), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoAdjustment)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IrCutFilterAutoAdjustment *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__IrCutFilterAutoAdjustment*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_BoundaryType1 = 1;
	size_t soap_flag_BoundaryOffset1 = 1;
	size_t soap_flag_ResponseTime1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundaryType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:BoundaryType", &a->tt__IrCutFilterAutoAdjustment::BoundaryType, "xsd:string"))
				{	soap_flag_BoundaryType1--;
					continue;
				}
			}
			if (soap_flag_BoundaryOffset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:BoundaryOffset", &a->tt__IrCutFilterAutoAdjustment::BoundaryOffset, "xsd:float"))
				{	soap_flag_BoundaryOffset1--;
					continue;
				}
			}
			if (soap_flag_ResponseTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__duration(soap, "tt:ResponseTime", &a->tt__IrCutFilterAutoAdjustment::ResponseTime, "xsd:duration"))
				{	soap_flag_ResponseTime1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, "tt:Extension", &a->tt__IrCutFilterAutoAdjustment::Extension, "tt:IrCutFilterAutoAdjustmentExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BoundaryType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(tt__IrCutFilterAutoAdjustment), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustment * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IrCutFilterAutoAdjustment(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoAdjustment *p;
	size_t k = sizeof(tt__IrCutFilterAutoAdjustment);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoAdjustment);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoAdjustment, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoAdjustment location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoAdjustment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoAdjustment(soap, tag ? tag : "tt:IrCutFilterAutoAdjustment", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoAdjustment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoAdjustment(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustment * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilizationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImageStabilizationExtension::__any);
}

void tt__ImageStabilizationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImageStabilizationExtension::__any);
#endif
}

int tt__ImageStabilizationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilizationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationExtension(struct soap *soap, const char *tag, int id, const tt__ImageStabilizationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ImageStabilizationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImageStabilizationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilizationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilizationExtension * SOAP_FMAC4 soap_in_tt__ImageStabilizationExtension(struct soap *soap, const char *tag, tt__ImageStabilizationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImageStabilizationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(tt__ImageStabilizationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilizationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImageStabilizationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ImageStabilizationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImageStabilizationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationExtension, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(tt__ImageStabilizationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImageStabilizationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilizationExtension *p;
	size_t k = sizeof(tt__ImageStabilizationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilizationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilizationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilizationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilizationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilizationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilizationExtension(soap, tag ? tag : "tt:ImageStabilizationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilizationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilizationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilizationExtension * SOAP_FMAC4 soap_get_tt__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilization::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ImageStabilizationMode(soap, &this->tt__ImageStabilization::Mode);
	this->tt__ImageStabilization::Level = NULL;
	this->tt__ImageStabilization::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ImageStabilization::__anyAttribute);
}

void tt__ImageStabilization::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__ImageStabilization::Level);
	soap_serialize_PointerTott__ImageStabilizationExtension(soap, &this->tt__ImageStabilization::Extension);
#endif
}

int tt__ImageStabilization::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilization(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilization(struct soap *soap, const char *tag, int id, const tt__ImageStabilization *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImageStabilization*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilization), type))
		return soap->error;
	if (soap_out_tt__ImageStabilizationMode(soap, "tt:Mode", -1, &a->tt__ImageStabilization::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__ImageStabilization::Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationExtension(soap, "tt:Extension", -1, &a->tt__ImageStabilization::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImageStabilization::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilization(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilization * SOAP_FMAC4 soap_in_tt__ImageStabilization(struct soap *soap, const char *tag, tt__ImageStabilization *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImageStabilization*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilization, sizeof(tt__ImageStabilization), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilization)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImageStabilization *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImageStabilization*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ImageStabilizationMode(soap, "tt:Mode", &a->tt__ImageStabilization::Mode, "tt:ImageStabilizationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__ImageStabilization::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilizationExtension(soap, "tt:Extension", &a->tt__ImageStabilization::Extension, "tt:ImageStabilizationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ImageStabilization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilization, SOAP_TYPE_tt__ImageStabilization, sizeof(tt__ImageStabilization), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilization * SOAP_FMAC2 soap_instantiate_tt__ImageStabilization(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImageStabilization(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilization *p;
	size_t k = sizeof(tt__ImageStabilization);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilization, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilization);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilization, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilization location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilization::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilization(soap, tag ? tag : "tt:ImageStabilization", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilization::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilization(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilization * SOAP_FMAC4 soap_get_tt__ImageStabilization(struct soap *soap, tt__ImageStabilization *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension204::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingSettingsExtension204::__any);
}

void tt__ImagingSettingsExtension204::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingSettingsExtension204::__any);
#endif
}

int tt__ImagingSettingsExtension204::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension204(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension204(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension204 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension204), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ImagingSettingsExtension204::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension204::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension204(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension204 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension204(struct soap *soap, const char *tag, tt__ImagingSettingsExtension204 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension204*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(tt__ImagingSettingsExtension204), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension204)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettingsExtension204 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ImagingSettingsExtension204::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension204 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension204, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(tt__ImagingSettingsExtension204), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension204 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension204(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettingsExtension204(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension204 *p;
	size_t k = sizeof(tt__ImagingSettingsExtension204);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension204, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension204);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension204, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension204 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension204::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension204(soap, tag ? tag : "tt:ImagingSettingsExtension204", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension204::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension204(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension204 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension204(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension203::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ImagingSettingsExtension203::ToneCompensation = NULL;
	this->tt__ImagingSettingsExtension203::Defogging = NULL;
	this->tt__ImagingSettingsExtension203::NoiseReduction = NULL;
	this->tt__ImagingSettingsExtension203::Extension = NULL;
}

void tt__ImagingSettingsExtension203::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ToneCompensation(soap, &this->tt__ImagingSettingsExtension203::ToneCompensation);
	soap_serialize_PointerTott__Defogging(soap, &this->tt__ImagingSettingsExtension203::Defogging);
	soap_serialize_PointerTott__NoiseReduction(soap, &this->tt__ImagingSettingsExtension203::NoiseReduction);
	soap_serialize_PointerTott__ImagingSettingsExtension204(soap, &this->tt__ImagingSettingsExtension203::Extension);
#endif
}

int tt__ImagingSettingsExtension203::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension203(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension203(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension203 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension203), type))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensation(soap, "tt:ToneCompensation", -1, &a->tt__ImagingSettingsExtension203::ToneCompensation, ""))
		return soap->error;
	if (soap_out_PointerTott__Defogging(soap, "tt:Defogging", -1, &a->tt__ImagingSettingsExtension203::Defogging, ""))
		return soap->error;
	if (soap_out_PointerTott__NoiseReduction(soap, "tt:NoiseReduction", -1, &a->tt__ImagingSettingsExtension203::NoiseReduction, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension204(soap, "tt:Extension", -1, &a->tt__ImagingSettingsExtension203::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension203::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension203(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension203 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension203(struct soap *soap, const char *tag, tt__ImagingSettingsExtension203 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension203*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(tt__ImagingSettingsExtension203), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension203)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettingsExtension203 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ToneCompensation1 = 1;
	size_t soap_flag_Defogging1 = 1;
	size_t soap_flag_NoiseReduction1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToneCompensation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ToneCompensation(soap, "tt:ToneCompensation", &a->tt__ImagingSettingsExtension203::ToneCompensation, "tt:ToneCompensation"))
				{	soap_flag_ToneCompensation1--;
					continue;
				}
			}
			if (soap_flag_Defogging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Defogging(soap, "tt:Defogging", &a->tt__ImagingSettingsExtension203::Defogging, "tt:Defogging"))
				{	soap_flag_Defogging1--;
					continue;
				}
			}
			if (soap_flag_NoiseReduction1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NoiseReduction(soap, "tt:NoiseReduction", &a->tt__ImagingSettingsExtension203::NoiseReduction, "tt:NoiseReduction"))
				{	soap_flag_NoiseReduction1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension204(soap, "tt:Extension", &a->tt__ImagingSettingsExtension203::Extension, "tt:ImagingSettingsExtension204"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension203 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension203, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(tt__ImagingSettingsExtension203), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension203 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension203(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettingsExtension203(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension203 *p;
	size_t k = sizeof(tt__ImagingSettingsExtension203);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension203, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension203);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension203, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension203 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension203::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension203(soap, tag ? tag : "tt:ImagingSettingsExtension203", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension203::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension203(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension203 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension203(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.cpp */
