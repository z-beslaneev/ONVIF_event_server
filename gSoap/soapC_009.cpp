/* soapC_nnn.cpp
   Generated by gSOAP 2.8.78 for WS/onvifFull.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.cpp ver 2.8.78 2019-03-11 21:45:01 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetScopes(struct soap *soap, const char *tag, int id, _tds__SetScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetScopes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetScopes ? type : NULL);
}

SOAP_FMAC3 _tds__SetScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__SetScopes(struct soap *soap, const char *tag, _tds__SetScopes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetScopes **)soap_malloc(soap, sizeof(_tds__SetScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetScopes *)soap_instantiate__tds__SetScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetScopes, sizeof(_tds__SetScopes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetScopes(soap, tag ? tag : "tds:SetScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetScopes(struct soap *soap, const char *tag, int id, _tds__GetScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetScopes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetScopes ? type : NULL);
}

SOAP_FMAC3 _tds__GetScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__GetScopes(struct soap *soap, const char *tag, _tds__GetScopes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetScopes **)soap_malloc(soap, sizeof(_tds__GetScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetScopes *)soap_instantiate__tds__GetScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetScopes, sizeof(_tds__GetScopes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetScopes(soap, tag ? tag : "tds:GetScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemSupportInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, _tds__GetSystemSupportInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemSupportInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemSupportInformation ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemSupportInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, const char *tag, _tds__GetSystemSupportInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemSupportInformation **)soap_malloc(soap, sizeof(_tds__GetSystemSupportInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemSupportInformation *)soap_instantiate__tds__GetSystemSupportInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemSupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(_tds__GetSystemSupportInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemSupportInformation(soap, tag ? tag : "tds:GetSystemSupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemSupportInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, int id, _tds__GetSystemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemLog, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemLog ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemLog ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, _tds__GetSystemLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemLog **)soap_malloc(soap, sizeof(_tds__GetSystemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemLog *)soap_instantiate__tds__GetSystemLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemLog, sizeof(_tds__GetSystemLog), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemLog(soap, tag ? tag : "tds:GetSystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemLog ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemBackup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, int id, _tds__GetSystemBackup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemBackup, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemBackup ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemBackup ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, _tds__GetSystemBackup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemBackup **)soap_malloc(soap, sizeof(_tds__GetSystemBackup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemBackup *)soap_instantiate__tds__GetSystemBackup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemBackup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackup, sizeof(_tds__GetSystemBackup), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemBackup(soap, tag ? tag : "tds:GetSystemBackup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemBackup ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RestoreSystem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, int id, _tds__RestoreSystem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RestoreSystem, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__RestoreSystem ? type : NULL);
}

SOAP_FMAC3 _tds__RestoreSystem ** SOAP_FMAC4 soap_in_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, _tds__RestoreSystem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RestoreSystem **)soap_malloc(soap, sizeof(_tds__RestoreSystem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RestoreSystem *)soap_instantiate__tds__RestoreSystem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__RestoreSystem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystem, sizeof(_tds__RestoreSystem), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__RestoreSystem(soap, tag ? tag : "tds:RestoreSystem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RestoreSystem ** SOAP_FMAC4 soap_get_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemReboot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, int id, _tds__SystemReboot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemReboot, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SystemReboot ? type : NULL);
}

SOAP_FMAC3 _tds__SystemReboot ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, _tds__SystemReboot **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SystemReboot **)soap_malloc(soap, sizeof(_tds__SystemReboot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SystemReboot *)soap_instantiate__tds__SystemReboot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SystemReboot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemReboot, sizeof(_tds__SystemReboot), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SystemReboot(soap, tag ? tag : "tds:SystemReboot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SystemReboot ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UpgradeSystemFirmware))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, _tds__UpgradeSystemFirmware *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UpgradeSystemFirmware, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__UpgradeSystemFirmware ? type : NULL);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_in_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, _tds__UpgradeSystemFirmware **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__UpgradeSystemFirmware **)soap_malloc(soap, sizeof(_tds__UpgradeSystemFirmware *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__UpgradeSystemFirmware *)soap_instantiate__tds__UpgradeSystemFirmware(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__UpgradeSystemFirmware **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(_tds__UpgradeSystemFirmware), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, tag ? tag : "tds:UpgradeSystemFirmware", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_get_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, _tds__SetSystemFactoryDefault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetSystemFactoryDefault ? type : NULL);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, _tds__SetSystemFactoryDefault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetSystemFactoryDefault **)soap_malloc(soap, sizeof(_tds__SetSystemFactoryDefault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetSystemFactoryDefault *)soap_instantiate__tds__SetSystemFactoryDefault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetSystemFactoryDefault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(_tds__SetSystemFactoryDefault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, tag ? tag : "tds:SetSystemFactoryDefault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, _tds__GetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemDateAndTime ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, _tds__GetSystemDateAndTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemDateAndTime **)soap_malloc(soap, sizeof(_tds__GetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemDateAndTime *)soap_instantiate__tds__GetSystemDateAndTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(_tds__GetSystemDateAndTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, tag ? tag : "tds:GetSystemDateAndTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, _tds__SetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetSystemDateAndTime ? type : NULL);
}

SOAP_FMAC3 _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, _tds__SetSystemDateAndTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetSystemDateAndTime **)soap_malloc(soap, sizeof(_tds__SetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetSystemDateAndTime *)soap_instantiate__tds__SetSystemDateAndTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(_tds__SetSystemDateAndTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, tag ? tag : "tds:SetSystemDateAndTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, _tds__GetDeviceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDeviceInformation ? type : NULL);
}

SOAP_FMAC3 _tds__GetDeviceInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, _tds__GetDeviceInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDeviceInformation **)soap_malloc(soap, sizeof(_tds__GetDeviceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDeviceInformation *)soap_instantiate__tds__GetDeviceInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDeviceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(_tds__GetDeviceInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, tag ? tag : "tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDeviceInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, _tds__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetServiceCapabilities ? type : NULL);
}

SOAP_FMAC3 _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, _tds__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetServiceCapabilities **)soap_malloc(soap, sizeof(_tds__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetServiceCapabilities *)soap_instantiate__tds__GetServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(_tds__GetServiceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, tag ? tag : "tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServices))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServices(struct soap *soap, const char *tag, int id, _tds__GetServices *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServices, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetServices ? type : NULL);
}

SOAP_FMAC3 _tds__GetServices ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServices(struct soap *soap, const char *tag, _tds__GetServices **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetServices **)soap_malloc(soap, sizeof(_tds__GetServices *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetServices *)soap_instantiate__tds__GetServices(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetServices **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServices, sizeof(_tds__GetServices), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServices(soap, tag ? tag : "tds:GetServices", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetServices ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableTerminationTimeFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, wsnt__UnacceptableTerminationTimeFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__UnacceptableTerminationTimeFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, wsnt__UnacceptableTerminationTimeFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnacceptableTerminationTimeFaultType **)soap_malloc(soap, sizeof(wsnt__UnacceptableTerminationTimeFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnacceptableTerminationTimeFaultType *)soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnacceptableTerminationTimeFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(wsnt__UnacceptableTerminationTimeFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableTerminationTimeFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnacceptableTerminationTimeFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableTerminationTimeFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, wsnt__ResumeFailedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__ResumeFailedFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, wsnt__ResumeFailedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__ResumeFailedFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__ResumeFailedFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__ResumeFailedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, wsnt__ResumeFailedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__ResumeFailedFaultType **)soap_malloc(soap, sizeof(wsnt__ResumeFailedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__ResumeFailedFaultType *)soap_instantiate_wsnt__ResumeFailedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__ResumeFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(wsnt__ResumeFailedFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, wsnt__ResumeFailedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__ResumeFailedFaultType(soap, tag ? tag : "wsnt:ResumeFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__ResumeFailedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, wsnt__ResumeFailedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__PauseFailedFaultType(struct soap *soap, wsnt__PauseFailedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__PauseFailedFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__PauseFailedFaultType(struct soap *soap, const char *tag, int id, wsnt__PauseFailedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__PauseFailedFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__PauseFailedFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__PauseFailedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__PauseFailedFaultType(struct soap *soap, const char *tag, wsnt__PauseFailedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__PauseFailedFaultType **)soap_malloc(soap, sizeof(wsnt__PauseFailedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__PauseFailedFaultType *)soap_instantiate_wsnt__PauseFailedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__PauseFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(wsnt__PauseFailedFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__PauseFailedFaultType(struct soap *soap, wsnt__PauseFailedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__PauseFailedFaultType(soap, tag ? tag : "wsnt:PauseFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__PauseFailedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__PauseFailedFaultType(struct soap *soap, wsnt__PauseFailedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnt__UnableToDestroySubscriptionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, wsnt__UnableToDestroySubscriptionFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__UnableToDestroySubscriptionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, wsnt__UnableToDestroySubscriptionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnableToDestroySubscriptionFaultType **)soap_malloc(soap, sizeof(wsnt__UnableToDestroySubscriptionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnableToDestroySubscriptionFaultType *)soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnableToDestroySubscriptionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(wsnt__UnableToDestroySubscriptionFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnt__UnableToDestroySubscriptionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnableToDestroySubscriptionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnt__UnableToDestroySubscriptionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, _tev__PullMessagesFaultResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__PullMessagesFaultResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, int id, _tev__PullMessagesFaultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__PullMessagesFaultResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tev__PullMessagesFaultResponse ? type : NULL);
}

SOAP_FMAC3 _tev__PullMessagesFaultResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, _tev__PullMessagesFaultResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tev__PullMessagesFaultResponse **)soap_malloc(soap, sizeof(_tev__PullMessagesFaultResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tev__PullMessagesFaultResponse *)soap_instantiate__tev__PullMessagesFaultResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tev__PullMessagesFaultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(_tev__PullMessagesFaultResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, _tev__PullMessagesFaultResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__PullMessagesFaultResponse(soap, tag ? tag : "tev:PullMessagesFaultResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tev__PullMessagesFaultResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, _tev__PullMessagesFaultResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__PullMessagesFaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, wsnt__UnableToGetMessagesFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, wsnt__UnableToGetMessagesFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnableToGetMessagesFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__UnableToGetMessagesFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, wsnt__UnableToGetMessagesFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnableToGetMessagesFaultType **)soap_malloc(soap, sizeof(wsnt__UnableToGetMessagesFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnableToGetMessagesFaultType *)soap_instantiate_wsnt__UnableToGetMessagesFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnableToGetMessagesFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(wsnt__UnableToGetMessagesFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, wsnt__UnableToGetMessagesFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnableToGetMessagesFaultType(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnableToGetMessagesFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, wsnt__UnableToGetMessagesFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, wsnt__UnableToDestroyPullPointFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, wsnt__UnableToDestroyPullPointFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__UnableToDestroyPullPointFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, wsnt__UnableToDestroyPullPointFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnableToDestroyPullPointFaultType **)soap_malloc(soap, sizeof(wsnt__UnableToDestroyPullPointFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnableToDestroyPullPointFaultType *)soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnableToDestroyPullPointFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(wsnt__UnableToDestroyPullPointFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, wsnt__UnableToDestroyPullPointFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnableToDestroyPullPointFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, wsnt__UnableToDestroyPullPointFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnt__NoCurrentMessageOnTopicFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, wsnt__NoCurrentMessageOnTopicFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__NoCurrentMessageOnTopicFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, wsnt__NoCurrentMessageOnTopicFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__NoCurrentMessageOnTopicFaultType **)soap_malloc(soap, sizeof(wsnt__NoCurrentMessageOnTopicFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__NoCurrentMessageOnTopicFaultType *)soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__NoCurrentMessageOnTopicFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(wsnt__NoCurrentMessageOnTopicFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnt__NoCurrentMessageOnTopicFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__NoCurrentMessageOnTopicFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnt__NoCurrentMessageOnTopicFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnt__MultipleTopicsSpecifiedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, wsnt__MultipleTopicsSpecifiedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__MultipleTopicsSpecifiedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, wsnt__MultipleTopicsSpecifiedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__MultipleTopicsSpecifiedFaultType **)soap_malloc(soap, sizeof(wsnt__MultipleTopicsSpecifiedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__MultipleTopicsSpecifiedFaultType *)soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__MultipleTopicsSpecifiedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(wsnt__MultipleTopicsSpecifiedFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnt__MultipleTopicsSpecifiedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__MultipleTopicsSpecifiedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnt__MultipleTopicsSpecifiedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnt__UnsupportedPolicyRequestFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, wsnt__UnsupportedPolicyRequestFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__UnsupportedPolicyRequestFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, wsnt__UnsupportedPolicyRequestFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnsupportedPolicyRequestFaultType **)soap_malloc(soap, sizeof(wsnt__UnsupportedPolicyRequestFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnsupportedPolicyRequestFaultType *)soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnsupportedPolicyRequestFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(wsnt__UnsupportedPolicyRequestFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnt__UnsupportedPolicyRequestFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnsupportedPolicyRequestFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnt__UnsupportedPolicyRequestFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnt__UnrecognizedPolicyRequestFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, wsnt__UnrecognizedPolicyRequestFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__UnrecognizedPolicyRequestFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, wsnt__UnrecognizedPolicyRequestFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnrecognizedPolicyRequestFaultType **)soap_malloc(soap, sizeof(wsnt__UnrecognizedPolicyRequestFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnrecognizedPolicyRequestFaultType *)soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnrecognizedPolicyRequestFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(wsnt__UnrecognizedPolicyRequestFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnt__UnrecognizedPolicyRequestFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnrecognizedPolicyRequestFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnt__UnrecognizedPolicyRequestFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableInitialTerminationTimeFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, wsnt__UnacceptableInitialTerminationTimeFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__UnacceptableInitialTerminationTimeFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, wsnt__UnacceptableInitialTerminationTimeFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnacceptableInitialTerminationTimeFaultType **)soap_malloc(soap, sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnacceptableInitialTerminationTimeFaultType *)soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnacceptableInitialTerminationTimeFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableInitialTerminationTimeFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnacceptableInitialTerminationTimeFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableInitialTerminationTimeFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, wsnt__TopicNotSupportedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, wsnt__TopicNotSupportedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__TopicNotSupportedFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__TopicNotSupportedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, wsnt__TopicNotSupportedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__TopicNotSupportedFaultType **)soap_malloc(soap, sizeof(wsnt__TopicNotSupportedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__TopicNotSupportedFaultType *)soap_instantiate_wsnt__TopicNotSupportedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__TopicNotSupportedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(wsnt__TopicNotSupportedFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, wsnt__TopicNotSupportedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicNotSupportedFaultType(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__TopicNotSupportedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, wsnt__TopicNotSupportedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnt__TopicExpressionDialectUnknownFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, wsnt__TopicExpressionDialectUnknownFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__TopicExpressionDialectUnknownFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, wsnt__TopicExpressionDialectUnknownFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__TopicExpressionDialectUnknownFaultType **)soap_malloc(soap, sizeof(wsnt__TopicExpressionDialectUnknownFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__TopicExpressionDialectUnknownFaultType *)soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__TopicExpressionDialectUnknownFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(wsnt__TopicExpressionDialectUnknownFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnt__TopicExpressionDialectUnknownFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__TopicExpressionDialectUnknownFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnt__TopicExpressionDialectUnknownFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, wsnt__SubscribeCreationFailedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, wsnt__SubscribeCreationFailedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__SubscribeCreationFailedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, wsnt__SubscribeCreationFailedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__SubscribeCreationFailedFaultType **)soap_malloc(soap, sizeof(wsnt__SubscribeCreationFailedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__SubscribeCreationFailedFaultType *)soap_instantiate_wsnt__SubscribeCreationFailedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__SubscribeCreationFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(wsnt__SubscribeCreationFailedFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, wsnt__SubscribeCreationFailedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__SubscribeCreationFailedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, wsnt__SubscribeCreationFailedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrf__ResourceUnknownFaultType(struct soap *soap, wsrf__ResourceUnknownFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrf__ResourceUnknownFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrf__ResourceUnknownFaultType(struct soap *soap, const char *tag, int id, wsrf__ResourceUnknownFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrf__ResourceUnknownFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsrf__ResourceUnknownFaultType ? type : NULL);
}

SOAP_FMAC3 wsrf__ResourceUnknownFaultType ** SOAP_FMAC4 soap_in_PointerTowsrf__ResourceUnknownFaultType(struct soap *soap, const char *tag, wsrf__ResourceUnknownFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsrf__ResourceUnknownFaultType **)soap_malloc(soap, sizeof(wsrf__ResourceUnknownFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsrf__ResourceUnknownFaultType *)soap_instantiate_wsrf__ResourceUnknownFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsrf__ResourceUnknownFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrf__ResourceUnknownFaultType, sizeof(wsrf__ResourceUnknownFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrf__ResourceUnknownFaultType(struct soap *soap, wsrf__ResourceUnknownFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrf__ResourceUnknownFaultType(soap, tag ? tag : "wsrf:ResourceUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsrf__ResourceUnknownFaultType ** SOAP_FMAC4 soap_get_PointerTowsrf__ResourceUnknownFaultType(struct soap *soap, wsrf__ResourceUnknownFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrf__ResourceUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnt__NotifyMessageNotSupportedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, wsnt__NotifyMessageNotSupportedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__NotifyMessageNotSupportedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, wsnt__NotifyMessageNotSupportedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__NotifyMessageNotSupportedFaultType **)soap_malloc(soap, sizeof(wsnt__NotifyMessageNotSupportedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__NotifyMessageNotSupportedFaultType *)soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__NotifyMessageNotSupportedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(wsnt__NotifyMessageNotSupportedFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnt__NotifyMessageNotSupportedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__NotifyMessageNotSupportedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnt__NotifyMessageNotSupportedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, wsnt__InvalidTopicExpressionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, wsnt__InvalidTopicExpressionFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__InvalidTopicExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidTopicExpressionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__InvalidTopicExpressionFaultType **)soap_malloc(soap, sizeof(wsnt__InvalidTopicExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__InvalidTopicExpressionFaultType *)soap_instantiate_wsnt__InvalidTopicExpressionFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__InvalidTopicExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(wsnt__InvalidTopicExpressionFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, wsnt__InvalidTopicExpressionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__InvalidTopicExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, wsnt__InvalidTopicExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnt__InvalidProducerPropertiesExpressionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, wsnt__InvalidProducerPropertiesExpressionFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__InvalidProducerPropertiesExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidProducerPropertiesExpressionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__InvalidProducerPropertiesExpressionFaultType **)soap_malloc(soap, sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__InvalidProducerPropertiesExpressionFaultType *)soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__InvalidProducerPropertiesExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnt__InvalidProducerPropertiesExpressionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__InvalidProducerPropertiesExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnt__InvalidProducerPropertiesExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnt__InvalidMessageContentExpressionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, wsnt__InvalidMessageContentExpressionFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__InvalidMessageContentExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidMessageContentExpressionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__InvalidMessageContentExpressionFaultType **)soap_malloc(soap, sizeof(wsnt__InvalidMessageContentExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__InvalidMessageContentExpressionFaultType *)soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__InvalidMessageContentExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(wsnt__InvalidMessageContentExpressionFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnt__InvalidMessageContentExpressionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__InvalidMessageContentExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnt__InvalidMessageContentExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, wsnt__InvalidFilterFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidFilterFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, wsnt__InvalidFilterFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidFilterFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__InvalidFilterFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__InvalidFilterFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, wsnt__InvalidFilterFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__InvalidFilterFaultType **)soap_malloc(soap, sizeof(wsnt__InvalidFilterFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__InvalidFilterFaultType *)soap_instantiate_wsnt__InvalidFilterFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__InvalidFilterFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(wsnt__InvalidFilterFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, wsnt__InvalidFilterFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__InvalidFilterFaultType(soap, tag ? tag : "wsnt:InvalidFilterFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__InvalidFilterFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, wsnt__InvalidFilterFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, wsnt__UnableToCreatePullPointFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, wsnt__UnableToCreatePullPointFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType ? type : NULL);
}

SOAP_FMAC3 wsnt__UnableToCreatePullPointFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, wsnt__UnableToCreatePullPointFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnableToCreatePullPointFaultType **)soap_malloc(soap, sizeof(wsnt__UnableToCreatePullPointFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnableToCreatePullPointFaultType *)soap_instantiate_wsnt__UnableToCreatePullPointFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnableToCreatePullPointFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(wsnt__UnableToCreatePullPointFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, wsnt__UnableToCreatePullPointFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnableToCreatePullPointFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, wsnt__UnableToCreatePullPointFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NCName(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__NCName))
		soap_serialize_xsd__NCName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NCName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__NCName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NCName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NCName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NCName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NCName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NCName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__ConcreteTopicExpression))
		soap_serialize_wstop__ConcreteTopicExpression(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__ConcreteTopicExpression, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__ConcreteTopicExpression(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowstop__ConcreteTopicExpression(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__ConcreteTopicExpression(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__ConcreteTopicExpression(soap, tag ? tag : "wstop:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__QName(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__QName))
		soap_serialize_xsd__QName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__QName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__QName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__QName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__QName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__QName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicType(struct soap *soap, const char *tag, int id, wstop__TopicType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__TopicType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicType(struct soap *soap, const char *tag, wstop__TopicType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicType **)soap_malloc(soap, sizeof(wstop__TopicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__TopicType *)soap_instantiate_wstop__TopicType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__TopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__QueryExpressionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, int id, wstop__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__QueryExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__QueryExpressionType ? type : NULL);
}

SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, wstop__QueryExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__QueryExpressionType **)soap_malloc(soap, sizeof(wstop__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__QueryExpressionType *)soap_instantiate_wstop__QueryExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__QueryExpressionType(soap, tag ? tag : "wstop:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfigurationExtension(struct soap *soap, tt__OSDConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfigurationExtension(struct soap *soap, const char *tag, int id, tt__OSDConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDConfigurationExtension(struct soap *soap, const char *tag, tt__OSDConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDConfigurationExtension **)soap_malloc(soap, sizeof(tt__OSDConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDConfigurationExtension *)soap_instantiate_tt__OSDConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(tt__OSDConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfigurationExtension(struct soap *soap, tt__OSDConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfigurationExtension(soap, tag ? tag : "tt:OSDConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDConfigurationExtension(struct soap *soap, tt__OSDConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgConfiguration(struct soap *soap, tt__OSDImgConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgConfiguration(struct soap *soap, const char *tag, int id, tt__OSDImgConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDImgConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__OSDImgConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDImgConfiguration(struct soap *soap, const char *tag, tt__OSDImgConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDImgConfiguration **)soap_malloc(soap, sizeof(tt__OSDImgConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDImgConfiguration *)soap_instantiate_tt__OSDImgConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDImgConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(tt__OSDImgConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgConfiguration(struct soap *soap, tt__OSDImgConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgConfiguration(soap, tag ? tag : "tt:OSDImgConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDImgConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDImgConfiguration(struct soap *soap, tt__OSDImgConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextConfiguration(struct soap *soap, tt__OSDTextConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextConfiguration(struct soap *soap, const char *tag, int id, tt__OSDTextConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDTextConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__OSDTextConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDTextConfiguration(struct soap *soap, const char *tag, tt__OSDTextConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDTextConfiguration **)soap_malloc(soap, sizeof(tt__OSDTextConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDTextConfiguration *)soap_instantiate_tt__OSDTextConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDTextConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(tt__OSDTextConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextConfiguration(struct soap *soap, tt__OSDTextConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextConfiguration(soap, tag ? tag : "tt:OSDTextConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDTextConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDTextConfiguration(struct soap *soap, tt__OSDTextConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDPosConfiguration(struct soap *soap, tt__OSDPosConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDPosConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDPosConfiguration(struct soap *soap, const char *tag, int id, tt__OSDPosConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDPosConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDPosConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__OSDPosConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDPosConfiguration(struct soap *soap, const char *tag, tt__OSDPosConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDPosConfiguration **)soap_malloc(soap, sizeof(tt__OSDPosConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDPosConfiguration *)soap_instantiate_tt__OSDPosConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDPosConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(tt__OSDPosConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDPosConfiguration(struct soap *soap, tt__OSDPosConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDPosConfiguration(soap, tag ? tag : "tt:OSDPosConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDPosConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDPosConfiguration(struct soap *soap, tt__OSDPosConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDPosConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDReference(struct soap *soap, tt__OSDReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDReference))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDReference(struct soap *soap, const char *tag, int id, tt__OSDReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDReference, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDReference ? type : NULL);
}

SOAP_FMAC3 tt__OSDReference ** SOAP_FMAC4 soap_in_PointerTott__OSDReference(struct soap *soap, const char *tag, tt__OSDReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDReference **)soap_malloc(soap, sizeof(tt__OSDReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDReference *)soap_instantiate_tt__OSDReference(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDReference, sizeof(tt__OSDReference), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDReference(struct soap *soap, tt__OSDReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDReference(soap, tag ? tag : "tt:OSDReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDReference ** SOAP_FMAC4 soap_get_PointerTott__OSDReference(struct soap *soap, tt__OSDReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataInput(struct soap *soap, tt__MetadataInput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataInput))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataInput(struct soap *soap, const char *tag, int id, tt__MetadataInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataInput, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MetadataInput ? type : NULL);
}

SOAP_FMAC3 tt__MetadataInput ** SOAP_FMAC4 soap_in_PointerTott__MetadataInput(struct soap *soap, const char *tag, tt__MetadataInput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataInput **)soap_malloc(soap, sizeof(tt__MetadataInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataInput *)soap_instantiate_tt__MetadataInput(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MetadataInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInput, sizeof(tt__MetadataInput), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataInput(struct soap *soap, tt__MetadataInput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataInput(soap, tag ? tag : "tt:MetadataInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataInput ** SOAP_FMAC4 soap_get_PointerTott__MetadataInput(struct soap *soap, tt__MetadataInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceIdentification(struct soap *soap, tt__SourceIdentification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceIdentification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceIdentification(struct soap *soap, const char *tag, int id, tt__SourceIdentification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceIdentification, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SourceIdentification ? type : NULL);
}

SOAP_FMAC3 tt__SourceIdentification ** SOAP_FMAC4 soap_in_PointerTott__SourceIdentification(struct soap *soap, const char *tag, tt__SourceIdentification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SourceIdentification **)soap_malloc(soap, sizeof(tt__SourceIdentification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SourceIdentification *)soap_instantiate_tt__SourceIdentification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SourceIdentification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentification, sizeof(tt__SourceIdentification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceIdentification(struct soap *soap, tt__SourceIdentification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SourceIdentification(soap, tag ? tag : "tt:SourceIdentification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SourceIdentification ** SOAP_FMAC4 soap_get_PointerTott__SourceIdentification(struct soap *soap, tt__SourceIdentification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, tt__AnalyticsDeviceEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, int id, tt__AnalyticsDeviceEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsDeviceEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, tt__AnalyticsDeviceEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsDeviceEngineConfiguration **)soap_malloc(soap, sizeof(tt__AnalyticsDeviceEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsDeviceEngineConfiguration *)soap_instantiate_tt__AnalyticsDeviceEngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsDeviceEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(tt__AnalyticsDeviceEngineConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, tt__AnalyticsDeviceEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(soap, tag ? tag : "tt:AnalyticsDeviceEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsDeviceEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, tt__AnalyticsDeviceEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, tt__PTZConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, tt__PTZConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfigurationExtension **)soap_malloc(soap, sizeof(tt__PTZConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfigurationExtension *)soap_instantiate_tt__PTZConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, tag ? tag : "tt:PTZConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ZoomLimits))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ZoomLimits(struct soap *soap, const char *tag, int id, tt__ZoomLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ZoomLimits, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ZoomLimits ? type : NULL);
}

SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTott__ZoomLimits(struct soap *soap, const char *tag, tt__ZoomLimits **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ZoomLimits **)soap_malloc(soap, sizeof(tt__ZoomLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ZoomLimits *)soap_instantiate_tt__ZoomLimits(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PanTiltLimits))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, int id, tt__PanTiltLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PanTiltLimits, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PanTiltLimits ? type : NULL);
}

SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, tt__PanTiltLimits **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PanTiltLimits **)soap_malloc(soap, sizeof(tt__PanTiltLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PanTiltLimits *)soap_instantiate_tt__PanTiltLimits(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNodeExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, int id, tt__PTZNodeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNodeExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZNodeExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZNodeExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, tt__PTZNodeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZNodeExtension **)soap_malloc(soap, sizeof(tt__PTZNodeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZNodeExtension *)soap_instantiate_tt__PTZNodeExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZNodeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(tt__PTZNodeExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZNodeExtension(soap, tag ? tag : "tt:PTZNodeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZNodeExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DigitalIdleState(struct soap *soap, tt__DigitalIdleState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__DigitalIdleState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DigitalIdleState(struct soap *soap, const char *tag, int id, tt__DigitalIdleState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DigitalIdleState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DigitalIdleState(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__DigitalIdleState ** SOAP_FMAC4 soap_in_PointerTott__DigitalIdleState(struct soap *soap, const char *tag, tt__DigitalIdleState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DigitalIdleState **)soap_malloc(soap, sizeof(tt__DigitalIdleState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DigitalIdleState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__DigitalIdleState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DigitalIdleState, sizeof(tt__DigitalIdleState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DigitalIdleState(struct soap *soap, tt__DigitalIdleState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DigitalIdleState(soap, tag ? tag : "tt:DigitalIdleState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DigitalIdleState ** SOAP_FMAC4 soap_get_PointerTott__DigitalIdleState(struct soap *soap, tt__DigitalIdleState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DigitalIdleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceExtension ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceExtension **)soap_malloc(soap, sizeof(tt__NetworkInterfaceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceExtension *)soap_instantiate_tt__NetworkInterfaceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(tt__NetworkInterfaceExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, tag ? tag : "tt:NetworkInterfaceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterface))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, tt__IPv6NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv6NetworkInterface ? type : NULL);
}

SOAP_FMAC3 tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, tt__IPv6NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6NetworkInterface **)soap_malloc(soap, sizeof(tt__IPv6NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6NetworkInterface *)soap_instantiate_tt__IPv6NetworkInterface(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv6NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(tt__IPv6NetworkInterface), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, tag ? tag : "tt:IPv6NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterface))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, tt__IPv4NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv4NetworkInterface ? type : NULL);
}

SOAP_FMAC3 tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, tt__IPv4NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv4NetworkInterface **)soap_malloc(soap, sizeof(tt__IPv4NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv4NetworkInterface *)soap_instantiate_tt__IPv4NetworkInterface(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv4NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(tt__IPv4NetworkInterface), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, tag ? tag : "tt:IPv4NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceLink))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceLink, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceLink ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, tt__NetworkInterfaceLink **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceLink **)soap_malloc(soap, sizeof(tt__NetworkInterfaceLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceLink *)soap_instantiate_tt__NetworkInterfaceLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(tt__NetworkInterfaceLink), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, tag ? tag : "tt:NetworkInterfaceLink", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceInfo ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, tt__NetworkInterfaceInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceInfo **)soap_malloc(soap, sizeof(tt__NetworkInterfaceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceInfo *)soap_instantiate_tt__NetworkInterfaceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(tt__NetworkInterfaceInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, tag ? tag : "tt:NetworkInterfaceInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoOutputExtension(struct soap *soap, tt__VideoOutputExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoOutputExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoOutputExtension(struct soap *soap, const char *tag, int id, tt__VideoOutputExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoOutputExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoOutputExtension ? type : NULL);
}

SOAP_FMAC3 tt__VideoOutputExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoOutputExtension(struct soap *soap, const char *tag, tt__VideoOutputExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoOutputExtension **)soap_malloc(soap, sizeof(tt__VideoOutputExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoOutputExtension *)soap_instantiate_tt__VideoOutputExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoOutputExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutputExtension, sizeof(tt__VideoOutputExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoOutputExtension(struct soap *soap, tt__VideoOutputExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoOutputExtension(soap, tag ? tag : "tt:VideoOutputExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoOutputExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoOutputExtension(struct soap *soap, tt__VideoOutputExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoOutputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Layout(struct soap *soap, tt__Layout *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Layout))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Layout(struct soap *soap, const char *tag, int id, tt__Layout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Layout, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Layout ? type : NULL);
}

SOAP_FMAC3 tt__Layout ** SOAP_FMAC4 soap_in_PointerTott__Layout(struct soap *soap, const char *tag, tt__Layout **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Layout **)soap_malloc(soap, sizeof(tt__Layout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Layout *)soap_instantiate_tt__Layout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Layout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Layout, sizeof(tt__Layout), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Layout(struct soap *soap, tt__Layout *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Layout(soap, tag ? tag : "tt:Layout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Layout ** SOAP_FMAC4 soap_get_PointerTott__Layout(struct soap *soap, tt__Layout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Layout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, int id, tt__MetadataConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MetadataConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, tt__MetadataConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataConfigurationExtension **)soap_malloc(soap, sizeof(tt__MetadataConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataConfigurationExtension *)soap_instantiate_tt__MetadataConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MetadataConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(tt__MetadataConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfigurationExtension(soap, tag ? tag : "tt:MetadataConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventSubscription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventSubscription(struct soap *soap, const char *tag, int id, tt__EventSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventSubscription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EventSubscription ? type : NULL);
}

SOAP_FMAC3 tt__EventSubscription ** SOAP_FMAC4 soap_in_PointerTott__EventSubscription(struct soap *soap, const char *tag, tt__EventSubscription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EventSubscription **)soap_malloc(soap, sizeof(tt__EventSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EventSubscription *)soap_instantiate_tt__EventSubscription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EventSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventSubscription, sizeof(tt__EventSubscription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventSubscription(soap, tag ? tag : "tt:EventSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EventSubscription ** SOAP_FMAC4 soap_get_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZFilter(struct soap *soap, const char *tag, int id, tt__PTZFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZFilter ? type : NULL);
}

SOAP_FMAC3 tt__PTZFilter ** SOAP_FMAC4 soap_in_PointerTott__PTZFilter(struct soap *soap, const char *tag, tt__PTZFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZFilter **)soap_malloc(soap, sizeof(tt__PTZFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZFilter *)soap_instantiate_tt__PTZFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZFilter, sizeof(tt__PTZFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZFilter(soap, tag ? tag : "tt:PTZFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZFilter ** SOAP_FMAC4 soap_get_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, tt__RuleEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RuleEngineConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, tt__RuleEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RuleEngineConfiguration **)soap_malloc(soap, sizeof(tt__RuleEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RuleEngineConfiguration *)soap_instantiate_tt__RuleEngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RuleEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(tt__RuleEngineConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RuleEngineConfiguration(soap, tag ? tag : "tt:RuleEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, tt__AnalyticsEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineConfiguration **)soap_malloc(soap, sizeof(tt__AnalyticsEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineConfiguration *)soap_instantiate_tt__AnalyticsEngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(tt__AnalyticsEngineConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, tag ? tag : "tt:AnalyticsEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl2(struct soap *soap, tt__VideoRateControl2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl2(struct soap *soap, const char *tag, int id, tt__VideoRateControl2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoRateControl2 ? type : NULL);
}

SOAP_FMAC3 tt__VideoRateControl2 ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl2(struct soap *soap, const char *tag, tt__VideoRateControl2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoRateControl2 **)soap_malloc(soap, sizeof(tt__VideoRateControl2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoRateControl2 *)soap_instantiate_tt__VideoRateControl2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoRateControl2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl2, sizeof(tt__VideoRateControl2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl2(struct soap *soap, tt__VideoRateControl2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoRateControl2(soap, tag ? tag : "tt:VideoRateControl2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoRateControl2 ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl2(struct soap *soap, tt__VideoRateControl2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MulticastConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, int id, tt__MulticastConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MulticastConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MulticastConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__MulticastConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, tt__MulticastConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MulticastConfiguration **)soap_malloc(soap, sizeof(tt__MulticastConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MulticastConfiguration *)soap_instantiate_tt__MulticastConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MulticastConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(tt__MulticastConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MulticastConfiguration(soap, tag ? tag : "tt:MulticastConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MulticastConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Configuration(struct soap *soap, const char *tag, int id, tt__H264Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__H264Configuration ? type : NULL);
}

SOAP_FMAC3 tt__H264Configuration ** SOAP_FMAC4 soap_in_PointerTott__H264Configuration(struct soap *soap, const char *tag, tt__H264Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__H264Configuration **)soap_malloc(soap, sizeof(tt__H264Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__H264Configuration *)soap_instantiate_tt__H264Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__H264Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Configuration(soap, tag ? tag : "tt:H264Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__H264Configuration ** SOAP_FMAC4 soap_get_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, int id, tt__Mpeg4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Mpeg4Configuration ? type : NULL);
}

SOAP_FMAC3 tt__Mpeg4Configuration ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, tt__Mpeg4Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Mpeg4Configuration **)soap_malloc(soap, sizeof(tt__Mpeg4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Mpeg4Configuration *)soap_instantiate_tt__Mpeg4Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Mpeg4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Configuration(soap, tag ? tag : "tt:Mpeg4Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Mpeg4Configuration ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl(struct soap *soap, const char *tag, int id, tt__VideoRateControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoRateControl ? type : NULL);
}

SOAP_FMAC3 tt__VideoRateControl ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl(struct soap *soap, const char *tag, tt__VideoRateControl **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoRateControl **)soap_malloc(soap, sizeof(tt__VideoRateControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoRateControl *)soap_instantiate_tt__VideoRateControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoRateControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoRateControl(soap, tag ? tag : "tt:VideoRateControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoRateControl ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, int id, tt__VideoSourceConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfigurationExtension **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfigurationExtension *)soap_instantiate_tt__VideoSourceConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(tt__VideoSourceConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, tag ? tag : "tt:VideoSourceConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangle))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangle(struct soap *soap, const char *tag, int id, tt__IntRectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangle, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IntRectangle ? type : NULL);
}

SOAP_FMAC3 tt__IntRectangle ** SOAP_FMAC4 soap_in_PointerTott__IntRectangle(struct soap *soap, const char *tag, tt__IntRectangle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntRectangle **)soap_malloc(soap, sizeof(tt__IntRectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntRectangle *)soap_instantiate_tt__IntRectangle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IntRectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangle, sizeof(tt__IntRectangle), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRectangle(soap, tag ? tag : "tt:IntRectangle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntRectangle ** SOAP_FMAC4 soap_get_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, int id, tt__VideoSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSourceExtension ? type : NULL);
}

SOAP_FMAC3 tt__VideoSourceExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, tt__VideoSourceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceExtension **)soap_malloc(soap, sizeof(tt__VideoSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceExtension *)soap_instantiate_tt__VideoSourceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(tt__VideoSourceExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceExtension(soap, tag ? tag : "tt:VideoSourceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings(struct soap *soap, const char *tag, int id, tt__ImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettings ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettings ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings(struct soap *soap, const char *tag, tt__ImagingSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettings **)soap_malloc(soap, sizeof(tt__ImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettings *)soap_instantiate_tt__ImagingSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings, sizeof(tt__ImagingSettings), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettings(soap, tag ? tag : "tt:ImagingSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettings ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageDescription(struct soap *soap, tt__MessageDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageDescription(struct soap *soap, const char *tag, int id, tt__MessageDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageDescription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MessageDescription ? type : NULL);
}

SOAP_FMAC3 tt__MessageDescription ** SOAP_FMAC4 soap_in_PointerTott__MessageDescription(struct soap *soap, const char *tag, tt__MessageDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MessageDescription **)soap_malloc(soap, sizeof(tt__MessageDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MessageDescription *)soap_instantiate_tt__MessageDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MessageDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageDescription, sizeof(tt__MessageDescription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageDescription(struct soap *soap, tt__MessageDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MessageDescription(soap, tag ? tag : "tt:MessageDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MessageDescription ** SOAP_FMAC4 soap_get_PointerTott__MessageDescription(struct soap *soap, tt__MessageDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ServiceNameType(struct soap *soap, wsa__ServiceNameType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ServiceNameType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, int id, wsa__ServiceNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ServiceNameType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsa__ServiceNameType ? type : NULL);
}

SOAP_FMAC3 wsa__ServiceNameType ** SOAP_FMAC4 soap_in_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, wsa__ServiceNameType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsa__ServiceNameType **)soap_malloc(soap, sizeof(wsa__ServiceNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsa__ServiceNameType *)soap_instantiate_wsa__ServiceNameType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsa__ServiceNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ServiceNameType, sizeof(wsa__ServiceNameType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ServiceNameType(struct soap *soap, wsa__ServiceNameType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__ServiceNameType(soap, tag ? tag : "wsa:ServiceNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsa__ServiceNameType ** SOAP_FMAC4 soap_get_PointerTowsa__ServiceNameType(struct soap *soap, wsa__ServiceNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__AttributedQName(struct soap *soap, wsa__AttributedQName *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__AttributedQName))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__AttributedQName(struct soap *soap, const char *tag, int id, wsa__AttributedQName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__AttributedQName, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsa__AttributedQName ? type : NULL);
}

SOAP_FMAC3 wsa__AttributedQName ** SOAP_FMAC4 soap_in_PointerTowsa__AttributedQName(struct soap *soap, const char *tag, wsa__AttributedQName **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsa__AttributedQName **)soap_malloc(soap, sizeof(wsa__AttributedQName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsa__AttributedQName *)soap_instantiate_wsa__AttributedQName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsa__AttributedQName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__AttributedQName, sizeof(wsa__AttributedQName), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__AttributedQName(struct soap *soap, wsa__AttributedQName *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__AttributedQName(soap, tag ? tag : "wsa:AttributedQName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsa__AttributedQName ** SOAP_FMAC4 soap_get_PointerTowsa__AttributedQName(struct soap *soap, wsa__AttributedQName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__AttributedQName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferenceParametersType(struct soap *soap, wsa__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferenceParametersType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, wsa__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsa__ReferenceParametersType ? type : NULL);
}

SOAP_FMAC3 wsa__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, wsa__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsa__ReferenceParametersType **)soap_malloc(soap, sizeof(wsa__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsa__ReferenceParametersType *)soap_instantiate_wsa__ReferenceParametersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsa__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(wsa__ReferenceParametersType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferenceParametersType(struct soap *soap, wsa__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, tag ? tag : "wsa:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsa__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferenceParametersType(struct soap *soap, wsa__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferencePropertiesType(struct soap *soap, wsa__ReferencePropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferencePropertiesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, wsa__ReferencePropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferencePropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsa__ReferencePropertiesType ? type : NULL);
}

SOAP_FMAC3 wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, wsa__ReferencePropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsa__ReferencePropertiesType **)soap_malloc(soap, sizeof(wsa__ReferencePropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsa__ReferencePropertiesType *)soap_instantiate_wsa__ReferencePropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsa__ReferencePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(wsa__ReferencePropertiesType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferencePropertiesType(struct soap *soap, wsa__ReferencePropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, tag ? tag : "wsa:ReferencePropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferencePropertiesType(struct soap *soap, wsa__ReferencePropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__AttributedURI(struct soap *soap, wsa__AttributedURI *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__AttributedURI))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__AttributedURI(struct soap *soap, const char *tag, int id, wsa__AttributedURI *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__AttributedURI, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsa__AttributedURI ? type : NULL);
}

SOAP_FMAC3 wsa__AttributedURI ** SOAP_FMAC4 soap_in_PointerTowsa__AttributedURI(struct soap *soap, const char *tag, wsa__AttributedURI **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsa__AttributedURI **)soap_malloc(soap, sizeof(wsa__AttributedURI *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsa__AttributedURI *)soap_instantiate_wsa__AttributedURI(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsa__AttributedURI **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__AttributedURI, sizeof(wsa__AttributedURI), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__AttributedURI(struct soap *soap, wsa__AttributedURI *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__AttributedURI(soap, tag ? tag : "wsa:AttributedURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsa__AttributedURI ** SOAP_FMAC4 soap_get_PointerTowsa__AttributedURI(struct soap *soap, wsa__AttributedURI **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__AttributedURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_xsd__base64Binary, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xsd__base64Binary ? type : NULL);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsd__SigType(struct soap *soap, wsd__SigType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsd__SigType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsd__SigType(struct soap *soap, const char *tag, int id, wsd__SigType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsd__SigType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsd__SigType ? type : NULL);
}

SOAP_FMAC3 wsd__SigType ** SOAP_FMAC4 soap_in_PointerTowsd__SigType(struct soap *soap, const char *tag, wsd__SigType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsd__SigType **)soap_malloc(soap, sizeof(wsd__SigType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsd__SigType *)soap_instantiate_wsd__SigType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsd__SigType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsd__SigType, sizeof(wsd__SigType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsd__SigType(struct soap *soap, wsd__SigType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsd__SigType(soap, tag ? tag : "wsd:SigType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsd__SigType ** SOAP_FMAC4 soap_get_PointerTowsd__SigType(struct soap *soap, wsd__SigType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsd__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsd__ResolveMatchType(struct soap *soap, wsd__ResolveMatchType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsd__ResolveMatchType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsd__ResolveMatchType(struct soap *soap, const char *tag, int id, wsd__ResolveMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsd__ResolveMatchType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsd__ResolveMatchType ? type : NULL);
}

SOAP_FMAC3 wsd__ResolveMatchType ** SOAP_FMAC4 soap_in_PointerTowsd__ResolveMatchType(struct soap *soap, const char *tag, wsd__ResolveMatchType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsd__ResolveMatchType **)soap_malloc(soap, sizeof(wsd__ResolveMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsd__ResolveMatchType *)soap_instantiate_wsd__ResolveMatchType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsd__ResolveMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsd__ResolveMatchType, sizeof(wsd__ResolveMatchType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsd__ResolveMatchType(struct soap *soap, wsd__ResolveMatchType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsd__ResolveMatchType(soap, tag ? tag : "wsd:ResolveMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsd__ResolveMatchType ** SOAP_FMAC4 soap_get_PointerTowsd__ResolveMatchType(struct soap *soap, wsd__ResolveMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsd__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsd__ProbeMatchType(struct soap *soap, wsd__ProbeMatchType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsd__ProbeMatchType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsd__ProbeMatchType(struct soap *soap, const char *tag, int id, wsd__ProbeMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsd__ProbeMatchType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsd__ProbeMatchType ? type : NULL);
}

SOAP_FMAC3 wsd__ProbeMatchType ** SOAP_FMAC4 soap_in_PointerTowsd__ProbeMatchType(struct soap *soap, const char *tag, wsd__ProbeMatchType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsd__ProbeMatchType **)soap_malloc(soap, sizeof(wsd__ProbeMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsd__ProbeMatchType *)soap_instantiate_wsd__ProbeMatchType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsd__ProbeMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsd__ProbeMatchType, sizeof(wsd__ProbeMatchType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsd__ProbeMatchType(struct soap *soap, wsd__ProbeMatchType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsd__ProbeMatchType(soap, tag ? tag : "wsd:ProbeMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsd__ProbeMatchType ** SOAP_FMAC4 soap_get_PointerTowsd__ProbeMatchType(struct soap *soap, wsd__ProbeMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsd__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsd__UriListType(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsd__UriListType))
		soap_serialize_wsd__UriListType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsd__UriListType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsd__UriListType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsd__UriListType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowsd__UriListType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsd__UriListType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsd__UriListType, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsd__UriListType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsd__UriListType(soap, tag ? tag : "wsd:UriListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowsd__UriListType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsd__UriListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsd__ScopesType(struct soap *soap, wsd__ScopesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsd__ScopesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsd__ScopesType(struct soap *soap, const char *tag, int id, wsd__ScopesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsd__ScopesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsd__ScopesType ? type : NULL);
}

SOAP_FMAC3 wsd__ScopesType ** SOAP_FMAC4 soap_in_PointerTowsd__ScopesType(struct soap *soap, const char *tag, wsd__ScopesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsd__ScopesType **)soap_malloc(soap, sizeof(wsd__ScopesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsd__ScopesType *)soap_instantiate_wsd__ScopesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsd__ScopesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsd__ScopesType, sizeof(wsd__ScopesType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsd__ScopesType(struct soap *soap, wsd__ScopesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsd__ScopesType(soap, tag ? tag : "wsd:ScopesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsd__ScopesType ** SOAP_FMAC4 soap_get_PointerTowsd__ScopesType(struct soap *soap, wsd__ScopesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsd__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsd__QNameListType(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsd__QNameListType))
		soap_serialize_wsd__QNameListType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsd__QNameListType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsd__QNameListType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsd__QNameListType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowsd__QNameListType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsd__QNameListType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsd__QNameListType, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsd__QNameListType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsd__QNameListType(soap, tag ? tag : "wsd:QNameListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowsd__QNameListType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsd__QNameListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__EndpointReferenceType(struct soap *soap, wsa__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__EndpointReferenceType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__EndpointReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsa__EndpointReferenceType ? type : NULL);
}

SOAP_FMAC3 wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa__EndpointReferenceType(struct soap *soap, const char *tag, wsa__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsa__EndpointReferenceType *)soap_instantiate_wsa__EndpointReferenceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(wsa__EndpointReferenceType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__EndpointReferenceType(struct soap *soap, wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__EndpointReferenceType(soap, tag ? tag : "wsa:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa__EndpointReferenceType(struct soap *soap, wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy ? type : NULL);
}

SOAP_FMAC3 _tev__CreatePullPointSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, _tev__CreatePullPointSubscription_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tev__CreatePullPointSubscription_SubscriptionPolicy **)soap_malloc(soap, sizeof(_tev__CreatePullPointSubscription_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tev__CreatePullPointSubscription_SubscriptionPolicy *)soap_instantiate__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tev__CreatePullPointSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(_tev__CreatePullPointSubscription_SubscriptionPolicy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag ? tag : "tev:CreatePullPointSubscription-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tev__CreatePullPointSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, _tev__CreatePullPointSubscription_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotev__Capabilities(struct soap *soap, tev__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tev__Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotev__Capabilities(struct soap *soap, const char *tag, int id, tev__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tev__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tev__Capabilities ? type : NULL);
}

SOAP_FMAC3 tev__Capabilities ** SOAP_FMAC4 soap_in_PointerTotev__Capabilities(struct soap *soap, const char *tag, tev__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tev__Capabilities **)soap_malloc(soap, sizeof(tev__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tev__Capabilities *)soap_instantiate_tev__Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tev__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tev__Capabilities, sizeof(tev__Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotev__Capabilities(struct soap *soap, tev__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotev__Capabilities(soap, tag ? tag : "tev:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tev__Capabilities ** SOAP_FMAC4 soap_get_PointerTotev__Capabilities(struct soap *soap, tev__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotev__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__Documentation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__Documentation(struct soap *soap, const char *tag, int id, wstop__Documentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__Documentation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__Documentation ? type : NULL);
}

SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_in_PointerTowstop__Documentation(struct soap *soap, const char *tag, wstop__Documentation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__Documentation **)soap_malloc(soap, sizeof(wstop__Documentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__Documentation *)soap_instantiate_wstop__Documentation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_get_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause ? type : NULL);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_FaultCause *)soap_instantiate__wsrfbf__BaseFaultType_FaultCause(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsrfbf__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(_wsrfbf__BaseFaultType_FaultCause), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xml__lang(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xml__lang))
		soap_serialize__xml__lang(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xml__lang(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xml__lang, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__xml__lang(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTo_xml__lang(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xml__lang(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xml__lang, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xml__lang(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTo_xml__lang(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xml__lang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode ? type : NULL);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_ErrorCode *)soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsrfbf__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(_wsrfbf__BaseFaultType_ErrorCode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger))
		soap_serialize_xsd__nonNegativeInteger(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__nonNegativeInteger, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__nonNegativeInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy ? type : NULL);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, _wsnt__Subscribe_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(_wsnt__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__Subscribe_SubscriptionPolicy *)soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(_wsnt__Subscribe_SubscriptionPolicy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType))
		soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, tag ? tag : "wsnt:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscriptionPolicyType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, wsnt__SubscriptionPolicyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscriptionPolicyType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__SubscriptionPolicyType ? type : NULL);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, wsnt__SubscriptionPolicyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__SubscriptionPolicyType **)soap_malloc(soap, sizeof(wsnt__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__SubscriptionPolicyType *)soap_instantiate_wsnt__SubscriptionPolicyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(wsnt__SubscriptionPolicyType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicSetType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, int id, wstop__TopicSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicSetType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__TopicSetType ? type : NULL);
}

SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, wstop__TopicSetType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicSetType **)soap_malloc(soap, sizeof(wstop__TopicSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__TopicSetType *)soap_instantiate_wstop__TopicSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionTypeCustom(struct soap *soap, wsnt__TopicExpressionTypeCustom *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionTypeCustom))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionTypeCustom(struct soap *soap, const char *tag, int id, wsnt__TopicExpressionTypeCustom *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionTypeCustom, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__TopicExpressionTypeCustom ? type : NULL);
}

SOAP_FMAC3 wsnt__TopicExpressionTypeCustom ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionTypeCustom(struct soap *soap, const char *tag, wsnt__TopicExpressionTypeCustom **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__TopicExpressionTypeCustom **)soap_malloc(soap, sizeof(wsnt__TopicExpressionTypeCustom *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__TopicExpressionTypeCustom *)soap_instantiate_wsnt__TopicExpressionTypeCustom(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__TopicExpressionTypeCustom **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionTypeCustom, sizeof(wsnt__TopicExpressionTypeCustom), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionTypeCustom(struct soap *soap, wsnt__TopicExpressionTypeCustom *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicExpressionTypeCustom(soap, tag ? tag : "wsnt:TopicExpressionTypeCustom", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__TopicExpressionTypeCustom ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionTypeCustom(struct soap *soap, wsnt__TopicExpressionTypeCustom **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionTypeCustom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PropertyOperation(struct soap *soap, tt__PropertyOperation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__PropertyOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PropertyOperation(struct soap *soap, const char *tag, int id, tt__PropertyOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PropertyOperation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PropertyOperation(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__PropertyOperation ** SOAP_FMAC4 soap_in_PointerTott__PropertyOperation(struct soap *soap, const char *tag, tt__PropertyOperation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PropertyOperation **)soap_malloc(soap, sizeof(tt__PropertyOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PropertyOperation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__PropertyOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PropertyOperation, sizeof(tt__PropertyOperation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PropertyOperation(struct soap *soap, tt__PropertyOperation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PropertyOperation(soap, tag ? tag : "tt:PropertyOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PropertyOperation ** SOAP_FMAC4 soap_get_PointerTott__PropertyOperation(struct soap *soap, tt__PropertyOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageExtension(struct soap *soap, const char *tag, int id, tt__MessageExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MessageExtension ? type : NULL);
}

SOAP_FMAC3 tt__MessageExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageExtension(struct soap *soap, const char *tag, tt__MessageExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MessageExtension **)soap_malloc(soap, sizeof(tt__MessageExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MessageExtension *)soap_instantiate_tt__MessageExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MessageExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageExtension, sizeof(tt__MessageExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MessageExtension(soap, tag ? tag : "tt:MessageExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MessageExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocalOrientation(struct soap *soap, tt__LocalOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocalOrientation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocalOrientation(struct soap *soap, const char *tag, int id, tt__LocalOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocalOrientation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LocalOrientation ? type : NULL);
}

SOAP_FMAC3 tt__LocalOrientation ** SOAP_FMAC4 soap_in_PointerTott__LocalOrientation(struct soap *soap, const char *tag, tt__LocalOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LocalOrientation **)soap_malloc(soap, sizeof(tt__LocalOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LocalOrientation *)soap_instantiate_tt__LocalOrientation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LocalOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocalOrientation, sizeof(tt__LocalOrientation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocalOrientation(struct soap *soap, tt__LocalOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocalOrientation(soap, tag ? tag : "tt:LocalOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LocalOrientation ** SOAP_FMAC4 soap_get_PointerTott__LocalOrientation(struct soap *soap, tt__LocalOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocalOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocalLocation(struct soap *soap, tt__LocalLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocalLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocalLocation(struct soap *soap, const char *tag, int id, tt__LocalLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocalLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LocalLocation ? type : NULL);
}

SOAP_FMAC3 tt__LocalLocation ** SOAP_FMAC4 soap_in_PointerTott__LocalLocation(struct soap *soap, const char *tag, tt__LocalLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LocalLocation **)soap_malloc(soap, sizeof(tt__LocalLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LocalLocation *)soap_instantiate_tt__LocalLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LocalLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocalLocation, sizeof(tt__LocalLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocalLocation(struct soap *soap, tt__LocalLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocalLocation(soap, tag ? tag : "tt:LocalLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LocalLocation ** SOAP_FMAC4 soap_get_PointerTott__LocalLocation(struct soap *soap, tt__LocalLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocalLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GeoOrientation(struct soap *soap, tt__GeoOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GeoOrientation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GeoOrientation(struct soap *soap, const char *tag, int id, tt__GeoOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GeoOrientation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__GeoOrientation ? type : NULL);
}

SOAP_FMAC3 tt__GeoOrientation ** SOAP_FMAC4 soap_in_PointerTott__GeoOrientation(struct soap *soap, const char *tag, tt__GeoOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__GeoOrientation **)soap_malloc(soap, sizeof(tt__GeoOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__GeoOrientation *)soap_instantiate_tt__GeoOrientation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__GeoOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoOrientation, sizeof(tt__GeoOrientation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GeoOrientation(struct soap *soap, tt__GeoOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GeoOrientation(soap, tag ? tag : "tt:GeoOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__GeoOrientation ** SOAP_FMAC4 soap_get_PointerTott__GeoOrientation(struct soap *soap, tt__GeoOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GeoOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GeoLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GeoLocation(struct soap *soap, const char *tag, int id, tt__GeoLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GeoLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__GeoLocation ? type : NULL);
}

SOAP_FMAC3 tt__GeoLocation ** SOAP_FMAC4 soap_in_PointerTott__GeoLocation(struct soap *soap, const char *tag, tt__GeoLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__GeoLocation **)soap_malloc(soap, sizeof(tt__GeoLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__GeoLocation *)soap_instantiate_tt__GeoLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__GeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoLocation, sizeof(tt__GeoLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GeoLocation(soap, tag ? tag : "tt:GeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__GeoLocation ** SOAP_FMAC4 soap_get_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodouble(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TransformationExtension(struct soap *soap, tt__TransformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TransformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TransformationExtension(struct soap *soap, const char *tag, int id, tt__TransformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TransformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__TransformationExtension ? type : NULL);
}

SOAP_FMAC3 tt__TransformationExtension ** SOAP_FMAC4 soap_in_PointerTott__TransformationExtension(struct soap *soap, const char *tag, tt__TransformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TransformationExtension **)soap_malloc(soap, sizeof(tt__TransformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TransformationExtension *)soap_instantiate_tt__TransformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__TransformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TransformationExtension, sizeof(tt__TransformationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TransformationExtension(struct soap *soap, tt__TransformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TransformationExtension(soap, tag ? tag : "tt:TransformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TransformationExtension ** SOAP_FMAC4 soap_get_PointerTott__TransformationExtension(struct soap *soap, tt__TransformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveStatus(struct soap *soap, tt__MoveStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__MoveStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveStatus(struct soap *soap, const char *tag, int id, tt__MoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MoveStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MoveStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__MoveStatus ** SOAP_FMAC4 soap_in_PointerTott__MoveStatus(struct soap *soap, const char *tag, tt__MoveStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MoveStatus **)soap_malloc(soap, sizeof(tt__MoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MoveStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__MoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveStatus, sizeof(tt__MoveStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveStatus(struct soap *soap, tt__MoveStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MoveStatus(soap, tag ? tag : "tt:MoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MoveStatus ** SOAP_FMAC4 soap_get_PointerTott__MoveStatus(struct soap *soap, tt__MoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZMoveStatus(struct soap *soap, tt__PTZMoveStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZMoveStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZMoveStatus(struct soap *soap, const char *tag, int id, tt__PTZMoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZMoveStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZMoveStatus ? type : NULL);
}

SOAP_FMAC3 tt__PTZMoveStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZMoveStatus(struct soap *soap, const char *tag, tt__PTZMoveStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZMoveStatus **)soap_malloc(soap, sizeof(tt__PTZMoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZMoveStatus *)soap_instantiate_tt__PTZMoveStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZMoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(tt__PTZMoveStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZMoveStatus(struct soap *soap, tt__PTZMoveStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZMoveStatus(soap, tag ? tag : "tt:PTZMoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZMoveStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZMoveStatus(struct soap *soap, tt__PTZMoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StorageReferencePathExtension(struct soap *soap, tt__StorageReferencePathExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StorageReferencePathExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StorageReferencePathExtension(struct soap *soap, const char *tag, int id, tt__StorageReferencePathExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StorageReferencePathExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__StorageReferencePathExtension ? type : NULL);
}

SOAP_FMAC3 tt__StorageReferencePathExtension ** SOAP_FMAC4 soap_in_PointerTott__StorageReferencePathExtension(struct soap *soap, const char *tag, tt__StorageReferencePathExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__StorageReferencePathExtension **)soap_malloc(soap, sizeof(tt__StorageReferencePathExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__StorageReferencePathExtension *)soap_instantiate_tt__StorageReferencePathExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__StorageReferencePathExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StorageReferencePathExtension, sizeof(tt__StorageReferencePathExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StorageReferencePathExtension(struct soap *soap, tt__StorageReferencePathExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StorageReferencePathExtension(soap, tag ? tag : "tt:StorageReferencePathExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__StorageReferencePathExtension ** SOAP_FMAC4 soap_get_PointerTott__StorageReferencePathExtension(struct soap *soap, tt__StorageReferencePathExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StorageReferencePathExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, tt__ArrayOfFileProgressExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ArrayOfFileProgressExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, const char *tag, int id, tt__ArrayOfFileProgressExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ArrayOfFileProgressExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ArrayOfFileProgressExtension ? type : NULL);
}

SOAP_FMAC3 tt__ArrayOfFileProgressExtension ** SOAP_FMAC4 soap_in_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, const char *tag, tt__ArrayOfFileProgressExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ArrayOfFileProgressExtension **)soap_malloc(soap, sizeof(tt__ArrayOfFileProgressExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ArrayOfFileProgressExtension *)soap_instantiate_tt__ArrayOfFileProgressExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ArrayOfFileProgressExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ArrayOfFileProgressExtension, sizeof(tt__ArrayOfFileProgressExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, tt__ArrayOfFileProgressExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ArrayOfFileProgressExtension(soap, tag ? tag : "tt:ArrayOfFileProgressExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ArrayOfFileProgressExtension ** SOAP_FMAC4 soap_get_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, tt__ArrayOfFileProgressExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ArrayOfFileProgressExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FileProgress(struct soap *soap, tt__FileProgress *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FileProgress))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FileProgress(struct soap *soap, const char *tag, int id, tt__FileProgress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FileProgress, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FileProgress ? type : NULL);
}

SOAP_FMAC3 tt__FileProgress ** SOAP_FMAC4 soap_in_PointerTott__FileProgress(struct soap *soap, const char *tag, tt__FileProgress **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FileProgress **)soap_malloc(soap, sizeof(tt__FileProgress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FileProgress *)soap_instantiate_tt__FileProgress(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FileProgress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FileProgress, sizeof(tt__FileProgress), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FileProgress(struct soap *soap, tt__FileProgress *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FileProgress(soap, tag ? tag : "tt:FileProgress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FileProgress ** SOAP_FMAC4 soap_get_PointerTott__FileProgress(struct soap *soap, tt__FileProgress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FileProgress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, tt__OSDConfigurationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, tt__OSDConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDConfigurationOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__OSDConfigurationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDConfigurationOptionsExtension **)soap_malloc(soap, sizeof(tt__OSDConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDConfigurationOptionsExtension *)soap_instantiate_tt__OSDConfigurationOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(tt__OSDConfigurationOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, tt__OSDConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfigurationOptionsExtension(soap, tag ? tag : "tt:OSDConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, tt__OSDConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgOptions(struct soap *soap, tt__OSDImgOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgOptions(struct soap *soap, const char *tag, int id, tt__OSDImgOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDImgOptions ? type : NULL);
}

SOAP_FMAC3 tt__OSDImgOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDImgOptions(struct soap *soap, const char *tag, tt__OSDImgOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDImgOptions **)soap_malloc(soap, sizeof(tt__OSDImgOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDImgOptions *)soap_instantiate_tt__OSDImgOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDImgOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgOptions, sizeof(tt__OSDImgOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgOptions(struct soap *soap, tt__OSDImgOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgOptions(soap, tag ? tag : "tt:OSDImgOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDImgOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDImgOptions(struct soap *soap, tt__OSDImgOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextOptions(struct soap *soap, tt__OSDTextOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextOptions(struct soap *soap, const char *tag, int id, tt__OSDTextOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDTextOptions ? type : NULL);
}

SOAP_FMAC3 tt__OSDTextOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDTextOptions(struct soap *soap, const char *tag, tt__OSDTextOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDTextOptions **)soap_malloc(soap, sizeof(tt__OSDTextOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDTextOptions *)soap_instantiate_tt__OSDTextOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDTextOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextOptions, sizeof(tt__OSDTextOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextOptions(struct soap *soap, tt__OSDTextOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextOptions(soap, tag ? tag : "tt:OSDTextOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDTextOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDTextOptions(struct soap *soap, tt__OSDTextOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MaximumNumberOfOSDs(struct soap *soap, tt__MaximumNumberOfOSDs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MaximumNumberOfOSDs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MaximumNumberOfOSDs(struct soap *soap, const char *tag, int id, tt__MaximumNumberOfOSDs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MaximumNumberOfOSDs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MaximumNumberOfOSDs ? type : NULL);
}

SOAP_FMAC3 tt__MaximumNumberOfOSDs ** SOAP_FMAC4 soap_in_PointerTott__MaximumNumberOfOSDs(struct soap *soap, const char *tag, tt__MaximumNumberOfOSDs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MaximumNumberOfOSDs **)soap_malloc(soap, sizeof(tt__MaximumNumberOfOSDs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MaximumNumberOfOSDs *)soap_instantiate_tt__MaximumNumberOfOSDs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MaximumNumberOfOSDs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(tt__MaximumNumberOfOSDs), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MaximumNumberOfOSDs(struct soap *soap, tt__MaximumNumberOfOSDs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MaximumNumberOfOSDs(soap, tag ? tag : "tt:MaximumNumberOfOSDs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MaximumNumberOfOSDs ** SOAP_FMAC4 soap_get_PointerTott__MaximumNumberOfOSDs(struct soap *soap, tt__MaximumNumberOfOSDs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MaximumNumberOfOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgOptionsExtension(struct soap *soap, tt__OSDImgOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgOptionsExtension(struct soap *soap, const char *tag, int id, tt__OSDImgOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDImgOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDImgOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDImgOptionsExtension(struct soap *soap, const char *tag, tt__OSDImgOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDImgOptionsExtension **)soap_malloc(soap, sizeof(tt__OSDImgOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDImgOptionsExtension *)soap_instantiate_tt__OSDImgOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDImgOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(tt__OSDImgOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgOptionsExtension(struct soap *soap, tt__OSDImgOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgOptionsExtension(soap, tag ? tag : "tt:OSDImgOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDImgOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDImgOptionsExtension(struct soap *soap, tt__OSDImgOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextOptionsExtension(struct soap *soap, tt__OSDTextOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextOptionsExtension(struct soap *soap, const char *tag, int id, tt__OSDTextOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDTextOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDTextOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDTextOptionsExtension(struct soap *soap, const char *tag, tt__OSDTextOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDTextOptionsExtension **)soap_malloc(soap, sizeof(tt__OSDTextOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDTextOptionsExtension *)soap_instantiate_tt__OSDTextOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDTextOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(tt__OSDTextOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextOptionsExtension(struct soap *soap, tt__OSDTextOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextOptionsExtension(soap, tag ? tag : "tt:OSDTextOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDTextOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDTextOptionsExtension(struct soap *soap, tt__OSDTextOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDColorOptions(struct soap *soap, tt__OSDColorOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDColorOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDColorOptions(struct soap *soap, const char *tag, int id, tt__OSDColorOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDColorOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDColorOptions ? type : NULL);
}

SOAP_FMAC3 tt__OSDColorOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDColorOptions(struct soap *soap, const char *tag, tt__OSDColorOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDColorOptions **)soap_malloc(soap, sizeof(tt__OSDColorOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDColorOptions *)soap_instantiate_tt__OSDColorOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDColorOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColorOptions, sizeof(tt__OSDColorOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDColorOptions(struct soap *soap, tt__OSDColorOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDColorOptions(soap, tag ? tag : "tt:OSDColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDColorOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDColorOptions(struct soap *soap, tt__OSDColorOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDColorOptionsExtension(struct soap *soap, tt__OSDColorOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDColorOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDColorOptionsExtension(struct soap *soap, const char *tag, int id, tt__OSDColorOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDColorOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDColorOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDColorOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDColorOptionsExtension(struct soap *soap, const char *tag, tt__OSDColorOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDColorOptionsExtension **)soap_malloc(soap, sizeof(tt__OSDColorOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDColorOptionsExtension *)soap_instantiate_tt__OSDColorOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDColorOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(tt__OSDColorOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDColorOptionsExtension(struct soap *soap, tt__OSDColorOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDColorOptionsExtension(soap, tag ? tag : "tt:OSDColorOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDColorOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDColorOptionsExtension(struct soap *soap, tt__OSDColorOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDColorOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorOptions(struct soap *soap, tt__ColorOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorOptions(struct soap *soap, const char *tag, int id, tt__ColorOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ColorOptions ? type : NULL);
}

SOAP_FMAC3 tt__ColorOptions ** SOAP_FMAC4 soap_in_PointerTott__ColorOptions(struct soap *soap, const char *tag, tt__ColorOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ColorOptions **)soap_malloc(soap, sizeof(tt__ColorOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ColorOptions *)soap_instantiate_tt__ColorOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ColorOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorOptions, sizeof(tt__ColorOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorOptions(struct soap *soap, tt__ColorOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorOptions(soap, tag ? tag : "tt:ColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ColorOptions ** SOAP_FMAC4 soap_get_PointerTott__ColorOptions(struct soap *soap, tt__ColorOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, std::vector<tt__ColorspaceRange *> *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTott__ColorspaceRange))
		soap_serialize_std__vectorTemplateOfPointerTott__ColorspaceRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const char *tag, int id, std::vector<tt__ColorspaceRange *> *const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTott__ColorspaceRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<tt__ColorspaceRange *> ** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const char *tag, std::vector<tt__ColorspaceRange *> **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<tt__ColorspaceRange *> **)soap_malloc(soap, sizeof(std::vector<tt__ColorspaceRange *> *))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOfPointerTott__ColorspaceRange(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, std::vector<tt__ColorspaceRange *> *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(soap, tag ? tag : "", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<tt__ColorspaceRange *> ** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, std::vector<tt__ColorspaceRange *> **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorspaceRange(struct soap *soap, tt__ColorspaceRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorspaceRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorspaceRange(struct soap *soap, const char *tag, int id, tt__ColorspaceRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorspaceRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ColorspaceRange ? type : NULL);
}

SOAP_FMAC3 tt__ColorspaceRange ** SOAP_FMAC4 soap_in_PointerTott__ColorspaceRange(struct soap *soap, const char *tag, tt__ColorspaceRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ColorspaceRange **)soap_malloc(soap, sizeof(tt__ColorspaceRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ColorspaceRange *)soap_instantiate_tt__ColorspaceRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ColorspaceRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorspaceRange, sizeof(tt__ColorspaceRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorspaceRange(struct soap *soap, tt__ColorspaceRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorspaceRange(soap, tag ? tag : "tt:ColorspaceRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ColorspaceRange ** SOAP_FMAC4 soap_get_PointerTott__ColorspaceRange(struct soap *soap, tt__ColorspaceRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorspaceRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTott__Color(struct soap *soap, std::vector<tt__Color *> *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTott__Color))
		soap_serialize_std__vectorTemplateOfPointerTott__Color(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTott__Color(struct soap *soap, const char *tag, int id, std::vector<tt__Color *> *const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTott__Color(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<tt__Color *> ** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTott__Color(struct soap *soap, const char *tag, std::vector<tt__Color *> **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<tt__Color *> **)soap_malloc(soap, sizeof(std::vector<tt__Color *> *))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOfPointerTott__Color(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTott__Color(struct soap *soap, std::vector<tt__Color *> *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__vectorTemplateOfPointerTott__Color(soap, tag ? tag : "", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<tt__Color *> ** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTott__Color(struct soap *soap, std::vector<tt__Color *> **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTott__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgConfigurationExtension(struct soap *soap, tt__OSDImgConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgConfigurationExtension(struct soap *soap, const char *tag, int id, tt__OSDImgConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDImgConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDImgConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDImgConfigurationExtension(struct soap *soap, const char *tag, tt__OSDImgConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDImgConfigurationExtension **)soap_malloc(soap, sizeof(tt__OSDImgConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDImgConfigurationExtension *)soap_instantiate_tt__OSDImgConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDImgConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(tt__OSDImgConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgConfigurationExtension(struct soap *soap, tt__OSDImgConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgConfigurationExtension(soap, tag ? tag : "tt:OSDImgConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDImgConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDImgConfigurationExtension(struct soap *soap, tt__OSDImgConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextConfigurationExtension(struct soap *soap, tt__OSDTextConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextConfigurationExtension(struct soap *soap, const char *tag, int id, tt__OSDTextConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDTextConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDTextConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDTextConfigurationExtension(struct soap *soap, const char *tag, tt__OSDTextConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDTextConfigurationExtension **)soap_malloc(soap, sizeof(tt__OSDTextConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDTextConfigurationExtension *)soap_instantiate_tt__OSDTextConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDTextConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(tt__OSDTextConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextConfigurationExtension(struct soap *soap, tt__OSDTextConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextConfigurationExtension(soap, tag ? tag : "tt:OSDTextConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDTextConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDTextConfigurationExtension(struct soap *soap, tt__OSDTextConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDColor(struct soap *soap, tt__OSDColor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDColor))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDColor(struct soap *soap, const char *tag, int id, tt__OSDColor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDColor, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDColor ? type : NULL);
}

SOAP_FMAC3 tt__OSDColor ** SOAP_FMAC4 soap_in_PointerTott__OSDColor(struct soap *soap, const char *tag, tt__OSDColor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDColor **)soap_malloc(soap, sizeof(tt__OSDColor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDColor *)soap_instantiate_tt__OSDColor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDColor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColor, sizeof(tt__OSDColor), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDColor(struct soap *soap, tt__OSDColor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDColor(soap, tag ? tag : "tt:OSDColor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDColor ** SOAP_FMAC4 soap_get_PointerTott__OSDColor(struct soap *soap, tt__OSDColor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDColor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Color(struct soap *soap, tt__Color *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Color))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Color(struct soap *soap, const char *tag, int id, tt__Color *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Color, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Color ? type : NULL);
}

SOAP_FMAC3 tt__Color ** SOAP_FMAC4 soap_in_PointerTott__Color(struct soap *soap, const char *tag, tt__Color **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Color **)soap_malloc(soap, sizeof(tt__Color *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Color *)soap_instantiate_tt__Color(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Color **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Color, sizeof(tt__Color), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Color(struct soap *soap, tt__Color *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Color(soap, tag ? tag : "tt:Color", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Color ** SOAP_FMAC4 soap_get_PointerTott__Color(struct soap *soap, tt__Color **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDPosConfigurationExtension(struct soap *soap, tt__OSDPosConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDPosConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDPosConfigurationExtension(struct soap *soap, const char *tag, int id, tt__OSDPosConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDPosConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDPosConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDPosConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDPosConfigurationExtension(struct soap *soap, const char *tag, tt__OSDPosConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDPosConfigurationExtension **)soap_malloc(soap, sizeof(tt__OSDPosConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDPosConfigurationExtension *)soap_instantiate_tt__OSDPosConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDPosConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(tt__OSDPosConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDPosConfigurationExtension(struct soap *soap, tt__OSDPosConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDPosConfigurationExtension(soap, tag ? tag : "tt:OSDPosConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDPosConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDPosConfigurationExtension(struct soap *soap, tt__OSDPosConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDPosConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileStatusExtension(struct soap *soap, tt__ProfileStatusExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileStatusExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileStatusExtension(struct soap *soap, const char *tag, int id, tt__ProfileStatusExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileStatusExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ProfileStatusExtension ? type : NULL);
}

SOAP_FMAC3 tt__ProfileStatusExtension ** SOAP_FMAC4 soap_in_PointerTott__ProfileStatusExtension(struct soap *soap, const char *tag, tt__ProfileStatusExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ProfileStatusExtension **)soap_malloc(soap, sizeof(tt__ProfileStatusExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ProfileStatusExtension *)soap_instantiate_tt__ProfileStatusExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ProfileStatusExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(tt__ProfileStatusExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileStatusExtension(struct soap *soap, tt__ProfileStatusExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileStatusExtension(soap, tag ? tag : "tt:ProfileStatusExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ProfileStatusExtension ** SOAP_FMAC4 soap_get_PointerTott__ProfileStatusExtension(struct soap *soap, tt__ProfileStatusExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ActiveConnection(struct soap *soap, tt__ActiveConnection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ActiveConnection))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ActiveConnection(struct soap *soap, const char *tag, int id, tt__ActiveConnection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ActiveConnection, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ActiveConnection ? type : NULL);
}

SOAP_FMAC3 tt__ActiveConnection ** SOAP_FMAC4 soap_in_PointerTott__ActiveConnection(struct soap *soap, const char *tag, tt__ActiveConnection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ActiveConnection **)soap_malloc(soap, sizeof(tt__ActiveConnection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ActiveConnection *)soap_instantiate_tt__ActiveConnection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ActiveConnection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ActiveConnection, sizeof(tt__ActiveConnection), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ActiveConnection(struct soap *soap, tt__ActiveConnection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ActiveConnection(soap, tag ? tag : "tt:ActiveConnection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ActiveConnection ** SOAP_FMAC4 soap_get_PointerTott__ActiveConnection(struct soap *soap, tt__ActiveConnection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ActiveConnection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioClassDescriptorExtension(struct soap *soap, tt__AudioClassDescriptorExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioClassDescriptorExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioClassDescriptorExtension(struct soap *soap, const char *tag, int id, tt__AudioClassDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioClassDescriptorExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioClassDescriptorExtension ? type : NULL);
}

SOAP_FMAC3 tt__AudioClassDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__AudioClassDescriptorExtension(struct soap *soap, const char *tag, tt__AudioClassDescriptorExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioClassDescriptorExtension **)soap_malloc(soap, sizeof(tt__AudioClassDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioClassDescriptorExtension *)soap_instantiate_tt__AudioClassDescriptorExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioClassDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(tt__AudioClassDescriptorExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioClassDescriptorExtension(struct soap *soap, tt__AudioClassDescriptorExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioClassDescriptorExtension(soap, tag ? tag : "tt:AudioClassDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioClassDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__AudioClassDescriptorExtension(struct soap *soap, tt__AudioClassDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioClassCandidate(struct soap *soap, tt__AudioClassCandidate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioClassCandidate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioClassCandidate(struct soap *soap, const char *tag, int id, tt__AudioClassCandidate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioClassCandidate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioClassCandidate ? type : NULL);
}

SOAP_FMAC3 tt__AudioClassCandidate ** SOAP_FMAC4 soap_in_PointerTott__AudioClassCandidate(struct soap *soap, const char *tag, tt__AudioClassCandidate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioClassCandidate **)soap_malloc(soap, sizeof(tt__AudioClassCandidate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioClassCandidate *)soap_instantiate_tt__AudioClassCandidate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioClassCandidate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioClassCandidate, sizeof(tt__AudioClassCandidate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioClassCandidate(struct soap *soap, tt__AudioClassCandidate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioClassCandidate(soap, tag ? tag : "tt:AudioClassCandidate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioClassCandidate ** SOAP_FMAC4 soap_get_PointerTott__AudioClassCandidate(struct soap *soap, tt__AudioClassCandidate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, tt__ActionEngineEventPayloadExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, int id, tt__ActionEngineEventPayloadExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ActionEngineEventPayloadExtension ? type : NULL);
}

SOAP_FMAC3 tt__ActionEngineEventPayloadExtension ** SOAP_FMAC4 soap_in_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, tt__ActionEngineEventPayloadExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ActionEngineEventPayloadExtension **)soap_malloc(soap, sizeof(tt__ActionEngineEventPayloadExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ActionEngineEventPayloadExtension *)soap_instantiate_tt__ActionEngineEventPayloadExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ActionEngineEventPayloadExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(tt__ActionEngineEventPayloadExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, tt__ActionEngineEventPayloadExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ActionEngineEventPayloadExtension(soap, tag ? tag : "tt:ActionEngineEventPayloadExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ActionEngineEventPayloadExtension ** SOAP_FMAC4 soap_get_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, tt__ActionEngineEventPayloadExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ActionEngineEventPayloadExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Fault))
		soap_serialize_SOAP_ENV__Fault(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Fault(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Fault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Fault, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Fault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Fault ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Fault **)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Fault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Envelope(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Envelope))
		soap_serialize_SOAP_ENV__Envelope(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Envelope(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Envelope, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Envelope(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Envelope(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Envelope(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Envelope(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, tag ? tag : "SOAP-ENV:Envelope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Envelope(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Envelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsState(struct soap *soap, tt__AnalyticsState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsState(struct soap *soap, const char *tag, int id, tt__AnalyticsState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsState, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsState ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsState ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsState(struct soap *soap, const char *tag, tt__AnalyticsState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsState **)soap_malloc(soap, sizeof(tt__AnalyticsState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsState *)soap_instantiate_tt__AnalyticsState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsState, sizeof(tt__AnalyticsState), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsState(struct soap *soap, tt__AnalyticsState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsState(soap, tag ? tag : "tt:AnalyticsState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsState ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsState(struct soap *soap, tt__AnalyticsState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataInputExtension(struct soap *soap, tt__MetadataInputExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataInputExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataInputExtension(struct soap *soap, const char *tag, int id, tt__MetadataInputExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataInputExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MetadataInputExtension ? type : NULL);
}

SOAP_FMAC3 tt__MetadataInputExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataInputExtension(struct soap *soap, const char *tag, tt__MetadataInputExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataInputExtension **)soap_malloc(soap, sizeof(tt__MetadataInputExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataInputExtension *)soap_instantiate_tt__MetadataInputExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MetadataInputExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInputExtension, sizeof(tt__MetadataInputExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataInputExtension(struct soap *soap, tt__MetadataInputExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataInputExtension(soap, tag ? tag : "tt:MetadataInputExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataInputExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataInputExtension(struct soap *soap, tt__MetadataInputExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataInputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceIdentificationExtension(struct soap *soap, tt__SourceIdentificationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceIdentificationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceIdentificationExtension(struct soap *soap, const char *tag, int id, tt__SourceIdentificationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceIdentificationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SourceIdentificationExtension ? type : NULL);
}

SOAP_FMAC3 tt__SourceIdentificationExtension ** SOAP_FMAC4 soap_in_PointerTott__SourceIdentificationExtension(struct soap *soap, const char *tag, tt__SourceIdentificationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SourceIdentificationExtension **)soap_malloc(soap, sizeof(tt__SourceIdentificationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SourceIdentificationExtension *)soap_instantiate_tt__SourceIdentificationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SourceIdentificationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(tt__SourceIdentificationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceIdentificationExtension(struct soap *soap, tt__SourceIdentificationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SourceIdentificationExtension(soap, tag ? tag : "tt:SourceIdentificationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SourceIdentificationExtension ** SOAP_FMAC4 soap_get_PointerTott__SourceIdentificationExtension(struct soap *soap, tt__SourceIdentificationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceIdentificationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, tt__AnalyticsEngineInputInfoExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineInputInfoExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsEngineInputInfoExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, tt__AnalyticsEngineInputInfoExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineInputInfoExtension **)soap_malloc(soap, sizeof(tt__AnalyticsEngineInputInfoExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineInputInfoExtension *)soap_instantiate_tt__AnalyticsEngineInputInfoExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsEngineInputInfoExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(tt__AnalyticsEngineInputInfoExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, tt__AnalyticsEngineInputInfoExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineInputInfoExtension(soap, tag ? tag : "tt:AnalyticsEngineInputInfoExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineInputInfoExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, tt__AnalyticsEngineInputInfoExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineInputInfoExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, tt__AnalyticsEngineInputInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineInputInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineInputInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineInputInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsEngineInputInfo ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsEngineInputInfo ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, tt__AnalyticsEngineInputInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineInputInfo **)soap_malloc(soap, sizeof(tt__AnalyticsEngineInputInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineInputInfo *)soap_instantiate_tt__AnalyticsEngineInputInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsEngineInputInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(tt__AnalyticsEngineInputInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, tt__AnalyticsEngineInputInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineInputInfo(soap, tag ? tag : "tt:AnalyticsEngineInputInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineInputInfo ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, tt__AnalyticsEngineInputInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineInputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, tt__AnalyticsDeviceEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, int id, tt__AnalyticsDeviceEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsDeviceEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, tt__AnalyticsDeviceEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsDeviceEngineConfigurationExtension **)soap_malloc(soap, sizeof(tt__AnalyticsDeviceEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsDeviceEngineConfigurationExtension *)soap_instantiate_tt__AnalyticsDeviceEngineConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsDeviceEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(tt__AnalyticsDeviceEngineConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, tt__AnalyticsDeviceEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsDeviceEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsDeviceEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, tt__AnalyticsDeviceEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EngineConfiguration(struct soap *soap, tt__EngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EngineConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EngineConfiguration(struct soap *soap, const char *tag, int id, tt__EngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EngineConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__EngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__EngineConfiguration(struct soap *soap, const char *tag, tt__EngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EngineConfiguration **)soap_malloc(soap, sizeof(tt__EngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EngineConfiguration *)soap_instantiate_tt__EngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EngineConfiguration, sizeof(tt__EngineConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EngineConfiguration(struct soap *soap, tt__EngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EngineConfiguration(soap, tag ? tag : "tt:EngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__EngineConfiguration(struct soap *soap, tt__EngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobConfiguration(struct soap *soap, tt__RecordingJobConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobConfiguration(struct soap *soap, const char *tag, int id, tt__RecordingJobConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingJobConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__RecordingJobConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobConfiguration(struct soap *soap, const char *tag, tt__RecordingJobConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobConfiguration **)soap_malloc(soap, sizeof(tt__RecordingJobConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobConfiguration *)soap_instantiate_tt__RecordingJobConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingJobConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(tt__RecordingJobConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobConfiguration(struct soap *soap, tt__RecordingJobConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobConfiguration(soap, tag ? tag : "tt:RecordingJobConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobConfiguration(struct soap *soap, tt__RecordingJobConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateTrack(struct soap *soap, tt__RecordingJobStateTrack *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateTrack))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, int id, tt__RecordingJobStateTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateTrack, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingJobStateTrack ? type : NULL);
}

SOAP_FMAC3 tt__RecordingJobStateTrack ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, tt__RecordingJobStateTrack **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobStateTrack **)soap_malloc(soap, sizeof(tt__RecordingJobStateTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobStateTrack *)soap_instantiate_tt__RecordingJobStateTrack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingJobStateTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(tt__RecordingJobStateTrack), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateTrack(struct soap *soap, tt__RecordingJobStateTrack *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateTrack(soap, tag ? tag : "tt:RecordingJobStateTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobStateTrack ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateTrack(struct soap *soap, tt__RecordingJobStateTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateTracks(struct soap *soap, tt__RecordingJobStateTracks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateTracks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateTracks(struct soap *soap, const char *tag, int id, tt__RecordingJobStateTracks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateTracks, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingJobStateTracks ? type : NULL);
}

SOAP_FMAC3 tt__RecordingJobStateTracks ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateTracks(struct soap *soap, const char *tag, tt__RecordingJobStateTracks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobStateTracks **)soap_malloc(soap, sizeof(tt__RecordingJobStateTracks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobStateTracks *)soap_instantiate_tt__RecordingJobStateTracks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingJobStateTracks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(tt__RecordingJobStateTracks), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateTracks(struct soap *soap, tt__RecordingJobStateTracks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateTracks(soap, tag ? tag : "tt:RecordingJobStateTracks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobStateTracks ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateTracks(struct soap *soap, tt__RecordingJobStateTracks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateTracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, tt__RecordingJobStateInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateInformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, int id, tt__RecordingJobStateInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingJobStateInformationExtension ? type : NULL);
}

SOAP_FMAC3 tt__RecordingJobStateInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, tt__RecordingJobStateInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobStateInformationExtension **)soap_malloc(soap, sizeof(tt__RecordingJobStateInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobStateInformationExtension *)soap_instantiate_tt__RecordingJobStateInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingJobStateInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(tt__RecordingJobStateInformationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, tt__RecordingJobStateInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateInformationExtension(soap, tag ? tag : "tt:RecordingJobStateInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobStateInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, tt__RecordingJobStateInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateSource(struct soap *soap, tt__RecordingJobStateSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateSource))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, int id, tt__RecordingJobStateSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateSource, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingJobStateSource ? type : NULL);
}

SOAP_FMAC3 tt__RecordingJobStateSource ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, tt__RecordingJobStateSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobStateSource **)soap_malloc(soap, sizeof(tt__RecordingJobStateSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobStateSource *)soap_instantiate_tt__RecordingJobStateSource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingJobStateSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(tt__RecordingJobStateSource), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateSource(struct soap *soap, tt__RecordingJobStateSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateSource(soap, tag ? tag : "tt:RecordingJobStateSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobStateSource ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateSource(struct soap *soap, tt__RecordingJobStateSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobSourceExtension(struct soap *soap, tt__RecordingJobSourceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobSourceExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobSourceExtension(struct soap *soap, const char *tag, int id, tt__RecordingJobSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobSourceExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingJobSourceExtension ? type : NULL);
}

SOAP_FMAC3 tt__RecordingJobSourceExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobSourceExtension(struct soap *soap, const char *tag, tt__RecordingJobSourceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobSourceExtension **)soap_malloc(soap, sizeof(tt__RecordingJobSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobSourceExtension *)soap_instantiate_tt__RecordingJobSourceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingJobSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(tt__RecordingJobSourceExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobSourceExtension(struct soap *soap, tt__RecordingJobSourceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobSourceExtension(soap, tag ? tag : "tt:RecordingJobSourceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobSourceExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobSourceExtension(struct soap *soap, tt__RecordingJobSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobTrack(struct soap *soap, tt__RecordingJobTrack *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobTrack))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobTrack(struct soap *soap, const char *tag, int id, tt__RecordingJobTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobTrack, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingJobTrack ? type : NULL);
}

SOAP_FMAC3 tt__RecordingJobTrack ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobTrack(struct soap *soap, const char *tag, tt__RecordingJobTrack **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobTrack **)soap_malloc(soap, sizeof(tt__RecordingJobTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobTrack *)soap_instantiate_tt__RecordingJobTrack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingJobTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobTrack, sizeof(tt__RecordingJobTrack), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobTrack(struct soap *soap, tt__RecordingJobTrack *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobTrack(soap, tag ? tag : "tt:RecordingJobTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobTrack ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobTrack(struct soap *soap, tt__RecordingJobTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, tt__RecordingJobConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, int id, tt__RecordingJobConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingJobConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__RecordingJobConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, tt__RecordingJobConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobConfigurationExtension **)soap_malloc(soap, sizeof(tt__RecordingJobConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobConfigurationExtension *)soap_instantiate_tt__RecordingJobConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingJobConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(tt__RecordingJobConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, tt__RecordingJobConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobConfigurationExtension(soap, tag ? tag : "tt:RecordingJobConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, tt__RecordingJobConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobSource(struct soap *soap, tt__RecordingJobSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobSource))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobSource(struct soap *soap, const char *tag, int id, tt__RecordingJobSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobSource, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingJobSource ? type : NULL);
}

SOAP_FMAC3 tt__RecordingJobSource ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobSource(struct soap *soap, const char *tag, tt__RecordingJobSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobSource **)soap_malloc(soap, sizeof(tt__RecordingJobSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobSource *)soap_instantiate_tt__RecordingJobSource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingJobSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobSource, sizeof(tt__RecordingJobSource), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobSource(struct soap *soap, tt__RecordingJobSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobSource(soap, tag ? tag : "tt:RecordingJobSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobSource ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobSource(struct soap *soap, tt__RecordingJobSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackConfiguration(struct soap *soap, tt__TrackConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackConfiguration(struct soap *soap, const char *tag, int id, tt__TrackConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__TrackConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__TrackConfiguration ** SOAP_FMAC4 soap_in_PointerTott__TrackConfiguration(struct soap *soap, const char *tag, tt__TrackConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TrackConfiguration **)soap_malloc(soap, sizeof(tt__TrackConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TrackConfiguration *)soap_instantiate_tt__TrackConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__TrackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackConfiguration, sizeof(tt__TrackConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackConfiguration(struct soap *soap, tt__TrackConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TrackConfiguration(soap, tag ? tag : "tt:TrackConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TrackConfiguration ** SOAP_FMAC4 soap_get_PointerTott__TrackConfiguration(struct soap *soap, tt__TrackConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetTracksResponseItem(struct soap *soap, tt__GetTracksResponseItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetTracksResponseItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, int id, tt__GetTracksResponseItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetTracksResponseItem, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__GetTracksResponseItem ? type : NULL);
}

SOAP_FMAC3 tt__GetTracksResponseItem ** SOAP_FMAC4 soap_in_PointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, tt__GetTracksResponseItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__GetTracksResponseItem **)soap_malloc(soap, sizeof(tt__GetTracksResponseItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__GetTracksResponseItem *)soap_instantiate_tt__GetTracksResponseItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__GetTracksResponseItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(tt__GetTracksResponseItem), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetTracksResponseItem(struct soap *soap, tt__GetTracksResponseItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GetTracksResponseItem(soap, tag ? tag : "tt:GetTracksResponseItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__GetTracksResponseItem ** SOAP_FMAC4 soap_get_PointerTott__GetTracksResponseItem(struct soap *soap, tt__GetTracksResponseItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetTracksResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetTracksResponseList(struct soap *soap, tt__GetTracksResponseList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetTracksResponseList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetTracksResponseList(struct soap *soap, const char *tag, int id, tt__GetTracksResponseList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetTracksResponseList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__GetTracksResponseList ? type : NULL);
}

SOAP_FMAC3 tt__GetTracksResponseList ** SOAP_FMAC4 soap_in_PointerTott__GetTracksResponseList(struct soap *soap, const char *tag, tt__GetTracksResponseList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__GetTracksResponseList **)soap_malloc(soap, sizeof(tt__GetTracksResponseList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__GetTracksResponseList *)soap_instantiate_tt__GetTracksResponseList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__GetTracksResponseList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetTracksResponseList, sizeof(tt__GetTracksResponseList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetTracksResponseList(struct soap *soap, tt__GetTracksResponseList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GetTracksResponseList(soap, tag ? tag : "tt:GetTracksResponseList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__GetTracksResponseList ** SOAP_FMAC4 soap_get_PointerTott__GetTracksResponseList(struct soap *soap, tt__GetTracksResponseList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetTracksResponseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingConfiguration(struct soap *soap, tt__RecordingConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingConfiguration(struct soap *soap, const char *tag, int id, tt__RecordingConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__RecordingConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RecordingConfiguration(struct soap *soap, const char *tag, tt__RecordingConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingConfiguration **)soap_malloc(soap, sizeof(tt__RecordingConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingConfiguration *)soap_instantiate_tt__RecordingConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingConfiguration, sizeof(tt__RecordingConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingConfiguration(struct soap *soap, tt__RecordingConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingConfiguration(soap, tag ? tag : "tt:RecordingConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RecordingConfiguration(struct soap *soap, tt__RecordingConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackAttributesExtension(struct soap *soap, tt__TrackAttributesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackAttributesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackAttributesExtension(struct soap *soap, const char *tag, int id, tt__TrackAttributesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackAttributesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__TrackAttributesExtension ? type : NULL);
}

SOAP_FMAC3 tt__TrackAttributesExtension ** SOAP_FMAC4 soap_in_PointerTott__TrackAttributesExtension(struct soap *soap, const char *tag, tt__TrackAttributesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TrackAttributesExtension **)soap_malloc(soap, sizeof(tt__TrackAttributesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TrackAttributesExtension *)soap_instantiate_tt__TrackAttributesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__TrackAttributesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(tt__TrackAttributesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackAttributesExtension(struct soap *soap, tt__TrackAttributesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TrackAttributesExtension(soap, tag ? tag : "tt:TrackAttributesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TrackAttributesExtension ** SOAP_FMAC4 soap_get_PointerTott__TrackAttributesExtension(struct soap *soap, tt__TrackAttributesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackAttributesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataAttributes(struct soap *soap, tt__MetadataAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataAttributes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataAttributes(struct soap *soap, const char *tag, int id, tt__MetadataAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataAttributes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MetadataAttributes ? type : NULL);
}

SOAP_FMAC3 tt__MetadataAttributes ** SOAP_FMAC4 soap_in_PointerTott__MetadataAttributes(struct soap *soap, const char *tag, tt__MetadataAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataAttributes **)soap_malloc(soap, sizeof(tt__MetadataAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataAttributes *)soap_instantiate_tt__MetadataAttributes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MetadataAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataAttributes, sizeof(tt__MetadataAttributes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataAttributes(struct soap *soap, tt__MetadataAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataAttributes(soap, tag ? tag : "tt:MetadataAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataAttributes ** SOAP_FMAC4 soap_get_PointerTott__MetadataAttributes(struct soap *soap, tt__MetadataAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioAttributes(struct soap *soap, tt__AudioAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioAttributes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioAttributes(struct soap *soap, const char *tag, int id, tt__AudioAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioAttributes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioAttributes ? type : NULL);
}

SOAP_FMAC3 tt__AudioAttributes ** SOAP_FMAC4 soap_in_PointerTott__AudioAttributes(struct soap *soap, const char *tag, tt__AudioAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioAttributes **)soap_malloc(soap, sizeof(tt__AudioAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioAttributes *)soap_instantiate_tt__AudioAttributes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioAttributes, sizeof(tt__AudioAttributes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioAttributes(struct soap *soap, tt__AudioAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioAttributes(soap, tag ? tag : "tt:AudioAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioAttributes ** SOAP_FMAC4 soap_get_PointerTott__AudioAttributes(struct soap *soap, tt__AudioAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAttributes(struct soap *soap, tt__VideoAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAttributes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAttributes(struct soap *soap, const char *tag, int id, tt__VideoAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAttributes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoAttributes ? type : NULL);
}

SOAP_FMAC3 tt__VideoAttributes ** SOAP_FMAC4 soap_in_PointerTott__VideoAttributes(struct soap *soap, const char *tag, tt__VideoAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoAttributes **)soap_malloc(soap, sizeof(tt__VideoAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoAttributes *)soap_instantiate_tt__VideoAttributes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAttributes, sizeof(tt__VideoAttributes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAttributes(struct soap *soap, tt__VideoAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoAttributes(soap, tag ? tag : "tt:VideoAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoAttributes ** SOAP_FMAC4 soap_get_PointerTott__VideoAttributes(struct soap *soap, tt__VideoAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackAttributes(struct soap *soap, tt__TrackAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackAttributes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackAttributes(struct soap *soap, const char *tag, int id, tt__TrackAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackAttributes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__TrackAttributes ? type : NULL);
}

SOAP_FMAC3 tt__TrackAttributes ** SOAP_FMAC4 soap_in_PointerTott__TrackAttributes(struct soap *soap, const char *tag, tt__TrackAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TrackAttributes **)soap_malloc(soap, sizeof(tt__TrackAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TrackAttributes *)soap_instantiate_tt__TrackAttributes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__TrackAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackAttributes, sizeof(tt__TrackAttributes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackAttributes(struct soap *soap, tt__TrackAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TrackAttributes(soap, tag ? tag : "tt:TrackAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TrackAttributes ** SOAP_FMAC4 soap_get_PointerTott__TrackAttributes(struct soap *soap, tt__TrackAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackInformation(struct soap *soap, tt__TrackInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackInformation(struct soap *soap, const char *tag, int id, tt__TrackInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__TrackInformation ? type : NULL);
}

SOAP_FMAC3 tt__TrackInformation ** SOAP_FMAC4 soap_in_PointerTott__TrackInformation(struct soap *soap, const char *tag, tt__TrackInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TrackInformation **)soap_malloc(soap, sizeof(tt__TrackInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TrackInformation *)soap_instantiate_tt__TrackInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__TrackInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackInformation, sizeof(tt__TrackInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackInformation(struct soap *soap, tt__TrackInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TrackInformation(soap, tag ? tag : "tt:TrackInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TrackInformation ** SOAP_FMAC4 soap_get_PointerTott__TrackInformation(struct soap *soap, tt__TrackInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingSourceInformation(struct soap *soap, tt__RecordingSourceInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingSourceInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingSourceInformation(struct soap *soap, const char *tag, int id, tt__RecordingSourceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingSourceInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingSourceInformation ? type : NULL);
}

SOAP_FMAC3 tt__RecordingSourceInformation ** SOAP_FMAC4 soap_in_PointerTott__RecordingSourceInformation(struct soap *soap, const char *tag, tt__RecordingSourceInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingSourceInformation **)soap_malloc(soap, sizeof(tt__RecordingSourceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingSourceInformation *)soap_instantiate_tt__RecordingSourceInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingSourceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(tt__RecordingSourceInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingSourceInformation(struct soap *soap, tt__RecordingSourceInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingSourceInformation(soap, tag ? tag : "tt:RecordingSourceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingSourceInformation ** SOAP_FMAC4 soap_get_PointerTott__RecordingSourceInformation(struct soap *soap, tt__RecordingSourceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingSourceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindMetadataResult(struct soap *soap, tt__FindMetadataResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindMetadataResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindMetadataResult(struct soap *soap, const char *tag, int id, tt__FindMetadataResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindMetadataResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FindMetadataResult ? type : NULL);
}

SOAP_FMAC3 tt__FindMetadataResult ** SOAP_FMAC4 soap_in_PointerTott__FindMetadataResult(struct soap *soap, const char *tag, tt__FindMetadataResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FindMetadataResult **)soap_malloc(soap, sizeof(tt__FindMetadataResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FindMetadataResult *)soap_instantiate_tt__FindMetadataResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FindMetadataResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindMetadataResult, sizeof(tt__FindMetadataResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindMetadataResult(struct soap *soap, tt__FindMetadataResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindMetadataResult(soap, tag ? tag : "tt:FindMetadataResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FindMetadataResult ** SOAP_FMAC4 soap_get_PointerTott__FindMetadataResult(struct soap *soap, tt__FindMetadataResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindPTZPositionResult(struct soap *soap, tt__FindPTZPositionResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindPTZPositionResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, int id, tt__FindPTZPositionResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindPTZPositionResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FindPTZPositionResult ? type : NULL);
}

SOAP_FMAC3 tt__FindPTZPositionResult ** SOAP_FMAC4 soap_in_PointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, tt__FindPTZPositionResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FindPTZPositionResult **)soap_malloc(soap, sizeof(tt__FindPTZPositionResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FindPTZPositionResult *)soap_instantiate_tt__FindPTZPositionResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FindPTZPositionResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(tt__FindPTZPositionResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindPTZPositionResult(struct soap *soap, tt__FindPTZPositionResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindPTZPositionResult(soap, tag ? tag : "tt:FindPTZPositionResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FindPTZPositionResult ** SOAP_FMAC4 soap_get_PointerTott__FindPTZPositionResult(struct soap *soap, tt__FindPTZPositionResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindPTZPositionResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotificationMessageHolderType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, wsnt__NotificationMessageHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotificationMessageHolderType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__NotificationMessageHolderType ? type : NULL);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, wsnt__NotificationMessageHolderType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__NotificationMessageHolderType **)soap_malloc(soap, sizeof(wsnt__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__NotificationMessageHolderType *)soap_instantiate_wsnt__NotificationMessageHolderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindEventResult(struct soap *soap, tt__FindEventResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindEventResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindEventResult(struct soap *soap, const char *tag, int id, tt__FindEventResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindEventResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FindEventResult ? type : NULL);
}

SOAP_FMAC3 tt__FindEventResult ** SOAP_FMAC4 soap_in_PointerTott__FindEventResult(struct soap *soap, const char *tag, tt__FindEventResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FindEventResult **)soap_malloc(soap, sizeof(tt__FindEventResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FindEventResult *)soap_instantiate_tt__FindEventResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FindEventResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindEventResult, sizeof(tt__FindEventResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindEventResult(struct soap *soap, tt__FindEventResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindEventResult(soap, tag ? tag : "tt:FindEventResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FindEventResult ** SOAP_FMAC4 soap_get_PointerTott__FindEventResult(struct soap *soap, tt__FindEventResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindEventResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingInformation(struct soap *soap, tt__RecordingInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingInformation(struct soap *soap, const char *tag, int id, tt__RecordingInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingInformation ? type : NULL);
}

SOAP_FMAC3 tt__RecordingInformation ** SOAP_FMAC4 soap_in_PointerTott__RecordingInformation(struct soap *soap, const char *tag, tt__RecordingInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingInformation **)soap_malloc(soap, sizeof(tt__RecordingInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingInformation *)soap_instantiate_tt__RecordingInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingInformation, sizeof(tt__RecordingInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingInformation(struct soap *soap, tt__RecordingInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingInformation(soap, tag ? tag : "tt:RecordingInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingInformation ** SOAP_FMAC4 soap_get_PointerTott__RecordingInformation(struct soap *soap, tt__RecordingInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SearchScopeExtension(struct soap *soap, tt__SearchScopeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SearchScopeExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SearchScopeExtension(struct soap *soap, const char *tag, int id, tt__SearchScopeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SearchScopeExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SearchScopeExtension ? type : NULL);
}

SOAP_FMAC3 tt__SearchScopeExtension ** SOAP_FMAC4 soap_in_PointerTott__SearchScopeExtension(struct soap *soap, const char *tag, tt__SearchScopeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SearchScopeExtension **)soap_malloc(soap, sizeof(tt__SearchScopeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SearchScopeExtension *)soap_instantiate_tt__SearchScopeExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SearchScopeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchScopeExtension, sizeof(tt__SearchScopeExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SearchScopeExtension(struct soap *soap, tt__SearchScopeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SearchScopeExtension(soap, tag ? tag : "tt:SearchScopeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SearchScopeExtension ** SOAP_FMAC4 soap_get_PointerTott__SearchScopeExtension(struct soap *soap, tt__SearchScopeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SearchScopeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__XPathExpression(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__XPathExpression))
		soap_serialize_tt__XPathExpression(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__XPathExpression(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__XPathExpression, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__XPathExpression(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__XPathExpression(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__XPathExpression(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__XPathExpression, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__XPathExpression(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__XPathExpression(soap, tag ? tag : "tt:XPathExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__XPathExpression(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__XPathExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceReference(struct soap *soap, tt__SourceReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceReference))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceReference(struct soap *soap, const char *tag, int id, tt__SourceReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceReference, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SourceReference ? type : NULL);
}

SOAP_FMAC3 tt__SourceReference ** SOAP_FMAC4 soap_in_PointerTott__SourceReference(struct soap *soap, const char *tag, tt__SourceReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SourceReference **)soap_malloc(soap, sizeof(tt__SourceReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SourceReference *)soap_instantiate_tt__SourceReference(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SourceReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceReference, sizeof(tt__SourceReference), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceReference(struct soap *soap, tt__SourceReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SourceReference(soap, tag ? tag : "tt:SourceReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SourceReference ** SOAP_FMAC4 soap_get_PointerTott__SourceReference(struct soap *soap, tt__SourceReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StreamSetup(struct soap *soap, tt__StreamSetup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StreamSetup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StreamSetup(struct soap *soap, const char *tag, int id, tt__StreamSetup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StreamSetup, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__StreamSetup ? type : NULL);
}

SOAP_FMAC3 tt__StreamSetup ** SOAP_FMAC4 soap_in_PointerTott__StreamSetup(struct soap *soap, const char *tag, tt__StreamSetup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__StreamSetup **)soap_malloc(soap, sizeof(tt__StreamSetup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__StreamSetup *)soap_instantiate_tt__StreamSetup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__StreamSetup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StreamSetup, sizeof(tt__StreamSetup), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StreamSetup(struct soap *soap, tt__StreamSetup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StreamSetup(soap, tag ? tag : "tt:StreamSetup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__StreamSetup ** SOAP_FMAC4 soap_get_PointerTott__StreamSetup(struct soap *soap, tt__StreamSetup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StreamSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReceiverConfiguration(struct soap *soap, tt__ReceiverConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReceiverConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReceiverConfiguration(struct soap *soap, const char *tag, int id, tt__ReceiverConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReceiverConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ReceiverConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__ReceiverConfiguration ** SOAP_FMAC4 soap_in_PointerTott__ReceiverConfiguration(struct soap *soap, const char *tag, tt__ReceiverConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ReceiverConfiguration **)soap_malloc(soap, sizeof(tt__ReceiverConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ReceiverConfiguration *)soap_instantiate_tt__ReceiverConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ReceiverConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(tt__ReceiverConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReceiverConfiguration(struct soap *soap, tt__ReceiverConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReceiverConfiguration(soap, tag ? tag : "tt:ReceiverConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ReceiverConfiguration ** SOAP_FMAC4 soap_get_PointerTott__ReceiverConfiguration(struct soap *soap, tt__ReceiverConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReceiverConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneOptionExtension(struct soap *soap, tt__PaneOptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneOptionExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneOptionExtension(struct soap *soap, const char *tag, int id, tt__PaneOptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneOptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PaneOptionExtension ? type : NULL);
}

SOAP_FMAC3 tt__PaneOptionExtension ** SOAP_FMAC4 soap_in_PointerTott__PaneOptionExtension(struct soap *soap, const char *tag, tt__PaneOptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PaneOptionExtension **)soap_malloc(soap, sizeof(tt__PaneOptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PaneOptionExtension *)soap_instantiate_tt__PaneOptionExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PaneOptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneOptionExtension, sizeof(tt__PaneOptionExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneOptionExtension(struct soap *soap, tt__PaneOptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PaneOptionExtension(soap, tag ? tag : "tt:PaneOptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PaneOptionExtension ** SOAP_FMAC4 soap_get_PointerTott__PaneOptionExtension(struct soap *soap, tt__PaneOptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneOptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LayoutOptionsExtension(struct soap *soap, tt__LayoutOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LayoutOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LayoutOptionsExtension(struct soap *soap, const char *tag, int id, tt__LayoutOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LayoutOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LayoutOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__LayoutOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__LayoutOptionsExtension(struct soap *soap, const char *tag, tt__LayoutOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LayoutOptionsExtension **)soap_malloc(soap, sizeof(tt__LayoutOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LayoutOptionsExtension *)soap_instantiate_tt__LayoutOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LayoutOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(tt__LayoutOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LayoutOptionsExtension(struct soap *soap, tt__LayoutOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LayoutOptionsExtension(soap, tag ? tag : "tt:LayoutOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LayoutOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__LayoutOptionsExtension(struct soap *soap, tt__LayoutOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LayoutOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneLayoutOptions(struct soap *soap, tt__PaneLayoutOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneLayoutOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneLayoutOptions(struct soap *soap, const char *tag, int id, tt__PaneLayoutOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneLayoutOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PaneLayoutOptions ? type : NULL);
}

SOAP_FMAC3 tt__PaneLayoutOptions ** SOAP_FMAC4 soap_in_PointerTott__PaneLayoutOptions(struct soap *soap, const char *tag, tt__PaneLayoutOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PaneLayoutOptions **)soap_malloc(soap, sizeof(tt__PaneLayoutOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PaneLayoutOptions *)soap_instantiate_tt__PaneLayoutOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PaneLayoutOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(tt__PaneLayoutOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneLayoutOptions(struct soap *soap, tt__PaneLayoutOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PaneLayoutOptions(soap, tag ? tag : "tt:PaneLayoutOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PaneLayoutOptions ** SOAP_FMAC4 soap_get_PointerTott__PaneLayoutOptions(struct soap *soap, tt__PaneLayoutOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneLayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, tt__VideoDecoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, tt__VideoDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoDecoderConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 tt__VideoDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, tt__VideoDecoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoDecoderConfigurationOptions **)soap_malloc(soap, sizeof(tt__VideoDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoDecoderConfigurationOptions *)soap_instantiate_tt__VideoDecoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, sizeof(tt__VideoDecoderConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, tt__VideoDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoDecoderConfigurationOptions(soap, tag ? tag : "tt:VideoDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, tt__VideoDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, tt__AudioDecoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, tt__AudioDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioDecoderConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, tt__AudioDecoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioDecoderConfigurationOptions **)soap_malloc(soap, sizeof(tt__AudioDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioDecoderConfigurationOptions *)soap_instantiate_tt__AudioDecoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(tt__AudioDecoderConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, tt__AudioDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioDecoderConfigurationOptions(soap, tag ? tag : "tt:AudioDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, tt__AudioDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, tt__AudioEncoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, tt__AudioEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioEncoderConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, tt__AudioEncoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioEncoderConfigurationOptions **)soap_malloc(soap, sizeof(tt__AudioEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioEncoderConfigurationOptions *)soap_instantiate_tt__AudioEncoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(tt__AudioEncoderConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, tt__AudioEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioEncoderConfigurationOptions(soap, tag ? tag : "tt:AudioEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, tt__AudioEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LayoutExtension(struct soap *soap, tt__LayoutExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LayoutExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LayoutExtension(struct soap *soap, const char *tag, int id, tt__LayoutExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LayoutExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LayoutExtension ? type : NULL);
}

SOAP_FMAC3 tt__LayoutExtension ** SOAP_FMAC4 soap_in_PointerTott__LayoutExtension(struct soap *soap, const char *tag, tt__LayoutExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LayoutExtension **)soap_malloc(soap, sizeof(tt__LayoutExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LayoutExtension *)soap_instantiate_tt__LayoutExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LayoutExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutExtension, sizeof(tt__LayoutExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LayoutExtension(struct soap *soap, tt__LayoutExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LayoutExtension(soap, tag ? tag : "tt:LayoutExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LayoutExtension ** SOAP_FMAC4 soap_get_PointerTott__LayoutExtension(struct soap *soap, tt__LayoutExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LayoutExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneLayout(struct soap *soap, tt__PaneLayout *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneLayout))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneLayout(struct soap *soap, const char *tag, int id, tt__PaneLayout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneLayout, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PaneLayout ? type : NULL);
}

SOAP_FMAC3 tt__PaneLayout ** SOAP_FMAC4 soap_in_PointerTott__PaneLayout(struct soap *soap, const char *tag, tt__PaneLayout **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PaneLayout **)soap_malloc(soap, sizeof(tt__PaneLayout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PaneLayout *)soap_instantiate_tt__PaneLayout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PaneLayout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneLayout, sizeof(tt__PaneLayout), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneLayout(struct soap *soap, tt__PaneLayout *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PaneLayout(soap, tag ? tag : "tt:PaneLayout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PaneLayout ** SOAP_FMAC4 soap_get_PointerTott__PaneLayout(struct soap *soap, tt__PaneLayout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Transformation(struct soap *soap, tt__Transformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Transformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Transformation(struct soap *soap, const char *tag, int id, tt__Transformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Transformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Transformation ? type : NULL);
}

SOAP_FMAC3 tt__Transformation ** SOAP_FMAC4 soap_in_PointerTott__Transformation(struct soap *soap, const char *tag, tt__Transformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Transformation **)soap_malloc(soap, sizeof(tt__Transformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Transformation *)soap_instantiate_tt__Transformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Transformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transformation, sizeof(tt__Transformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Transformation(struct soap *soap, tt__Transformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Transformation(soap, tag ? tag : "tt:Transformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Transformation ** SOAP_FMAC4 soap_get_PointerTott__Transformation(struct soap *soap, tt__Transformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MotionExpression(struct soap *soap, tt__MotionExpression *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MotionExpression))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MotionExpression(struct soap *soap, const char *tag, int id, tt__MotionExpression *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MotionExpression, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MotionExpression ? type : NULL);
}

SOAP_FMAC3 tt__MotionExpression ** SOAP_FMAC4 soap_in_PointerTott__MotionExpression(struct soap *soap, const char *tag, tt__MotionExpression **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MotionExpression **)soap_malloc(soap, sizeof(tt__MotionExpression *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MotionExpression *)soap_instantiate_tt__MotionExpression(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MotionExpression **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MotionExpression, sizeof(tt__MotionExpression), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MotionExpression(struct soap *soap, tt__MotionExpression *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MotionExpression(soap, tag ? tag : "tt:MotionExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MotionExpression ** SOAP_FMAC4 soap_get_PointerTott__MotionExpression(struct soap *soap, tt__MotionExpression **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MotionExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PolylineArray(struct soap *soap, tt__PolylineArray *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PolylineArray))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PolylineArray(struct soap *soap, const char *tag, int id, tt__PolylineArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PolylineArray, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PolylineArray ? type : NULL);
}

SOAP_FMAC3 tt__PolylineArray ** SOAP_FMAC4 soap_in_PointerTott__PolylineArray(struct soap *soap, const char *tag, tt__PolylineArray **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PolylineArray **)soap_malloc(soap, sizeof(tt__PolylineArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PolylineArray *)soap_instantiate_tt__PolylineArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PolylineArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PolylineArray, sizeof(tt__PolylineArray), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PolylineArray(struct soap *soap, tt__PolylineArray *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PolylineArray(soap, tag ? tag : "tt:PolylineArray", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PolylineArray ** SOAP_FMAC4 soap_get_PointerTott__PolylineArray(struct soap *soap, tt__PolylineArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PolylineArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PolylineArrayExtension(struct soap *soap, tt__PolylineArrayExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PolylineArrayExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PolylineArrayExtension(struct soap *soap, const char *tag, int id, tt__PolylineArrayExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PolylineArrayExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PolylineArrayExtension ? type : NULL);
}

SOAP_FMAC3 tt__PolylineArrayExtension ** SOAP_FMAC4 soap_in_PointerTott__PolylineArrayExtension(struct soap *soap, const char *tag, tt__PolylineArrayExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PolylineArrayExtension **)soap_malloc(soap, sizeof(tt__PolylineArrayExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PolylineArrayExtension *)soap_instantiate_tt__PolylineArrayExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PolylineArrayExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(tt__PolylineArrayExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PolylineArrayExtension(struct soap *soap, tt__PolylineArrayExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PolylineArrayExtension(soap, tag ? tag : "tt:PolylineArrayExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PolylineArrayExtension ** SOAP_FMAC4 soap_get_PointerTott__PolylineArrayExtension(struct soap *soap, tt__PolylineArrayExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PolylineArrayExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Polyline(struct soap *soap, tt__Polyline *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Polyline))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Polyline(struct soap *soap, const char *tag, int id, tt__Polyline *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Polyline, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Polyline ? type : NULL);
}

SOAP_FMAC3 tt__Polyline ** SOAP_FMAC4 soap_in_PointerTott__Polyline(struct soap *soap, const char *tag, tt__Polyline **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Polyline **)soap_malloc(soap, sizeof(tt__Polyline *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Polyline *)soap_instantiate_tt__Polyline(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Polyline **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Polyline, sizeof(tt__Polyline), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Polyline(struct soap *soap, tt__Polyline *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Polyline(soap, tag ? tag : "tt:Polyline", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Polyline ** SOAP_FMAC4 soap_get_PointerTott__Polyline(struct soap *soap, tt__Polyline **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Polyline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Polygon(struct soap *soap, tt__Polygon *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Polygon))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Polygon(struct soap *soap, const char *tag, int id, tt__Polygon *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Polygon, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Polygon ? type : NULL);
}

SOAP_FMAC3 tt__Polygon ** SOAP_FMAC4 soap_in_PointerTott__Polygon(struct soap *soap, const char *tag, tt__Polygon **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Polygon **)soap_malloc(soap, sizeof(tt__Polygon *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Polygon *)soap_instantiate_tt__Polygon(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Polygon **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Polygon, sizeof(tt__Polygon), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Polygon(struct soap *soap, tt__Polygon *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Polygon(soap, tag ? tag : "tt:Polygon", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Polygon ** SOAP_FMAC4 soap_get_PointerTott__Polygon(struct soap *soap, tt__Polygon **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, tt__SupportedAnalyticsModulesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, int id, tt__SupportedAnalyticsModulesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SupportedAnalyticsModulesExtension ? type : NULL);
}

SOAP_FMAC3 tt__SupportedAnalyticsModulesExtension ** SOAP_FMAC4 soap_in_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, tt__SupportedAnalyticsModulesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SupportedAnalyticsModulesExtension **)soap_malloc(soap, sizeof(tt__SupportedAnalyticsModulesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SupportedAnalyticsModulesExtension *)soap_instantiate_tt__SupportedAnalyticsModulesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SupportedAnalyticsModulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(tt__SupportedAnalyticsModulesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, tt__SupportedAnalyticsModulesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SupportedAnalyticsModulesExtension(soap, tag ? tag : "tt:SupportedAnalyticsModulesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SupportedAnalyticsModulesExtension ** SOAP_FMAC4 soap_get_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, tt__SupportedAnalyticsModulesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedAnalyticsModulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedRulesExtension(struct soap *soap, tt__SupportedRulesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedRulesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedRulesExtension(struct soap *soap, const char *tag, int id, tt__SupportedRulesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedRulesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SupportedRulesExtension ? type : NULL);
}

SOAP_FMAC3 tt__SupportedRulesExtension ** SOAP_FMAC4 soap_in_PointerTott__SupportedRulesExtension(struct soap *soap, const char *tag, tt__SupportedRulesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SupportedRulesExtension **)soap_malloc(soap, sizeof(tt__SupportedRulesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SupportedRulesExtension *)soap_instantiate_tt__SupportedRulesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SupportedRulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(tt__SupportedRulesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedRulesExtension(struct soap *soap, tt__SupportedRulesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SupportedRulesExtension(soap, tag ? tag : "tt:SupportedRulesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SupportedRulesExtension ** SOAP_FMAC4 soap_get_PointerTott__SupportedRulesExtension(struct soap *soap, tt__SupportedRulesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedRulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ConfigDescription(struct soap *soap, tt__ConfigDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ConfigDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ConfigDescription(struct soap *soap, const char *tag, int id, tt__ConfigDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ConfigDescription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ConfigDescription ? type : NULL);
}

SOAP_FMAC3 tt__ConfigDescription ** SOAP_FMAC4 soap_in_PointerTott__ConfigDescription(struct soap *soap, const char *tag, tt__ConfigDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ConfigDescription **)soap_malloc(soap, sizeof(tt__ConfigDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ConfigDescription *)soap_instantiate_tt__ConfigDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ConfigDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigDescription, sizeof(tt__ConfigDescription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ConfigDescription(struct soap *soap, tt__ConfigDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ConfigDescription(soap, tag ? tag : "tt:ConfigDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ConfigDescription ** SOAP_FMAC4 soap_get_PointerTott__ConfigDescription(struct soap *soap, tt__ConfigDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ConfigDescriptionExtension(struct soap *soap, tt__ConfigDescriptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ConfigDescriptionExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ConfigDescriptionExtension(struct soap *soap, const char *tag, int id, tt__ConfigDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ConfigDescriptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ConfigDescriptionExtension ? type : NULL);
}

SOAP_FMAC3 tt__ConfigDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__ConfigDescriptionExtension(struct soap *soap, const char *tag, tt__ConfigDescriptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ConfigDescriptionExtension **)soap_malloc(soap, sizeof(tt__ConfigDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ConfigDescriptionExtension *)soap_instantiate_tt__ConfigDescriptionExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ConfigDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(tt__ConfigDescriptionExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ConfigDescriptionExtension(struct soap *soap, tt__ConfigDescriptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ConfigDescriptionExtension(soap, tag ? tag : "tt:ConfigDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ConfigDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__ConfigDescriptionExtension(struct soap *soap, tt__ConfigDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ConfigDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemList(struct soap *soap, tt__ItemList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemList(struct soap *soap, const char *tag, int id, tt__ItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ItemList ? type : NULL);
}

SOAP_FMAC3 tt__ItemList ** SOAP_FMAC4 soap_in_PointerTott__ItemList(struct soap *soap, const char *tag, tt__ItemList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ItemList **)soap_malloc(soap, sizeof(tt__ItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ItemList *)soap_instantiate_tt__ItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemList, sizeof(tt__ItemList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemList(struct soap *soap, tt__ItemList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemList(soap, tag ? tag : "tt:ItemList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ItemList ** SOAP_FMAC4 soap_get_PointerTott__ItemList(struct soap *soap, tt__ItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, tt__RuleEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RuleEngineConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, tt__RuleEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RuleEngineConfigurationExtension **)soap_malloc(soap, sizeof(tt__RuleEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RuleEngineConfigurationExtension *)soap_instantiate_tt__RuleEngineConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RuleEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(tt__RuleEngineConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, tag ? tag : "tt:RuleEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, tt__AnalyticsEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineConfigurationExtension **)soap_malloc(soap, sizeof(tt__AnalyticsEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineConfigurationExtension *)soap_instantiate_tt__AnalyticsEngineConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(tt__AnalyticsEngineConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Config(struct soap *soap, tt__Config *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Config))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Config(struct soap *soap, const char *tag, int id, tt__Config *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Config, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Config ? type : NULL);
}

SOAP_FMAC3 tt__Config ** SOAP_FMAC4 soap_in_PointerTott__Config(struct soap *soap, const char *tag, tt__Config **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Config **)soap_malloc(soap, sizeof(tt__Config *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Config *)soap_instantiate_tt__Config(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Config **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Config, sizeof(tt__Config), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Config(struct soap *soap, tt__Config *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Config(soap, tag ? tag : "tt:Config", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Config ** SOAP_FMAC4 soap_get_PointerTott__Config(struct soap *soap, tt__Config **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.cpp */
