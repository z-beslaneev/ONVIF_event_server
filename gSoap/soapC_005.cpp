/* soapC_nnn.cpp
   Generated by gSOAP 2.8.78 for WS/onvifFull.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.cpp ver 2.8.78 2019-03-11 21:45:01 GMT")


void tt__AudioOutputConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AudioOutputConfigurationOptions::OutputTokensAvailable);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__AudioOutputConfigurationOptions::SendPrimacyOptions);
	this->tt__AudioOutputConfigurationOptions::OutputLevelRange = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioOutputConfigurationOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioOutputConfigurationOptions::__anyAttribute);
}

void tt__AudioOutputConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AudioOutputConfigurationOptions::OutputTokensAvailable);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__AudioOutputConfigurationOptions::SendPrimacyOptions);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__AudioOutputConfigurationOptions::OutputLevelRange);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioOutputConfigurationOptions::__any);
#endif
}

int tt__AudioOutputConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioOutputConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioOutputConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioOutputConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutputConfigurationOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:OutputTokensAvailable", -1, &a->tt__AudioOutputConfigurationOptions::OutputTokensAvailable, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tt:SendPrimacyOptions", -1, &a->tt__AudioOutputConfigurationOptions::SendPrimacyOptions, ""))
		return soap->error;
	if (!a->tt__AudioOutputConfigurationOptions::OutputLevelRange)
	{	if (soap_element_empty(soap, "tt:OutputLevelRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:OutputLevelRange", -1, &a->tt__AudioOutputConfigurationOptions::OutputLevelRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioOutputConfigurationOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioOutputConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioOutputConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioOutputConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, tt__AudioOutputConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioOutputConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(tt__AudioOutputConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioOutputConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioOutputConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioOutputConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_OutputLevelRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:OutputTokensAvailable", &a->tt__AudioOutputConfigurationOptions::OutputTokensAvailable, "tt:ReferenceToken"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tt:SendPrimacyOptions", &a->tt__AudioOutputConfigurationOptions::SendPrimacyOptions, "xsd:anyURI"))
					continue;
			}
			if (soap_flag_OutputLevelRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:OutputLevelRange", &a->tt__AudioOutputConfigurationOptions::OutputLevelRange, "tt:IntRange"))
				{	soap_flag_OutputLevelRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioOutputConfigurationOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__AudioOutputConfigurationOptions::OutputTokensAvailable.size() < 1 || !a->tt__AudioOutputConfigurationOptions::OutputLevelRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfigurationOptions, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(tt__AudioOutputConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioOutputConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioOutputConfigurationOptions *p;
	size_t k = sizeof(tt__AudioOutputConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioOutputConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioOutputConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioOutputConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioOutputConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioOutputConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioOutputConfigurationOptions(soap, tag ? tag : "tt:AudioOutputConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioOutputConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioOutputConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioOutputConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioOutputConfigurationOptions(struct soap *soap, tt__AudioOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioOutputConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__AudioOutputConfiguration::OutputToken);
	this->tt__AudioOutputConfiguration::SendPrimacy = NULL;
	soap_default_int(soap, &this->tt__AudioOutputConfiguration::OutputLevel);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioOutputConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioOutputConfiguration::__anyAttribute);
}

void tt__AudioOutputConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AudioOutputConfiguration::OutputToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__AudioOutputConfiguration::OutputToken);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__AudioOutputConfiguration::SendPrimacy);
	soap_embedded(soap, &this->tt__AudioOutputConfiguration::OutputLevel, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioOutputConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioOutputConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioOutputConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioOutputConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioOutputConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutputConfiguration), type ? type : "tt:AudioOutputConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:OutputToken", -1, &a->tt__AudioOutputConfiguration::OutputToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:SendPrimacy", -1, &a->tt__AudioOutputConfiguration::SendPrimacy, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:OutputLevel", -1, &a->tt__AudioOutputConfiguration::OutputLevel, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioOutputConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioOutputConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioOutputConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioOutputConfiguration * SOAP_FMAC4 soap_in_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, tt__AudioOutputConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(tt__AudioOutputConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioOutputConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioOutputConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioOutputConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_OutputToken1 = 1;
	size_t soap_flag_SendPrimacy1 = 1;
	size_t soap_flag_OutputLevel1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_OutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:OutputToken", &a->tt__AudioOutputConfiguration::OutputToken, "tt:ReferenceToken"))
				{	soap_flag_OutputToken1--;
					continue;
				}
			}
			if (soap_flag_SendPrimacy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:SendPrimacy", &a->tt__AudioOutputConfiguration::SendPrimacy, "xsd:anyURI"))
				{	soap_flag_SendPrimacy1--;
					continue;
				}
			}
			if (soap_flag_OutputLevel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:OutputLevel", &a->tt__AudioOutputConfiguration::OutputLevel, "xsd:int"))
				{	soap_flag_OutputLevel1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioOutputConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_OutputToken1 > 0 || soap_flag_OutputLevel1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfiguration, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(tt__AudioOutputConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioOutputConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioOutputConfiguration *p;
	size_t k = sizeof(tt__AudioOutputConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioOutputConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioOutputConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioOutputConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioOutputConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioOutputConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioOutputConfiguration(soap, tag ? tag : "tt:AudioOutputConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioOutputConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioOutputConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioOutputConfiguration * SOAP_FMAC4 soap_get_tt__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioOutput::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__DeviceEntity::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioOutput::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioOutput::__anyAttribute);
}

void tt__AudioOutput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioOutput::__any);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__AudioOutput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioOutput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutput(struct soap *soap, const char *tag, int id, const tt__AudioOutput *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioOutput*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutput), type ? type : "tt:AudioOutput"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioOutput::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioOutput::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioOutput(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioOutput * SOAP_FMAC4 soap_in_tt__AudioOutput(struct soap *soap, const char *tag, tt__AudioOutput *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioOutput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutput, sizeof(tt__AudioOutput), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioOutput)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioOutput *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioOutput*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioOutput::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutput, SOAP_TYPE_tt__AudioOutput, sizeof(tt__AudioOutput), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioOutput * SOAP_FMAC2 soap_instantiate_tt__AudioOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioOutput *p;
	size_t k = sizeof(tt__AudioOutput);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioOutput);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioOutput, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioOutput location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioOutput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioOutput(soap, tag ? tag : "tt:AudioOutput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioOutput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioOutput(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioOutput * SOAP_FMAC4 soap_get_tt__AudioOutput(struct soap *soap, tt__AudioOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoDecoderConfigurationOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoDecoderConfigurationOptionsExtension::__any);
}

void tt__VideoDecoderConfigurationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoDecoderConfigurationOptionsExtension::__any);
#endif
}

int tt__VideoDecoderConfigurationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoDecoderConfigurationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__VideoDecoderConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoDecoderConfigurationOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoDecoderConfigurationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoDecoderConfigurationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__VideoDecoderConfigurationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoDecoderConfigurationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, sizeof(tt__VideoDecoderConfigurationOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoDecoderConfigurationOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoDecoderConfigurationOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoDecoderConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, sizeof(tt__VideoDecoderConfigurationOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoDecoderConfigurationOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoDecoderConfigurationOptionsExtension *p;
	size_t k = sizeof(tt__VideoDecoderConfigurationOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoDecoderConfigurationOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoDecoderConfigurationOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoDecoderConfigurationOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoDecoderConfigurationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoDecoderConfigurationOptionsExtension(soap, tag ? tag : "tt:VideoDecoderConfigurationOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoDecoderConfigurationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoDecoderConfigurationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, tt__VideoDecoderConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoDecoderConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Mpeg4DecOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__Mpeg4DecOptions::ResolutionsAvailable);
	soap_default_std__vectorTemplateOftt__Mpeg4Profile(soap, &this->tt__Mpeg4DecOptions::SupportedMpeg4Profiles);
	this->tt__Mpeg4DecOptions::SupportedInputBitrate = NULL;
	this->tt__Mpeg4DecOptions::SupportedFrameRate = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Mpeg4DecOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__Mpeg4DecOptions::__anyAttribute);
}

void tt__Mpeg4DecOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__Mpeg4DecOptions::ResolutionsAvailable);
	soap_serialize_std__vectorTemplateOftt__Mpeg4Profile(soap, &this->tt__Mpeg4DecOptions::SupportedMpeg4Profiles);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4DecOptions::SupportedInputBitrate);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4DecOptions::SupportedFrameRate);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Mpeg4DecOptions::__any);
#endif
}

int tt__Mpeg4DecOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4DecOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4DecOptions(struct soap *soap, const char *tag, int id, const tt__Mpeg4DecOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Mpeg4DecOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4DecOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__Mpeg4DecOptions::ResolutionsAvailable, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Mpeg4Profile(soap, "tt:SupportedMpeg4Profiles", -1, &a->tt__Mpeg4DecOptions::SupportedMpeg4Profiles, ""))
		return soap->error;
	if (!a->tt__Mpeg4DecOptions::SupportedInputBitrate)
	{	if (soap_element_empty(soap, "tt:SupportedInputBitrate"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", -1, &a->tt__Mpeg4DecOptions::SupportedInputBitrate, ""))
		return soap->error;
	if (!a->tt__Mpeg4DecOptions::SupportedFrameRate)
	{	if (soap_element_empty(soap, "tt:SupportedFrameRate"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:SupportedFrameRate", -1, &a->tt__Mpeg4DecOptions::SupportedFrameRate, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__Mpeg4DecOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4DecOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Mpeg4DecOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4DecOptions * SOAP_FMAC4 soap_in_tt__Mpeg4DecOptions(struct soap *soap, const char *tag, tt__Mpeg4DecOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4DecOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4DecOptions, sizeof(tt__Mpeg4DecOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Mpeg4DecOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Mpeg4DecOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Mpeg4DecOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SupportedInputBitrate1 = 1;
	size_t soap_flag_SupportedFrameRate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__Mpeg4DecOptions::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Mpeg4Profile(soap, "tt:SupportedMpeg4Profiles", &a->tt__Mpeg4DecOptions::SupportedMpeg4Profiles, "tt:Mpeg4Profile"))
					continue;
			}
			if (soap_flag_SupportedInputBitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", &a->tt__Mpeg4DecOptions::SupportedInputBitrate, "tt:IntRange"))
				{	soap_flag_SupportedInputBitrate1--;
					continue;
				}
			}
			if (soap_flag_SupportedFrameRate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:SupportedFrameRate", &a->tt__Mpeg4DecOptions::SupportedFrameRate, "tt:IntRange"))
				{	soap_flag_SupportedFrameRate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__Mpeg4DecOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Mpeg4DecOptions::ResolutionsAvailable.size() < 1 || a->tt__Mpeg4DecOptions::SupportedMpeg4Profiles.size() < 1 || !a->tt__Mpeg4DecOptions::SupportedInputBitrate || !a->tt__Mpeg4DecOptions::SupportedFrameRate))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Mpeg4DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4DecOptions, SOAP_TYPE_tt__Mpeg4DecOptions, sizeof(tt__Mpeg4DecOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Mpeg4DecOptions * SOAP_FMAC2 soap_instantiate_tt__Mpeg4DecOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4DecOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Mpeg4DecOptions *p;
	size_t k = sizeof(tt__Mpeg4DecOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Mpeg4DecOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Mpeg4DecOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Mpeg4DecOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Mpeg4DecOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Mpeg4DecOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Mpeg4DecOptions(soap, tag ? tag : "tt:Mpeg4DecOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4DecOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4DecOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4DecOptions * SOAP_FMAC4 soap_get_tt__Mpeg4DecOptions(struct soap *soap, tt__Mpeg4DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__JpegDecOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__JpegDecOptions::ResolutionsAvailable);
	this->tt__JpegDecOptions::SupportedInputBitrate = NULL;
	this->tt__JpegDecOptions::SupportedFrameRate = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__JpegDecOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__JpegDecOptions::__anyAttribute);
}

void tt__JpegDecOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__JpegDecOptions::ResolutionsAvailable);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegDecOptions::SupportedInputBitrate);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegDecOptions::SupportedFrameRate);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__JpegDecOptions::__any);
#endif
}

int tt__JpegDecOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__JpegDecOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegDecOptions(struct soap *soap, const char *tag, int id, const tt__JpegDecOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__JpegDecOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegDecOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__JpegDecOptions::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__JpegDecOptions::SupportedInputBitrate)
	{	if (soap_element_empty(soap, "tt:SupportedInputBitrate"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", -1, &a->tt__JpegDecOptions::SupportedInputBitrate, ""))
		return soap->error;
	if (!a->tt__JpegDecOptions::SupportedFrameRate)
	{	if (soap_element_empty(soap, "tt:SupportedFrameRate"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:SupportedFrameRate", -1, &a->tt__JpegDecOptions::SupportedFrameRate, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__JpegDecOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__JpegDecOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__JpegDecOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__JpegDecOptions * SOAP_FMAC4 soap_in_tt__JpegDecOptions(struct soap *soap, const char *tag, tt__JpegDecOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__JpegDecOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegDecOptions, sizeof(tt__JpegDecOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__JpegDecOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__JpegDecOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__JpegDecOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SupportedInputBitrate1 = 1;
	size_t soap_flag_SupportedFrameRate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__JpegDecOptions::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_SupportedInputBitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", &a->tt__JpegDecOptions::SupportedInputBitrate, "tt:IntRange"))
				{	soap_flag_SupportedInputBitrate1--;
					continue;
				}
			}
			if (soap_flag_SupportedFrameRate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:SupportedFrameRate", &a->tt__JpegDecOptions::SupportedFrameRate, "tt:IntRange"))
				{	soap_flag_SupportedFrameRate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__JpegDecOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__JpegDecOptions::ResolutionsAvailable.size() < 1 || !a->tt__JpegDecOptions::SupportedInputBitrate || !a->tt__JpegDecOptions::SupportedFrameRate))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__JpegDecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegDecOptions, SOAP_TYPE_tt__JpegDecOptions, sizeof(tt__JpegDecOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__JpegDecOptions * SOAP_FMAC2 soap_instantiate_tt__JpegDecOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__JpegDecOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__JpegDecOptions *p;
	size_t k = sizeof(tt__JpegDecOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__JpegDecOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__JpegDecOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__JpegDecOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__JpegDecOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__JpegDecOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__JpegDecOptions(soap, tag ? tag : "tt:JpegDecOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__JpegDecOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__JpegDecOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__JpegDecOptions * SOAP_FMAC4 soap_get_tt__JpegDecOptions(struct soap *soap, tt__JpegDecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegDecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__H264DecOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__H264DecOptions::ResolutionsAvailable);
	soap_default_std__vectorTemplateOftt__H264Profile(soap, &this->tt__H264DecOptions::SupportedH264Profiles);
	this->tt__H264DecOptions::SupportedInputBitrate = NULL;
	this->tt__H264DecOptions::SupportedFrameRate = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__H264DecOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__H264DecOptions::__anyAttribute);
}

void tt__H264DecOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__H264DecOptions::ResolutionsAvailable);
	soap_serialize_std__vectorTemplateOftt__H264Profile(soap, &this->tt__H264DecOptions::SupportedH264Profiles);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264DecOptions::SupportedInputBitrate);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264DecOptions::SupportedFrameRate);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__H264DecOptions::__any);
#endif
}

int tt__H264DecOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264DecOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264DecOptions(struct soap *soap, const char *tag, int id, const tt__H264DecOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__H264DecOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264DecOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__H264DecOptions::ResolutionsAvailable, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__H264Profile(soap, "tt:SupportedH264Profiles", -1, &a->tt__H264DecOptions::SupportedH264Profiles, ""))
		return soap->error;
	if (!a->tt__H264DecOptions::SupportedInputBitrate)
	{	if (soap_element_empty(soap, "tt:SupportedInputBitrate"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", -1, &a->tt__H264DecOptions::SupportedInputBitrate, ""))
		return soap->error;
	if (!a->tt__H264DecOptions::SupportedFrameRate)
	{	if (soap_element_empty(soap, "tt:SupportedFrameRate"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:SupportedFrameRate", -1, &a->tt__H264DecOptions::SupportedFrameRate, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__H264DecOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__H264DecOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__H264DecOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264DecOptions * SOAP_FMAC4 soap_in_tt__H264DecOptions(struct soap *soap, const char *tag, tt__H264DecOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264DecOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264DecOptions, sizeof(tt__H264DecOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__H264DecOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__H264DecOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__H264DecOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SupportedInputBitrate1 = 1;
	size_t soap_flag_SupportedFrameRate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__H264DecOptions::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__H264Profile(soap, "tt:SupportedH264Profiles", &a->tt__H264DecOptions::SupportedH264Profiles, "tt:H264Profile"))
					continue;
			}
			if (soap_flag_SupportedInputBitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", &a->tt__H264DecOptions::SupportedInputBitrate, "tt:IntRange"))
				{	soap_flag_SupportedInputBitrate1--;
					continue;
				}
			}
			if (soap_flag_SupportedFrameRate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:SupportedFrameRate", &a->tt__H264DecOptions::SupportedFrameRate, "tt:IntRange"))
				{	soap_flag_SupportedFrameRate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__H264DecOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__H264DecOptions::ResolutionsAvailable.size() < 1 || a->tt__H264DecOptions::SupportedH264Profiles.size() < 1 || !a->tt__H264DecOptions::SupportedInputBitrate || !a->tt__H264DecOptions::SupportedFrameRate))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__H264DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264DecOptions, SOAP_TYPE_tt__H264DecOptions, sizeof(tt__H264DecOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__H264DecOptions * SOAP_FMAC2 soap_instantiate_tt__H264DecOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264DecOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__H264DecOptions *p;
	size_t k = sizeof(tt__H264DecOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__H264DecOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__H264DecOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__H264DecOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__H264DecOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__H264DecOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__H264DecOptions(soap, tag ? tag : "tt:H264DecOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264DecOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264DecOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264DecOptions * SOAP_FMAC4 soap_get_tt__H264DecOptions(struct soap *soap, tt__H264DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoDecoderConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__VideoDecoderConfigurationOptions::JpegDecOptions = NULL;
	this->tt__VideoDecoderConfigurationOptions::H264DecOptions = NULL;
	this->tt__VideoDecoderConfigurationOptions::Mpeg4DecOptions = NULL;
	this->tt__VideoDecoderConfigurationOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoDecoderConfigurationOptions::__anyAttribute);
}

void tt__VideoDecoderConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__JpegDecOptions(soap, &this->tt__VideoDecoderConfigurationOptions::JpegDecOptions);
	soap_serialize_PointerTott__H264DecOptions(soap, &this->tt__VideoDecoderConfigurationOptions::H264DecOptions);
	soap_serialize_PointerTott__Mpeg4DecOptions(soap, &this->tt__VideoDecoderConfigurationOptions::Mpeg4DecOptions);
	soap_serialize_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, &this->tt__VideoDecoderConfigurationOptions::Extension);
#endif
}

int tt__VideoDecoderConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoDecoderConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__VideoDecoderConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoDecoderConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_PointerTott__JpegDecOptions(soap, "tt:JpegDecOptions", -1, &a->tt__VideoDecoderConfigurationOptions::JpegDecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__H264DecOptions(soap, "tt:H264DecOptions", -1, &a->tt__VideoDecoderConfigurationOptions::H264DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4DecOptions(soap, "tt:Mpeg4DecOptions", -1, &a->tt__VideoDecoderConfigurationOptions::Mpeg4DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->tt__VideoDecoderConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoDecoderConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoDecoderConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoDecoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, tt__VideoDecoderConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoDecoderConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, sizeof(tt__VideoDecoderConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoDecoderConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoDecoderConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoDecoderConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_JpegDecOptions1 = 1;
	size_t soap_flag_H264DecOptions1 = 1;
	size_t soap_flag_Mpeg4DecOptions1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JpegDecOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__JpegDecOptions(soap, "tt:JpegDecOptions", &a->tt__VideoDecoderConfigurationOptions::JpegDecOptions, "tt:JpegDecOptions"))
				{	soap_flag_JpegDecOptions1--;
					continue;
				}
			}
			if (soap_flag_H264DecOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__H264DecOptions(soap, "tt:H264DecOptions", &a->tt__VideoDecoderConfigurationOptions::H264DecOptions, "tt:H264DecOptions"))
				{	soap_flag_H264DecOptions1--;
					continue;
				}
			}
			if (soap_flag_Mpeg4DecOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Mpeg4DecOptions(soap, "tt:Mpeg4DecOptions", &a->tt__VideoDecoderConfigurationOptions::Mpeg4DecOptions, "tt:Mpeg4DecOptions"))
				{	soap_flag_Mpeg4DecOptions1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, "tt:Extension", &a->tt__VideoDecoderConfigurationOptions::Extension, "tt:VideoDecoderConfigurationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoDecoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, sizeof(tt__VideoDecoderConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoDecoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoDecoderConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoDecoderConfigurationOptions *p;
	size_t k = sizeof(tt__VideoDecoderConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoDecoderConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoDecoderConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoDecoderConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoDecoderConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoDecoderConfigurationOptions(soap, tag ? tag : "tt:VideoDecoderConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoDecoderConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoDecoderConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoDecoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoDecoderConfigurationOptions(struct soap *soap, tt__VideoDecoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoOutputConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoOutputConfigurationOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoOutputConfigurationOptions::__anyAttribute);
}

void tt__VideoOutputConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoOutputConfigurationOptions::__any);
#endif
}

int tt__VideoOutputConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoOutputConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__VideoOutputConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoOutputConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutputConfigurationOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoOutputConfigurationOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoOutputConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoOutputConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoOutputConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoOutputConfigurationOptions(struct soap *soap, const char *tag, tt__VideoOutputConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoOutputConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputConfigurationOptions, sizeof(tt__VideoOutputConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoOutputConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoOutputConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoOutputConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoOutputConfigurationOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputConfigurationOptions, SOAP_TYPE_tt__VideoOutputConfigurationOptions, sizeof(tt__VideoOutputConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoOutputConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoOutputConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoOutputConfigurationOptions *p;
	size_t k = sizeof(tt__VideoOutputConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoOutputConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoOutputConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoOutputConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoOutputConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoOutputConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoOutputConfigurationOptions(soap, tag ? tag : "tt:VideoOutputConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoOutputConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoOutputConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoOutputConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoOutputConfigurationOptions(struct soap *soap, tt__VideoOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoOutputConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__VideoOutputConfiguration::OutputToken);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoOutputConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoOutputConfiguration::__anyAttribute);
}

void tt__VideoOutputConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoOutputConfiguration::OutputToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__VideoOutputConfiguration::OutputToken);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoOutputConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__VideoOutputConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoOutputConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutputConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoOutputConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoOutputConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutputConfiguration), type ? type : "tt:VideoOutputConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:OutputToken", -1, &a->tt__VideoOutputConfiguration::OutputToken, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoOutputConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoOutputConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoOutputConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoOutputConfiguration * SOAP_FMAC4 soap_in_tt__VideoOutputConfiguration(struct soap *soap, const char *tag, tt__VideoOutputConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(tt__VideoOutputConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoOutputConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoOutputConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoOutputConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_OutputToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_OutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:OutputToken", &a->tt__VideoOutputConfiguration::OutputToken, "tt:ReferenceToken"))
				{	soap_flag_OutputToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoOutputConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_OutputToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputConfiguration, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(tt__VideoOutputConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoOutputConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoOutputConfiguration *p;
	size_t k = sizeof(tt__VideoOutputConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoOutputConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoOutputConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoOutputConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoOutputConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoOutputConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoOutputConfiguration(soap, tag ? tag : "tt:VideoOutputConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoOutputConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoOutputConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoOutputConfiguration * SOAP_FMAC4 soap_get_tt__VideoOutputConfiguration(struct soap *soap, tt__VideoOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoOutputExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoOutputExtension::__any);
}

void tt__VideoOutputExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoOutputExtension::__any);
#endif
}

int tt__VideoOutputExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoOutputExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutputExtension(struct soap *soap, const char *tag, int id, const tt__VideoOutputExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutputExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoOutputExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoOutputExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoOutputExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoOutputExtension * SOAP_FMAC4 soap_in_tt__VideoOutputExtension(struct soap *soap, const char *tag, tt__VideoOutputExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoOutputExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputExtension, sizeof(tt__VideoOutputExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoOutputExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoOutputExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoOutputExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoOutputExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputExtension, SOAP_TYPE_tt__VideoOutputExtension, sizeof(tt__VideoOutputExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoOutputExtension * SOAP_FMAC2 soap_instantiate_tt__VideoOutputExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoOutputExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoOutputExtension *p;
	size_t k = sizeof(tt__VideoOutputExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoOutputExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoOutputExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoOutputExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoOutputExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoOutputExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoOutputExtension(soap, tag ? tag : "tt:VideoOutputExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoOutputExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoOutputExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoOutputExtension * SOAP_FMAC4 soap_get_tt__VideoOutputExtension(struct soap *soap, tt__VideoOutputExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoOutput::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__DeviceEntity::soap_default(soap);
	this->tt__VideoOutput::Layout = NULL;
	this->tt__VideoOutput::Resolution = NULL;
	this->tt__VideoOutput::RefreshRate = NULL;
	this->tt__VideoOutput::AspectRatio = NULL;
	this->tt__VideoOutput::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoOutput::__anyAttribute);
}

void tt__VideoOutput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Layout(soap, &this->tt__VideoOutput::Layout);
	soap_serialize_PointerTott__VideoResolution(soap, &this->tt__VideoOutput::Resolution);
	soap_serialize_PointerTofloat(soap, &this->tt__VideoOutput::RefreshRate);
	soap_serialize_PointerTofloat(soap, &this->tt__VideoOutput::AspectRatio);
	soap_serialize_PointerTott__VideoOutputExtension(soap, &this->tt__VideoOutput::Extension);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__VideoOutput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoOutput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutput(struct soap *soap, const char *tag, int id, const tt__VideoOutput *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoOutput*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutput), type ? type : "tt:VideoOutput"))
		return soap->error;
	if (!a->tt__VideoOutput::Layout)
	{	if (soap_element_empty(soap, "tt:Layout"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Layout(soap, "tt:Layout", -1, &a->tt__VideoOutput::Layout, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->tt__VideoOutput::Resolution, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:RefreshRate", -1, &a->tt__VideoOutput::RefreshRate, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:AspectRatio", -1, &a->tt__VideoOutput::AspectRatio, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoOutputExtension(soap, "tt:Extension", -1, &a->tt__VideoOutput::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoOutput::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoOutput(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoOutput * SOAP_FMAC4 soap_in_tt__VideoOutput(struct soap *soap, const char *tag, tt__VideoOutput *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoOutput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutput, sizeof(tt__VideoOutput), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoOutput)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoOutput *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoOutput*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Layout1 = 1;
	size_t soap_flag_Resolution1 = 1;
	size_t soap_flag_RefreshRate1 = 1;
	size_t soap_flag_AspectRatio1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Layout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Layout(soap, "tt:Layout", &a->tt__VideoOutput::Layout, "tt:Layout"))
				{	soap_flag_Layout1--;
					continue;
				}
			}
			if (soap_flag_Resolution1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->tt__VideoOutput::Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution1--;
					continue;
				}
			}
			if (soap_flag_RefreshRate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:RefreshRate", &a->tt__VideoOutput::RefreshRate, "xsd:float"))
				{	soap_flag_RefreshRate1--;
					continue;
				}
			}
			if (soap_flag_AspectRatio1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:AspectRatio", &a->tt__VideoOutput::AspectRatio, "xsd:float"))
				{	soap_flag_AspectRatio1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoOutputExtension(soap, "tt:Extension", &a->tt__VideoOutput::Extension, "tt:VideoOutputExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__VideoOutput::Layout))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutput, SOAP_TYPE_tt__VideoOutput, sizeof(tt__VideoOutput), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoOutput * SOAP_FMAC2 soap_instantiate_tt__VideoOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoOutput *p;
	size_t k = sizeof(tt__VideoOutput);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoOutput);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoOutput, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoOutput location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoOutput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoOutput(soap, tag ? tag : "tt:VideoOutput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoOutput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoOutput(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoOutput * SOAP_FMAC4 soap_get_tt__VideoOutput(struct soap *soap, tt__VideoOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZStatusFilterOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZStatusFilterOptionsExtension::__any);
}

void tt__PTZStatusFilterOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZStatusFilterOptionsExtension::__any);
#endif
}

int tt__PTZStatusFilterOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZStatusFilterOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, int id, const tt__PTZStatusFilterOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZStatusFilterOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZStatusFilterOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZStatusFilterOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZStatusFilterOptionsExtension * SOAP_FMAC4 soap_in_tt__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, tt__PTZStatusFilterOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZStatusFilterOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, sizeof(tt__PTZStatusFilterOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZStatusFilterOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZStatusFilterOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZStatusFilterOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZStatusFilterOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, sizeof(tt__PTZStatusFilterOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZStatusFilterOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZStatusFilterOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZStatusFilterOptionsExtension *p;
	size_t k = sizeof(tt__PTZStatusFilterOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZStatusFilterOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZStatusFilterOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZStatusFilterOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZStatusFilterOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZStatusFilterOptionsExtension(soap, tag ? tag : "tt:PTZStatusFilterOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZStatusFilterOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZStatusFilterOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZStatusFilterOptionsExtension * SOAP_FMAC4 soap_get_tt__PTZStatusFilterOptionsExtension(struct soap *soap, tt__PTZStatusFilterOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatusFilterOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZStatusFilterOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__PTZStatusFilterOptions::PanTiltStatusSupported);
	soap_default_bool(soap, &this->tt__PTZStatusFilterOptions::ZoomStatusSupported);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZStatusFilterOptions::__any);
	this->tt__PTZStatusFilterOptions::PanTiltPositionSupported = NULL;
	this->tt__PTZStatusFilterOptions::ZoomPositionSupported = NULL;
	this->tt__PTZStatusFilterOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZStatusFilterOptions::__anyAttribute);
}

void tt__PTZStatusFilterOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZStatusFilterOptions::PanTiltStatusSupported, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__PTZStatusFilterOptions::ZoomStatusSupported, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZStatusFilterOptions::__any);
	soap_serialize_PointerTobool(soap, &this->tt__PTZStatusFilterOptions::PanTiltPositionSupported);
	soap_serialize_PointerTobool(soap, &this->tt__PTZStatusFilterOptions::ZoomPositionSupported);
	soap_serialize_PointerTott__PTZStatusFilterOptionsExtension(soap, &this->tt__PTZStatusFilterOptions::Extension);
#endif
}

int tt__PTZStatusFilterOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZStatusFilterOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatusFilterOptions(struct soap *soap, const char *tag, int id, const tt__PTZStatusFilterOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZStatusFilterOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatusFilterOptions), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:PanTiltStatusSupported", -1, &a->tt__PTZStatusFilterOptions::PanTiltStatusSupported, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:ZoomStatusSupported", -1, &a->tt__PTZStatusFilterOptions::ZoomStatusSupported, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZStatusFilterOptions::__any, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:PanTiltPositionSupported", -1, &a->tt__PTZStatusFilterOptions::PanTiltPositionSupported, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:ZoomPositionSupported", -1, &a->tt__PTZStatusFilterOptions::ZoomPositionSupported, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZStatusFilterOptionsExtension(soap, "tt:Extension", -1, &a->tt__PTZStatusFilterOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZStatusFilterOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZStatusFilterOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZStatusFilterOptions * SOAP_FMAC4 soap_in_tt__PTZStatusFilterOptions(struct soap *soap, const char *tag, tt__PTZStatusFilterOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZStatusFilterOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(tt__PTZStatusFilterOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZStatusFilterOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZStatusFilterOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZStatusFilterOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_PanTiltStatusSupported1 = 1;
	size_t soap_flag_ZoomStatusSupported1 = 1;
	size_t soap_flag_PanTiltPositionSupported1 = 1;
	size_t soap_flag_ZoomPositionSupported1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTiltStatusSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:PanTiltStatusSupported", &a->tt__PTZStatusFilterOptions::PanTiltStatusSupported, "xsd:boolean"))
				{	soap_flag_PanTiltStatusSupported1--;
					continue;
				}
			}
			if (soap_flag_ZoomStatusSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:ZoomStatusSupported", &a->tt__PTZStatusFilterOptions::ZoomStatusSupported, "xsd:boolean"))
				{	soap_flag_ZoomStatusSupported1--;
					continue;
				}
			}
			if (soap_flag_PanTiltPositionSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:PanTiltPositionSupported", &a->tt__PTZStatusFilterOptions::PanTiltPositionSupported, "xsd:boolean"))
				{	soap_flag_PanTiltPositionSupported1--;
					continue;
				}
			}
			if (soap_flag_ZoomPositionSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:ZoomPositionSupported", &a->tt__PTZStatusFilterOptions::ZoomPositionSupported, "xsd:boolean"))
				{	soap_flag_ZoomPositionSupported1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZStatusFilterOptionsExtension(soap, "tt:Extension", &a->tt__PTZStatusFilterOptions::Extension, "tt:PTZStatusFilterOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZStatusFilterOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PanTiltStatusSupported1 > 0 || soap_flag_ZoomStatusSupported1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZStatusFilterOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatusFilterOptions, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(tt__PTZStatusFilterOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZStatusFilterOptions * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZStatusFilterOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZStatusFilterOptions *p;
	size_t k = sizeof(tt__PTZStatusFilterOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZStatusFilterOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZStatusFilterOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZStatusFilterOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZStatusFilterOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZStatusFilterOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZStatusFilterOptions(soap, tag ? tag : "tt:PTZStatusFilterOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZStatusFilterOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZStatusFilterOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZStatusFilterOptions * SOAP_FMAC4 soap_get_tt__PTZStatusFilterOptions(struct soap *soap, tt__PTZStatusFilterOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatusFilterOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataConfigurationOptionsExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataConfigurationOptionsExtension2::__any);
}

void tt__MetadataConfigurationOptionsExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataConfigurationOptionsExtension2::__any);
#endif
}

int tt__MetadataConfigurationOptionsExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfigurationOptionsExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, const tt__MetadataConfigurationOptionsExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MetadataConfigurationOptionsExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataConfigurationOptionsExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataConfigurationOptionsExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC4 soap_in_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, const char *tag, tt__MetadataConfigurationOptionsExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataConfigurationOptionsExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, sizeof(tt__MetadataConfigurationOptionsExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataConfigurationOptionsExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MetadataConfigurationOptionsExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MetadataConfigurationOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, sizeof(tt__MetadataConfigurationOptionsExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataConfigurationOptionsExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataConfigurationOptionsExtension2 *p;
	size_t k = sizeof(tt__MetadataConfigurationOptionsExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataConfigurationOptionsExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataConfigurationOptionsExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataConfigurationOptionsExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataConfigurationOptionsExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataConfigurationOptionsExtension2(soap, tag ? tag : "tt:MetadataConfigurationOptionsExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfigurationOptionsExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfigurationOptionsExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC4 soap_get_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, tt__MetadataConfigurationOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataConfigurationOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__MetadataConfigurationOptionsExtension::CompressionType);
	this->tt__MetadataConfigurationOptionsExtension::Extension = NULL;
}

void tt__MetadataConfigurationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__MetadataConfigurationOptionsExtension::CompressionType);
	soap_serialize_PointerTott__MetadataConfigurationOptionsExtension2(soap, &this->tt__MetadataConfigurationOptionsExtension::Extension);
#endif
}

int tt__MetadataConfigurationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfigurationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__MetadataConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:CompressionType", -1, &a->tt__MetadataConfigurationOptionsExtension::CompressionType, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfigurationOptionsExtension2(soap, "tt:Extension", -1, &a->tt__MetadataConfigurationOptionsExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataConfigurationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataConfigurationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__MetadataConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__MetadataConfigurationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataConfigurationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, sizeof(tt__MetadataConfigurationOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataConfigurationOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataConfigurationOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:CompressionType", &a->tt__MetadataConfigurationOptionsExtension::CompressionType, "xsd:string"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataConfigurationOptionsExtension2(soap, "tt:Extension", &a->tt__MetadataConfigurationOptionsExtension::Extension, "tt:MetadataConfigurationOptionsExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MetadataConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, sizeof(tt__MetadataConfigurationOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataConfigurationOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataConfigurationOptionsExtension *p;
	size_t k = sizeof(tt__MetadataConfigurationOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataConfigurationOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataConfigurationOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataConfigurationOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataConfigurationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataConfigurationOptionsExtension(soap, tag ? tag : "tt:MetadataConfigurationOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfigurationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfigurationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__MetadataConfigurationOptionsExtension(struct soap *soap, tt__MetadataConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__MetadataConfigurationOptions::PTZStatusFilterOptions = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataConfigurationOptions::__any);
	this->tt__MetadataConfigurationOptions::Extension = NULL;
	this->tt__MetadataConfigurationOptions::GeoLocation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__MetadataConfigurationOptions::__anyAttribute);
}

void tt__MetadataConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZStatusFilterOptions(soap, &this->tt__MetadataConfigurationOptions::PTZStatusFilterOptions);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataConfigurationOptions::__any);
	soap_serialize_PointerTott__MetadataConfigurationOptionsExtension(soap, &this->tt__MetadataConfigurationOptions::Extension);
#endif
}

int tt__MetadataConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__MetadataConfigurationOptions *a, const char *type)
{
	if (((tt__MetadataConfigurationOptions*)a)->GeoLocation)
	{	soap_set_attr(soap, "GeoLocation", soap_bool2s(soap, *((tt__MetadataConfigurationOptions*)a)->GeoLocation), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MetadataConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationOptions), type))
		return soap->error;
	if (!a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions)
	{	if (soap_element_empty(soap, "tt:PTZStatusFilterOptions"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZStatusFilterOptions(soap, "tt:PTZStatusFilterOptions", -1, &a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MetadataConfigurationOptions::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->tt__MetadataConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptions * SOAP_FMAC4 soap_in_tt__MetadataConfigurationOptions(struct soap *soap, const char *tag, tt__MetadataConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(tt__MetadataConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "GeoLocation", 5, 0);
		if (t)
		{
			if (!(((tt__MetadataConfigurationOptions*)a)->GeoLocation = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__MetadataConfigurationOptions*)a)->GeoLocation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MetadataConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_PTZStatusFilterOptions1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatusFilterOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZStatusFilterOptions(soap, "tt:PTZStatusFilterOptions", &a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions, "tt:PTZStatusFilterOptions"))
				{	soap_flag_PTZStatusFilterOptions1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataConfigurationOptionsExtension(soap, "tt:Extension", &a->tt__MetadataConfigurationOptions::Extension, "tt:MetadataConfigurationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MetadataConfigurationOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MetadataConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptions, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(tt__MetadataConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataConfigurationOptions *p;
	size_t k = sizeof(tt__MetadataConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataConfigurationOptions(soap, tag ? tag : "tt:MetadataConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptions * SOAP_FMAC4 soap_get_tt__MetadataConfigurationOptions(struct soap *soap, tt__MetadataConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EventSubscription::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__EventSubscription::Filter = NULL;
	this->tt__EventSubscription::SubscriptionPolicy = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EventSubscription::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__EventSubscription::__anyAttribute);
}

void tt__EventSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__FilterType(soap, &this->tt__EventSubscription::Filter);
	soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, &this->tt__EventSubscription::SubscriptionPolicy);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EventSubscription::__any);
#endif
}

int tt__EventSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EventSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventSubscription(struct soap *soap, const char *tag, int id, const tt__EventSubscription *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__EventSubscription*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventSubscription), type))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tt:Filter", -1, &a->tt__EventSubscription::Filter, ""))
		return soap->error;
	if (soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, "tt:SubscriptionPolicy", -1, &a->tt__EventSubscription::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__EventSubscription::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EventSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EventSubscription(soap, tag, this, type);
}

SOAP_FMAC3 tt__EventSubscription * SOAP_FMAC4 soap_in_tt__EventSubscription(struct soap *soap, const char *tag, tt__EventSubscription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EventSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventSubscription, sizeof(tt__EventSubscription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EventSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EventSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__EventSubscription*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "tt:Filter", &a->tt__EventSubscription::Filter, "wsnt:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, "tt:SubscriptionPolicy", &a->tt__EventSubscription::SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__EventSubscription::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EventSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventSubscription, SOAP_TYPE_tt__EventSubscription, sizeof(tt__EventSubscription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EventSubscription * SOAP_FMAC2 soap_instantiate_tt__EventSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EventSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EventSubscription *p;
	size_t k = sizeof(tt__EventSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EventSubscription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EventSubscription);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EventSubscription, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EventSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EventSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EventSubscription(soap, tag ? tag : "tt:EventSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EventSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EventSubscription(soap, this, tag, type);
}

SOAP_FMAC3 tt__EventSubscription * SOAP_FMAC4 soap_get_tt__EventSubscription(struct soap *soap, tt__EventSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZFilter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__PTZFilter::Status);
	soap_default_bool(soap, &this->tt__PTZFilter::Position);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZFilter::__anyAttribute);
}

void tt__PTZFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZFilter::Status, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__PTZFilter::Position, SOAP_TYPE_bool);
#endif
}

int tt__PTZFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZFilter(struct soap *soap, const char *tag, int id, const tt__PTZFilter *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZFilter*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZFilter), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:Status", -1, &a->tt__PTZFilter::Status, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Position", -1, &a->tt__PTZFilter::Position, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZFilter(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZFilter * SOAP_FMAC4 soap_in_tt__PTZFilter(struct soap *soap, const char *tag, tt__PTZFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZFilter, sizeof(tt__PTZFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZFilter*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_Position1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Status", &a->tt__PTZFilter::Status, "xsd:boolean"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Position", &a->tt__PTZFilter::Position, "xsd:boolean"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status1 > 0 || soap_flag_Position1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZFilter, SOAP_TYPE_tt__PTZFilter, sizeof(tt__PTZFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZFilter * SOAP_FMAC2 soap_instantiate_tt__PTZFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZFilter *p;
	size_t k = sizeof(tt__PTZFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZFilter(soap, tag ? tag : "tt:PTZFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZFilter(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZFilter * SOAP_FMAC4 soap_get_tt__PTZFilter(struct soap *soap, tt__PTZFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataConfigurationExtension::__any);
}

void tt__MetadataConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataConfigurationExtension::__any);
#endif
}

int tt__MetadataConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__MetadataConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MetadataConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_in_tt__MetadataConfigurationExtension(struct soap *soap, const char *tag, tt__MetadataConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(tt__MetadataConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MetadataConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MetadataConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationExtension, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(tt__MetadataConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataConfigurationExtension *p;
	size_t k = sizeof(tt__MetadataConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataConfigurationExtension(soap, tag ? tag : "tt:MetadataConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_get_tt__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	this->tt__MetadataConfiguration::PTZStatus = NULL;
	this->tt__MetadataConfiguration::Events = NULL;
	this->tt__MetadataConfiguration::Analytics = NULL;
	this->tt__MetadataConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__MetadataConfiguration::SessionTimeout);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataConfiguration::__any);
	this->tt__MetadataConfiguration::AnalyticsEngineConfiguration = NULL;
	this->tt__MetadataConfiguration::Extension = NULL;
	this->tt__MetadataConfiguration::CompressionType = NULL;
	this->tt__MetadataConfiguration::GeoLocation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__MetadataConfiguration::__anyAttribute);
}

void tt__MetadataConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZFilter(soap, &this->tt__MetadataConfiguration::PTZStatus);
	soap_serialize_PointerTott__EventSubscription(soap, &this->tt__MetadataConfiguration::Events);
	soap_serialize_PointerTobool(soap, &this->tt__MetadataConfiguration::Analytics);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__MetadataConfiguration::Multicast);
	soap_embedded(soap, &this->tt__MetadataConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__MetadataConfiguration::SessionTimeout);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataConfiguration::__any);
	soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, &this->tt__MetadataConfiguration::AnalyticsEngineConfiguration);
	soap_serialize_PointerTott__MetadataConfigurationExtension(soap, &this->tt__MetadataConfiguration::Extension);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__MetadataConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfiguration(struct soap *soap, const char *tag, int id, const tt__MetadataConfiguration *a, const char *type)
{
	if (((tt__MetadataConfiguration*)a)->CompressionType)
	{	soap_set_attr(soap, "CompressionType", soap_std__string2s(soap, *((tt__MetadataConfiguration*)a)->CompressionType), 1);
	}
	if (((tt__MetadataConfiguration*)a)->GeoLocation)
	{	soap_set_attr(soap, "GeoLocation", soap_bool2s(soap, *((tt__MetadataConfiguration*)a)->GeoLocation), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MetadataConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfiguration), type ? type : "tt:MetadataConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZFilter(soap, "tt:PTZStatus", -1, &a->tt__MetadataConfiguration::PTZStatus, ""))
		return soap->error;
	if (soap_out_PointerTott__EventSubscription(soap, "tt:Events", -1, &a->tt__MetadataConfiguration::Events, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Analytics", -1, &a->tt__MetadataConfiguration::Analytics, ""))
		return soap->error;
	if (!a->tt__MetadataConfiguration::Multicast)
	{	if (soap_element_empty(soap, "tt:Multicast"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__MetadataConfiguration::Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->tt__MetadataConfiguration::SessionTimeout, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MetadataConfiguration::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->tt__MetadataConfiguration::AnalyticsEngineConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfigurationExtension(soap, "tt:Extension", -1, &a->tt__MetadataConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfiguration * SOAP_FMAC4 soap_in_tt__MetadataConfiguration(struct soap *soap, const char *tag, tt__MetadataConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(tt__MetadataConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "CompressionType", 1, 0);
		if (t)
		{
			if (!(((tt__MetadataConfiguration*)a)->CompressionType = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((tt__MetadataConfiguration*)a)->CompressionType))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoLocation", 5, 0);
		if (t)
		{
			if (!(((tt__MetadataConfiguration*)a)->GeoLocation = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__MetadataConfiguration*)a)->GeoLocation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MetadataConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_PTZStatus1 = 1;
	size_t soap_flag_Events1 = 1;
	size_t soap_flag_Analytics1 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	size_t soap_flag_AnalyticsEngineConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_PTZStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZFilter(soap, "tt:PTZStatus", &a->tt__MetadataConfiguration::PTZStatus, "tt:PTZFilter"))
				{	soap_flag_PTZStatus1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EventSubscription(soap, "tt:Events", &a->tt__MetadataConfiguration::Events, "tt:EventSubscription"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap_flag_Analytics1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Analytics", &a->tt__MetadataConfiguration::Analytics, "xsd:boolean"))
				{	soap_flag_Analytics1--;
					continue;
				}
			}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->tt__MetadataConfiguration::Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			}
			if (soap_flag_SessionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->tt__MetadataConfiguration::SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->tt__MetadataConfiguration::AnalyticsEngineConfiguration, "tt:AnalyticsEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataConfigurationExtension(soap, "tt:Extension", &a->tt__MetadataConfiguration::Extension, "tt:MetadataConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MetadataConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || !a->tt__MetadataConfiguration::Multicast || soap_flag_SessionTimeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfiguration, SOAP_TYPE_tt__MetadataConfiguration, sizeof(tt__MetadataConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfiguration * SOAP_FMAC2 soap_instantiate_tt__MetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataConfiguration *p;
	size_t k = sizeof(tt__MetadataConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataConfiguration(soap, tag ? tag : "tt:MetadataConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfiguration * SOAP_FMAC4 soap_get_tt__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoAnalyticsConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	this->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration = NULL;
	this->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoAnalyticsConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoAnalyticsConfiguration::__anyAttribute);
}

void tt__VideoAnalyticsConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, &this->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration);
	soap_serialize_PointerTott__RuleEngineConfiguration(soap, &this->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoAnalyticsConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__VideoAnalyticsConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoAnalyticsConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoAnalyticsConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoAnalyticsConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration), type ? type : "tt:VideoAnalyticsConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (!a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration)
	{	if (soap_element_empty(soap, "tt:AnalyticsEngineConfiguration"))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration, ""))
		return soap->error;
	if (!a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration)
	{	if (soap_element_empty(soap, "tt:RuleEngineConfiguration"))
			return soap->error;
	}
	else if (soap_out_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", -1, &a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoAnalyticsConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoAnalyticsConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoAnalyticsConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_in_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, tt__VideoAnalyticsConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoAnalyticsConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(tt__VideoAnalyticsConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoAnalyticsConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoAnalyticsConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoAnalyticsConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_AnalyticsEngineConfiguration1 = 1;
	size_t soap_flag_RuleEngineConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration, "tt:AnalyticsEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration1--;
					continue;
				}
			}
			if (soap_flag_RuleEngineConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", &a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration, "tt:RuleEngineConfiguration"))
				{	soap_flag_RuleEngineConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoAnalyticsConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || !a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration || !a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsConfiguration, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(tt__VideoAnalyticsConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoAnalyticsConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoAnalyticsConfiguration *p;
	size_t k = sizeof(tt__VideoAnalyticsConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoAnalyticsConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoAnalyticsConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoAnalyticsConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoAnalyticsConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoAnalyticsConfiguration(soap, tag ? tag : "tt:VideoAnalyticsConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoAnalyticsConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoAnalyticsConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_get_tt__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioEncoder2ConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__AudioEncoder2ConfigurationOptions::Encoding);
	this->tt__AudioEncoder2ConfigurationOptions::BitrateList = NULL;
	this->tt__AudioEncoder2ConfigurationOptions::SampleRateList = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioEncoder2ConfigurationOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioEncoder2ConfigurationOptions::__anyAttribute);
}

void tt__AudioEncoder2ConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AudioEncoder2ConfigurationOptions::Encoding, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__AudioEncoder2ConfigurationOptions::Encoding);
	soap_serialize_PointerTott__IntList(soap, &this->tt__AudioEncoder2ConfigurationOptions::BitrateList);
	soap_serialize_PointerTott__IntList(soap, &this->tt__AudioEncoder2ConfigurationOptions::SampleRateList);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioEncoder2ConfigurationOptions::__any);
#endif
}

int tt__AudioEncoder2ConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoder2ConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoder2ConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioEncoder2ConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioEncoder2ConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Encoding", -1, &a->tt__AudioEncoder2ConfigurationOptions::Encoding, ""))
		return soap->error;
	if (!a->tt__AudioEncoder2ConfigurationOptions::BitrateList)
	{	if (soap_element_empty(soap, "tt:BitrateList"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntList(soap, "tt:BitrateList", -1, &a->tt__AudioEncoder2ConfigurationOptions::BitrateList, ""))
		return soap->error;
	if (!a->tt__AudioEncoder2ConfigurationOptions::SampleRateList)
	{	if (soap_element_empty(soap, "tt:SampleRateList"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntList(soap, "tt:SampleRateList", -1, &a->tt__AudioEncoder2ConfigurationOptions::SampleRateList, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioEncoder2ConfigurationOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoder2ConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioEncoder2ConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoder2ConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioEncoder2ConfigurationOptions(struct soap *soap, const char *tag, tt__AudioEncoder2ConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoder2ConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions, sizeof(tt__AudioEncoder2ConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioEncoder2ConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioEncoder2ConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_BitrateList1 = 1;
	size_t soap_flag_SampleRateList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Encoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Encoding", &a->tt__AudioEncoder2ConfigurationOptions::Encoding, "xsd:string"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_BitrateList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntList(soap, "tt:BitrateList", &a->tt__AudioEncoder2ConfigurationOptions::BitrateList, "tt:IntList"))
				{	soap_flag_BitrateList1--;
					continue;
				}
			}
			if (soap_flag_SampleRateList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntList(soap, "tt:SampleRateList", &a->tt__AudioEncoder2ConfigurationOptions::SampleRateList, "tt:IntList"))
				{	soap_flag_SampleRateList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioEncoder2ConfigurationOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding1 > 0 || !a->tt__AudioEncoder2ConfigurationOptions::BitrateList || !a->tt__AudioEncoder2ConfigurationOptions::SampleRateList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioEncoder2ConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions, sizeof(tt__AudioEncoder2ConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioEncoder2ConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoder2ConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoder2ConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioEncoder2ConfigurationOptions *p;
	size_t k = sizeof(tt__AudioEncoder2ConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioEncoder2ConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioEncoder2ConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioEncoder2ConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioEncoder2ConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioEncoder2ConfigurationOptions(soap, tag ? tag : "tt:AudioEncoder2ConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoder2ConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoder2ConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoder2ConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioEncoder2ConfigurationOptions(struct soap *soap, tt__AudioEncoder2ConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoder2ConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioEncoder2Configuration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_std__string(soap, &this->tt__AudioEncoder2Configuration::Encoding);
	this->tt__AudioEncoder2Configuration::Multicast = NULL;
	soap_default_int(soap, &this->tt__AudioEncoder2Configuration::Bitrate);
	soap_default_int(soap, &this->tt__AudioEncoder2Configuration::SampleRate);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioEncoder2Configuration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioEncoder2Configuration::__anyAttribute);
}

void tt__AudioEncoder2Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AudioEncoder2Configuration::Encoding, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__AudioEncoder2Configuration::Encoding);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__AudioEncoder2Configuration::Multicast);
	soap_embedded(soap, &this->tt__AudioEncoder2Configuration::Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__AudioEncoder2Configuration::SampleRate, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioEncoder2Configuration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioEncoder2Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoder2Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoder2Configuration(struct soap *soap, const char *tag, int id, const tt__AudioEncoder2Configuration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioEncoder2Configuration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoder2Configuration), type ? type : "tt:AudioEncoder2Configuration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Encoding", -1, &a->tt__AudioEncoder2Configuration::Encoding, ""))
		return soap->error;
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__AudioEncoder2Configuration::Multicast, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Bitrate", -1, &a->tt__AudioEncoder2Configuration::Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SampleRate", -1, &a->tt__AudioEncoder2Configuration::SampleRate, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioEncoder2Configuration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoder2Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioEncoder2Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoder2Configuration * SOAP_FMAC4 soap_in_tt__AudioEncoder2Configuration(struct soap *soap, const char *tag, tt__AudioEncoder2Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoder2Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoder2Configuration, sizeof(tt__AudioEncoder2Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioEncoder2Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioEncoder2Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioEncoder2Configuration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_SampleRate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_Encoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Encoding", &a->tt__AudioEncoder2Configuration::Encoding, "xsd:string"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->tt__AudioEncoder2Configuration::Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			}
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Bitrate", &a->tt__AudioEncoder2Configuration::Bitrate, "xsd:int"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			}
			if (soap_flag_SampleRate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:SampleRate", &a->tt__AudioEncoder2Configuration::SampleRate, "xsd:int"))
				{	soap_flag_SampleRate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioEncoder2Configuration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Encoding1 > 0 || soap_flag_Bitrate1 > 0 || soap_flag_SampleRate1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioEncoder2Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoder2Configuration, SOAP_TYPE_tt__AudioEncoder2Configuration, sizeof(tt__AudioEncoder2Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioEncoder2Configuration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoder2Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoder2Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioEncoder2Configuration *p;
	size_t k = sizeof(tt__AudioEncoder2Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioEncoder2Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioEncoder2Configuration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioEncoder2Configuration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioEncoder2Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioEncoder2Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioEncoder2Configuration(soap, tag ? tag : "tt:AudioEncoder2Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoder2Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoder2Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoder2Configuration * SOAP_FMAC4 soap_get_tt__AudioEncoder2Configuration(struct soap *soap, tt__AudioEncoder2Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoder2Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioEncoderConfigurationOption::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__AudioEncoding(soap, &this->tt__AudioEncoderConfigurationOption::Encoding);
	this->tt__AudioEncoderConfigurationOption::BitrateList = NULL;
	this->tt__AudioEncoderConfigurationOption::SampleRateList = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioEncoderConfigurationOption::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioEncoderConfigurationOption::__anyAttribute);
}

void tt__AudioEncoderConfigurationOption::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntList(soap, &this->tt__AudioEncoderConfigurationOption::BitrateList);
	soap_serialize_PointerTott__IntList(soap, &this->tt__AudioEncoderConfigurationOption::SampleRateList);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioEncoderConfigurationOption::__any);
#endif
}

int tt__AudioEncoderConfigurationOption::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfigurationOption(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfigurationOption *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioEncoderConfigurationOption*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption), type))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &a->tt__AudioEncoderConfigurationOption::Encoding, ""))
		return soap->error;
	if (!a->tt__AudioEncoderConfigurationOption::BitrateList)
	{	if (soap_element_empty(soap, "tt:BitrateList"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntList(soap, "tt:BitrateList", -1, &a->tt__AudioEncoderConfigurationOption::BitrateList, ""))
		return soap->error;
	if (!a->tt__AudioEncoderConfigurationOption::SampleRateList)
	{	if (soap_element_empty(soap, "tt:SampleRateList"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntList(soap, "tt:SampleRateList", -1, &a->tt__AudioEncoderConfigurationOption::SampleRateList, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioEncoderConfigurationOption::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfigurationOption::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioEncoderConfigurationOption(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_in_tt__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, tt__AudioEncoderConfigurationOption *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfigurationOption*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(tt__AudioEncoderConfigurationOption), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioEncoderConfigurationOption)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioEncoderConfigurationOption *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioEncoderConfigurationOption*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_BitrateList1 = 1;
	size_t soap_flag_SampleRateList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &a->tt__AudioEncoderConfigurationOption::Encoding, "tt:AudioEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_BitrateList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntList(soap, "tt:BitrateList", &a->tt__AudioEncoderConfigurationOption::BitrateList, "tt:IntList"))
				{	soap_flag_BitrateList1--;
					continue;
				}
			}
			if (soap_flag_SampleRateList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntList(soap, "tt:SampleRateList", &a->tt__AudioEncoderConfigurationOption::SampleRateList, "tt:IntList"))
				{	soap_flag_SampleRateList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioEncoderConfigurationOption::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding1 > 0 || !a->tt__AudioEncoderConfigurationOption::BitrateList || !a->tt__AudioEncoderConfigurationOption::SampleRateList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfigurationOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOption, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(tt__AudioEncoderConfigurationOption), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioEncoderConfigurationOption * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoderConfigurationOption(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioEncoderConfigurationOption *p;
	size_t k = sizeof(tt__AudioEncoderConfigurationOption);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioEncoderConfigurationOption, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioEncoderConfigurationOption);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioEncoderConfigurationOption, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioEncoderConfigurationOption location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioEncoderConfigurationOption::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioEncoderConfigurationOption(soap, tag ? tag : "tt:AudioEncoderConfigurationOption", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfigurationOption::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfigurationOption(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_get_tt__AudioEncoderConfigurationOption(struct soap *soap, tt__AudioEncoderConfigurationOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfigurationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioEncoderConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, &this->tt__AudioEncoderConfigurationOptions::Options);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioEncoderConfigurationOptions::__anyAttribute);
}

void tt__AudioEncoderConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, &this->tt__AudioEncoderConfigurationOptions::Options);
#endif
}

int tt__AudioEncoderConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioEncoderConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, "tt:Options", -1, &a->tt__AudioEncoderConfigurationOptions::Options, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, tt__AudioEncoderConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(tt__AudioEncoderConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioEncoderConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioEncoderConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioEncoderConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, "tt:Options", &a->tt__AudioEncoderConfigurationOptions::Options, "tt:AudioEncoderConfigurationOption"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(tt__AudioEncoderConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoderConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioEncoderConfigurationOptions *p;
	size_t k = sizeof(tt__AudioEncoderConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioEncoderConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioEncoderConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioEncoderConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioEncoderConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioEncoderConfigurationOptions(soap, tag ? tag : "tt:AudioEncoderConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioEncoderConfigurationOptions(struct soap *soap, tt__AudioEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioEncoderConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__AudioEncoding(soap, &this->tt__AudioEncoderConfiguration::Encoding);
	soap_default_int(soap, &this->tt__AudioEncoderConfiguration::Bitrate);
	soap_default_int(soap, &this->tt__AudioEncoderConfiguration::SampleRate);
	this->tt__AudioEncoderConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioEncoderConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioEncoderConfiguration::__anyAttribute);
}

void tt__AudioEncoderConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::SampleRate, SOAP_TYPE_int);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__AudioEncoderConfiguration::Multicast);
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioEncoderConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioEncoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioEncoderConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfiguration), type ? type : "tt:AudioEncoderConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &a->tt__AudioEncoderConfiguration::Encoding, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Bitrate", -1, &a->tt__AudioEncoderConfiguration::Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SampleRate", -1, &a->tt__AudioEncoderConfiguration::SampleRate, ""))
		return soap->error;
	if (!a->tt__AudioEncoderConfiguration::Multicast)
	{	if (soap_element_empty(soap, "tt:Multicast"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__AudioEncoderConfiguration::Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->tt__AudioEncoderConfiguration::SessionTimeout, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioEncoderConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioEncoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, tt__AudioEncoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioEncoderConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioEncoderConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioEncoderConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_SampleRate1 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &a->tt__AudioEncoderConfiguration::Encoding, "tt:AudioEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Bitrate", &a->tt__AudioEncoderConfiguration::Bitrate, "xsd:int"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			}
			if (soap_flag_SampleRate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:SampleRate", &a->tt__AudioEncoderConfiguration::SampleRate, "xsd:int"))
				{	soap_flag_SampleRate1--;
					continue;
				}
			}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->tt__AudioEncoderConfiguration::Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			}
			if (soap_flag_SessionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->tt__AudioEncoderConfiguration::SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioEncoderConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Encoding1 > 0 || soap_flag_Bitrate1 > 0 || soap_flag_SampleRate1 > 0 || !a->tt__AudioEncoderConfiguration::Multicast || soap_flag_SessionTimeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfiguration, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioEncoderConfiguration *p;
	size_t k = sizeof(tt__AudioEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioEncoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioEncoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioEncoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioEncoderConfiguration(soap, tag ? tag : "tt:AudioEncoderConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioSourceOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioSourceOptionsExtension::__any);
}

void tt__AudioSourceOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioSourceOptionsExtension::__any);
#endif
}

int tt__AudioSourceOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceOptionsExtension(struct soap *soap, const char *tag, int id, const tt__AudioSourceOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioSourceOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSourceOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioSourceOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_in_tt__AudioSourceOptionsExtension(struct soap *soap, const char *tag, tt__AudioSourceOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSourceOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(tt__AudioSourceOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioSourceOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioSourceOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioSourceOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioSourceOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceOptionsExtension, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(tt__AudioSourceOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioSourceOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioSourceOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSourceOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioSourceOptionsExtension *p;
	size_t k = sizeof(tt__AudioSourceOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioSourceOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioSourceOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioSourceOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioSourceOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioSourceOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioSourceOptionsExtension(soap, tag ? tag : "tt:AudioSourceOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_get_tt__AudioSourceOptionsExtension(struct soap *soap, tt__AudioSourceOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioSourceConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AudioSourceConfigurationOptions::InputTokensAvailable);
	this->tt__AudioSourceConfigurationOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioSourceConfigurationOptions::__anyAttribute);
}

void tt__AudioSourceConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AudioSourceConfigurationOptions::InputTokensAvailable);
	soap_serialize_PointerTott__AudioSourceOptionsExtension(soap, &this->tt__AudioSourceConfigurationOptions::Extension);
#endif
}

int tt__AudioSourceConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioSourceConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioSourceConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:InputTokensAvailable", -1, &a->tt__AudioSourceConfigurationOptions::InputTokensAvailable, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", -1, &a->tt__AudioSourceConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSourceConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioSourceConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, tt__AudioSourceConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSourceConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(tt__AudioSourceConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioSourceConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioSourceConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioSourceConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:InputTokensAvailable", &a->tt__AudioSourceConfigurationOptions::InputTokensAvailable, "tt:ReferenceToken"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", &a->tt__AudioSourceConfigurationOptions::Extension, "tt:AudioSourceOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__AudioSourceConfigurationOptions::InputTokensAvailable.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfigurationOptions, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(tt__AudioSourceConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSourceConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioSourceConfigurationOptions *p;
	size_t k = sizeof(tt__AudioSourceConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioSourceConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioSourceConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioSourceConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioSourceConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioSourceConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioSourceConfigurationOptions(soap, tag ? tag : "tt:AudioSourceConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioSourceConfigurationOptions(struct soap *soap, tt__AudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioSourceConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__AudioSourceConfiguration::SourceToken);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioSourceConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioSourceConfiguration::__anyAttribute);
}

void tt__AudioSourceConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AudioSourceConfiguration::SourceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__AudioSourceConfiguration::SourceToken);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioSourceConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioSourceConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioSourceConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioSourceConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfiguration), type ? type : "tt:AudioSourceConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &a->tt__AudioSourceConfiguration::SourceToken, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioSourceConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSourceConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioSourceConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceConfiguration * SOAP_FMAC4 soap_in_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, tt__AudioSourceConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioSourceConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioSourceConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioSourceConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_SourceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_SourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &a->tt__AudioSourceConfiguration::SourceToken, "tt:ReferenceToken"))
				{	soap_flag_SourceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioSourceConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_SourceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfiguration, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioSourceConfiguration *p;
	size_t k = sizeof(tt__AudioSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioSourceConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioSourceConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioSourceConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioSourceConfiguration(soap, tag ? tag : "tt:AudioSourceConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceConfiguration * SOAP_FMAC4 soap_get_tt__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoder2ConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__VideoEncoder2ConfigurationOptions::Encoding);
	this->tt__VideoEncoder2ConfigurationOptions::QualityRange = NULL;
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution2(soap, &this->tt__VideoEncoder2ConfigurationOptions::ResolutionsAvailable);
	this->tt__VideoEncoder2ConfigurationOptions::BitrateRange = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoder2ConfigurationOptions::__any);
	this->tt__VideoEncoder2ConfigurationOptions::GovLengthRange = NULL;
	this->tt__VideoEncoder2ConfigurationOptions::FrameRatesSupported = NULL;
	this->tt__VideoEncoder2ConfigurationOptions::ProfilesSupported = NULL;
	this->tt__VideoEncoder2ConfigurationOptions::ConstantBitRateSupported = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoEncoder2ConfigurationOptions::__anyAttribute);
}

void tt__VideoEncoder2ConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoEncoder2ConfigurationOptions::Encoding, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__VideoEncoder2ConfigurationOptions::Encoding);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__VideoEncoder2ConfigurationOptions::QualityRange);
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution2(soap, &this->tt__VideoEncoder2ConfigurationOptions::ResolutionsAvailable);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__VideoEncoder2ConfigurationOptions::BitrateRange);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoder2ConfigurationOptions::__any);
#endif
}

int tt__VideoEncoder2ConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoder2ConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoder2ConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__VideoEncoder2ConfigurationOptions *a, const char *type)
{
	if (((tt__VideoEncoder2ConfigurationOptions*)a)->GovLengthRange)
	{	soap_set_attr(soap, "GovLengthRange", soap_tt__IntAttrList2s(soap, *((tt__VideoEncoder2ConfigurationOptions*)a)->GovLengthRange), 1);
	}
	if (((tt__VideoEncoder2ConfigurationOptions*)a)->FrameRatesSupported)
	{	soap_set_attr(soap, "FrameRatesSupported", soap_tt__FloatAttrList2s(soap, *((tt__VideoEncoder2ConfigurationOptions*)a)->FrameRatesSupported), 1);
	}
	if (((tt__VideoEncoder2ConfigurationOptions*)a)->ProfilesSupported)
	{	soap_set_attr(soap, "ProfilesSupported", soap_tt__StringAttrList2s(soap, *((tt__VideoEncoder2ConfigurationOptions*)a)->ProfilesSupported), 1);
	}
	if (((tt__VideoEncoder2ConfigurationOptions*)a)->ConstantBitRateSupported)
	{	soap_set_attr(soap, "ConstantBitRateSupported", soap_bool2s(soap, *((tt__VideoEncoder2ConfigurationOptions*)a)->ConstantBitRateSupported), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoEncoder2ConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Encoding", -1, &a->tt__VideoEncoder2ConfigurationOptions::Encoding, ""))
		return soap->error;
	if (!a->tt__VideoEncoder2ConfigurationOptions::QualityRange)
	{	if (soap_element_empty(soap, "tt:QualityRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:QualityRange", -1, &a->tt__VideoEncoder2ConfigurationOptions::QualityRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution2(soap, "tt:ResolutionsAvailable", -1, &a->tt__VideoEncoder2ConfigurationOptions::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__VideoEncoder2ConfigurationOptions::BitrateRange)
	{	if (soap_element_empty(soap, "tt:BitrateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->tt__VideoEncoder2ConfigurationOptions::BitrateRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoEncoder2ConfigurationOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoder2ConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoder2ConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoder2ConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoEncoder2ConfigurationOptions(struct soap *soap, const char *tag, tt__VideoEncoder2ConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoder2ConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions, sizeof(tt__VideoEncoder2ConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoEncoder2ConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "GovLengthRange", 1, 0);
		if (t)
		{
			if (!(((tt__VideoEncoder2ConfigurationOptions*)a)->GovLengthRange = soap_new_tt__IntAttrList(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__IntAttrList(soap, t, ((tt__VideoEncoder2ConfigurationOptions*)a)->GovLengthRange))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "FrameRatesSupported", 1, 0);
		if (t)
		{
			if (!(((tt__VideoEncoder2ConfigurationOptions*)a)->FrameRatesSupported = soap_new_tt__FloatAttrList(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__FloatAttrList(soap, t, ((tt__VideoEncoder2ConfigurationOptions*)a)->FrameRatesSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "ProfilesSupported", 1, 0);
		if (t)
		{
			if (!(((tt__VideoEncoder2ConfigurationOptions*)a)->ProfilesSupported = soap_new_tt__StringAttrList(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__StringAttrList(soap, t, ((tt__VideoEncoder2ConfigurationOptions*)a)->ProfilesSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "ConstantBitRateSupported", 5, 0);
		if (t)
		{
			if (!(((tt__VideoEncoder2ConfigurationOptions*)a)->ConstantBitRateSupported = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__VideoEncoder2ConfigurationOptions*)a)->ConstantBitRateSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoEncoder2ConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_QualityRange1 = 1;
	size_t soap_flag_BitrateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Encoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Encoding", &a->tt__VideoEncoder2ConfigurationOptions::Encoding, "xsd:string"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_QualityRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:QualityRange", &a->tt__VideoEncoder2ConfigurationOptions::QualityRange, "tt:FloatRange"))
				{	soap_flag_QualityRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution2(soap, "tt:ResolutionsAvailable", &a->tt__VideoEncoder2ConfigurationOptions::ResolutionsAvailable, "tt:VideoResolution2"))
					continue;
			}
			if (soap_flag_BitrateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->tt__VideoEncoder2ConfigurationOptions::BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoEncoder2ConfigurationOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding1 > 0 || !a->tt__VideoEncoder2ConfigurationOptions::QualityRange || a->tt__VideoEncoder2ConfigurationOptions::ResolutionsAvailable.size() < 1 || !a->tt__VideoEncoder2ConfigurationOptions::BitrateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoEncoder2ConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions, sizeof(tt__VideoEncoder2ConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoder2ConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoder2ConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoder2ConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoder2ConfigurationOptions *p;
	size_t k = sizeof(tt__VideoEncoder2ConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoder2ConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoder2ConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoder2ConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoder2ConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoder2ConfigurationOptions(soap, tag ? tag : "tt:VideoEncoder2ConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoder2ConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoder2ConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoder2ConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoEncoder2ConfigurationOptions(struct soap *soap, tt__VideoEncoder2ConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoder2ConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoRateControl2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__VideoRateControl2::FrameRateLimit);
	soap_default_int(soap, &this->tt__VideoRateControl2::BitrateLimit);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoRateControl2::__any);
	this->tt__VideoRateControl2::ConstantBitRate = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoRateControl2::__anyAttribute);
}

void tt__VideoRateControl2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoRateControl2::FrameRateLimit, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__VideoRateControl2::BitrateLimit, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoRateControl2::__any);
#endif
}

int tt__VideoRateControl2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoRateControl2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoRateControl2(struct soap *soap, const char *tag, int id, const tt__VideoRateControl2 *a, const char *type)
{
	if (((tt__VideoRateControl2*)a)->ConstantBitRate)
	{	soap_set_attr(soap, "ConstantBitRate", soap_bool2s(soap, *((tt__VideoRateControl2*)a)->ConstantBitRate), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoRateControl2*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoRateControl2), type))
		return soap->error;
	if (soap_out_float(soap, "tt:FrameRateLimit", -1, &a->tt__VideoRateControl2::FrameRateLimit, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:BitrateLimit", -1, &a->tt__VideoRateControl2::BitrateLimit, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoRateControl2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoRateControl2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoRateControl2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoRateControl2 * SOAP_FMAC4 soap_in_tt__VideoRateControl2(struct soap *soap, const char *tag, tt__VideoRateControl2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoRateControl2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl2, sizeof(tt__VideoRateControl2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoRateControl2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoRateControl2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "ConstantBitRate", 5, 0);
		if (t)
		{
			if (!(((tt__VideoRateControl2*)a)->ConstantBitRate = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__VideoRateControl2*)a)->ConstantBitRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoRateControl2*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_FrameRateLimit1 = 1;
	size_t soap_flag_BitrateLimit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FrameRateLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:FrameRateLimit", &a->tt__VideoRateControl2::FrameRateLimit, "xsd:float"))
				{	soap_flag_FrameRateLimit1--;
					continue;
				}
			}
			if (soap_flag_BitrateLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:BitrateLimit", &a->tt__VideoRateControl2::BitrateLimit, "xsd:int"))
				{	soap_flag_BitrateLimit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoRateControl2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit1 > 0 || soap_flag_BitrateLimit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoRateControl2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl2, SOAP_TYPE_tt__VideoRateControl2, sizeof(tt__VideoRateControl2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoRateControl2 * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoRateControl2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoRateControl2 *p;
	size_t k = sizeof(tt__VideoRateControl2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoRateControl2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoRateControl2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoRateControl2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoRateControl2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoRateControl2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoRateControl2(soap, tag ? tag : "tt:VideoRateControl2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoRateControl2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoRateControl2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoRateControl2 * SOAP_FMAC4 soap_get_tt__VideoRateControl2(struct soap *soap, tt__VideoRateControl2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoRateControl2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoResolution2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__VideoResolution2::Width);
	soap_default_int(soap, &this->tt__VideoResolution2::Height);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoResolution2::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoResolution2::__anyAttribute);
}

void tt__VideoResolution2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoResolution2::Width, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoResolution2::Height, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoResolution2::__any);
#endif
}

int tt__VideoResolution2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoResolution2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoResolution2(struct soap *soap, const char *tag, int id, const tt__VideoResolution2 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoResolution2*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoResolution2), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &a->tt__VideoResolution2::Width, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &a->tt__VideoResolution2::Height, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoResolution2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoResolution2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoResolution2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoResolution2 * SOAP_FMAC4 soap_in_tt__VideoResolution2(struct soap *soap, const char *tag, tt__VideoResolution2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoResolution2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution2, sizeof(tt__VideoResolution2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoResolution2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoResolution2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoResolution2*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Width1 = 1;
	size_t soap_flag_Height1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Width", &a->tt__VideoResolution2::Width, "xsd:int"))
				{	soap_flag_Width1--;
					continue;
				}
			}
			if (soap_flag_Height1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Height", &a->tt__VideoResolution2::Height, "xsd:int"))
				{	soap_flag_Height1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoResolution2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width1 > 0 || soap_flag_Height1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoResolution2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution2, SOAP_TYPE_tt__VideoResolution2, sizeof(tt__VideoResolution2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoResolution2 * SOAP_FMAC2 soap_instantiate_tt__VideoResolution2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoResolution2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoResolution2 *p;
	size_t k = sizeof(tt__VideoResolution2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoResolution2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoResolution2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoResolution2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoResolution2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoResolution2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoResolution2(soap, tag ? tag : "tt:VideoResolution2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoResolution2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoResolution2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoResolution2 * SOAP_FMAC4 soap_get_tt__VideoResolution2(struct soap *soap, tt__VideoResolution2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoResolution2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoder2Configuration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_std__string(soap, &this->tt__VideoEncoder2Configuration::Encoding);
	this->tt__VideoEncoder2Configuration::Resolution = NULL;
	this->tt__VideoEncoder2Configuration::RateControl = NULL;
	this->tt__VideoEncoder2Configuration::Multicast = NULL;
	soap_default_float(soap, &this->tt__VideoEncoder2Configuration::Quality);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoder2Configuration::__any);
	this->tt__VideoEncoder2Configuration::GovLength = NULL;
	this->tt__VideoEncoder2Configuration::Profile = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoEncoder2Configuration::__anyAttribute);
}

void tt__VideoEncoder2Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoEncoder2Configuration::Encoding, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__VideoEncoder2Configuration::Encoding);
	soap_serialize_PointerTott__VideoResolution2(soap, &this->tt__VideoEncoder2Configuration::Resolution);
	soap_serialize_PointerTott__VideoRateControl2(soap, &this->tt__VideoEncoder2Configuration::RateControl);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__VideoEncoder2Configuration::Multicast);
	soap_embedded(soap, &this->tt__VideoEncoder2Configuration::Quality, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoder2Configuration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__VideoEncoder2Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoder2Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoder2Configuration(struct soap *soap, const char *tag, int id, const tt__VideoEncoder2Configuration *a, const char *type)
{
	if (((tt__VideoEncoder2Configuration*)a)->GovLength)
	{	soap_set_attr(soap, "GovLength", soap_int2s(soap, *((tt__VideoEncoder2Configuration*)a)->GovLength), 1);
	}
	if (((tt__VideoEncoder2Configuration*)a)->Profile)
	{	soap_set_attr(soap, "Profile", soap_std__string2s(soap, *((tt__VideoEncoder2Configuration*)a)->Profile), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoEncoder2Configuration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoder2Configuration), type ? type : "tt:VideoEncoder2Configuration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Encoding", -1, &a->tt__VideoEncoder2Configuration::Encoding, ""))
		return soap->error;
	if (!a->tt__VideoEncoder2Configuration::Resolution)
	{	if (soap_element_empty(soap, "tt:Resolution"))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoResolution2(soap, "tt:Resolution", -1, &a->tt__VideoEncoder2Configuration::Resolution, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoRateControl2(soap, "tt:RateControl", -1, &a->tt__VideoEncoder2Configuration::RateControl, ""))
		return soap->error;
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__VideoEncoder2Configuration::Multicast, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Quality", -1, &a->tt__VideoEncoder2Configuration::Quality, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoEncoder2Configuration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoder2Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoder2Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoder2Configuration * SOAP_FMAC4 soap_in_tt__VideoEncoder2Configuration(struct soap *soap, const char *tag, tt__VideoEncoder2Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoder2Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoder2Configuration, sizeof(tt__VideoEncoder2Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoder2Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoEncoder2Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "GovLength", 5, 0);
		if (t)
		{
			if (!(((tt__VideoEncoder2Configuration*)a)->GovLength = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__VideoEncoder2Configuration*)a)->GovLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Profile", 1, 0);
		if (t)
		{
			if (!(((tt__VideoEncoder2Configuration*)a)->Profile = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((tt__VideoEncoder2Configuration*)a)->Profile))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoEncoder2Configuration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Resolution1 = 1;
	size_t soap_flag_RateControl1 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_Quality1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_Encoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Encoding", &a->tt__VideoEncoder2Configuration::Encoding, "xsd:string"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_Resolution1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution2(soap, "tt:Resolution", &a->tt__VideoEncoder2Configuration::Resolution, "tt:VideoResolution2"))
				{	soap_flag_Resolution1--;
					continue;
				}
			}
			if (soap_flag_RateControl1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoRateControl2(soap, "tt:RateControl", &a->tt__VideoEncoder2Configuration::RateControl, "tt:VideoRateControl2"))
				{	soap_flag_RateControl1--;
					continue;
				}
			}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->tt__VideoEncoder2Configuration::Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			}
			if (soap_flag_Quality1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Quality", &a->tt__VideoEncoder2Configuration::Quality, "xsd:float"))
				{	soap_flag_Quality1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoEncoder2Configuration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Encoding1 > 0 || !a->tt__VideoEncoder2Configuration::Resolution || soap_flag_Quality1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoEncoder2Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoder2Configuration, SOAP_TYPE_tt__VideoEncoder2Configuration, sizeof(tt__VideoEncoder2Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoder2Configuration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoder2Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoder2Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoder2Configuration *p;
	size_t k = sizeof(tt__VideoEncoder2Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoder2Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoder2Configuration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoder2Configuration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoder2Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoder2Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoder2Configuration(soap, tag ? tag : "tt:VideoEncoder2Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoder2Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoder2Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoder2Configuration * SOAP_FMAC4 soap_get_tt__VideoEncoder2Configuration(struct soap *soap, tt__VideoEncoder2Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoder2Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__H264Options2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__H264Options::soap_default(soap);
	this->tt__H264Options2::BitrateRange = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__H264Options2::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__H264Options2::__anyAttribute);
}

void tt__H264Options2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options2::BitrateRange);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__H264Options2::__any);
	this->tt__H264Options::soap_serialize(soap);
#endif
}

int tt__H264Options2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Options2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options2(struct soap *soap, const char *tag, int id, const tt__H264Options2 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__H264Options2*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options2), type ? type : "tt:H264Options2"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__H264Options::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__H264Options::GovLengthRange)
	{	if (soap_element_empty(soap, "tt:GovLengthRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__H264Options::GovLengthRange, ""))
		return soap->error;
	if (!a->tt__H264Options::FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__H264Options::FrameRateRange, ""))
		return soap->error;
	if (!a->tt__H264Options::EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__H264Options::EncodingIntervalRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__H264Profile(soap, "tt:H264ProfilesSupported", -1, &a->tt__H264Options::H264ProfilesSupported, ""))
		return soap->error;
	if (!a->tt__H264Options2::BitrateRange)
	{	if (soap_element_empty(soap, "tt:BitrateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->tt__H264Options2::BitrateRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__H264Options2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__H264Options2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__H264Options2(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Options2 * SOAP_FMAC4 soap_in_tt__H264Options2(struct soap *soap, const char *tag, tt__H264Options2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264Options2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options2, sizeof(tt__H264Options2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__H264Options2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__H264Options2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__H264Options2*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_GovLengthRange2 = 1;
	size_t soap_flag_FrameRateRange2 = 1;
	size_t soap_flag_EncodingIntervalRange2 = 1;
	size_t soap_flag_BitrateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__H264Options::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_GovLengthRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->tt__H264Options::GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange2--;
					continue;
				}
			}
			if (soap_flag_FrameRateRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->tt__H264Options::FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange2--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->tt__H264Options::EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__H264Profile(soap, "tt:H264ProfilesSupported", &a->tt__H264Options::H264ProfilesSupported, "tt:H264Profile"))
					continue;
			}
			if (soap_flag_BitrateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->tt__H264Options2::BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__H264Options2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__H264Options::ResolutionsAvailable.size() < 1 || !a->tt__H264Options::GovLengthRange || !a->tt__H264Options::FrameRateRange || !a->tt__H264Options::EncodingIntervalRange || a->tt__H264Options::H264ProfilesSupported.size() < 1 || !a->tt__H264Options2::BitrateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__H264Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options2, SOAP_TYPE_tt__H264Options2, sizeof(tt__H264Options2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__H264Options2 * SOAP_FMAC2 soap_instantiate_tt__H264Options2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264Options2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__H264Options2 *p;
	size_t k = sizeof(tt__H264Options2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__H264Options2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__H264Options2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__H264Options2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__H264Options2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__H264Options2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__H264Options2(soap, tag ? tag : "tt:H264Options2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Options2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Options2(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Options2 * SOAP_FMAC4 soap_get_tt__H264Options2(struct soap *soap, tt__H264Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__H264Options::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__H264Options::ResolutionsAvailable);
	this->tt__H264Options::GovLengthRange = NULL;
	this->tt__H264Options::FrameRateRange = NULL;
	this->tt__H264Options::EncodingIntervalRange = NULL;
	soap_default_std__vectorTemplateOftt__H264Profile(soap, &this->tt__H264Options::H264ProfilesSupported);
}

void tt__H264Options::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__H264Options::ResolutionsAvailable);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options::GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options::FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options::EncodingIntervalRange);
	soap_serialize_std__vectorTemplateOftt__H264Profile(soap, &this->tt__H264Options::H264ProfilesSupported);
#endif
}

int tt__H264Options::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Options(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options(struct soap *soap, const char *tag, int id, const tt__H264Options *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__H264Options::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__H264Options::GovLengthRange)
	{	if (soap_element_empty(soap, "tt:GovLengthRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__H264Options::GovLengthRange, ""))
		return soap->error;
	if (!a->tt__H264Options::FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__H264Options::FrameRateRange, ""))
		return soap->error;
	if (!a->tt__H264Options::EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__H264Options::EncodingIntervalRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__H264Profile(soap, "tt:H264ProfilesSupported", -1, &a->tt__H264Options::H264ProfilesSupported, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__H264Options::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__H264Options(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Options * SOAP_FMAC4 soap_in_tt__H264Options(struct soap *soap, const char *tag, tt__H264Options *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264Options*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options, sizeof(tt__H264Options), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__H264Options)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__H264Options *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_GovLengthRange1 = 1;
	size_t soap_flag_FrameRateRange1 = 1;
	size_t soap_flag_EncodingIntervalRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__H264Options::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_GovLengthRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->tt__H264Options::GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange1--;
					continue;
				}
			}
			if (soap_flag_FrameRateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->tt__H264Options::FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange1--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->tt__H264Options::EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__H264Profile(soap, "tt:H264ProfilesSupported", &a->tt__H264Options::H264ProfilesSupported, "tt:H264Profile"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__H264Options::ResolutionsAvailable.size() < 1 || !a->tt__H264Options::GovLengthRange || !a->tt__H264Options::FrameRateRange || !a->tt__H264Options::EncodingIntervalRange || a->tt__H264Options::H264ProfilesSupported.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__H264Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options, SOAP_TYPE_tt__H264Options, sizeof(tt__H264Options), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__H264Options * SOAP_FMAC2 soap_instantiate_tt__H264Options(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264Options(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tt:H264Options2"))
		return soap_instantiate_tt__H264Options2(soap, n, NULL, NULL, size);
	tt__H264Options *p;
	size_t k = sizeof(tt__H264Options);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__H264Options, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__H264Options);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__H264Options, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__H264Options location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__H264Options::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__H264Options(soap, tag ? tag : "tt:H264Options", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Options::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Options(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Options * SOAP_FMAC4 soap_get_tt__H264Options(struct soap *soap, tt__H264Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Mpeg4Options2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__Mpeg4Options::soap_default(soap);
	this->tt__Mpeg4Options2::BitrateRange = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Mpeg4Options2::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__Mpeg4Options2::__anyAttribute);
}

void tt__Mpeg4Options2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options2::BitrateRange);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Mpeg4Options2::__any);
	this->tt__Mpeg4Options::soap_serialize(soap);
#endif
}

int tt__Mpeg4Options2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Options2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options2(struct soap *soap, const char *tag, int id, const tt__Mpeg4Options2 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Mpeg4Options2*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options2), type ? type : "tt:Mpeg4Options2"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__Mpeg4Options::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options::GovLengthRange)
	{	if (soap_element_empty(soap, "tt:GovLengthRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__Mpeg4Options::GovLengthRange, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options::FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__Mpeg4Options::FrameRateRange, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options::EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__Mpeg4Options::EncodingIntervalRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, &a->tt__Mpeg4Options::Mpeg4ProfilesSupported, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options2::BitrateRange)
	{	if (soap_element_empty(soap, "tt:BitrateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->tt__Mpeg4Options2::BitrateRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__Mpeg4Options2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4Options2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Mpeg4Options2(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Options2 * SOAP_FMAC4 soap_in_tt__Mpeg4Options2(struct soap *soap, const char *tag, tt__Mpeg4Options2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4Options2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(tt__Mpeg4Options2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Mpeg4Options2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Mpeg4Options2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Mpeg4Options2*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_GovLengthRange2 = 1;
	size_t soap_flag_FrameRateRange2 = 1;
	size_t soap_flag_EncodingIntervalRange2 = 1;
	size_t soap_flag_BitrateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__Mpeg4Options::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_GovLengthRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->tt__Mpeg4Options::GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange2--;
					continue;
				}
			}
			if (soap_flag_FrameRateRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->tt__Mpeg4Options::FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange2--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->tt__Mpeg4Options::EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", &a->tt__Mpeg4Options::Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
					continue;
			}
			if (soap_flag_BitrateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->tt__Mpeg4Options2::BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__Mpeg4Options2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Mpeg4Options::ResolutionsAvailable.size() < 1 || !a->tt__Mpeg4Options::GovLengthRange || !a->tt__Mpeg4Options::FrameRateRange || !a->tt__Mpeg4Options::EncodingIntervalRange || a->tt__Mpeg4Options::Mpeg4ProfilesSupported.size() < 1 || !a->tt__Mpeg4Options2::BitrateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Mpeg4Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options2, SOAP_TYPE_tt__Mpeg4Options2, sizeof(tt__Mpeg4Options2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Mpeg4Options2 * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4Options2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Mpeg4Options2 *p;
	size_t k = sizeof(tt__Mpeg4Options2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Mpeg4Options2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Mpeg4Options2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Mpeg4Options2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Mpeg4Options2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Mpeg4Options2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Mpeg4Options2(soap, tag ? tag : "tt:Mpeg4Options2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Options2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Options2(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Options2 * SOAP_FMAC4 soap_get_tt__Mpeg4Options2(struct soap *soap, tt__Mpeg4Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Mpeg4Options::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__Mpeg4Options::ResolutionsAvailable);
	this->tt__Mpeg4Options::GovLengthRange = NULL;
	this->tt__Mpeg4Options::FrameRateRange = NULL;
	this->tt__Mpeg4Options::EncodingIntervalRange = NULL;
	soap_default_std__vectorTemplateOftt__Mpeg4Profile(soap, &this->tt__Mpeg4Options::Mpeg4ProfilesSupported);
}

void tt__Mpeg4Options::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__Mpeg4Options::ResolutionsAvailable);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options::GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options::FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options::EncodingIntervalRange);
	soap_serialize_std__vectorTemplateOftt__Mpeg4Profile(soap, &this->tt__Mpeg4Options::Mpeg4ProfilesSupported);
#endif
}

int tt__Mpeg4Options::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Options(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options(struct soap *soap, const char *tag, int id, const tt__Mpeg4Options *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__Mpeg4Options::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options::GovLengthRange)
	{	if (soap_element_empty(soap, "tt:GovLengthRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__Mpeg4Options::GovLengthRange, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options::FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__Mpeg4Options::FrameRateRange, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options::EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__Mpeg4Options::EncodingIntervalRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, &a->tt__Mpeg4Options::Mpeg4ProfilesSupported, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4Options::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Mpeg4Options(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Options * SOAP_FMAC4 soap_in_tt__Mpeg4Options(struct soap *soap, const char *tag, tt__Mpeg4Options *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4Options*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options, sizeof(tt__Mpeg4Options), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Mpeg4Options)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Mpeg4Options *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_GovLengthRange1 = 1;
	size_t soap_flag_FrameRateRange1 = 1;
	size_t soap_flag_EncodingIntervalRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__Mpeg4Options::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_GovLengthRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->tt__Mpeg4Options::GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange1--;
					continue;
				}
			}
			if (soap_flag_FrameRateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->tt__Mpeg4Options::FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange1--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->tt__Mpeg4Options::EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", &a->tt__Mpeg4Options::Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Mpeg4Options::ResolutionsAvailable.size() < 1 || !a->tt__Mpeg4Options::GovLengthRange || !a->tt__Mpeg4Options::FrameRateRange || !a->tt__Mpeg4Options::EncodingIntervalRange || a->tt__Mpeg4Options::Mpeg4ProfilesSupported.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Mpeg4Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options, SOAP_TYPE_tt__Mpeg4Options, sizeof(tt__Mpeg4Options), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Mpeg4Options * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4Options(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tt:Mpeg4Options2"))
		return soap_instantiate_tt__Mpeg4Options2(soap, n, NULL, NULL, size);
	tt__Mpeg4Options *p;
	size_t k = sizeof(tt__Mpeg4Options);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Mpeg4Options, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Mpeg4Options);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Mpeg4Options, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Mpeg4Options location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Mpeg4Options::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Mpeg4Options(soap, tag ? tag : "tt:Mpeg4Options", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Options::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Options(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Options * SOAP_FMAC4 soap_get_tt__Mpeg4Options(struct soap *soap, tt__Mpeg4Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__JpegOptions2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__JpegOptions::soap_default(soap);
	this->tt__JpegOptions2::BitrateRange = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__JpegOptions2::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__JpegOptions2::__anyAttribute);
}

void tt__JpegOptions2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegOptions2::BitrateRange);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__JpegOptions2::__any);
	this->tt__JpegOptions::soap_serialize(soap);
#endif
}

int tt__JpegOptions2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__JpegOptions2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions2(struct soap *soap, const char *tag, int id, const tt__JpegOptions2 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__JpegOptions2*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions2), type ? type : "tt:JpegOptions2"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__JpegOptions::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__JpegOptions::FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__JpegOptions::FrameRateRange, ""))
		return soap->error;
	if (!a->tt__JpegOptions::EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__JpegOptions::EncodingIntervalRange, ""))
		return soap->error;
	if (!a->tt__JpegOptions2::BitrateRange)
	{	if (soap_element_empty(soap, "tt:BitrateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->tt__JpegOptions2::BitrateRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__JpegOptions2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__JpegOptions2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__JpegOptions2(soap, tag, this, type);
}

SOAP_FMAC3 tt__JpegOptions2 * SOAP_FMAC4 soap_in_tt__JpegOptions2(struct soap *soap, const char *tag, tt__JpegOptions2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__JpegOptions2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions2, sizeof(tt__JpegOptions2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__JpegOptions2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__JpegOptions2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__JpegOptions2*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_FrameRateRange2 = 1;
	size_t soap_flag_EncodingIntervalRange2 = 1;
	size_t soap_flag_BitrateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__JpegOptions::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_FrameRateRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->tt__JpegOptions::FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange2--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->tt__JpegOptions::EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange2--;
					continue;
				}
			}
			if (soap_flag_BitrateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->tt__JpegOptions2::BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__JpegOptions2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__JpegOptions::ResolutionsAvailable.size() < 1 || !a->tt__JpegOptions::FrameRateRange || !a->tt__JpegOptions::EncodingIntervalRange || !a->tt__JpegOptions2::BitrateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__JpegOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions2, SOAP_TYPE_tt__JpegOptions2, sizeof(tt__JpegOptions2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__JpegOptions2 * SOAP_FMAC2 soap_instantiate_tt__JpegOptions2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__JpegOptions2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__JpegOptions2 *p;
	size_t k = sizeof(tt__JpegOptions2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__JpegOptions2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__JpegOptions2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__JpegOptions2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__JpegOptions2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__JpegOptions2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__JpegOptions2(soap, tag ? tag : "tt:JpegOptions2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__JpegOptions2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__JpegOptions2(soap, this, tag, type);
}

SOAP_FMAC3 tt__JpegOptions2 * SOAP_FMAC4 soap_get_tt__JpegOptions2(struct soap *soap, tt__JpegOptions2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__JpegOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__JpegOptions::ResolutionsAvailable);
	this->tt__JpegOptions::FrameRateRange = NULL;
	this->tt__JpegOptions::EncodingIntervalRange = NULL;
}

void tt__JpegOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__JpegOptions::ResolutionsAvailable);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegOptions::FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegOptions::EncodingIntervalRange);
#endif
}

int tt__JpegOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__JpegOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions(struct soap *soap, const char *tag, int id, const tt__JpegOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__JpegOptions::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__JpegOptions::FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__JpegOptions::FrameRateRange, ""))
		return soap->error;
	if (!a->tt__JpegOptions::EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__JpegOptions::EncodingIntervalRange, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__JpegOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__JpegOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__JpegOptions * SOAP_FMAC4 soap_in_tt__JpegOptions(struct soap *soap, const char *tag, tt__JpegOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__JpegOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions, sizeof(tt__JpegOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__JpegOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__JpegOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_FrameRateRange1 = 1;
	size_t soap_flag_EncodingIntervalRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__JpegOptions::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_FrameRateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->tt__JpegOptions::FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange1--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->tt__JpegOptions::EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__JpegOptions::ResolutionsAvailable.size() < 1 || !a->tt__JpegOptions::FrameRateRange || !a->tt__JpegOptions::EncodingIntervalRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__JpegOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions, SOAP_TYPE_tt__JpegOptions, sizeof(tt__JpegOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__JpegOptions * SOAP_FMAC2 soap_instantiate_tt__JpegOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__JpegOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tt:JpegOptions2"))
		return soap_instantiate_tt__JpegOptions2(soap, n, NULL, NULL, size);
	tt__JpegOptions *p;
	size_t k = sizeof(tt__JpegOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__JpegOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__JpegOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__JpegOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__JpegOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__JpegOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__JpegOptions(soap, tag ? tag : "tt:JpegOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__JpegOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__JpegOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__JpegOptions * SOAP_FMAC4 soap_get_tt__JpegOptions(struct soap *soap, tt__JpegOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoderOptionsExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoderOptionsExtension2::__any);
}

void tt__VideoEncoderOptionsExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoderOptionsExtension2::__any);
#endif
}

int tt__VideoEncoderOptionsExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderOptionsExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, const tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoEncoderOptionsExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderOptionsExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderOptionsExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(tt__VideoEncoderOptionsExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoderOptionsExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoEncoderOptionsExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoEncoderOptionsExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoEncoderOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(tt__VideoEncoderOptionsExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderOptionsExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoderOptionsExtension2 *p;
	size_t k = sizeof(tt__VideoEncoderOptionsExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoderOptionsExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoderOptionsExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoderOptionsExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoderOptionsExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoderOptionsExtension2(soap, tag ? tag : "tt:VideoEncoderOptionsExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderOptionsExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderOptionsExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension2(struct soap *soap, tt__VideoEncoderOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoderOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoderOptionsExtension::__any);
	this->tt__VideoEncoderOptionsExtension::JPEG = NULL;
	this->tt__VideoEncoderOptionsExtension::MPEG4 = NULL;
	this->tt__VideoEncoderOptionsExtension::H264 = NULL;
	this->tt__VideoEncoderOptionsExtension::Extension = NULL;
}

void tt__VideoEncoderOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoderOptionsExtension::__any);
	soap_serialize_PointerTott__JpegOptions2(soap, &this->tt__VideoEncoderOptionsExtension::JPEG);
	soap_serialize_PointerTott__Mpeg4Options2(soap, &this->tt__VideoEncoderOptionsExtension::MPEG4);
	soap_serialize_PointerTott__H264Options2(soap, &this->tt__VideoEncoderOptionsExtension::H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension2(soap, &this->tt__VideoEncoderOptionsExtension::Extension);
#endif
}

int tt__VideoEncoderOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, const tt__VideoEncoderOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoEncoderOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__JpegOptions2(soap, "tt:JPEG", -1, &a->tt__VideoEncoderOptionsExtension::JPEG, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", -1, &a->tt__VideoEncoderOptionsExtension::MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options2(soap, "tt:H264", -1, &a->tt__VideoEncoderOptionsExtension::H264, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", -1, &a->tt__VideoEncoderOptionsExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoderOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, tt__VideoEncoderOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(tt__VideoEncoderOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoderOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoEncoderOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_JPEG1 = 1;
	size_t soap_flag_MPEG41 = 1;
	size_t soap_flag_H2641 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JPEG1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__JpegOptions2(soap, "tt:JPEG", &a->tt__VideoEncoderOptionsExtension::JPEG, "tt:JpegOptions2"))
				{	soap_flag_JPEG1--;
					continue;
				}
			}
			if (soap_flag_MPEG41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", &a->tt__VideoEncoderOptionsExtension::MPEG4, "tt:Mpeg4Options2"))
				{	soap_flag_MPEG41--;
					continue;
				}
			}
			if (soap_flag_H2641 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__H264Options2(soap, "tt:H264", &a->tt__VideoEncoderOptionsExtension::H264, "tt:H264Options2"))
				{	soap_flag_H2641--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", &a->tt__VideoEncoderOptionsExtension::Extension, "tt:VideoEncoderOptionsExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoEncoderOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoEncoderOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(tt__VideoEncoderOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoderOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoderOptionsExtension *p;
	size_t k = sizeof(tt__VideoEncoderOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoderOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoderOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoderOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoderOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoderOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoderOptionsExtension(soap, tag ? tag : "tt:VideoEncoderOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension(struct soap *soap, tt__VideoEncoderOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoderConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__VideoEncoderConfigurationOptions::QualityRange = NULL;
	this->tt__VideoEncoderConfigurationOptions::JPEG = NULL;
	this->tt__VideoEncoderConfigurationOptions::MPEG4 = NULL;
	this->tt__VideoEncoderConfigurationOptions::H264 = NULL;
	this->tt__VideoEncoderConfigurationOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoEncoderConfigurationOptions::__anyAttribute);
}

void tt__VideoEncoderConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__VideoEncoderConfigurationOptions::QualityRange);
	soap_serialize_PointerTott__JpegOptions(soap, &this->tt__VideoEncoderConfigurationOptions::JPEG);
	soap_serialize_PointerTott__Mpeg4Options(soap, &this->tt__VideoEncoderConfigurationOptions::MPEG4);
	soap_serialize_PointerTott__H264Options(soap, &this->tt__VideoEncoderConfigurationOptions::H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension(soap, &this->tt__VideoEncoderConfigurationOptions::Extension);
#endif
}

int tt__VideoEncoderConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoEncoderConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions), type))
		return soap->error;
	if (!a->tt__VideoEncoderConfigurationOptions::QualityRange)
	{	if (soap_element_empty(soap, "tt:QualityRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:QualityRange", -1, &a->tt__VideoEncoderConfigurationOptions::QualityRange, ""))
		return soap->error;
	if (soap_out_PointerTott__JpegOptions(soap, "tt:JPEG", -1, &a->tt__VideoEncoderConfigurationOptions::JPEG, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options(soap, "tt:MPEG4", -1, &a->tt__VideoEncoderConfigurationOptions::MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options(soap, "tt:H264", -1, &a->tt__VideoEncoderConfigurationOptions::H264, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", -1, &a->tt__VideoEncoderConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(tt__VideoEncoderConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoderConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoEncoderConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoEncoderConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_QualityRange1 = 1;
	size_t soap_flag_JPEG1 = 1;
	size_t soap_flag_MPEG41 = 1;
	size_t soap_flag_H2641 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QualityRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:QualityRange", &a->tt__VideoEncoderConfigurationOptions::QualityRange, "tt:IntRange"))
				{	soap_flag_QualityRange1--;
					continue;
				}
			}
			if (soap_flag_JPEG1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__JpegOptions(soap, "tt:JPEG", &a->tt__VideoEncoderConfigurationOptions::JPEG, "tt:JpegOptions"))
				{	soap_flag_JPEG1--;
					continue;
				}
			}
			if (soap_flag_MPEG41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Mpeg4Options(soap, "tt:MPEG4", &a->tt__VideoEncoderConfigurationOptions::MPEG4, "tt:Mpeg4Options"))
				{	soap_flag_MPEG41--;
					continue;
				}
			}
			if (soap_flag_H2641 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__H264Options(soap, "tt:H264", &a->tt__VideoEncoderConfigurationOptions::H264, "tt:H264Options"))
				{	soap_flag_H2641--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", &a->tt__VideoEncoderConfigurationOptions::Extension, "tt:VideoEncoderOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__VideoEncoderConfigurationOptions::QualityRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(tt__VideoEncoderConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoderConfigurationOptions *p;
	size_t k = sizeof(tt__VideoEncoderConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoderConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoderConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoderConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoderConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoderConfigurationOptions(soap, tag ? tag : "tt:VideoEncoderConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoEncoderConfigurationOptions(struct soap *soap, tt__VideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__H264Configuration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__H264Configuration::GovLength);
	soap_default_tt__H264Profile(soap, &this->tt__H264Configuration::H264Profile);
}

void tt__H264Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__H264Configuration::GovLength, SOAP_TYPE_int);
#endif
}

int tt__H264Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Configuration(struct soap *soap, const char *tag, int id, const tt__H264Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Configuration), type))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &a->tt__H264Configuration::GovLength, ""))
		return soap->error;
	if (soap_out_tt__H264Profile(soap, "tt:H264Profile", -1, &a->tt__H264Configuration::H264Profile, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__H264Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__H264Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Configuration * SOAP_FMAC4 soap_in_tt__H264Configuration(struct soap *soap, const char *tag, tt__H264Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__H264Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__H264Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_GovLength1 = 1;
	size_t soap_flag_H264Profile1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:GovLength", &a->tt__H264Configuration::GovLength, "xsd:int"))
				{	soap_flag_GovLength1--;
					continue;
				}
			}
			if (soap_flag_H264Profile1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__H264Profile(soap, "tt:H264Profile", &a->tt__H264Configuration::H264Profile, "tt:H264Profile"))
				{	soap_flag_H264Profile1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength1 > 0 || soap_flag_H264Profile1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__H264Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Configuration, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 soap_instantiate_tt__H264Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__H264Configuration *p;
	size_t k = sizeof(tt__H264Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__H264Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__H264Configuration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__H264Configuration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__H264Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__H264Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__H264Configuration(soap, tag ? tag : "tt:H264Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Configuration * SOAP_FMAC4 soap_get_tt__H264Configuration(struct soap *soap, tt__H264Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Mpeg4Configuration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__Mpeg4Configuration::GovLength);
	soap_default_tt__Mpeg4Profile(soap, &this->tt__Mpeg4Configuration::Mpeg4Profile);
}

void tt__Mpeg4Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Mpeg4Configuration::GovLength, SOAP_TYPE_int);
#endif
}

int tt__Mpeg4Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Configuration(struct soap *soap, const char *tag, int id, const tt__Mpeg4Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Configuration), type))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &a->tt__Mpeg4Configuration::GovLength, ""))
		return soap->error;
	if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", -1, &a->tt__Mpeg4Configuration::Mpeg4Profile, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Mpeg4Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Configuration * SOAP_FMAC4 soap_in_tt__Mpeg4Configuration(struct soap *soap, const char *tag, tt__Mpeg4Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Mpeg4Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Mpeg4Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_GovLength1 = 1;
	size_t soap_flag_Mpeg4Profile1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:GovLength", &a->tt__Mpeg4Configuration::GovLength, "xsd:int"))
				{	soap_flag_GovLength1--;
					continue;
				}
			}
			if (soap_flag_Mpeg4Profile1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", &a->tt__Mpeg4Configuration::Mpeg4Profile, "tt:Mpeg4Profile"))
				{	soap_flag_Mpeg4Profile1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength1 > 0 || soap_flag_Mpeg4Profile1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Mpeg4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Configuration, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Mpeg4Configuration *p;
	size_t k = sizeof(tt__Mpeg4Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Mpeg4Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Mpeg4Configuration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Mpeg4Configuration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Mpeg4Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Mpeg4Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Mpeg4Configuration(soap, tag ? tag : "tt:Mpeg4Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Configuration * SOAP_FMAC4 soap_get_tt__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoRateControl::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__VideoRateControl::FrameRateLimit);
	soap_default_int(soap, &this->tt__VideoRateControl::EncodingInterval);
	soap_default_int(soap, &this->tt__VideoRateControl::BitrateLimit);
}

void tt__VideoRateControl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoRateControl::FrameRateLimit, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoRateControl::EncodingInterval, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoRateControl::BitrateLimit, SOAP_TYPE_int);
#endif
}

int tt__VideoRateControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoRateControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoRateControl(struct soap *soap, const char *tag, int id, const tt__VideoRateControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoRateControl), type))
		return soap->error;
	if (soap_out_int(soap, "tt:FrameRateLimit", -1, &a->tt__VideoRateControl::FrameRateLimit, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EncodingInterval", -1, &a->tt__VideoRateControl::EncodingInterval, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:BitrateLimit", -1, &a->tt__VideoRateControl::BitrateLimit, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoRateControl::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoRateControl(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoRateControl * SOAP_FMAC4 soap_in_tt__VideoRateControl(struct soap *soap, const char *tag, tt__VideoRateControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoRateControl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoRateControl)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoRateControl *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_FrameRateLimit1 = 1;
	size_t soap_flag_EncodingInterval1 = 1;
	size_t soap_flag_BitrateLimit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FrameRateLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:FrameRateLimit", &a->tt__VideoRateControl::FrameRateLimit, "xsd:int"))
				{	soap_flag_FrameRateLimit1--;
					continue;
				}
			}
			if (soap_flag_EncodingInterval1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:EncodingInterval", &a->tt__VideoRateControl::EncodingInterval, "xsd:int"))
				{	soap_flag_EncodingInterval1--;
					continue;
				}
			}
			if (soap_flag_BitrateLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:BitrateLimit", &a->tt__VideoRateControl::BitrateLimit, "xsd:int"))
				{	soap_flag_BitrateLimit1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit1 > 0 || soap_flag_EncodingInterval1 > 0 || soap_flag_BitrateLimit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoRateControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoRateControl(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoRateControl *p;
	size_t k = sizeof(tt__VideoRateControl);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoRateControl, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoRateControl);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoRateControl, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoRateControl location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoRateControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoRateControl(soap, tag ? tag : "tt:VideoRateControl", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoRateControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoRateControl(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoRateControl * SOAP_FMAC4 soap_get_tt__VideoRateControl(struct soap *soap, tt__VideoRateControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoResolution::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__VideoResolution::Width);
	soap_default_int(soap, &this->tt__VideoResolution::Height);
}

void tt__VideoResolution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoResolution::Width, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoResolution::Height, SOAP_TYPE_int);
#endif
}

int tt__VideoResolution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoResolution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoResolution(struct soap *soap, const char *tag, int id, const tt__VideoResolution *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoResolution), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &a->tt__VideoResolution::Width, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &a->tt__VideoResolution::Height, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoResolution::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoResolution(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoResolution * SOAP_FMAC4 soap_in_tt__VideoResolution(struct soap *soap, const char *tag, tt__VideoResolution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoResolution*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution, sizeof(tt__VideoResolution), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoResolution)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoResolution *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Width1 = 1;
	size_t soap_flag_Height1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Width", &a->tt__VideoResolution::Width, "xsd:int"))
				{	soap_flag_Width1--;
					continue;
				}
			}
			if (soap_flag_Height1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Height", &a->tt__VideoResolution::Height, "xsd:int"))
				{	soap_flag_Height1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width1 > 0 || soap_flag_Height1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoResolution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution, SOAP_TYPE_tt__VideoResolution, sizeof(tt__VideoResolution), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 soap_instantiate_tt__VideoResolution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoResolution(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoResolution *p;
	size_t k = sizeof(tt__VideoResolution);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoResolution, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoResolution);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoResolution, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoResolution location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoResolution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoResolution(soap, tag ? tag : "tt:VideoResolution", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoResolution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoResolution(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoResolution * SOAP_FMAC4 soap_get_tt__VideoResolution(struct soap *soap, tt__VideoResolution *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoderConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__VideoEncoding(soap, &this->tt__VideoEncoderConfiguration::Encoding);
	this->tt__VideoEncoderConfiguration::Resolution = NULL;
	soap_default_float(soap, &this->tt__VideoEncoderConfiguration::Quality);
	this->tt__VideoEncoderConfiguration::RateControl = NULL;
	this->tt__VideoEncoderConfiguration::MPEG4 = NULL;
	this->tt__VideoEncoderConfiguration::H264 = NULL;
	this->tt__VideoEncoderConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoderConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoEncoderConfiguration::__anyAttribute);
}

void tt__VideoEncoderConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoResolution(soap, &this->tt__VideoEncoderConfiguration::Resolution);
	soap_embedded(soap, &this->tt__VideoEncoderConfiguration::Quality, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoRateControl(soap, &this->tt__VideoEncoderConfiguration::RateControl);
	soap_serialize_PointerTott__Mpeg4Configuration(soap, &this->tt__VideoEncoderConfiguration::MPEG4);
	soap_serialize_PointerTott__H264Configuration(soap, &this->tt__VideoEncoderConfiguration::H264);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__VideoEncoderConfiguration::Multicast);
	soap_embedded(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoderConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__VideoEncoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoEncoderConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoEncoderConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfiguration), type ? type : "tt:VideoEncoderConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__VideoEncoding(soap, "tt:Encoding", -1, &a->tt__VideoEncoderConfiguration::Encoding, ""))
		return soap->error;
	if (!a->tt__VideoEncoderConfiguration::Resolution)
	{	if (soap_element_empty(soap, "tt:Resolution"))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->tt__VideoEncoderConfiguration::Resolution, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Quality", -1, &a->tt__VideoEncoderConfiguration::Quality, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoRateControl(soap, "tt:RateControl", -1, &a->tt__VideoEncoderConfiguration::RateControl, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", -1, &a->tt__VideoEncoderConfiguration::MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Configuration(soap, "tt:H264", -1, &a->tt__VideoEncoderConfiguration::H264, ""))
		return soap->error;
	if (!a->tt__VideoEncoderConfiguration::Multicast)
	{	if (soap_element_empty(soap, "tt:Multicast"))
			return soap->error;
	}
	else if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__VideoEncoderConfiguration::Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->tt__VideoEncoderConfiguration::SessionTimeout, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoEncoderConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_in_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, tt__VideoEncoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoderConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoEncoderConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoEncoderConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Resolution1 = 1;
	size_t soap_flag_Quality1 = 1;
	size_t soap_flag_RateControl1 = 1;
	size_t soap_flag_MPEG41 = 1;
	size_t soap_flag_H2641 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__VideoEncoding(soap, "tt:Encoding", &a->tt__VideoEncoderConfiguration::Encoding, "tt:VideoEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_Resolution1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->tt__VideoEncoderConfiguration::Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution1--;
					continue;
				}
			}
			if (soap_flag_Quality1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Quality", &a->tt__VideoEncoderConfiguration::Quality, "xsd:float"))
				{	soap_flag_Quality1--;
					continue;
				}
			}
			if (soap_flag_RateControl1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoRateControl(soap, "tt:RateControl", &a->tt__VideoEncoderConfiguration::RateControl, "tt:VideoRateControl"))
				{	soap_flag_RateControl1--;
					continue;
				}
			}
			if (soap_flag_MPEG41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", &a->tt__VideoEncoderConfiguration::MPEG4, "tt:Mpeg4Configuration"))
				{	soap_flag_MPEG41--;
					continue;
				}
			}
			if (soap_flag_H2641 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__H264Configuration(soap, "tt:H264", &a->tt__VideoEncoderConfiguration::H264, "tt:H264Configuration"))
				{	soap_flag_H2641--;
					continue;
				}
			}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->tt__VideoEncoderConfiguration::Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			}
			if (soap_flag_SessionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->tt__VideoEncoderConfiguration::SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoEncoderConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Encoding1 > 0 || !a->tt__VideoEncoderConfiguration::Resolution || soap_flag_Quality1 > 0 || !a->tt__VideoEncoderConfiguration::Multicast || soap_flag_SessionTimeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfiguration, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoderConfiguration *p;
	size_t k = sizeof(tt__VideoEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoderConfiguration(soap, tag ? tag : "tt:VideoEncoderConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_get_tt__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SceneOrientation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__SceneOrientationMode(soap, &this->tt__SceneOrientation::Mode);
	this->tt__SceneOrientation::Orientation = NULL;
}

void tt__SceneOrientation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->tt__SceneOrientation::Orientation);
#endif
}

int tt__SceneOrientation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SceneOrientation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientation(struct soap *soap, const char *tag, int id, const tt__SceneOrientation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SceneOrientation), type))
		return soap->error;
	if (soap_out_tt__SceneOrientationMode(soap, "tt:Mode", -1, &a->tt__SceneOrientation::Mode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Orientation", -1, &a->tt__SceneOrientation::Orientation, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SceneOrientation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SceneOrientation(soap, tag, this, type);
}

SOAP_FMAC3 tt__SceneOrientation * SOAP_FMAC4 soap_in_tt__SceneOrientation(struct soap *soap, const char *tag, tt__SceneOrientation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SceneOrientation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientation, sizeof(tt__SceneOrientation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SceneOrientation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SceneOrientation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Orientation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SceneOrientationMode(soap, "tt:Mode", &a->tt__SceneOrientation::Mode, "tt:SceneOrientationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Orientation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Orientation", &a->tt__SceneOrientation::Orientation, "xsd:string"))
				{	soap_flag_Orientation1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SceneOrientation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SceneOrientation, SOAP_TYPE_tt__SceneOrientation, sizeof(tt__SceneOrientation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SceneOrientation * SOAP_FMAC2 soap_instantiate_tt__SceneOrientation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SceneOrientation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SceneOrientation *p;
	size_t k = sizeof(tt__SceneOrientation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SceneOrientation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SceneOrientation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SceneOrientation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SceneOrientation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SceneOrientation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SceneOrientation(soap, tag ? tag : "tt:SceneOrientation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SceneOrientation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SceneOrientation(soap, this, tag, type);
}

SOAP_FMAC3 tt__SceneOrientation * SOAP_FMAC4 soap_get_tt__SceneOrientation(struct soap *soap, tt__SceneOrientation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SceneOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RotateOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RotateOptionsExtension::__any);
}

void tt__RotateOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RotateOptionsExtension::__any);
#endif
}

int tt__RotateOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RotateOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateOptionsExtension(struct soap *soap, const char *tag, int id, const tt__RotateOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RotateOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RotateOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RotateOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RotateOptionsExtension * SOAP_FMAC4 soap_in_tt__RotateOptionsExtension(struct soap *soap, const char *tag, tt__RotateOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RotateOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(tt__RotateOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RotateOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RotateOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RotateOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RotateOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateOptionsExtension, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(tt__RotateOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RotateOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__RotateOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RotateOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RotateOptionsExtension *p;
	size_t k = sizeof(tt__RotateOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RotateOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RotateOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RotateOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RotateOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RotateOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RotateOptionsExtension(soap, tag ? tag : "tt:RotateOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RotateOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RotateOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RotateOptionsExtension * SOAP_FMAC4 soap_get_tt__RotateOptionsExtension(struct soap *soap, tt__RotateOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RotateOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__RotateMode(soap, &this->tt__RotateOptions::Mode);
	this->tt__RotateOptions::DegreeList = NULL;
	this->tt__RotateOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__RotateOptions::__anyAttribute);
}

void tt__RotateOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__RotateMode(soap, &this->tt__RotateOptions::Mode);
	soap_serialize_PointerTott__IntList(soap, &this->tt__RotateOptions::DegreeList);
	soap_serialize_PointerTott__RotateOptionsExtension(soap, &this->tt__RotateOptions::Extension);
#endif
}

int tt__RotateOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RotateOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateOptions(struct soap *soap, const char *tag, int id, const tt__RotateOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RotateOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__RotateMode(soap, "tt:Mode", -1, &a->tt__RotateOptions::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__IntList(soap, "tt:DegreeList", -1, &a->tt__RotateOptions::DegreeList, ""))
		return soap->error;
	if (soap_out_PointerTott__RotateOptionsExtension(soap, "tt:Extension", -1, &a->tt__RotateOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RotateOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RotateOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__RotateOptions * SOAP_FMAC4 soap_in_tt__RotateOptions(struct soap *soap, const char *tag, tt__RotateOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RotateOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateOptions, sizeof(tt__RotateOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RotateOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RotateOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RotateOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_DegreeList1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__RotateMode(soap, "tt:Mode", &a->tt__RotateOptions::Mode, "tt:RotateMode"))
					continue;
			}
			if (soap_flag_DegreeList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntList(soap, "tt:DegreeList", &a->tt__RotateOptions::DegreeList, "tt:IntList"))
				{	soap_flag_DegreeList1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RotateOptionsExtension(soap, "tt:Extension", &a->tt__RotateOptions::Extension, "tt:RotateOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__RotateOptions::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RotateOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateOptions, SOAP_TYPE_tt__RotateOptions, sizeof(tt__RotateOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RotateOptions * SOAP_FMAC2 soap_instantiate_tt__RotateOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RotateOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RotateOptions *p;
	size_t k = sizeof(tt__RotateOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RotateOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RotateOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RotateOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RotateOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RotateOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RotateOptions(soap, tag ? tag : "tt:RotateOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RotateOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RotateOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__RotateOptions * SOAP_FMAC4 soap_get_tt__RotateOptions(struct soap *soap, tt__RotateOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfigurationOptionsExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__SceneOrientationMode(soap, &this->tt__VideoSourceConfigurationOptionsExtension2::SceneOrientationMode);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceConfigurationOptionsExtension2::__any);
}

void tt__VideoSourceConfigurationOptionsExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__SceneOrientationMode(soap, &this->tt__VideoSourceConfigurationOptionsExtension2::SceneOrientationMode);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceConfigurationOptionsExtension2::__any);
#endif
}

int tt__VideoSourceConfigurationOptionsExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationOptionsExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__SceneOrientationMode(soap, "tt:SceneOrientationMode", -1, &a->tt__VideoSourceConfigurationOptionsExtension2::SceneOrientationMode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoSourceConfigurationOptionsExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationOptionsExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptionsExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationOptionsExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(tt__VideoSourceConfigurationOptionsExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfigurationOptionsExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__SceneOrientationMode(soap, "tt:SceneOrientationMode", &a->tt__VideoSourceConfigurationOptionsExtension2::SceneOrientationMode, "tt:SceneOrientationMode"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoSourceConfigurationOptionsExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(tt__VideoSourceConfigurationOptionsExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfigurationOptionsExtension2 *p;
	size_t k = sizeof(tt__VideoSourceConfigurationOptionsExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfigurationOptionsExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfigurationOptionsExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfigurationOptionsExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfigurationOptionsExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfigurationOptionsExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationOptionsExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationOptionsExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationOptionsExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfigurationOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceConfigurationOptionsExtension::__any);
	this->tt__VideoSourceConfigurationOptionsExtension::Rotate = NULL;
	this->tt__VideoSourceConfigurationOptionsExtension::Extension = NULL;
}

void tt__VideoSourceConfigurationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceConfigurationOptionsExtension::__any);
	soap_serialize_PointerTott__RotateOptions(soap, &this->tt__VideoSourceConfigurationOptionsExtension::Rotate);
	soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, &this->tt__VideoSourceConfigurationOptionsExtension::Extension);
#endif
}

int tt__VideoSourceConfigurationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoSourceConfigurationOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__RotateOptions(soap, "tt:Rotate", -1, &a->tt__VideoSourceConfigurationOptionsExtension::Rotate, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, "tt:Extension", -1, &a->tt__VideoSourceConfigurationOptionsExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(tt__VideoSourceConfigurationOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfigurationOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Rotate1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Rotate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RotateOptions(soap, "tt:Rotate", &a->tt__VideoSourceConfigurationOptionsExtension::Rotate, "tt:RotateOptions"))
				{	soap_flag_Rotate1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, "tt:Extension", &a->tt__VideoSourceConfigurationOptionsExtension::Extension, "tt:VideoSourceConfigurationOptionsExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoSourceConfigurationOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(tt__VideoSourceConfigurationOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfigurationOptionsExtension *p;
	size_t k = sizeof(tt__VideoSourceConfigurationOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfigurationOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfigurationOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfigurationOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfigurationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfigurationOptionsExtension(soap, tag ? tag : "tt:VideoSourceConfigurationOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__VideoSourceConfigurationOptions::BoundsRange = NULL;
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable);
	this->tt__VideoSourceConfigurationOptions::Extension = NULL;
	this->tt__VideoSourceConfigurationOptions::MaximumNumberOfProfiles = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoSourceConfigurationOptions::__anyAttribute);
}

void tt__VideoSourceConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRectangleRange(soap, &this->tt__VideoSourceConfigurationOptions::BoundsRange);
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable);
	soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(soap, &this->tt__VideoSourceConfigurationOptions::Extension);
#endif
}

int tt__VideoSourceConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationOptions *a, const char *type)
{
	if (((tt__VideoSourceConfigurationOptions*)a)->MaximumNumberOfProfiles)
	{	soap_set_attr(soap, "MaximumNumberOfProfiles", soap_int2s(soap, *((tt__VideoSourceConfigurationOptions*)a)->MaximumNumberOfProfiles), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoSourceConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions), type))
		return soap->error;
	if (!a->tt__VideoSourceConfigurationOptions::BoundsRange)
	{	if (soap_element_empty(soap, "tt:BoundsRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", -1, &a->tt__VideoSourceConfigurationOptions::BoundsRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:VideoSourceTokensAvailable", -1, &a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->tt__VideoSourceConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(tt__VideoSourceConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "MaximumNumberOfProfiles", 5, 0);
		if (t)
		{
			if (!(((tt__VideoSourceConfigurationOptions*)a)->MaximumNumberOfProfiles = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__VideoSourceConfigurationOptions*)a)->MaximumNumberOfProfiles))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoSourceConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_BoundsRange1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundsRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", &a->tt__VideoSourceConfigurationOptions::BoundsRange, "tt:IntRectangleRange"))
				{	soap_flag_BoundsRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:VideoSourceTokensAvailable", &a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable, "tt:ReferenceToken"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", &a->tt__VideoSourceConfigurationOptions::Extension, "tt:VideoSourceConfigurationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__VideoSourceConfigurationOptions::BoundsRange || a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptions, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(tt__VideoSourceConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfigurationOptions *p;
	size_t k = sizeof(tt__VideoSourceConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfigurationOptions(soap, tag ? tag : "tt:VideoSourceConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptions(struct soap *soap, tt__VideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LensDescription::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__LensDescription::Offset = NULL;
	soap_default_std__vectorTemplateOfPointerTott__LensProjection(soap, &this->tt__LensDescription::Projection);
	soap_default_float(soap, &this->tt__LensDescription::XFactor);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__LensDescription::__any);
	this->tt__LensDescription::FocalLength = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__LensDescription::__anyAttribute);
}

void tt__LensDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__LensOffset(soap, &this->tt__LensDescription::Offset);
	soap_serialize_std__vectorTemplateOfPointerTott__LensProjection(soap, &this->tt__LensDescription::Projection);
	soap_embedded(soap, &this->tt__LensDescription::XFactor, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__LensDescription::__any);
#endif
}

int tt__LensDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LensDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensDescription(struct soap *soap, const char *tag, int id, const tt__LensDescription *a, const char *type)
{
	if (((tt__LensDescription*)a)->FocalLength)
	{	soap_set_attr(soap, "FocalLength", soap_float2s(soap, *((tt__LensDescription*)a)->FocalLength), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__LensDescription*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LensDescription), type))
		return soap->error;
	if (!a->tt__LensDescription::Offset)
	{	if (soap_element_empty(soap, "tt:Offset"))
			return soap->error;
	}
	else if (soap_out_PointerTott__LensOffset(soap, "tt:Offset", -1, &a->tt__LensDescription::Offset, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__LensProjection(soap, "tt:Projection", -1, &a->tt__LensDescription::Projection, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:XFactor", -1, &a->tt__LensDescription::XFactor, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__LensDescription::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LensDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LensDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__LensDescription * SOAP_FMAC4 soap_in_tt__LensDescription(struct soap *soap, const char *tag, tt__LensDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LensDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensDescription, sizeof(tt__LensDescription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LensDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LensDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "FocalLength", 5, 0);
		if (t)
		{
			if (!(((tt__LensDescription*)a)->FocalLength = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__LensDescription*)a)->FocalLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__LensDescription*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Offset1 = 1;
	size_t soap_flag_XFactor1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Offset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LensOffset(soap, "tt:Offset", &a->tt__LensDescription::Offset, "tt:LensOffset"))
				{	soap_flag_Offset1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LensProjection(soap, "tt:Projection", &a->tt__LensDescription::Projection, "tt:LensProjection"))
					continue;
			}
			if (soap_flag_XFactor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:XFactor", &a->tt__LensDescription::XFactor, "xsd:float"))
				{	soap_flag_XFactor1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__LensDescription::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__LensDescription::Offset || a->tt__LensDescription::Projection.size() < 1 || soap_flag_XFactor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__LensDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensDescription, SOAP_TYPE_tt__LensDescription, sizeof(tt__LensDescription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LensDescription * SOAP_FMAC2 soap_instantiate_tt__LensDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LensDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LensDescription *p;
	size_t k = sizeof(tt__LensDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LensDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LensDescription);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LensDescription, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LensDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LensDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LensDescription(soap, tag ? tag : "tt:LensDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LensDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LensDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__LensDescription * SOAP_FMAC4 soap_get_tt__LensDescription(struct soap *soap, tt__LensDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LensDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LensOffset::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__LensOffset::x = NULL;
	this->tt__LensOffset::y = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__LensOffset::__anyAttribute);
}

void tt__LensOffset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__LensOffset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LensOffset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensOffset(struct soap *soap, const char *tag, int id, const tt__LensOffset *a, const char *type)
{
	if (((tt__LensOffset*)a)->x)
	{	soap_set_attr(soap, "x", soap_float2s(soap, *((tt__LensOffset*)a)->x), 1);
	}
	if (((tt__LensOffset*)a)->y)
	{	soap_set_attr(soap, "y", soap_float2s(soap, *((tt__LensOffset*)a)->y), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__LensOffset*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LensOffset), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LensOffset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LensOffset(soap, tag, this, type);
}

SOAP_FMAC3 tt__LensOffset * SOAP_FMAC4 soap_in_tt__LensOffset(struct soap *soap, const char *tag, tt__LensOffset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LensOffset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensOffset, sizeof(tt__LensOffset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LensOffset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LensOffset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "x", 5, 0);
		if (t)
		{
			if (!(((tt__LensOffset*)a)->x = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__LensOffset*)a)->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "y", 5, 0);
		if (t)
		{
			if (!(((tt__LensOffset*)a)->y = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__LensOffset*)a)->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__LensOffset*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__LensOffset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensOffset, SOAP_TYPE_tt__LensOffset, sizeof(tt__LensOffset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LensOffset * SOAP_FMAC2 soap_instantiate_tt__LensOffset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LensOffset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LensOffset *p;
	size_t k = sizeof(tt__LensOffset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LensOffset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LensOffset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LensOffset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LensOffset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LensOffset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LensOffset(soap, tag ? tag : "tt:LensOffset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LensOffset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LensOffset(soap, this, tag, type);
}

SOAP_FMAC3 tt__LensOffset * SOAP_FMAC4 soap_get_tt__LensOffset(struct soap *soap, tt__LensOffset *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LensOffset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LensProjection::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__LensProjection::Angle);
	soap_default_float(soap, &this->tt__LensProjection::Radius);
	this->tt__LensProjection::Transmittance = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__LensProjection::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__LensProjection::__anyAttribute);
}

void tt__LensProjection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__LensProjection::Angle, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__LensProjection::Radius, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &this->tt__LensProjection::Transmittance);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__LensProjection::__any);
#endif
}

int tt__LensProjection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LensProjection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensProjection(struct soap *soap, const char *tag, int id, const tt__LensProjection *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__LensProjection*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LensProjection), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Angle", -1, &a->tt__LensProjection::Angle, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Radius", -1, &a->tt__LensProjection::Radius, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Transmittance", -1, &a->tt__LensProjection::Transmittance, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__LensProjection::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LensProjection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LensProjection(soap, tag, this, type);
}

SOAP_FMAC3 tt__LensProjection * SOAP_FMAC4 soap_in_tt__LensProjection(struct soap *soap, const char *tag, tt__LensProjection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LensProjection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensProjection, sizeof(tt__LensProjection), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LensProjection)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LensProjection *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__LensProjection*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Angle1 = 1;
	size_t soap_flag_Radius1 = 1;
	size_t soap_flag_Transmittance1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Angle1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Angle", &a->tt__LensProjection::Angle, "xsd:float"))
				{	soap_flag_Angle1--;
					continue;
				}
			}
			if (soap_flag_Radius1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Radius", &a->tt__LensProjection::Radius, "xsd:float"))
				{	soap_flag_Radius1--;
					continue;
				}
			}
			if (soap_flag_Transmittance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Transmittance", &a->tt__LensProjection::Transmittance, "xsd:float"))
				{	soap_flag_Transmittance1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__LensProjection::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Angle1 > 0 || soap_flag_Radius1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__LensProjection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensProjection, SOAP_TYPE_tt__LensProjection, sizeof(tt__LensProjection), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LensProjection * SOAP_FMAC2 soap_instantiate_tt__LensProjection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LensProjection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LensProjection *p;
	size_t k = sizeof(tt__LensProjection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LensProjection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LensProjection);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LensProjection, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LensProjection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LensProjection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LensProjection(soap, tag ? tag : "tt:LensProjection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LensProjection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LensProjection(soap, this, tag, type);
}

SOAP_FMAC3 tt__LensProjection * SOAP_FMAC4 soap_get_tt__LensProjection(struct soap *soap, tt__LensProjection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LensProjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RotateExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RotateExtension::__any);
}

void tt__RotateExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RotateExtension::__any);
#endif
}

int tt__RotateExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RotateExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateExtension(struct soap *soap, const char *tag, int id, const tt__RotateExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RotateExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RotateExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RotateExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RotateExtension * SOAP_FMAC4 soap_in_tt__RotateExtension(struct soap *soap, const char *tag, tt__RotateExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RotateExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateExtension, sizeof(tt__RotateExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RotateExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RotateExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RotateExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RotateExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateExtension, SOAP_TYPE_tt__RotateExtension, sizeof(tt__RotateExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RotateExtension * SOAP_FMAC2 soap_instantiate_tt__RotateExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RotateExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RotateExtension *p;
	size_t k = sizeof(tt__RotateExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RotateExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RotateExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RotateExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RotateExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RotateExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RotateExtension(soap, tag ? tag : "tt:RotateExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RotateExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RotateExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RotateExtension * SOAP_FMAC4 soap_get_tt__RotateExtension(struct soap *soap, tt__RotateExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Rotate::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RotateMode(soap, &this->tt__Rotate::Mode);
	this->tt__Rotate::Degree = NULL;
	this->tt__Rotate::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Rotate::__anyAttribute);
}

void tt__Rotate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->tt__Rotate::Degree);
	soap_serialize_PointerTott__RotateExtension(soap, &this->tt__Rotate::Extension);
#endif
}

int tt__Rotate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Rotate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rotate(struct soap *soap, const char *tag, int id, const tt__Rotate *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Rotate*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rotate), type))
		return soap->error;
	if (soap_out_tt__RotateMode(soap, "tt:Mode", -1, &a->tt__Rotate::Mode, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Degree", -1, &a->tt__Rotate::Degree, ""))
		return soap->error;
	if (soap_out_PointerTott__RotateExtension(soap, "tt:Extension", -1, &a->tt__Rotate::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Rotate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Rotate(soap, tag, this, type);
}

SOAP_FMAC3 tt__Rotate * SOAP_FMAC4 soap_in_tt__Rotate(struct soap *soap, const char *tag, tt__Rotate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Rotate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rotate, sizeof(tt__Rotate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Rotate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Rotate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Rotate*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Degree1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RotateMode(soap, "tt:Mode", &a->tt__Rotate::Mode, "tt:RotateMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Degree1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:Degree", &a->tt__Rotate::Degree, "xsd:int"))
				{	soap_flag_Degree1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RotateExtension(soap, "tt:Extension", &a->tt__Rotate::Extension, "tt:RotateExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Rotate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rotate, SOAP_TYPE_tt__Rotate, sizeof(tt__Rotate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Rotate * SOAP_FMAC2 soap_instantiate_tt__Rotate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Rotate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Rotate *p;
	size_t k = sizeof(tt__Rotate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Rotate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Rotate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Rotate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Rotate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Rotate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Rotate(soap, tag ? tag : "tt:Rotate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Rotate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Rotate(soap, this, tag, type);
}

SOAP_FMAC3 tt__Rotate * SOAP_FMAC4 soap_get_tt__Rotate(struct soap *soap, tt__Rotate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rotate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfigurationExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__LensDescription(soap, &this->tt__VideoSourceConfigurationExtension2::LensDescription);
	this->tt__VideoSourceConfigurationExtension2::SceneOrientation = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceConfigurationExtension2::__any);
}

void tt__VideoSourceConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__LensDescription(soap, &this->tt__VideoSourceConfigurationExtension2::LensDescription);
	soap_serialize_PointerTott__SceneOrientation(soap, &this->tt__VideoSourceConfigurationExtension2::SceneOrientation);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceConfigurationExtension2::__any);
#endif
}

int tt__VideoSourceConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__LensDescription(soap, "tt:LensDescription", -1, &a->tt__VideoSourceConfigurationExtension2::LensDescription, ""))
		return soap->error;
	if (soap_out_PointerTott__SceneOrientation(soap, "tt:SceneOrientation", -1, &a->tt__VideoSourceConfigurationExtension2::SceneOrientation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoSourceConfigurationExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(tt__VideoSourceConfigurationExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfigurationExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfigurationExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SceneOrientation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LensDescription(soap, "tt:LensDescription", &a->tt__VideoSourceConfigurationExtension2::LensDescription, "tt:LensDescription"))
					continue;
			}
			if (soap_flag_SceneOrientation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SceneOrientation(soap, "tt:SceneOrientation", &a->tt__VideoSourceConfigurationExtension2::SceneOrientation, "tt:SceneOrientation"))
				{	soap_flag_SceneOrientation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoSourceConfigurationExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(tt__VideoSourceConfigurationExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfigurationExtension2 *p;
	size_t k = sizeof(tt__VideoSourceConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfigurationExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfigurationExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfigurationExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__VideoSourceConfigurationExtension::Rotate = NULL;
	this->tt__VideoSourceConfigurationExtension::Extension = NULL;
}

void tt__VideoSourceConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Rotate(soap, &this->tt__VideoSourceConfigurationExtension::Rotate);
	soap_serialize_PointerTott__VideoSourceConfigurationExtension2(soap, &this->tt__VideoSourceConfigurationExtension::Extension);
#endif
}

int tt__VideoSourceConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension), type))
		return soap->error;
	if (soap_out_PointerTott__Rotate(soap, "tt:Rotate", -1, &a->tt__VideoSourceConfigurationExtension::Rotate, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__VideoSourceConfigurationExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(tt__VideoSourceConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Rotate1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Rotate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rotate(soap, "tt:Rotate", &a->tt__VideoSourceConfigurationExtension::Rotate, "tt:Rotate"))
				{	soap_flag_Rotate1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationExtension2(soap, "tt:Extension", &a->tt__VideoSourceConfigurationExtension::Extension, "tt:VideoSourceConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationExtension, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(tt__VideoSourceConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfigurationExtension *p;
	size_t k = sizeof(tt__VideoSourceConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfigurationExtension(soap, tag ? tag : "tt:VideoSourceConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__VideoSourceConfiguration::SourceToken);
	this->tt__VideoSourceConfiguration::Bounds = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceConfiguration::__any);
	this->tt__VideoSourceConfiguration::Extension = NULL;
	this->tt__VideoSourceConfiguration::ViewMode = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoSourceConfiguration::__anyAttribute);
}

void tt__VideoSourceConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoSourceConfiguration::SourceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__VideoSourceConfiguration::SourceToken);
	soap_serialize_PointerTott__IntRectangle(soap, &this->tt__VideoSourceConfiguration::Bounds);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceConfiguration::__any);
	soap_serialize_PointerTott__VideoSourceConfigurationExtension(soap, &this->tt__VideoSourceConfiguration::Extension);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfiguration *a, const char *type)
{
	if (((tt__VideoSourceConfiguration*)a)->ViewMode)
	{	soap_set_attr(soap, "ViewMode", soap_std__string2s(soap, *((tt__VideoSourceConfiguration*)a)->ViewMode), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoSourceConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfiguration), type ? type : "tt:VideoSourceConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &a->tt__VideoSourceConfiguration::SourceToken, ""))
		return soap->error;
	if (!a->tt__VideoSourceConfiguration::Bounds)
	{	if (soap_element_empty(soap, "tt:Bounds"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRectangle(soap, "tt:Bounds", -1, &a->tt__VideoSourceConfiguration::Bounds, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoSourceConfiguration::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, "tt:Extension", -1, &a->tt__VideoSourceConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfiguration * SOAP_FMAC4 soap_in_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, tt__VideoSourceConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "ViewMode", 1, 0);
		if (t)
		{
			if (!(((tt__VideoSourceConfiguration*)a)->ViewMode = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((tt__VideoSourceConfiguration*)a)->ViewMode))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoSourceConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_SourceToken1 = 1;
	size_t soap_flag_Bounds1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_SourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &a->tt__VideoSourceConfiguration::SourceToken, "tt:ReferenceToken"))
				{	soap_flag_SourceToken1--;
					continue;
				}
			}
			if (soap_flag_Bounds1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRectangle(soap, "tt:Bounds", &a->tt__VideoSourceConfiguration::Bounds, "tt:IntRectangle"))
				{	soap_flag_Bounds1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationExtension(soap, "tt:Extension", &a->tt__VideoSourceConfiguration::Extension, "tt:VideoSourceConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoSourceConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_SourceToken1 > 0 || !a->tt__VideoSourceConfiguration::Bounds))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfiguration, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfiguration *p;
	size_t k = sizeof(tt__VideoSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfiguration(soap, tag ? tag : "tt:VideoSourceConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfiguration * SOAP_FMAC4 soap_get_tt__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ConfigurationEntity::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
}

void tt__ConfigurationEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ConfigurationEntity::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
#endif
}

int tt__ConfigurationEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ConfigurationEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigurationEntity(struct soap *soap, const char *tag, int id, const tt__ConfigurationEntity *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigurationEntity), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ConfigurationEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ConfigurationEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_in_tt__ConfigurationEntity(struct soap *soap, const char *tag, tt__ConfigurationEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ConfigurationEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigurationEntity, sizeof(tt__ConfigurationEntity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ConfigurationEntity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ConfigurationEntity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_UseCount1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_UseCount1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_UseCount1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ConfigurationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigurationEntity, SOAP_TYPE_tt__ConfigurationEntity, sizeof(tt__ConfigurationEntity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 soap_instantiate_tt__ConfigurationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ConfigurationEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceConfiguration"))
		return soap_instantiate_tt__VideoSourceConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoEncoderConfiguration"))
		return soap_instantiate_tt__VideoEncoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoEncoder2Configuration"))
		return soap_instantiate_tt__VideoEncoder2Configuration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioSourceConfiguration"))
		return soap_instantiate_tt__AudioSourceConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioEncoderConfiguration"))
		return soap_instantiate_tt__AudioEncoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioEncoder2Configuration"))
		return soap_instantiate_tt__AudioEncoder2Configuration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoAnalyticsConfiguration"))
		return soap_instantiate_tt__VideoAnalyticsConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MetadataConfiguration"))
		return soap_instantiate_tt__MetadataConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoOutputConfiguration"))
		return soap_instantiate_tt__VideoOutputConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioOutputConfiguration"))
		return soap_instantiate_tt__AudioOutputConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioDecoderConfiguration"))
		return soap_instantiate_tt__AudioDecoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZConfiguration"))
		return soap_instantiate_tt__PTZConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AnalyticsEngine"))
		return soap_instantiate_tt__AnalyticsEngine(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AnalyticsEngineInput"))
		return soap_instantiate_tt__AnalyticsEngineInput(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AnalyticsEngineControl"))
		return soap_instantiate_tt__AnalyticsEngineControl(soap, n, NULL, NULL, size);
	tt__ConfigurationEntity *p;
	size_t k = sizeof(tt__ConfigurationEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ConfigurationEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ConfigurationEntity);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ConfigurationEntity, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ConfigurationEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ConfigurationEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ConfigurationEntity(soap, tag ? tag : "tt:ConfigurationEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ConfigurationEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ConfigurationEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_get_tt__ConfigurationEntity(struct soap *soap, tt__ConfigurationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigurationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ProfileExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ProfileExtension2::__any);
}

void tt__ProfileExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ProfileExtension2::__any);
#endif
}

int tt__ProfileExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension2(struct soap *soap, const char *tag, int id, const tt__ProfileExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ProfileExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ProfileExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ProfileExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileExtension2 * SOAP_FMAC4 soap_in_tt__ProfileExtension2(struct soap *soap, const char *tag, tt__ProfileExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ProfileExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension2, sizeof(tt__ProfileExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ProfileExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ProfileExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ProfileExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ProfileExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension2, SOAP_TYPE_tt__ProfileExtension2, sizeof(tt__ProfileExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ProfileExtension2 * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ProfileExtension2 *p;
	size_t k = sizeof(tt__ProfileExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ProfileExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ProfileExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ProfileExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ProfileExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ProfileExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ProfileExtension2(soap, tag ? tag : "tt:ProfileExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileExtension2 * SOAP_FMAC4 soap_get_tt__ProfileExtension2(struct soap *soap, tt__ProfileExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ProfileExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ProfileExtension::__any);
	this->tt__ProfileExtension::AudioOutputConfiguration = NULL;
	this->tt__ProfileExtension::AudioDecoderConfiguration = NULL;
	this->tt__ProfileExtension::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ProfileExtension::__anyAttribute);
}

void tt__ProfileExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ProfileExtension::__any);
	soap_serialize_PointerTott__AudioOutputConfiguration(soap, &this->tt__ProfileExtension::AudioOutputConfiguration);
	soap_serialize_PointerTott__AudioDecoderConfiguration(soap, &this->tt__ProfileExtension::AudioDecoderConfiguration);
	soap_serialize_PointerTott__ProfileExtension2(soap, &this->tt__ProfileExtension::Extension);
#endif
}

int tt__ProfileExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension(struct soap *soap, const char *tag, int id, const tt__ProfileExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ProfileExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ProfileExtension::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, "tt:AudioOutputConfiguration", -1, &a->tt__ProfileExtension::AudioOutputConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, "tt:AudioDecoderConfiguration", -1, &a->tt__ProfileExtension::AudioDecoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__ProfileExtension2(soap, "tt:Extension", -1, &a->tt__ProfileExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ProfileExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ProfileExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileExtension * SOAP_FMAC4 soap_in_tt__ProfileExtension(struct soap *soap, const char *tag, tt__ProfileExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ProfileExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension, sizeof(tt__ProfileExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ProfileExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ProfileExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ProfileExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_AudioOutputConfiguration1 = 1;
	size_t soap_flag_AudioDecoderConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioOutputConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioOutputConfiguration(soap, "tt:AudioOutputConfiguration", &a->tt__ProfileExtension::AudioOutputConfiguration, "tt:AudioOutputConfiguration"))
				{	soap_flag_AudioOutputConfiguration1--;
					continue;
				}
			}
			if (soap_flag_AudioDecoderConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioDecoderConfiguration(soap, "tt:AudioDecoderConfiguration", &a->tt__ProfileExtension::AudioDecoderConfiguration, "tt:AudioDecoderConfiguration"))
				{	soap_flag_AudioDecoderConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ProfileExtension2(soap, "tt:Extension", &a->tt__ProfileExtension::Extension, "tt:ProfileExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ProfileExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ProfileExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension, SOAP_TYPE_tt__ProfileExtension, sizeof(tt__ProfileExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ProfileExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ProfileExtension *p;
	size_t k = sizeof(tt__ProfileExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ProfileExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ProfileExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ProfileExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ProfileExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ProfileExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ProfileExtension(soap, tag ? tag : "tt:ProfileExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileExtension * SOAP_FMAC4 soap_get_tt__ProfileExtension(struct soap *soap, tt__ProfileExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Profile::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &this->tt__Profile::Name);
	this->tt__Profile::VideoSourceConfiguration = NULL;
	this->tt__Profile::AudioSourceConfiguration = NULL;
	this->tt__Profile::VideoEncoderConfiguration = NULL;
	this->tt__Profile::AudioEncoderConfiguration = NULL;
	this->tt__Profile::VideoAnalyticsConfiguration = NULL;
	this->tt__Profile::PTZConfiguration = NULL;
	this->tt__Profile::MetadataConfiguration = NULL;
	this->tt__Profile::Extension = NULL;
	soap_default_tt__ReferenceToken(soap, &this->tt__Profile::token);
	this->tt__Profile::fixed = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Profile::__anyAttribute);
}

void tt__Profile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Profile::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__Profile::Name);
	soap_serialize_PointerTott__VideoSourceConfiguration(soap, &this->tt__Profile::VideoSourceConfiguration);
	soap_serialize_PointerTott__AudioSourceConfiguration(soap, &this->tt__Profile::AudioSourceConfiguration);
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &this->tt__Profile::VideoEncoderConfiguration);
	soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &this->tt__Profile::AudioEncoderConfiguration);
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &this->tt__Profile::VideoAnalyticsConfiguration);
	soap_serialize_PointerTott__PTZConfiguration(soap, &this->tt__Profile::PTZConfiguration);
	soap_serialize_PointerTott__MetadataConfiguration(soap, &this->tt__Profile::MetadataConfiguration);
	soap_serialize_PointerTott__ProfileExtension(soap, &this->tt__Profile::Extension);
#endif
}

int tt__Profile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Profile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Profile(struct soap *soap, const char *tag, int id, const tt__Profile *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__Profile*)a)->token), 1);
	if (((tt__Profile*)a)->fixed)
	{	soap_set_attr(soap, "fixed", soap_bool2s(soap, *((tt__Profile*)a)->fixed), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Profile*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Profile), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__Profile::Name, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", -1, &a->tt__Profile::VideoSourceConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", -1, &a->tt__Profile::AudioSourceConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", -1, &a->tt__Profile::VideoEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", -1, &a->tt__Profile::AudioEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", -1, &a->tt__Profile::VideoAnalyticsConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", -1, &a->tt__Profile::PTZConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", -1, &a->tt__Profile::MetadataConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__ProfileExtension(soap, "tt:Extension", -1, &a->tt__Profile::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Profile::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Profile(soap, tag, this, type);
}

SOAP_FMAC3 tt__Profile * SOAP_FMAC4 soap_in_tt__Profile(struct soap *soap, const char *tag, tt__Profile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Profile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Profile, sizeof(tt__Profile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Profile)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Profile *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__Profile*)a)->token))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "fixed", 5, 0);
		if (t)
		{
			if (!(((tt__Profile*)a)->fixed = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__Profile*)a)->fixed))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Profile*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_VideoSourceConfiguration1 = 1;
	size_t soap_flag_AudioSourceConfiguration1 = 1;
	size_t soap_flag_VideoEncoderConfiguration1 = 1;
	size_t soap_flag_AudioEncoderConfiguration1 = 1;
	size_t soap_flag_VideoAnalyticsConfiguration1 = 1;
	size_t soap_flag_PTZConfiguration1 = 1;
	size_t soap_flag_MetadataConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__Profile::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_VideoSourceConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", &a->tt__Profile::VideoSourceConfiguration, "tt:VideoSourceConfiguration"))
				{	soap_flag_VideoSourceConfiguration1--;
					continue;
				}
			}
			if (soap_flag_AudioSourceConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", &a->tt__Profile::AudioSourceConfiguration, "tt:AudioSourceConfiguration"))
				{	soap_flag_AudioSourceConfiguration1--;
					continue;
				}
			}
			if (soap_flag_VideoEncoderConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", &a->tt__Profile::VideoEncoderConfiguration, "tt:VideoEncoderConfiguration"))
				{	soap_flag_VideoEncoderConfiguration1--;
					continue;
				}
			}
			if (soap_flag_AudioEncoderConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", &a->tt__Profile::AudioEncoderConfiguration, "tt:AudioEncoderConfiguration"))
				{	soap_flag_AudioEncoderConfiguration1--;
					continue;
				}
			}
			if (soap_flag_VideoAnalyticsConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", &a->tt__Profile::VideoAnalyticsConfiguration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_VideoAnalyticsConfiguration1--;
					continue;
				}
			}
			if (soap_flag_PTZConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", &a->tt__Profile::PTZConfiguration, "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration1--;
					continue;
				}
			}
			if (soap_flag_MetadataConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", &a->tt__Profile::MetadataConfiguration, "tt:MetadataConfiguration"))
				{	soap_flag_MetadataConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ProfileExtension(soap, "tt:Extension", &a->tt__Profile::Extension, "tt:ProfileExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Profile, SOAP_TYPE_tt__Profile, sizeof(tt__Profile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Profile * SOAP_FMAC2 soap_instantiate_tt__Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Profile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Profile *p;
	size_t k = sizeof(tt__Profile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Profile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Profile);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Profile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Profile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Profile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Profile(soap, tag ? tag : "tt:Profile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Profile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Profile(soap, this, tag, type);
}

SOAP_FMAC3 tt__Profile * SOAP_FMAC4 soap_get_tt__Profile(struct soap *soap, tt__Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioSource::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__DeviceEntity::soap_default(soap);
	soap_default_int(soap, &this->tt__AudioSource::Channels);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioSource::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioSource::__anyAttribute);
}

void tt__AudioSource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AudioSource::Channels, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioSource::__any);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__AudioSource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSource(struct soap *soap, const char *tag, int id, const tt__AudioSource *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioSource*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSource), type ? type : "tt:AudioSource"))
		return soap->error;
	if (soap_out_int(soap, "tt:Channels", -1, &a->tt__AudioSource::Channels, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioSource::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSource::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioSource(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSource * SOAP_FMAC4 soap_in_tt__AudioSource(struct soap *soap, const char *tag, tt__AudioSource *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSource*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSource, sizeof(tt__AudioSource), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioSource)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioSource *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioSource*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Channels1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Channels1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Channels", &a->tt__AudioSource::Channels, "xsd:int"))
				{	soap_flag_Channels1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioSource::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Channels1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSource, SOAP_TYPE_tt__AudioSource, sizeof(tt__AudioSource), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioSource * SOAP_FMAC2 soap_instantiate_tt__AudioSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioSource *p;
	size_t k = sizeof(tt__AudioSource);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioSource);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioSource, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioSource location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioSource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioSource(soap, tag ? tag : "tt:AudioSource", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSource(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSource * SOAP_FMAC4 soap_get_tt__AudioSource(struct soap *soap, tt__AudioSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceExtension2::__any);
}

void tt__VideoSourceExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceExtension2::__any);
#endif
}

int tt__VideoSourceExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceExtension2(struct soap *soap, const char *tag, int id, const tt__VideoSourceExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoSourceExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceExtension2(struct soap *soap, const char *tag, tt__VideoSourceExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(tt__VideoSourceExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoSourceExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceExtension2, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(tt__VideoSourceExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceExtension2 *p;
	size_t k = sizeof(tt__VideoSourceExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceExtension2(soap, tag ? tag : "tt:VideoSourceExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceExtension2(struct soap *soap, tt__VideoSourceExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceExtension::__any);
	this->tt__VideoSourceExtension::Imaging = NULL;
	this->tt__VideoSourceExtension::Extension = NULL;
}

void tt__VideoSourceExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceExtension::__any);
	soap_serialize_PointerTott__ImagingSettings20(soap, &this->tt__VideoSourceExtension::Imaging);
	soap_serialize_PointerTott__VideoSourceExtension2(soap, &this->tt__VideoSourceExtension::Extension);
#endif
}

int tt__VideoSourceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceExtension(struct soap *soap, const char *tag, int id, const tt__VideoSourceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__VideoSourceExtension::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettings20(soap, "tt:Imaging", -1, &a->tt__VideoSourceExtension::Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceExtension2(soap, "tt:Extension", -1, &a->tt__VideoSourceExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceExtension * SOAP_FMAC4 soap_in_tt__VideoSourceExtension(struct soap *soap, const char *tag, tt__VideoSourceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(tt__VideoSourceExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Imaging1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Imaging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettings20(soap, "tt:Imaging", &a->tt__VideoSourceExtension::Imaging, "tt:ImagingSettings20"))
				{	soap_flag_Imaging1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceExtension2(soap, "tt:Extension", &a->tt__VideoSourceExtension::Extension, "tt:VideoSourceExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__VideoSourceExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceExtension, SOAP_TYPE_tt__VideoSourceExtension, sizeof(tt__VideoSourceExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceExtension *p;
	size_t k = sizeof(tt__VideoSourceExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceExtension(soap, tag ? tag : "tt:VideoSourceExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceExtension * SOAP_FMAC4 soap_get_tt__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSource::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__DeviceEntity::soap_default(soap);
	soap_default_float(soap, &this->tt__VideoSource::Framerate);
	this->tt__VideoSource::Resolution = NULL;
	this->tt__VideoSource::Imaging = NULL;
	this->tt__VideoSource::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoSource::__anyAttribute);
}

void tt__VideoSource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoSource::Framerate, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoResolution(soap, &this->tt__VideoSource::Resolution);
	soap_serialize_PointerTott__ImagingSettings(soap, &this->tt__VideoSource::Imaging);
	soap_serialize_PointerTott__VideoSourceExtension(soap, &this->tt__VideoSource::Extension);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__VideoSource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSource(struct soap *soap, const char *tag, int id, const tt__VideoSource *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoSource*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSource), type ? type : "tt:VideoSource"))
		return soap->error;
	if (soap_out_float(soap, "tt:Framerate", -1, &a->tt__VideoSource::Framerate, ""))
		return soap->error;
	if (!a->tt__VideoSource::Resolution)
	{	if (soap_element_empty(soap, "tt:Resolution"))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->tt__VideoSource::Resolution, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettings(soap, "tt:Imaging", -1, &a->tt__VideoSource::Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceExtension(soap, "tt:Extension", -1, &a->tt__VideoSource::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSource::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSource(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSource * SOAP_FMAC4 soap_in_tt__VideoSource(struct soap *soap, const char *tag, tt__VideoSource *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSource*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSource, sizeof(tt__VideoSource), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSource)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSource *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoSource*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Framerate1 = 1;
	size_t soap_flag_Resolution1 = 1;
	size_t soap_flag_Imaging1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Framerate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Framerate", &a->tt__VideoSource::Framerate, "xsd:float"))
				{	soap_flag_Framerate1--;
					continue;
				}
			}
			if (soap_flag_Resolution1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->tt__VideoSource::Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution1--;
					continue;
				}
			}
			if (soap_flag_Imaging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettings(soap, "tt:Imaging", &a->tt__VideoSource::Imaging, "tt:ImagingSettings"))
				{	soap_flag_Imaging1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceExtension(soap, "tt:Extension", &a->tt__VideoSource::Extension, "tt:VideoSourceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Framerate1 > 0 || !a->tt__VideoSource::Resolution))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSource, SOAP_TYPE_tt__VideoSource, sizeof(tt__VideoSource), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSource * SOAP_FMAC2 soap_instantiate_tt__VideoSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSource *p;
	size_t k = sizeof(tt__VideoSource);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSource);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSource, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSource location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSource(soap, tag ? tag : "tt:VideoSource", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSource(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSource * SOAP_FMAC4 soap_get_tt__VideoSource(struct soap *soap, tt__VideoSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnyHolder::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnyHolder::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AnyHolder::__anyAttribute);
}

void tt__AnyHolder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnyHolder::__any);
#endif
}

int tt__AnyHolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnyHolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnyHolder(struct soap *soap, const char *tag, int id, const tt__AnyHolder *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnyHolder*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnyHolder), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AnyHolder::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnyHolder::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnyHolder(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnyHolder * SOAP_FMAC4 soap_in_tt__AnyHolder(struct soap *soap, const char *tag, tt__AnyHolder *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnyHolder*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnyHolder, sizeof(tt__AnyHolder), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnyHolder)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnyHolder *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnyHolder*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AnyHolder::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnyHolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnyHolder, SOAP_TYPE_tt__AnyHolder, sizeof(tt__AnyHolder), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnyHolder * SOAP_FMAC2 soap_instantiate_tt__AnyHolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnyHolder(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnyHolder *p;
	size_t k = sizeof(tt__AnyHolder);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnyHolder, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnyHolder);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnyHolder, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnyHolder location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnyHolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnyHolder(soap, tag ? tag : "tt:AnyHolder", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnyHolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnyHolder(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnyHolder * SOAP_FMAC4 soap_get_tt__AnyHolder(struct soap *soap, tt__AnyHolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnyHolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FloatList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOffloat(soap, &this->tt__FloatList::Items);
}

void tt__FloatList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOffloat(soap, &this->tt__FloatList::Items);
#endif
}

int tt__FloatList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FloatList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatList(struct soap *soap, const char *tag, int id, const tt__FloatList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOffloat(soap, "tt:Items", -1, &a->tt__FloatList::Items, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FloatList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FloatList(soap, tag, this, type);
}

SOAP_FMAC3 tt__FloatList * SOAP_FMAC4 soap_in_tt__FloatList(struct soap *soap, const char *tag, tt__FloatList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FloatList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatList, sizeof(tt__FloatList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FloatList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FloatList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOffloat(soap, "tt:Items", &a->tt__FloatList::Items, "xsd:float"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FloatList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatList, SOAP_TYPE_tt__FloatList, sizeof(tt__FloatList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FloatList * SOAP_FMAC2 soap_instantiate_tt__FloatList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FloatList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FloatList *p;
	size_t k = sizeof(tt__FloatList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FloatList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FloatList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FloatList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FloatList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FloatList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FloatList(soap, tag ? tag : "tt:FloatList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FloatList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FloatList(soap, this, tag, type);
}

SOAP_FMAC3 tt__FloatList * SOAP_FMAC4 soap_get_tt__FloatList(struct soap *soap, tt__FloatList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfint(soap, &this->tt__IntList::Items);
}

void tt__IntList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfint(soap, &this->tt__IntList::Items);
#endif
}

int tt__IntList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntList(struct soap *soap, const char *tag, int id, const tt__IntList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "tt:Items", -1, &a->tt__IntList::Items, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntList(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntList * SOAP_FMAC4 soap_in_tt__IntList(struct soap *soap, const char *tag, tt__IntList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntList, sizeof(tt__IntList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IntList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfint(soap, "tt:Items", &a->tt__IntList::Items, "xsd:int"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IntList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntList, SOAP_TYPE_tt__IntList, sizeof(tt__IntList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntList * SOAP_FMAC2 soap_instantiate_tt__IntList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntList *p;
	size_t k = sizeof(tt__IntList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntList(soap, tag ? tag : "tt:IntList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntList(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntList * SOAP_FMAC4 soap_get_tt__IntList(struct soap *soap, tt__IntList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DurationRange::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &this->tt__DurationRange::Min);
	soap_default_xsd__duration(soap, &this->tt__DurationRange::Max);
}

void tt__DurationRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DurationRange::Min, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__DurationRange::Min);
	soap_embedded(soap, &this->tt__DurationRange::Max, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__DurationRange::Max);
#endif
}

int tt__DurationRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DurationRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DurationRange(struct soap *soap, const char *tag, int id, const tt__DurationRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DurationRange), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Min", -1, &a->tt__DurationRange::Min, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Max", -1, &a->tt__DurationRange::Max, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DurationRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DurationRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_in_tt__DurationRange(struct soap *soap, const char *tag, tt__DurationRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DurationRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DurationRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DurationRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:Min", &a->tt__DurationRange::Min, "xsd:duration"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:Max", &a->tt__DurationRange::Max, "xsd:duration"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DurationRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DurationRange, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 soap_instantiate_tt__DurationRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DurationRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DurationRange *p;
	size_t k = sizeof(tt__DurationRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DurationRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DurationRange);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DurationRange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DurationRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DurationRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DurationRange(soap, tag ? tag : "tt:DurationRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DurationRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DurationRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_get_tt__DurationRange(struct soap *soap, tt__DurationRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FloatRange::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__FloatRange::Min);
	soap_default_float(soap, &this->tt__FloatRange::Max);
}

void tt__FloatRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__FloatRange::Min, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FloatRange::Max, SOAP_TYPE_float);
#endif
}

int tt__FloatRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FloatRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatRange(struct soap *soap, const char *tag, int id, const tt__FloatRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatRange), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Min", -1, &a->tt__FloatRange::Min, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Max", -1, &a->tt__FloatRange::Max, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FloatRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FloatRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_in_tt__FloatRange(struct soap *soap, const char *tag, tt__FloatRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FloatRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FloatRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FloatRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Min", &a->tt__FloatRange::Min, "xsd:float"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Max", &a->tt__FloatRange::Max, "xsd:float"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FloatRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatRange, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 soap_instantiate_tt__FloatRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FloatRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FloatRange *p;
	size_t k = sizeof(tt__FloatRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FloatRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FloatRange);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FloatRange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FloatRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FloatRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FloatRange(soap, tag ? tag : "tt:FloatRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FloatRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FloatRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_get_tt__FloatRange(struct soap *soap, tt__FloatRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntRange::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__IntRange::Min);
	soap_default_int(soap, &this->tt__IntRange::Max);
}

void tt__IntRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IntRange::Min, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__IntRange::Max, SOAP_TYPE_int);
#endif
}

int tt__IntRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRange(struct soap *soap, const char *tag, int id, const tt__IntRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRange), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Min", -1, &a->tt__IntRange::Min, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Max", -1, &a->tt__IntRange::Max, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_in_tt__IntRange(struct soap *soap, const char *tag, tt__IntRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IntRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Min", &a->tt__IntRange::Min, "xsd:int"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Max", &a->tt__IntRange::Max, "xsd:int"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRange, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 soap_instantiate_tt__IntRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntRange *p;
	size_t k = sizeof(tt__IntRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntRange);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntRange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntRange(soap, tag ? tag : "tt:IntRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_get_tt__IntRange(struct soap *soap, tt__IntRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntRectangleRange::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__IntRectangleRange::XRange = NULL;
	this->tt__IntRectangleRange::YRange = NULL;
	this->tt__IntRectangleRange::WidthRange = NULL;
	this->tt__IntRectangleRange::HeightRange = NULL;
}

void tt__IntRectangleRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::XRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::YRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::WidthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::HeightRange);
#endif
}

int tt__IntRectangleRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRectangleRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangleRange(struct soap *soap, const char *tag, int id, const tt__IntRectangleRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangleRange), type))
		return soap->error;
	if (!a->tt__IntRectangleRange::XRange)
	{	if (soap_element_empty(soap, "tt:XRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:XRange", -1, &a->tt__IntRectangleRange::XRange, ""))
		return soap->error;
	if (!a->tt__IntRectangleRange::YRange)
	{	if (soap_element_empty(soap, "tt:YRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:YRange", -1, &a->tt__IntRectangleRange::YRange, ""))
		return soap->error;
	if (!a->tt__IntRectangleRange::WidthRange)
	{	if (soap_element_empty(soap, "tt:WidthRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:WidthRange", -1, &a->tt__IntRectangleRange::WidthRange, ""))
		return soap->error;
	if (!a->tt__IntRectangleRange::HeightRange)
	{	if (soap_element_empty(soap, "tt:HeightRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:HeightRange", -1, &a->tt__IntRectangleRange::HeightRange, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntRectangleRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntRectangleRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRectangleRange * SOAP_FMAC4 soap_in_tt__IntRectangleRange(struct soap *soap, const char *tag, tt__IntRectangleRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRectangleRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangleRange, sizeof(tt__IntRectangleRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntRectangleRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IntRectangleRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XRange1 = 1;
	size_t soap_flag_YRange1 = 1;
	size_t soap_flag_WidthRange1 = 1;
	size_t soap_flag_HeightRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:XRange", &a->tt__IntRectangleRange::XRange, "tt:IntRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			}
			if (soap_flag_YRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:YRange", &a->tt__IntRectangleRange::YRange, "tt:IntRange"))
				{	soap_flag_YRange1--;
					continue;
				}
			}
			if (soap_flag_WidthRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:WidthRange", &a->tt__IntRectangleRange::WidthRange, "tt:IntRange"))
				{	soap_flag_WidthRange1--;
					continue;
				}
			}
			if (soap_flag_HeightRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:HeightRange", &a->tt__IntRectangleRange::HeightRange, "tt:IntRange"))
				{	soap_flag_HeightRange1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__IntRectangleRange::XRange || !a->tt__IntRectangleRange::YRange || !a->tt__IntRectangleRange::WidthRange || !a->tt__IntRectangleRange::HeightRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IntRectangleRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangleRange, SOAP_TYPE_tt__IntRectangleRange, sizeof(tt__IntRectangleRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 soap_instantiate_tt__IntRectangleRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRectangleRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntRectangleRange *p;
	size_t k = sizeof(tt__IntRectangleRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntRectangleRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntRectangleRange);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntRectangleRange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntRectangleRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntRectangleRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntRectangleRange(soap, tag ? tag : "tt:IntRectangleRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRectangleRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRectangleRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRectangleRange * SOAP_FMAC4 soap_get_tt__IntRectangleRange(struct soap *soap, tt__IntRectangleRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntRectangle::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__IntRectangle::x);
	soap_default_int(soap, &this->tt__IntRectangle::y);
	soap_default_int(soap, &this->tt__IntRectangle::width);
	soap_default_int(soap, &this->tt__IntRectangle::height);
}

void tt__IntRectangle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__IntRectangle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRectangle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangle(struct soap *soap, const char *tag, int id, const tt__IntRectangle *a, const char *type)
{
	soap_set_attr(soap, "x", soap_int2s(soap, ((tt__IntRectangle*)a)->x), 1);
	soap_set_attr(soap, "y", soap_int2s(soap, ((tt__IntRectangle*)a)->y), 1);
	soap_set_attr(soap, "width", soap_int2s(soap, ((tt__IntRectangle*)a)->width), 1);
	soap_set_attr(soap, "height", soap_int2s(soap, ((tt__IntRectangle*)a)->height), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangle), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntRectangle::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntRectangle(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRectangle * SOAP_FMAC4 soap_in_tt__IntRectangle(struct soap *soap, const char *tag, tt__IntRectangle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRectangle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangle, sizeof(tt__IntRectangle), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntRectangle)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IntRectangle *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2int(soap, soap_attr_value(soap, "x", 5, 1), &((tt__IntRectangle*)a)->x))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "y", 5, 1), &((tt__IntRectangle*)a)->y))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "width", 5, 1), &((tt__IntRectangle*)a)->width))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "height", 5, 1), &((tt__IntRectangle*)a)->height))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IntRectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangle, SOAP_TYPE_tt__IntRectangle, sizeof(tt__IntRectangle), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 soap_instantiate_tt__IntRectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRectangle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntRectangle *p;
	size_t k = sizeof(tt__IntRectangle);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntRectangle, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntRectangle);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntRectangle, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntRectangle location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntRectangle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntRectangle(soap, tag ? tag : "tt:IntRectangle", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRectangle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRectangle(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRectangle * SOAP_FMAC4 soap_get_tt__IntRectangle(struct soap *soap, tt__IntRectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceEntity::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &this->tt__DeviceEntity::token);
}

void tt__DeviceEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__DeviceEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceEntity(struct soap *soap, const char *tag, int id, const tt__DeviceEntity *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceEntity), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceEntity * SOAP_FMAC4 soap_in_tt__DeviceEntity(struct soap *soap, const char *tag, tt__DeviceEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceEntity, sizeof(tt__DeviceEntity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceEntity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceEntity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DeviceEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceEntity, SOAP_TYPE_tt__DeviceEntity, sizeof(tt__DeviceEntity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceEntity * SOAP_FMAC2 soap_instantiate_tt__DeviceEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tds:StorageConfiguration"))
		return soap_instantiate_tds__StorageConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSource"))
		return soap_instantiate_tt__VideoSource(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioSource"))
		return soap_instantiate_tt__AudioSource(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoOutput"))
		return soap_instantiate_tt__VideoOutput(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioOutput"))
		return soap_instantiate_tt__AudioOutput(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterface"))
		return soap_instantiate_tt__NetworkInterface(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RelayOutput"))
		return soap_instantiate_tt__RelayOutput(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DigitalInput"))
		return soap_instantiate_tt__DigitalInput(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZNode"))
		return soap_instantiate_tt__PTZNode(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDConfiguration"))
		return soap_instantiate_tt__OSDConfiguration(soap, n, NULL, NULL, size);
	tt__DeviceEntity *p;
	size_t k = sizeof(tt__DeviceEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceEntity);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceEntity, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceEntity(soap, tag ? tag : "tt:DeviceEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceEntity * SOAP_FMAC4 soap_get_tt__DeviceEntity(struct soap *soap, tt__DeviceEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteGeoLocationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteGeoLocationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteGeoLocationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteGeoLocationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteGeoLocationResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteGeoLocationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteGeoLocationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteGeoLocationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteGeoLocationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteGeoLocationResponse * SOAP_FMAC4 soap_in__tds__DeleteGeoLocationResponse(struct soap *soap, const char *tag, _tds__DeleteGeoLocationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteGeoLocationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteGeoLocationResponse, sizeof(_tds__DeleteGeoLocationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteGeoLocationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteGeoLocationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteGeoLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteGeoLocationResponse, SOAP_TYPE__tds__DeleteGeoLocationResponse, sizeof(_tds__DeleteGeoLocationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteGeoLocationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteGeoLocationResponse *p;
	size_t k = sizeof(_tds__DeleteGeoLocationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteGeoLocationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteGeoLocationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteGeoLocationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteGeoLocationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteGeoLocationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteGeoLocationResponse(soap, tag ? tag : "tds:DeleteGeoLocationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteGeoLocationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteGeoLocationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteGeoLocationResponse * SOAP_FMAC4 soap_get__tds__DeleteGeoLocationResponse(struct soap *soap, _tds__DeleteGeoLocationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteGeoLocationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteGeoLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__DeleteGeoLocation::Location);
}

void _tds__DeleteGeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__DeleteGeoLocation::Location);
#endif
}

int _tds__DeleteGeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteGeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteGeoLocation(struct soap *soap, const char *tag, int id, const _tds__DeleteGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteGeoLocation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", -1, &a->_tds__DeleteGeoLocation::Location, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteGeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteGeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteGeoLocation * SOAP_FMAC4 soap_in__tds__DeleteGeoLocation(struct soap *soap, const char *tag, _tds__DeleteGeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteGeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteGeoLocation, sizeof(_tds__DeleteGeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteGeoLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteGeoLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", &a->_tds__DeleteGeoLocation::Location, "tt:LocationEntity"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__DeleteGeoLocation::Location.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__DeleteGeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteGeoLocation, SOAP_TYPE__tds__DeleteGeoLocation, sizeof(_tds__DeleteGeoLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteGeoLocation *p;
	size_t k = sizeof(_tds__DeleteGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteGeoLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteGeoLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteGeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteGeoLocation(soap, tag ? tag : "tds:DeleteGeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteGeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteGeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteGeoLocation * SOAP_FMAC4 soap_get__tds__DeleteGeoLocation(struct soap *soap, _tds__DeleteGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetGeoLocationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetGeoLocationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetGeoLocationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetGeoLocationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetGeoLocationResponse(struct soap *soap, const char *tag, int id, const _tds__SetGeoLocationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetGeoLocationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetGeoLocationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetGeoLocationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetGeoLocationResponse * SOAP_FMAC4 soap_in__tds__SetGeoLocationResponse(struct soap *soap, const char *tag, _tds__SetGeoLocationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetGeoLocationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetGeoLocationResponse, sizeof(_tds__SetGeoLocationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetGeoLocationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetGeoLocationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetGeoLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetGeoLocationResponse, SOAP_TYPE__tds__SetGeoLocationResponse, sizeof(_tds__SetGeoLocationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetGeoLocationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetGeoLocationResponse *p;
	size_t k = sizeof(_tds__SetGeoLocationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetGeoLocationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetGeoLocationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetGeoLocationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetGeoLocationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetGeoLocationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetGeoLocationResponse(soap, tag ? tag : "tds:SetGeoLocationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetGeoLocationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetGeoLocationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetGeoLocationResponse * SOAP_FMAC4 soap_get__tds__SetGeoLocationResponse(struct soap *soap, _tds__SetGeoLocationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetGeoLocationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetGeoLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__SetGeoLocation::Location);
}

void _tds__SetGeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__SetGeoLocation::Location);
#endif
}

int _tds__SetGeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetGeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetGeoLocation(struct soap *soap, const char *tag, int id, const _tds__SetGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetGeoLocation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", -1, &a->_tds__SetGeoLocation::Location, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetGeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetGeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetGeoLocation * SOAP_FMAC4 soap_in__tds__SetGeoLocation(struct soap *soap, const char *tag, _tds__SetGeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetGeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetGeoLocation, sizeof(_tds__SetGeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetGeoLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetGeoLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", &a->_tds__SetGeoLocation::Location, "tt:LocationEntity"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__SetGeoLocation::Location.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetGeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetGeoLocation, SOAP_TYPE__tds__SetGeoLocation, sizeof(_tds__SetGeoLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetGeoLocation *p;
	size_t k = sizeof(_tds__SetGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetGeoLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetGeoLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetGeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetGeoLocation(soap, tag ? tag : "tds:SetGeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetGeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetGeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetGeoLocation * SOAP_FMAC4 soap_get__tds__SetGeoLocation(struct soap *soap, _tds__SetGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetGeoLocationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__GetGeoLocationResponse::Location);
}

void _tds__GetGeoLocationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__GetGeoLocationResponse::Location);
#endif
}

int _tds__GetGeoLocationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetGeoLocationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetGeoLocationResponse(struct soap *soap, const char *tag, int id, const _tds__GetGeoLocationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetGeoLocationResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Location");
	if (soap_out_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", -1, &a->_tds__GetGeoLocationResponse::Location, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetGeoLocationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetGeoLocationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetGeoLocationResponse * SOAP_FMAC4 soap_in__tds__GetGeoLocationResponse(struct soap *soap, const char *tag, _tds__GetGeoLocationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetGeoLocationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetGeoLocationResponse, sizeof(_tds__GetGeoLocationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetGeoLocationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetGeoLocationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", &a->_tds__GetGeoLocationResponse::Location, "tt:LocationEntity"))
					continue;
			}
			soap_check_result(soap, "tds:Location");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetGeoLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetGeoLocationResponse, SOAP_TYPE__tds__GetGeoLocationResponse, sizeof(_tds__GetGeoLocationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetGeoLocationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetGeoLocationResponse *p;
	size_t k = sizeof(_tds__GetGeoLocationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetGeoLocationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetGeoLocationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetGeoLocationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetGeoLocationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetGeoLocationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetGeoLocationResponse(soap, tag ? tag : "tds:GetGeoLocationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetGeoLocationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetGeoLocationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetGeoLocationResponse * SOAP_FMAC4 soap_get__tds__GetGeoLocationResponse(struct soap *soap, _tds__GetGeoLocationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetGeoLocationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetGeoLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetGeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetGeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetGeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetGeoLocation(struct soap *soap, const char *tag, int id, const _tds__GetGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetGeoLocation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetGeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetGeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetGeoLocation * SOAP_FMAC4 soap_in__tds__GetGeoLocation(struct soap *soap, const char *tag, _tds__GetGeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetGeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetGeoLocation, sizeof(_tds__GetGeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetGeoLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetGeoLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetGeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetGeoLocation, SOAP_TYPE__tds__GetGeoLocation, sizeof(_tds__GetGeoLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetGeoLocation *p;
	size_t k = sizeof(_tds__GetGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetGeoLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetGeoLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetGeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetGeoLocation(soap, tag ? tag : "tds:GetGeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetGeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetGeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetGeoLocation * SOAP_FMAC4 soap_get__tds__GetGeoLocation(struct soap *soap, _tds__GetGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteStorageConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteStorageConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteStorageConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteStorageConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteStorageConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteStorageConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteStorageConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__DeleteStorageConfigurationResponse(struct soap *soap, const char *tag, _tds__DeleteStorageConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, sizeof(_tds__DeleteStorageConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteStorageConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteStorageConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, sizeof(_tds__DeleteStorageConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteStorageConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteStorageConfigurationResponse *p;
	size_t k = sizeof(_tds__DeleteStorageConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteStorageConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteStorageConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteStorageConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteStorageConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteStorageConfigurationResponse(soap, tag ? tag : "tds:DeleteStorageConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteStorageConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteStorageConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__DeleteStorageConfigurationResponse(struct soap *soap, _tds__DeleteStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteStorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__DeleteStorageConfiguration::Token);
}

void _tds__DeleteStorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__DeleteStorageConfiguration::Token, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__DeleteStorageConfiguration::Token);
#endif
}

int _tds__DeleteStorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteStorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, int id, const _tds__DeleteStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteStorageConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, &a->_tds__DeleteStorageConfiguration::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteStorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteStorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_in__tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, _tds__DeleteStorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(_tds__DeleteStorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteStorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteStorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Token", &a->_tds__DeleteStorageConfiguration::Token, "tt:ReferenceToken"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__DeleteStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteStorageConfiguration, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(_tds__DeleteStorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteStorageConfiguration *p;
	size_t k = sizeof(_tds__DeleteStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteStorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteStorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteStorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteStorageConfiguration(soap, tag ? tag : "tds:DeleteStorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteStorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteStorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_get__tds__DeleteStorageConfiguration(struct soap *soap, _tds__DeleteStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetStorageConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetStorageConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetStorageConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetStorageConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetStorageConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetStorageConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetStorageConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetStorageConfigurationResponse(struct soap *soap, const char *tag, _tds__SetStorageConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetStorageConfigurationResponse, sizeof(_tds__SetStorageConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetStorageConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetStorageConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetStorageConfigurationResponse, SOAP_TYPE__tds__SetStorageConfigurationResponse, sizeof(_tds__SetStorageConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetStorageConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetStorageConfigurationResponse *p;
	size_t k = sizeof(_tds__SetStorageConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetStorageConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetStorageConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetStorageConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetStorageConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetStorageConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetStorageConfigurationResponse(soap, tag ? tag : "tds:SetStorageConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetStorageConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetStorageConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetStorageConfigurationResponse(struct soap *soap, _tds__SetStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetStorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetStorageConfiguration::StorageConfiguration = NULL;
}

void _tds__SetStorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfiguration(soap, &this->_tds__SetStorageConfiguration::StorageConfiguration);
#endif
}

int _tds__SetStorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetStorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetStorageConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetStorageConfiguration), type))
		return soap->error;
	if (!a->_tds__SetStorageConfiguration::StorageConfiguration)
	{	if (soap_element_empty(soap, "tds:StorageConfiguration"))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", -1, &a->_tds__SetStorageConfiguration::StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetStorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetStorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetStorageConfiguration * SOAP_FMAC4 soap_in__tds__SetStorageConfiguration(struct soap *soap, const char *tag, _tds__SetStorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(_tds__SetStorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetStorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetStorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StorageConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", &a->_tds__SetStorageConfiguration::StorageConfiguration, "tds:StorageConfiguration"))
				{	soap_flag_StorageConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__SetStorageConfiguration::StorageConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetStorageConfiguration, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(_tds__SetStorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetStorageConfiguration *p;
	size_t k = sizeof(_tds__SetStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetStorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetStorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetStorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetStorageConfiguration(soap, tag ? tag : "tds:SetStorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetStorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetStorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetStorageConfiguration * SOAP_FMAC4 soap_get__tds__SetStorageConfiguration(struct soap *soap, _tds__SetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetStorageConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetStorageConfigurationResponse::StorageConfiguration = NULL;
}

void _tds__GetStorageConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfiguration(soap, &this->_tds__GetStorageConfigurationResponse::StorageConfiguration);
#endif
}

int _tds__GetStorageConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetStorageConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurationResponse), type))
		return soap->error;
	if (a->StorageConfiguration)
		soap_element_result(soap, "tds:StorageConfiguration");
	if (!a->_tds__GetStorageConfigurationResponse::StorageConfiguration)
	{	if (soap_element_empty(soap, "tds:StorageConfiguration"))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", -1, &a->_tds__GetStorageConfigurationResponse::StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetStorageConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetStorageConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetStorageConfigurationResponse(struct soap *soap, const char *tag, _tds__GetStorageConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurationResponse, sizeof(_tds__GetStorageConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetStorageConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetStorageConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StorageConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", &a->_tds__GetStorageConfigurationResponse::StorageConfiguration, "tds:StorageConfiguration"))
				{	soap_flag_StorageConfiguration1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:StorageConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetStorageConfigurationResponse::StorageConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurationResponse, SOAP_TYPE__tds__GetStorageConfigurationResponse, sizeof(_tds__GetStorageConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetStorageConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetStorageConfigurationResponse *p;
	size_t k = sizeof(_tds__GetStorageConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetStorageConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetStorageConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetStorageConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetStorageConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetStorageConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetStorageConfigurationResponse(soap, tag ? tag : "tds:GetStorageConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetStorageConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetStorageConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetStorageConfigurationResponse(struct soap *soap, _tds__GetStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetStorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__GetStorageConfiguration::Token);
}

void _tds__GetStorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetStorageConfiguration::Token, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__GetStorageConfiguration::Token);
#endif
}

int _tds__GetStorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetStorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, &a->_tds__GetStorageConfiguration::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetStorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetStorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetStorageConfiguration * SOAP_FMAC4 soap_in__tds__GetStorageConfiguration(struct soap *soap, const char *tag, _tds__GetStorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(_tds__GetStorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetStorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetStorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Token", &a->_tds__GetStorageConfiguration::Token, "tt:ReferenceToken"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfiguration, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(_tds__GetStorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetStorageConfiguration *p;
	size_t k = sizeof(_tds__GetStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetStorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetStorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetStorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetStorageConfiguration(soap, tag ? tag : "tds:GetStorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetStorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetStorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetStorageConfiguration * SOAP_FMAC4 soap_get__tds__GetStorageConfiguration(struct soap *soap, _tds__GetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateStorageConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__CreateStorageConfigurationResponse::Token);
}

void _tds__CreateStorageConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__CreateStorageConfigurationResponse::Token, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__CreateStorageConfigurationResponse::Token);
#endif
}

int _tds__CreateStorageConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateStorageConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__CreateStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateStorageConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Token");
	if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, &a->_tds__CreateStorageConfigurationResponse::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateStorageConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateStorageConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__CreateStorageConfigurationResponse(struct soap *soap, const char *tag, _tds__CreateStorageConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(_tds__CreateStorageConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateStorageConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateStorageConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Token", &a->_tds__CreateStorageConfigurationResponse::Token, "tt:ReferenceToken"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Token");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateStorageConfigurationResponse, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(_tds__CreateStorageConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateStorageConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateStorageConfigurationResponse *p;
	size_t k = sizeof(_tds__CreateStorageConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateStorageConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateStorageConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateStorageConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateStorageConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateStorageConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateStorageConfigurationResponse(soap, tag ? tag : "tds:CreateStorageConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateStorageConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateStorageConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__CreateStorageConfigurationResponse(struct soap *soap, _tds__CreateStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateStorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateStorageConfiguration::StorageConfiguration = NULL;
}

void _tds__CreateStorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfigurationData(soap, &this->_tds__CreateStorageConfiguration::StorageConfiguration);
#endif
}

int _tds__CreateStorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateStorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateStorageConfiguration(struct soap *soap, const char *tag, int id, const _tds__CreateStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateStorageConfiguration), type))
		return soap->error;
	if (!a->_tds__CreateStorageConfiguration::StorageConfiguration)
	{	if (soap_element_empty(soap, "tds:StorageConfiguration"))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfigurationData(soap, "tds:StorageConfiguration", -1, &a->_tds__CreateStorageConfiguration::StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateStorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateStorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateStorageConfiguration * SOAP_FMAC4 soap_in__tds__CreateStorageConfiguration(struct soap *soap, const char *tag, _tds__CreateStorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(_tds__CreateStorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateStorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateStorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StorageConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfigurationData(soap, "tds:StorageConfiguration", &a->_tds__CreateStorageConfiguration::StorageConfiguration, "tds:StorageConfigurationData"))
				{	soap_flag_StorageConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__CreateStorageConfiguration::StorageConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateStorageConfiguration, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(_tds__CreateStorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateStorageConfiguration *p;
	size_t k = sizeof(_tds__CreateStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateStorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateStorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateStorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateStorageConfiguration(soap, tag ? tag : "tds:CreateStorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateStorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateStorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateStorageConfiguration * SOAP_FMAC4 soap_get__tds__CreateStorageConfiguration(struct soap *soap, _tds__CreateStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetStorageConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, &this->_tds__GetStorageConfigurationsResponse::StorageConfigurations);
}

void _tds__GetStorageConfigurationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, &this->_tds__GetStorageConfigurationsResponse::StorageConfigurations);
#endif
}

int _tds__GetStorageConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetStorageConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurationsResponse(struct soap *soap, const char *tag, int id, const _tds__GetStorageConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:StorageConfigurations");
	if (soap_out_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, "tds:StorageConfigurations", -1, &a->_tds__GetStorageConfigurationsResponse::StorageConfigurations, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetStorageConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetStorageConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurationsResponse * SOAP_FMAC4 soap_in__tds__GetStorageConfigurationsResponse(struct soap *soap, const char *tag, _tds__GetStorageConfigurationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetStorageConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(_tds__GetStorageConfigurationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetStorageConfigurationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetStorageConfigurationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, "tds:StorageConfigurations", &a->_tds__GetStorageConfigurationsResponse::StorageConfigurations, "tds:StorageConfiguration"))
					continue;
			}
			soap_check_result(soap, "tds:StorageConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetStorageConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurationsResponse, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(_tds__GetStorageConfigurationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetStorageConfigurationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetStorageConfigurationsResponse *p;
	size_t k = sizeof(_tds__GetStorageConfigurationsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetStorageConfigurationsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetStorageConfigurationsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetStorageConfigurationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetStorageConfigurationsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetStorageConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetStorageConfigurationsResponse(soap, tag ? tag : "tds:GetStorageConfigurationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetStorageConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetStorageConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurationsResponse * SOAP_FMAC4 soap_get__tds__GetStorageConfigurationsResponse(struct soap *soap, _tds__GetStorageConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetStorageConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetStorageConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetStorageConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetStorageConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurations(struct soap *soap, const char *tag, int id, const _tds__GetStorageConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetStorageConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetStorageConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurations * SOAP_FMAC4 soap_in__tds__GetStorageConfigurations(struct soap *soap, const char *tag, _tds__GetStorageConfigurations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetStorageConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(_tds__GetStorageConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetStorageConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetStorageConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetStorageConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurations, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(_tds__GetStorageConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetStorageConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetStorageConfigurations *p;
	size_t k = sizeof(_tds__GetStorageConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetStorageConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetStorageConfigurations);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetStorageConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetStorageConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetStorageConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetStorageConfigurations(soap, tag ? tag : "tds:GetStorageConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetStorageConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetStorageConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurations * SOAP_FMAC4 soap_get__tds__GetStorageConfigurations(struct soap *soap, _tds__GetStorageConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StartSystemRestoreResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_tds__StartSystemRestoreResponse::UploadUri);
	soap_default_xsd__duration(soap, &this->_tds__StartSystemRestoreResponse::ExpectedDownTime);
}

void _tds__StartSystemRestoreResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__StartSystemRestoreResponse::UploadUri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->_tds__StartSystemRestoreResponse::UploadUri);
	soap_embedded(soap, &this->_tds__StartSystemRestoreResponse::ExpectedDownTime, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->_tds__StartSystemRestoreResponse::ExpectedDownTime);
#endif
}

int _tds__StartSystemRestoreResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartSystemRestoreResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, int id, const _tds__StartSystemRestoreResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestoreResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:UploadUri");
	if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, &a->_tds__StartSystemRestoreResponse::UploadUri, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, &a->_tds__StartSystemRestoreResponse::ExpectedDownTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StartSystemRestoreResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StartSystemRestoreResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_in__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, _tds__StartSystemRestoreResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartSystemRestoreResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(_tds__StartSystemRestoreResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StartSystemRestoreResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StartSystemRestoreResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UploadUri1 = 1;
	size_t soap_flag_ExpectedDownTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:UploadUri", &a->_tds__StartSystemRestoreResponse::UploadUri, "xsd:anyURI"))
				{	soap_flag_UploadUri1--;
					continue;
				}
			}
			if (soap_flag_ExpectedDownTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", &a->_tds__StartSystemRestoreResponse::ExpectedDownTime, "xsd:duration"))
				{	soap_flag_ExpectedDownTime1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadUri1 > 0 || soap_flag_ExpectedDownTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__StartSystemRestoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestoreResponse, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(_tds__StartSystemRestoreResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartSystemRestoreResponse * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestoreResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartSystemRestoreResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StartSystemRestoreResponse *p;
	size_t k = sizeof(_tds__StartSystemRestoreResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StartSystemRestoreResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StartSystemRestoreResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StartSystemRestoreResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StartSystemRestoreResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StartSystemRestoreResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StartSystemRestoreResponse(soap, tag ? tag : "tds:StartSystemRestoreResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartSystemRestoreResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartSystemRestoreResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_get__tds__StartSystemRestoreResponse(struct soap *soap, _tds__StartSystemRestoreResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StartSystemRestore::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__StartSystemRestore::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__StartSystemRestore::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartSystemRestore(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestore(struct soap *soap, const char *tag, int id, const _tds__StartSystemRestore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestore), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StartSystemRestore::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StartSystemRestore(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartSystemRestore * SOAP_FMAC4 soap_in__tds__StartSystemRestore(struct soap *soap, const char *tag, _tds__StartSystemRestore *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartSystemRestore*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestore, sizeof(_tds__StartSystemRestore), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StartSystemRestore)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StartSystemRestore *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__StartSystemRestore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestore, SOAP_TYPE__tds__StartSystemRestore, sizeof(_tds__StartSystemRestore), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartSystemRestore(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StartSystemRestore *p;
	size_t k = sizeof(_tds__StartSystemRestore);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StartSystemRestore, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StartSystemRestore);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StartSystemRestore, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StartSystemRestore location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StartSystemRestore::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StartSystemRestore(soap, tag ? tag : "tds:StartSystemRestore", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartSystemRestore::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartSystemRestore(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartSystemRestore * SOAP_FMAC4 soap_get__tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StartFirmwareUpgradeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadUri);
	soap_default_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadDelay);
	soap_default_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime);
}

void _tds__StartFirmwareUpgradeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadUri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadUri);
	soap_embedded(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadDelay, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadDelay);
	soap_embedded(soap, &this->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime);
#endif
}

int _tds__StartFirmwareUpgradeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartFirmwareUpgradeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, int id, const _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:UploadUri");
	if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, &a->_tds__StartFirmwareUpgradeResponse::UploadUri, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:UploadDelay", -1, &a->_tds__StartFirmwareUpgradeResponse::UploadDelay, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, &a->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StartFirmwareUpgradeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartFirmwareUpgradeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(_tds__StartFirmwareUpgradeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StartFirmwareUpgradeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StartFirmwareUpgradeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UploadUri1 = 1;
	size_t soap_flag_UploadDelay1 = 1;
	size_t soap_flag_ExpectedDownTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:UploadUri", &a->_tds__StartFirmwareUpgradeResponse::UploadUri, "xsd:anyURI"))
				{	soap_flag_UploadUri1--;
					continue;
				}
			}
			if (soap_flag_UploadDelay1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tds:UploadDelay", &a->_tds__StartFirmwareUpgradeResponse::UploadDelay, "xsd:duration"))
				{	soap_flag_UploadDelay1--;
					continue;
				}
			}
			if (soap_flag_ExpectedDownTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", &a->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime, "xsd:duration"))
				{	soap_flag_ExpectedDownTime1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadUri1 > 0 || soap_flag_UploadDelay1 > 0 || soap_flag_ExpectedDownTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__StartFirmwareUpgradeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(_tds__StartFirmwareUpgradeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgradeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartFirmwareUpgradeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StartFirmwareUpgradeResponse *p;
	size_t k = sizeof(_tds__StartFirmwareUpgradeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StartFirmwareUpgradeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StartFirmwareUpgradeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StartFirmwareUpgradeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StartFirmwareUpgradeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StartFirmwareUpgradeResponse(soap, tag ? tag : "tds:StartFirmwareUpgradeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartFirmwareUpgradeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartFirmwareUpgradeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgradeResponse(struct soap *soap, _tds__StartFirmwareUpgradeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StartFirmwareUpgrade::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__StartFirmwareUpgrade::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__StartFirmwareUpgrade::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartFirmwareUpgrade(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, const _tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgrade), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StartFirmwareUpgrade::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StartFirmwareUpgrade(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, _tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartFirmwareUpgrade*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(_tds__StartFirmwareUpgrade), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StartFirmwareUpgrade)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StartFirmwareUpgrade *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__StartFirmwareUpgrade *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgrade, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(_tds__StartFirmwareUpgrade), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgrade(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartFirmwareUpgrade(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StartFirmwareUpgrade *p;
	size_t k = sizeof(_tds__StartFirmwareUpgrade);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StartFirmwareUpgrade, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StartFirmwareUpgrade);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StartFirmwareUpgrade, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StartFirmwareUpgrade location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StartFirmwareUpgrade::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StartFirmwareUpgrade(soap, tag ? tag : "tds:StartFirmwareUpgrade", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartFirmwareUpgrade::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartFirmwareUpgrade(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemUrisResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetSystemUrisResponse::SystemLogUris = NULL;
	this->_tds__GetSystemUrisResponse::SupportInfoUri = NULL;
	this->_tds__GetSystemUrisResponse::SystemBackupUri = NULL;
	this->_tds__GetSystemUrisResponse::Extension = NULL;
}

void _tds__GetSystemUrisResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemLogUriList(soap, &this->_tds__GetSystemUrisResponse::SystemLogUris);
	soap_serialize_PointerToxsd__anyURI(soap, &this->_tds__GetSystemUrisResponse::SupportInfoUri);
	soap_serialize_PointerToxsd__anyURI(soap, &this->_tds__GetSystemUrisResponse::SystemBackupUri);
	soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(soap, &this->_tds__GetSystemUrisResponse::Extension);
#endif
}

int _tds__GetSystemUrisResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemUrisResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, int id, const _tds__GetSystemUrisResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse), type))
		return soap->error;
	if (a->SystemLogUris)
		soap_element_result(soap, "tds:SystemLogUris");
	if (soap_out_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", -1, &a->_tds__GetSystemUrisResponse::SystemLogUris, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tds:SupportInfoUri", -1, &a->_tds__GetSystemUrisResponse::SupportInfoUri, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tds:SystemBackupUri", -1, &a->_tds__GetSystemUrisResponse::SystemBackupUri, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", -1, &a->_tds__GetSystemUrisResponse::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemUrisResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemUrisResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, _tds__GetSystemUrisResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemUrisResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(_tds__GetSystemUrisResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemUrisResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemUrisResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SystemLogUris1 = 1;
	size_t soap_flag_SupportInfoUri1 = 1;
	size_t soap_flag_SystemBackupUri1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLogUris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", &a->_tds__GetSystemUrisResponse::SystemLogUris, "tt:SystemLogUriList"))
				{	soap_flag_SystemLogUris1--;
					continue;
				}
			}
			if (soap_flag_SupportInfoUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tds:SupportInfoUri", &a->_tds__GetSystemUrisResponse::SupportInfoUri, "xsd:anyURI"))
				{	soap_flag_SupportInfoUri1--;
					continue;
				}
			}
			if (soap_flag_SystemBackupUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tds:SystemBackupUri", &a->_tds__GetSystemUrisResponse::SystemBackupUri, "xsd:anyURI"))
				{	soap_flag_SystemBackupUri1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", &a->_tds__GetSystemUrisResponse::Extension, ""))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SystemLogUris");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemUrisResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(_tds__GetSystemUrisResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemUrisResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemUrisResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemUrisResponse *p;
	size_t k = sizeof(_tds__GetSystemUrisResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemUrisResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemUrisResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemUrisResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemUrisResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemUrisResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemUrisResponse(soap, tag ? tag : "tds:GetSystemUrisResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemUrisResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemUrisResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse(struct soap *soap, _tds__GetSystemUrisResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemUris::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetSystemUris::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetSystemUris::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemUris(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUris(struct soap *soap, const char *tag, int id, const _tds__GetSystemUris *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUris), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemUris::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemUris(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemUris * SOAP_FMAC4 soap_in__tds__GetSystemUris(struct soap *soap, const char *tag, _tds__GetSystemUris *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemUris*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUris, sizeof(_tds__GetSystemUris), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemUris)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemUris *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemUris *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUris, SOAP_TYPE__tds__GetSystemUris, sizeof(_tds__GetSystemUris), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemUris * SOAP_FMAC2 soap_instantiate__tds__GetSystemUris(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemUris(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemUris *p;
	size_t k = sizeof(_tds__GetSystemUris);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemUris, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemUris);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemUris, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemUris location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemUris::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemUris(soap, tag ? tag : "tds:GetSystemUris", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemUris::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemUris(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemUris * SOAP_FMAC4 soap_get__tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__ScanAvailableDot11NetworksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, &this->_tds__ScanAvailableDot11NetworksResponse::Networks);
}

void _tds__ScanAvailableDot11NetworksResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, &this->_tds__ScanAvailableDot11NetworksResponse::Networks);
#endif
}

int _tds__ScanAvailableDot11NetworksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, int id, const _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Networks");
	if (soap_out_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, "tds:Networks", -1, &a->_tds__ScanAvailableDot11NetworksResponse::Networks, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__ScanAvailableDot11NetworksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__ScanAvailableDot11NetworksResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(_tds__ScanAvailableDot11NetworksResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__ScanAvailableDot11NetworksResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, "tds:Networks", &a->_tds__ScanAvailableDot11NetworksResponse::Networks, "tt:Dot11AvailableNetworks"))
					continue;
			}
			soap_check_result(soap, "tds:Networks");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__ScanAvailableDot11NetworksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(_tds__ScanAvailableDot11NetworksResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__ScanAvailableDot11NetworksResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__ScanAvailableDot11NetworksResponse *p;
	size_t k = sizeof(_tds__ScanAvailableDot11NetworksResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__ScanAvailableDot11NetworksResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__ScanAvailableDot11NetworksResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__ScanAvailableDot11NetworksResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__ScanAvailableDot11NetworksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag ? tag : "tds:ScanAvailableDot11NetworksResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__ScanAvailableDot11NetworksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__ScanAvailableDot11NetworksResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, _tds__ScanAvailableDot11NetworksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__ScanAvailableDot11Networks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__ScanAvailableDot11Networks::InterfaceToken);
}

void _tds__ScanAvailableDot11Networks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__ScanAvailableDot11Networks::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__ScanAvailableDot11Networks::InterfaceToken);
#endif
}

int _tds__ScanAvailableDot11Networks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__ScanAvailableDot11Networks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, const _tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__ScanAvailableDot11Networks::InterfaceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__ScanAvailableDot11Networks::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__ScanAvailableDot11Networks(soap, tag, this, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, _tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__ScanAvailableDot11Networks*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(_tds__ScanAvailableDot11Networks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__ScanAvailableDot11Networks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__ScanAvailableDot11Networks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->_tds__ScanAvailableDot11Networks::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__ScanAvailableDot11Networks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11Networks, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(_tds__ScanAvailableDot11Networks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11Networks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__ScanAvailableDot11Networks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__ScanAvailableDot11Networks *p;
	size_t k = sizeof(_tds__ScanAvailableDot11Networks);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__ScanAvailableDot11Networks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__ScanAvailableDot11Networks);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__ScanAvailableDot11Networks, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__ScanAvailableDot11Networks location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__ScanAvailableDot11Networks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__ScanAvailableDot11Networks(soap, tag ? tag : "tds:ScanAvailableDot11Networks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__ScanAvailableDot11Networks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__ScanAvailableDot11Networks(soap, this, tag, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot11StatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot11StatusResponse::Status = NULL;
}

void _tds__GetDot11StatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Status(soap, &this->_tds__GetDot11StatusResponse::Status);
#endif
}

int _tds__GetDot11StatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11StatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot11StatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11StatusResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "tds:Status");
	if (!a->_tds__GetDot11StatusResponse::Status)
	{	if (soap_element_empty(soap, "tds:Status"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot11Status(soap, "tds:Status", -1, &a->_tds__GetDot11StatusResponse::Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11StatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot11StatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_in__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, _tds__GetDot11StatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11StatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(_tds__GetDot11StatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot11StatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot11StatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Status1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Status(soap, "tds:Status", &a->_tds__GetDot11StatusResponse::Status, "tt:Dot11Status"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetDot11StatusResponse::Status))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot11StatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11StatusResponse, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(_tds__GetDot11StatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11StatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11StatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11StatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot11StatusResponse *p;
	size_t k = sizeof(_tds__GetDot11StatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot11StatusResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot11StatusResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot11StatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot11StatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot11StatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot11StatusResponse(soap, tag ? tag : "tds:GetDot11StatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11StatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11StatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_get__tds__GetDot11StatusResponse(struct soap *soap, _tds__GetDot11StatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11StatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot11Status::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__GetDot11Status::InterfaceToken);
}

void _tds__GetDot11Status::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetDot11Status::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__GetDot11Status::InterfaceToken);
#endif
}

int _tds__GetDot11Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Status(struct soap *soap, const char *tag, int id, const _tds__GetDot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Status), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__GetDot11Status::InterfaceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11Status::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot11Status(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11Status * SOAP_FMAC4 soap_in__tds__GetDot11Status(struct soap *soap, const char *tag, _tds__GetDot11Status *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11Status*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Status, sizeof(_tds__GetDot11Status), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot11Status)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot11Status *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->_tds__GetDot11Status::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Status, SOAP_TYPE__tds__GetDot11Status, sizeof(_tds__GetDot11Status), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11Status * SOAP_FMAC2 soap_instantiate__tds__GetDot11Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11Status(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot11Status *p;
	size_t k = sizeof(_tds__GetDot11Status);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot11Status, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot11Status);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot11Status, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot11Status location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot11Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot11Status(soap, tag ? tag : "tds:GetDot11Status", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11Status(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11Status * SOAP_FMAC4 soap_get__tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot11CapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot11CapabilitiesResponse::Capabilities = NULL;
}

void _tds__GetDot11CapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Capabilities(soap, &this->_tds__GetDot11CapabilitiesResponse::Capabilities);
#endif
}

int _tds__GetDot11CapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11CapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->_tds__GetDot11CapabilitiesResponse::Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", -1, &a->_tds__GetDot11CapabilitiesResponse::Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11CapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11CapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(_tds__GetDot11CapabilitiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot11CapabilitiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot11CapabilitiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", &a->_tds__GetDot11CapabilitiesResponse::Capabilities, "tt:Dot11Capabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetDot11CapabilitiesResponse::Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot11CapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(_tds__GetDot11CapabilitiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11CapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11CapabilitiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot11CapabilitiesResponse *p;
	size_t k = sizeof(_tds__GetDot11CapabilitiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot11CapabilitiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot11CapabilitiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot11CapabilitiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot11CapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot11CapabilitiesResponse(soap, tag ? tag : "tds:GetDot11CapabilitiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11CapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11CapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetDot11CapabilitiesResponse(struct soap *soap, _tds__GetDot11CapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot11Capabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_tds__GetDot11Capabilities::__any);
}

void _tds__GetDot11Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_tds__GetDot11Capabilities::__any);
#endif
}

int _tds__GetDot11Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, const _tds__GetDot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Capabilities), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_tds__GetDot11Capabilities::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot11Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11Capabilities * SOAP_FMAC4 soap_in__tds__GetDot11Capabilities(struct soap *soap, const char *tag, _tds__GetDot11Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(_tds__GetDot11Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot11Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot11Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_tds__GetDot11Capabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Capabilities, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(_tds__GetDot11Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate__tds__GetDot11Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot11Capabilities *p;
	size_t k = sizeof(_tds__GetDot11Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot11Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot11Capabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot11Capabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot11Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot11Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot11Capabilities(soap, tag ? tag : "tds:GetDot11Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11Capabilities * SOAP_FMAC4 soap_get__tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SendAuxiliaryCommandResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse = NULL;
}

void _tds__SendAuxiliaryCommandResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse);
#endif
}

int _tds__SendAuxiliaryCommandResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SendAuxiliaryCommandResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse), type))
		return soap->error;
	if (a->AuxiliaryCommandResponse)
		soap_element_result(soap, "tds:AuxiliaryCommandResponse");
	if (soap_out_PointerTott__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", -1, &a->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SendAuxiliaryCommandResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SendAuxiliaryCommandResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(_tds__SendAuxiliaryCommandResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SendAuxiliaryCommandResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SendAuxiliaryCommandResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AuxiliaryCommandResponse1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommandResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", &a->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommandResponse1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:AuxiliaryCommandResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(_tds__SendAuxiliaryCommandResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommandResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SendAuxiliaryCommandResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SendAuxiliaryCommandResponse *p;
	size_t k = sizeof(_tds__SendAuxiliaryCommandResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SendAuxiliaryCommandResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SendAuxiliaryCommandResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SendAuxiliaryCommandResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SendAuxiliaryCommandResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SendAuxiliaryCommandResponse(soap, tag ? tag : "tds:SendAuxiliaryCommandResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SendAuxiliaryCommandResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SendAuxiliaryCommandResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommandResponse(struct soap *soap, _tds__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SendAuxiliaryCommand::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommand::AuxiliaryCommand);
}

void _tds__SendAuxiliaryCommand::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SendAuxiliaryCommand::AuxiliaryCommand, SOAP_TYPE_tt__AuxiliaryData);
	soap_serialize_tt__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommand::AuxiliaryCommand);
#endif
}

int _tds__SendAuxiliaryCommand::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SendAuxiliaryCommand(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const _tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommand), type))
		return soap->error;
	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", -1, &a->_tds__SendAuxiliaryCommand::AuxiliaryCommand, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SendAuxiliaryCommand::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SendAuxiliaryCommand(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, _tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SendAuxiliaryCommand*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(_tds__SendAuxiliaryCommand), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SendAuxiliaryCommand)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SendAuxiliaryCommand *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AuxiliaryCommand1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommand1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", &a->_tds__SendAuxiliaryCommand::AuxiliaryCommand, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommand1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AuxiliaryCommand1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommand, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(_tds__SendAuxiliaryCommand), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SendAuxiliaryCommand(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SendAuxiliaryCommand *p;
	size_t k = sizeof(_tds__SendAuxiliaryCommand);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SendAuxiliaryCommand, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SendAuxiliaryCommand);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SendAuxiliaryCommand, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SendAuxiliaryCommand location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SendAuxiliaryCommand::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SendAuxiliaryCommand(soap, tag ? tag : "tds:SendAuxiliaryCommand", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SendAuxiliaryCommand::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SendAuxiliaryCommand(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRelayOutputStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetRelayOutputStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetRelayOutputStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRelayOutputStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, _tds__SetRelayOutputStateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputStateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(_tds__SetRelayOutputStateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRelayOutputStateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRelayOutputStateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputStateResponse, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(_tds__SetRelayOutputStateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputStateResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputStateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRelayOutputStateResponse *p;
	size_t k = sizeof(_tds__SetRelayOutputStateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRelayOutputStateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRelayOutputStateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRelayOutputStateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRelayOutputStateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRelayOutputStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRelayOutputStateResponse(soap, tag ? tag : "tds:SetRelayOutputStateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputStateResponse(struct soap *soap, _tds__SetRelayOutputStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRelayOutputState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputState::RelayOutputToken);
	soap_default_tt__RelayLogicalState(soap, &this->_tds__SetRelayOutputState::LogicalState);
}

void _tds__SetRelayOutputState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetRelayOutputState::RelayOutputToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputState::RelayOutputToken);
#endif
}

int _tds__SetRelayOutputState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputState), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->_tds__SetRelayOutputState::RelayOutputToken, ""))
		return soap->error;
	if (soap_out_tt__RelayLogicalState(soap, "tds:LogicalState", -1, &a->_tds__SetRelayOutputState::LogicalState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputState::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRelayOutputState(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputState * SOAP_FMAC4 soap_in__tds__SetRelayOutputState(struct soap *soap, const char *tag, _tds__SetRelayOutputState *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(_tds__SetRelayOutputState), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRelayOutputState)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRelayOutputState *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RelayOutputToken1 = 1;
	size_t soap_flag_LogicalState1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &a->_tds__SetRelayOutputState::RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken1--;
					continue;
				}
			}
			if (soap_flag_LogicalState1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RelayLogicalState(soap, "tds:LogicalState", &a->_tds__SetRelayOutputState::LogicalState, "tt:RelayLogicalState"))
				{	soap_flag_LogicalState1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken1 > 0 || soap_flag_LogicalState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputState, SOAP_TYPE__tds__SetRelayOutputState, sizeof(_tds__SetRelayOutputState), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRelayOutputState *p;
	size_t k = sizeof(_tds__SetRelayOutputState);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRelayOutputState, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRelayOutputState);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRelayOutputState, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRelayOutputState location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRelayOutputState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRelayOutputState(soap, tag ? tag : "tds:SetRelayOutputState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputState(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputState * SOAP_FMAC4 soap_get__tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRelayOutputSettingsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetRelayOutputSettingsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetRelayOutputSettingsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputSettingsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputSettingsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputSettingsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(_tds__SetRelayOutputSettingsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRelayOutputSettingsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRelayOutputSettingsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(_tds__SetRelayOutputSettingsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettingsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputSettingsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRelayOutputSettingsResponse *p;
	size_t k = sizeof(_tds__SetRelayOutputSettingsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRelayOutputSettingsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRelayOutputSettingsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRelayOutputSettingsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRelayOutputSettingsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRelayOutputSettingsResponse(soap, tag ? tag : "tds:SetRelayOutputSettingsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputSettingsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputSettingsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettingsResponse(struct soap *soap, _tds__SetRelayOutputSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRelayOutputSettings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputSettings::RelayOutputToken);
	this->_tds__SetRelayOutputSettings::Properties = NULL;
}

void _tds__SetRelayOutputSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetRelayOutputSettings::RelayOutputToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputSettings::RelayOutputToken);
	soap_serialize_PointerTott__RelayOutputSettings(soap, &this->_tds__SetRelayOutputSettings::Properties);
#endif
}

int _tds__SetRelayOutputSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettings), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->_tds__SetRelayOutputSettings::RelayOutputToken, ""))
		return soap->error;
	if (!a->_tds__SetRelayOutputSettings::Properties)
	{	if (soap_element_empty(soap, "tds:Properties"))
			return soap->error;
	}
	else if (soap_out_PointerTott__RelayOutputSettings(soap, "tds:Properties", -1, &a->_tds__SetRelayOutputSettings::Properties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRelayOutputSettings(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, _tds__SetRelayOutputSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(_tds__SetRelayOutputSettings), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRelayOutputSettings)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRelayOutputSettings *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RelayOutputToken1 = 1;
	size_t soap_flag_Properties1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &a->_tds__SetRelayOutputSettings::RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken1--;
					continue;
				}
			}
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelayOutputSettings(soap, "tds:Properties", &a->_tds__SetRelayOutputSettings::Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken1 > 0 || !a->_tds__SetRelayOutputSettings::Properties))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettings, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(_tds__SetRelayOutputSettings), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRelayOutputSettings *p;
	size_t k = sizeof(_tds__SetRelayOutputSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRelayOutputSettings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRelayOutputSettings);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRelayOutputSettings, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRelayOutputSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRelayOutputSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRelayOutputSettings(soap, tag ? tag : "tds:SetRelayOutputSettings", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputSettings(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRelayOutputsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__RelayOutput(soap, &this->_tds__GetRelayOutputsResponse::RelayOutputs);
}

void _tds__GetRelayOutputsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__RelayOutput(soap, &this->_tds__GetRelayOutputsResponse::RelayOutputs);
#endif
}

int _tds__GetRelayOutputsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRelayOutputsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, const _tds__GetRelayOutputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputsResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RelayOutputs");
	if (soap_out_std__vectorTemplateOfPointerTott__RelayOutput(soap, "tds:RelayOutputs", -1, &a->_tds__GetRelayOutputsResponse::RelayOutputs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRelayOutputsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRelayOutputsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_in__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, _tds__GetRelayOutputsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRelayOutputsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(_tds__GetRelayOutputsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRelayOutputsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRelayOutputsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__RelayOutput(soap, "tds:RelayOutputs", &a->_tds__GetRelayOutputsResponse::RelayOutputs, "tt:RelayOutput"))
					continue;
			}
			soap_check_result(soap, "tds:RelayOutputs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRelayOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputsResponse, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(_tds__GetRelayOutputsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRelayOutputsResponse * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRelayOutputsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRelayOutputsResponse *p;
	size_t k = sizeof(_tds__GetRelayOutputsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRelayOutputsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRelayOutputsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRelayOutputsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRelayOutputsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRelayOutputsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRelayOutputsResponse(soap, tag ? tag : "tds:GetRelayOutputsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRelayOutputsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRelayOutputsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_get__tds__GetRelayOutputsResponse(struct soap *soap, _tds__GetRelayOutputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRelayOutputs::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetRelayOutputs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetRelayOutputs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRelayOutputs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const _tds__GetRelayOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRelayOutputs::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRelayOutputs(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRelayOutputs * SOAP_FMAC4 soap_in__tds__GetRelayOutputs(struct soap *soap, const char *tag, _tds__GetRelayOutputs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRelayOutputs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(_tds__GetRelayOutputs), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRelayOutputs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRelayOutputs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRelayOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputs, SOAP_TYPE__tds__GetRelayOutputs, sizeof(_tds__GetRelayOutputs), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRelayOutputs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRelayOutputs *p;
	size_t k = sizeof(_tds__GetRelayOutputs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRelayOutputs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRelayOutputs);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRelayOutputs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRelayOutputs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRelayOutputs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRelayOutputs(soap, tag ? tag : "tds:GetRelayOutputs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRelayOutputs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRelayOutputs(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRelayOutputs * SOAP_FMAC4 soap_get__tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(_tds__DeleteDot1XConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteDot1XConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(_tds__DeleteDot1XConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteDot1XConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteDot1XConfigurationResponse *p;
	size_t k = sizeof(_tds__DeleteDot1XConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteDot1XConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteDot1XConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteDot1XConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag ? tag : "tds:DeleteDot1XConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfigurationResponse(struct soap *soap, _tds__DeleteDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken);
}

void _tds__DeleteDot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken);
#endif
}

int _tds__DeleteDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, &a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, _tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(_tds__DeleteDot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteDot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteDot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", &a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken, "tt:ReferenceToken"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfiguration, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(_tds__DeleteDot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteDot1XConfiguration *p;
	size_t k = sizeof(_tds__DeleteDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteDot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteDot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteDot1XConfiguration(soap, tag ? tag : "tds:DeleteDot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot1XConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, &this->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration);
}

void _tds__GetDot1XConfigurationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, &this->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration);
#endif
}

int _tds__GetDot1XConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Dot1XConfiguration");
	if (soap_out_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(_tds__GetDot1XConfigurationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot1XConfigurationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot1XConfigurationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration, "tt:Dot1XConfiguration"))
					continue;
			}
			soap_check_result(soap, "tds:Dot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(_tds__GetDot1XConfigurationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfigurationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot1XConfigurationsResponse *p;
	size_t k = sizeof(_tds__GetDot1XConfigurationsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot1XConfigurationsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot1XConfigurationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot1XConfigurationsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot1XConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot1XConfigurationsResponse(soap, tag ? tag : "tds:GetDot1XConfigurationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationsResponse(struct soap *soap, _tds__GetDot1XConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot1XConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDot1XConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDot1XConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot1XConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, _tds__GetDot1XConfigurations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(_tds__GetDot1XConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot1XConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot1XConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurations, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(_tds__GetDot1XConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot1XConfigurations *p;
	size_t k = sizeof(_tds__GetDot1XConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot1XConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot1XConfigurations);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot1XConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot1XConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot1XConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot1XConfigurations(soap, tag ? tag : "tds:GetDot1XConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration = NULL;
}

void _tds__GetDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &this->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration);
#endif
}

int _tds__GetDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse), type))
		return soap->error;
	if (a->Dot1XConfiguration)
		soap_element_result(soap, "tds:Dot1XConfiguration");
	if (!a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration)
	{	if (soap_element_empty(soap, "tds:Dot1XConfiguration"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(_tds__GetDot1XConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot1XConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Dot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationResponse, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(_tds__GetDot1XConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot1XConfigurationResponse *p;
	size_t k = sizeof(_tds__GetDot1XConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot1XConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot1XConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot1XConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot1XConfigurationResponse(soap, tag ? tag : "tds:GetDot1XConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationResponse(struct soap *soap, _tds__GetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__GetDot1XConfiguration::Dot1XConfigurationToken);
}

void _tds__GetDot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetDot1XConfiguration::Dot1XConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__GetDot1XConfiguration::Dot1XConfigurationToken);
#endif
}

int _tds__GetDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, &a->_tds__GetDot1XConfiguration::Dot1XConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, _tds__GetDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(_tds__GetDot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfigurationToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", &a->_tds__GetDot1XConfiguration::Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfigurationToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfiguration, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(_tds__GetDot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot1XConfiguration *p;
	size_t k = sizeof(_tds__GetDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot1XConfiguration(soap, tag ? tag : "tds:GetDot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(_tds__SetDot1XConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDot1XConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfigurationResponse, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(_tds__SetDot1XConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDot1XConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDot1XConfigurationResponse *p;
	size_t k = sizeof(_tds__SetDot1XConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDot1XConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDot1XConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDot1XConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDot1XConfigurationResponse(soap, tag ? tag : "tds:SetDot1XConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetDot1XConfigurationResponse(struct soap *soap, _tds__SetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetDot1XConfiguration::Dot1XConfiguration = NULL;
}

void _tds__SetDot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &this->_tds__SetDot1XConfiguration::Dot1XConfiguration);
#endif
}

int _tds__SetDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfiguration), type))
		return soap->error;
	if (!a->_tds__SetDot1XConfiguration::Dot1XConfiguration)
	{	if (soap_element_empty(soap, "tds:Dot1XConfiguration"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__SetDot1XConfiguration::Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, _tds__SetDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(_tds__SetDot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->_tds__SetDot1XConfiguration::Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__SetDot1XConfiguration::Dot1XConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfiguration, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(_tds__SetDot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDot1XConfiguration *p;
	size_t k = sizeof(_tds__SetDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDot1XConfiguration(soap, tag ? tag : "tds:SetDot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__CreateDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__CreateDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(_tds__CreateDot1XConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateDot1XConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(_tds__CreateDot1XConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateDot1XConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateDot1XConfigurationResponse *p;
	size_t k = sizeof(_tds__CreateDot1XConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateDot1XConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateDot1XConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateDot1XConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateDot1XConfigurationResponse(soap, tag ? tag : "tds:CreateDot1XConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__CreateDot1XConfigurationResponse(struct soap *soap, _tds__CreateDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateDot1XConfiguration::Dot1XConfiguration = NULL;
}

void _tds__CreateDot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &this->_tds__CreateDot1XConfiguration::Dot1XConfiguration);
#endif
}

int _tds__CreateDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__CreateDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfiguration), type))
		return soap->error;
	if (!a->_tds__CreateDot1XConfiguration::Dot1XConfiguration)
	{	if (soap_element_empty(soap, "tds:Dot1XConfiguration"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__CreateDot1XConfiguration::Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_in__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, _tds__CreateDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(_tds__CreateDot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateDot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateDot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->_tds__CreateDot1XConfiguration::Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__CreateDot1XConfiguration::Dot1XConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfiguration, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(_tds__CreateDot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateDot1XConfiguration *p;
	size_t k = sizeof(_tds__CreateDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateDot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateDot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateDot1XConfiguration(soap, tag ? tag : "tds:CreateDot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_get__tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCACertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__LoadCACertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__LoadCACertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCACertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__LoadCACertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCACertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCACertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, _tds__LoadCACertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCACertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(_tds__LoadCACertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCACertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCACertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificatesResponse, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(_tds__LoadCACertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCACertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCACertificatesResponse *p;
	size_t k = sizeof(_tds__LoadCACertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCACertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCACertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCACertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCACertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCACertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCACertificatesResponse(soap, tag ? tag : "tds:LoadCACertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCACertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCACertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCACertificatesResponse(struct soap *soap, _tds__LoadCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCACertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__LoadCACertificates::CACertificate);
}

void _tds__LoadCACertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__LoadCACertificates::CACertificate);
#endif
}

int _tds__LoadCACertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCACertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificates(struct soap *soap, const char *tag, int id, const _tds__LoadCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:CACertificate", -1, &a->_tds__LoadCACertificates::CACertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCACertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCACertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCACertificates * SOAP_FMAC4 soap_in__tds__LoadCACertificates(struct soap *soap, const char *tag, _tds__LoadCACertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCACertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificates, sizeof(_tds__LoadCACertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCACertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCACertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:CACertificate", &a->_tds__LoadCACertificates::CACertificate, "tt:Certificate"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__LoadCACertificates::CACertificate.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__LoadCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificates, SOAP_TYPE__tds__LoadCACertificates, sizeof(_tds__LoadCACertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCACertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCACertificates *p;
	size_t k = sizeof(_tds__LoadCACertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCACertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCACertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCACertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCACertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCACertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCACertificates(soap, tag ? tag : "tds:LoadCACertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCACertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCACertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCACertificates * SOAP_FMAC4 soap_get__tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificateInformationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetCertificateInformationResponse::CertificateInformation = NULL;
}

void _tds__GetCertificateInformationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__CertificateInformation(soap, &this->_tds__GetCertificateInformationResponse::CertificateInformation);
#endif
}

int _tds__GetCertificateInformationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificateInformationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, int id, const _tds__GetCertificateInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformationResponse), type))
		return soap->error;
	if (a->CertificateInformation)
		soap_element_result(soap, "tds:CertificateInformation");
	if (!a->_tds__GetCertificateInformationResponse::CertificateInformation)
	{	if (soap_element_empty(soap, "tds:CertificateInformation"))
			return soap->error;
	}
	else if (soap_out_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", -1, &a->_tds__GetCertificateInformationResponse::CertificateInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificateInformationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificateInformationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_in__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, _tds__GetCertificateInformationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificateInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(_tds__GetCertificateInformationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificateInformationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificateInformationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", &a->_tds__GetCertificateInformationResponse::CertificateInformation, "tt:CertificateInformation"))
				{	soap_flag_CertificateInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:CertificateInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetCertificateInformationResponse::CertificateInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetCertificateInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformationResponse, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(_tds__GetCertificateInformationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificateInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificateInformationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificateInformationResponse *p;
	size_t k = sizeof(_tds__GetCertificateInformationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificateInformationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificateInformationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificateInformationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificateInformationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificateInformationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificateInformationResponse(soap, tag ? tag : "tds:GetCertificateInformationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificateInformationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificateInformationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_get__tds__GetCertificateInformationResponse(struct soap *soap, _tds__GetCertificateInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificateInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__GetCertificateInformation::CertificateID);
}

void _tds__GetCertificateInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetCertificateInformation::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->_tds__GetCertificateInformation::CertificateID);
#endif
}

int _tds__GetCertificateInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificateInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, const _tds__GetCertificateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformation), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->_tds__GetCertificateInformation::CertificateID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificateInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificateInformation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificateInformation * SOAP_FMAC4 soap_in__tds__GetCertificateInformation(struct soap *soap, const char *tag, _tds__GetCertificateInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(_tds__GetCertificateInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificateInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificateInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:CertificateID", &a->_tds__GetCertificateInformation::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetCertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformation, SOAP_TYPE__tds__GetCertificateInformation, sizeof(_tds__GetCertificateInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificateInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificateInformation *p;
	size_t k = sizeof(_tds__GetCertificateInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificateInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificateInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificateInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificateInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificateInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificateInformation(soap, tag ? tag : "tds:GetCertificateInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificateInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificateInformation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificateInformation * SOAP_FMAC4 soap_get__tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCertificateWithPrivateKeyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__LoadCertificateWithPrivateKeyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__LoadCertificateWithPrivateKeyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, int id, const _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificateWithPrivateKeyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificateWithPrivateKeyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(_tds__LoadCertificateWithPrivateKeyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCertificateWithPrivateKeyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCertificateWithPrivateKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(_tds__LoadCertificateWithPrivateKeyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCertificateWithPrivateKeyResponse *p;
	size_t k = sizeof(_tds__LoadCertificateWithPrivateKeyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCertificateWithPrivateKeyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCertificateWithPrivateKeyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCertificateWithPrivateKeyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCertificateWithPrivateKeyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCertificateWithPrivateKeyResponse(soap, tag ? tag : "tds:LoadCertificateWithPrivateKeyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificateWithPrivateKeyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificateWithPrivateKeyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, _tds__LoadCertificateWithPrivateKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCertificateWithPrivateKey::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, &this->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey);
}

void _tds__LoadCertificateWithPrivateKey::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, &this->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey);
#endif
}

int _tds__LoadCertificateWithPrivateKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificateWithPrivateKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", -1, &a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificateWithPrivateKey::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificateWithPrivateKey*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(_tds__LoadCertificateWithPrivateKey), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCertificateWithPrivateKey)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCertificateWithPrivateKey *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", &a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey, "tt:CertificateWithPrivateKey"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__LoadCertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(_tds__LoadCertificateWithPrivateKey), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificateWithPrivateKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCertificateWithPrivateKey *p;
	size_t k = sizeof(_tds__LoadCertificateWithPrivateKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCertificateWithPrivateKey);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCertificateWithPrivateKey, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCertificateWithPrivateKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCertificateWithPrivateKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCertificateWithPrivateKey(soap, tag ? tag : "tds:LoadCertificateWithPrivateKey", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificateWithPrivateKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificateWithPrivateKey(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCACertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__GetCACertificatesResponse::CACertificate);
}

void _tds__GetCACertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__GetCACertificatesResponse::CACertificate);
#endif
}

int _tds__GetCACertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCACertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__GetCACertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:CACertificate");
	if (soap_out_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:CACertificate", -1, &a->_tds__GetCACertificatesResponse::CACertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCACertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCACertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, _tds__GetCACertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCACertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(_tds__GetCACertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCACertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCACertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:CACertificate", &a->_tds__GetCACertificatesResponse::CACertificate, "tt:Certificate"))
					continue;
			}
			soap_check_result(soap, "tds:CACertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificatesResponse, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(_tds__GetCACertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCACertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCACertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCACertificatesResponse *p;
	size_t k = sizeof(_tds__GetCACertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCACertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCACertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCACertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCACertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCACertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCACertificatesResponse(soap, tag ? tag : "tds:GetCACertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCACertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCACertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCACertificatesResponse(struct soap *soap, _tds__GetCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCACertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetCACertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetCACertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCACertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificates(struct soap *soap, const char *tag, int id, const _tds__GetCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCACertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCACertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCACertificates * SOAP_FMAC4 soap_in__tds__GetCACertificates(struct soap *soap, const char *tag, _tds__GetCACertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCACertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificates, sizeof(_tds__GetCACertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCACertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCACertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificates, SOAP_TYPE__tds__GetCACertificates, sizeof(_tds__GetCACertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCACertificates * SOAP_FMAC2 soap_instantiate__tds__GetCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCACertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCACertificates *p;
	size_t k = sizeof(_tds__GetCACertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCACertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCACertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCACertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCACertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCACertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCACertificates(soap, tag ? tag : "tds:GetCACertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCACertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCACertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCACertificates * SOAP_FMAC4 soap_get__tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetClientCertificateModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetClientCertificateModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetClientCertificateModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetClientCertificateModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const _tds__SetClientCertificateModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetClientCertificateModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetClientCertificateModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, _tds__SetClientCertificateModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetClientCertificateModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(_tds__SetClientCertificateModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetClientCertificateModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetClientCertificateModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateModeResponse, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(_tds__SetClientCertificateModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetClientCertificateModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetClientCertificateModeResponse *p;
	size_t k = sizeof(_tds__SetClientCertificateModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetClientCertificateModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetClientCertificateModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetClientCertificateModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetClientCertificateModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetClientCertificateModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetClientCertificateModeResponse(soap, tag ? tag : "tds:SetClientCertificateModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetClientCertificateModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetClientCertificateModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__SetClientCertificateModeResponse(struct soap *soap, _tds__SetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetClientCertificateMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetClientCertificateMode::Enabled);
}

void _tds__SetClientCertificateMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetClientCertificateMode::Enabled, SOAP_TYPE_bool);
#endif
}

int _tds__SetClientCertificateMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetClientCertificateMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, const _tds__SetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateMode), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__SetClientCertificateMode::Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetClientCertificateMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetClientCertificateMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetClientCertificateMode * SOAP_FMAC4 soap_in__tds__SetClientCertificateMode(struct soap *soap, const char *tag, _tds__SetClientCertificateMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetClientCertificateMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(_tds__SetClientCertificateMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetClientCertificateMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetClientCertificateMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__SetClientCertificateMode::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateMode, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(_tds__SetClientCertificateMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetClientCertificateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetClientCertificateMode *p;
	size_t k = sizeof(_tds__SetClientCertificateMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetClientCertificateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetClientCertificateMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetClientCertificateMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetClientCertificateMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetClientCertificateMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetClientCertificateMode(soap, tag ? tag : "tds:SetClientCertificateMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetClientCertificateMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetClientCertificateMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetClientCertificateMode * SOAP_FMAC4 soap_get__tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetClientCertificateModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__GetClientCertificateModeResponse::Enabled);
}

void _tds__GetClientCertificateModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetClientCertificateModeResponse::Enabled, SOAP_TYPE_bool);
#endif
}

int _tds__GetClientCertificateModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetClientCertificateModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const _tds__GetClientCertificateModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Enabled");
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__GetClientCertificateModeResponse::Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetClientCertificateModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetClientCertificateModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, _tds__GetClientCertificateModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetClientCertificateModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(_tds__GetClientCertificateModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetClientCertificateModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetClientCertificateModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__GetClientCertificateModeResponse::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Enabled");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateModeResponse, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(_tds__GetClientCertificateModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetClientCertificateModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetClientCertificateModeResponse *p;
	size_t k = sizeof(_tds__GetClientCertificateModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetClientCertificateModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetClientCertificateModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetClientCertificateModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetClientCertificateModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetClientCertificateModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetClientCertificateModeResponse(soap, tag ? tag : "tds:GetClientCertificateModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetClientCertificateModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetClientCertificateModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__GetClientCertificateModeResponse(struct soap *soap, _tds__GetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetClientCertificateMode::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetClientCertificateMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetClientCertificateMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetClientCertificateMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, const _tds__GetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetClientCertificateMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetClientCertificateMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetClientCertificateMode * SOAP_FMAC4 soap_in__tds__GetClientCertificateMode(struct soap *soap, const char *tag, _tds__GetClientCertificateMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetClientCertificateMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(_tds__GetClientCertificateMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetClientCertificateMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetClientCertificateMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateMode, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(_tds__GetClientCertificateMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetClientCertificateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetClientCertificateMode *p;
	size_t k = sizeof(_tds__GetClientCertificateMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetClientCertificateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetClientCertificateMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetClientCertificateMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetClientCertificateMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetClientCertificateMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetClientCertificateMode(soap, tag ? tag : "tds:GetClientCertificateMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetClientCertificateMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetClientCertificateMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetClientCertificateMode * SOAP_FMAC4 soap_get__tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__LoadCertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__LoadCertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__LoadCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, _tds__LoadCertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(_tds__LoadCertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificatesResponse, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(_tds__LoadCertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCertificatesResponse *p;
	size_t k = sizeof(_tds__LoadCertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCertificatesResponse(soap, tag ? tag : "tds:LoadCertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCertificatesResponse(struct soap *soap, _tds__LoadCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__LoadCertificates::NVTCertificate);
}

void _tds__LoadCertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__LoadCertificates::NVTCertificate);
#endif
}

int _tds__LoadCertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificates(struct soap *soap, const char *tag, int id, const _tds__LoadCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:NVTCertificate", -1, &a->_tds__LoadCertificates::NVTCertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificates * SOAP_FMAC4 soap_in__tds__LoadCertificates(struct soap *soap, const char *tag, _tds__LoadCertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificates, sizeof(_tds__LoadCertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:NVTCertificate", &a->_tds__LoadCertificates::NVTCertificate, "tt:Certificate"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__LoadCertificates::NVTCertificate.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__LoadCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificates, SOAP_TYPE__tds__LoadCertificates, sizeof(_tds__LoadCertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCertificates *p;
	size_t k = sizeof(_tds__LoadCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCertificates(soap, tag ? tag : "tds:LoadCertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificates * SOAP_FMAC4 soap_get__tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPkcs10RequestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetPkcs10RequestResponse::Pkcs10Request = NULL;
}

void _tds__GetPkcs10RequestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__GetPkcs10RequestResponse::Pkcs10Request);
#endif
}

int _tds__GetPkcs10RequestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPkcs10RequestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, int id, const _tds__GetPkcs10RequestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse), type))
		return soap->error;
	if (a->Pkcs10Request)
		soap_element_result(soap, "tds:Pkcs10Request");
	if (!a->_tds__GetPkcs10RequestResponse::Pkcs10Request)
	{	if (soap_element_empty(soap, "tds:Pkcs10Request"))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tds:Pkcs10Request", -1, &a->_tds__GetPkcs10RequestResponse::Pkcs10Request, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPkcs10RequestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPkcs10RequestResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_in__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, _tds__GetPkcs10RequestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPkcs10RequestResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(_tds__GetPkcs10RequestResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPkcs10RequestResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPkcs10RequestResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Pkcs10Request1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Pkcs10Request1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:Pkcs10Request", &a->_tds__GetPkcs10RequestResponse::Pkcs10Request, "tt:BinaryData"))
				{	soap_flag_Pkcs10Request1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Pkcs10Request");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetPkcs10RequestResponse::Pkcs10Request))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetPkcs10RequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10RequestResponse, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(_tds__GetPkcs10RequestResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPkcs10RequestResponse * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10RequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPkcs10RequestResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPkcs10RequestResponse *p;
	size_t k = sizeof(_tds__GetPkcs10RequestResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPkcs10RequestResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPkcs10RequestResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPkcs10RequestResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPkcs10RequestResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPkcs10RequestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPkcs10RequestResponse(soap, tag ? tag : "tds:GetPkcs10RequestResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPkcs10RequestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPkcs10RequestResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_get__tds__GetPkcs10RequestResponse(struct soap *soap, _tds__GetPkcs10RequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10RequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPkcs10Request::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__GetPkcs10Request::CertificateID);
	this->_tds__GetPkcs10Request::Subject = NULL;
	this->_tds__GetPkcs10Request::Attributes = NULL;
}

void _tds__GetPkcs10Request::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetPkcs10Request::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->_tds__GetPkcs10Request::CertificateID);
	soap_serialize_PointerTostd__string(soap, &this->_tds__GetPkcs10Request::Subject);
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__GetPkcs10Request::Attributes);
#endif
}

int _tds__GetPkcs10Request::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPkcs10Request(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, const _tds__GetPkcs10Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10Request), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->_tds__GetPkcs10Request::CertificateID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tds:Subject", -1, &a->_tds__GetPkcs10Request::Subject, ""))
		return soap->error;
	if (soap_out_PointerTott__BinaryData(soap, "tds:Attributes", -1, &a->_tds__GetPkcs10Request::Attributes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPkcs10Request::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPkcs10Request(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPkcs10Request * SOAP_FMAC4 soap_in__tds__GetPkcs10Request(struct soap *soap, const char *tag, _tds__GetPkcs10Request *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPkcs10Request*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(_tds__GetPkcs10Request), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPkcs10Request)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPkcs10Request *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Subject1 = 1;
	size_t soap_flag_Attributes1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:CertificateID", &a->_tds__GetPkcs10Request::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tds:Subject", &a->_tds__GetPkcs10Request::Subject, "xsd:string"))
				{	soap_flag_Subject1--;
					continue;
				}
			}
			if (soap_flag_Attributes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:Attributes", &a->_tds__GetPkcs10Request::Attributes, "tt:BinaryData"))
				{	soap_flag_Attributes1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetPkcs10Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10Request, SOAP_TYPE__tds__GetPkcs10Request, sizeof(_tds__GetPkcs10Request), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPkcs10Request(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPkcs10Request *p;
	size_t k = sizeof(_tds__GetPkcs10Request);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPkcs10Request, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPkcs10Request);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPkcs10Request, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPkcs10Request location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPkcs10Request::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPkcs10Request(soap, tag ? tag : "tds:GetPkcs10Request", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPkcs10Request::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPkcs10Request(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPkcs10Request * SOAP_FMAC4 soap_get__tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteCertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteCertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteCertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteCertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteCertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteCertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_in__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, _tds__DeleteCertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteCertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(_tds__DeleteCertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteCertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteCertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificatesResponse, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(_tds__DeleteCertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteCertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteCertificatesResponse *p;
	size_t k = sizeof(_tds__DeleteCertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteCertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteCertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteCertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteCertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteCertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteCertificatesResponse(soap, tag ? tag : "tds:DeleteCertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteCertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteCertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_get__tds__DeleteCertificatesResponse(struct soap *soap, _tds__DeleteCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteCertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->_tds__DeleteCertificates::CertificateID);
}

void _tds__DeleteCertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->_tds__DeleteCertificates::CertificateID);
#endif
}

int _tds__DeleteCertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteCertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificates(struct soap *soap, const char *tag, int id, const _tds__DeleteCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tds:CertificateID", -1, &a->_tds__DeleteCertificates::CertificateID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteCertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteCertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteCertificates * SOAP_FMAC4 soap_in__tds__DeleteCertificates(struct soap *soap, const char *tag, _tds__DeleteCertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteCertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificates, sizeof(_tds__DeleteCertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteCertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteCertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__token(soap, "tds:CertificateID", &a->_tds__DeleteCertificates::CertificateID, "xsd:token"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__DeleteCertificates::CertificateID.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__DeleteCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificates, SOAP_TYPE__tds__DeleteCertificates, sizeof(_tds__DeleteCertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteCertificates *p;
	size_t k = sizeof(_tds__DeleteCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteCertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteCertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteCertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteCertificates(soap, tag ? tag : "tds:DeleteCertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteCertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteCertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteCertificates * SOAP_FMAC4 soap_get__tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetCertificatesStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetCertificatesStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetCertificatesStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetCertificatesStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const _tds__SetCertificatesStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetCertificatesStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetCertificatesStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, _tds__SetCertificatesStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetCertificatesStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(_tds__SetCertificatesStatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetCertificatesStatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetCertificatesStatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatusResponse, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(_tds__SetCertificatesStatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetCertificatesStatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetCertificatesStatusResponse *p;
	size_t k = sizeof(_tds__SetCertificatesStatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetCertificatesStatusResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetCertificatesStatusResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetCertificatesStatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetCertificatesStatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetCertificatesStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetCertificatesStatusResponse(soap, tag ? tag : "tds:SetCertificatesStatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetCertificatesStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetCertificatesStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__SetCertificatesStatusResponse(struct soap *soap, _tds__SetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetCertificatesStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &this->_tds__SetCertificatesStatus::CertificateStatus);
}

void _tds__SetCertificatesStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &this->_tds__SetCertificatesStatus::CertificateStatus);
#endif
}

int _tds__SetCertificatesStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetCertificatesStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, const _tds__SetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatus), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__CertificateStatus(soap, "tds:CertificateStatus", -1, &a->_tds__SetCertificatesStatus::CertificateStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetCertificatesStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetCertificatesStatus(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatus * SOAP_FMAC4 soap_in__tds__SetCertificatesStatus(struct soap *soap, const char *tag, _tds__SetCertificatesStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetCertificatesStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(_tds__SetCertificatesStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetCertificatesStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetCertificatesStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__CertificateStatus(soap, "tds:CertificateStatus", &a->_tds__SetCertificatesStatus::CertificateStatus, "tt:CertificateStatus"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatus, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(_tds__SetCertificatesStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetCertificatesStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetCertificatesStatus *p;
	size_t k = sizeof(_tds__SetCertificatesStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetCertificatesStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetCertificatesStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetCertificatesStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetCertificatesStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetCertificatesStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetCertificatesStatus(soap, tag ? tag : "tds:SetCertificatesStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetCertificatesStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetCertificatesStatus(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatus * SOAP_FMAC4 soap_get__tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificatesStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &this->_tds__GetCertificatesStatusResponse::CertificateStatus);
}

void _tds__GetCertificatesStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &this->_tds__GetCertificatesStatusResponse::CertificateStatus);
#endif
}

int _tds__GetCertificatesStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificatesStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const _tds__GetCertificatesStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:CertificateStatus");
	if (soap_out_std__vectorTemplateOfPointerTott__CertificateStatus(soap, "tds:CertificateStatus", -1, &a->_tds__GetCertificatesStatusResponse::CertificateStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificatesStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificatesStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, _tds__GetCertificatesStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificatesStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(_tds__GetCertificatesStatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificatesStatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificatesStatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__CertificateStatus(soap, "tds:CertificateStatus", &a->_tds__GetCertificatesStatusResponse::CertificateStatus, "tt:CertificateStatus"))
					continue;
			}
			soap_check_result(soap, "tds:CertificateStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatusResponse, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(_tds__GetCertificatesStatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificatesStatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificatesStatusResponse *p;
	size_t k = sizeof(_tds__GetCertificatesStatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificatesStatusResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificatesStatusResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificatesStatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificatesStatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificatesStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificatesStatusResponse(soap, tag ? tag : "tds:GetCertificatesStatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificatesStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificatesStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesStatusResponse(struct soap *soap, _tds__GetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificatesStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetCertificatesStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetCertificatesStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificatesStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, const _tds__GetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatus), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificatesStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificatesStatus(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatus * SOAP_FMAC4 soap_in__tds__GetCertificatesStatus(struct soap *soap, const char *tag, _tds__GetCertificatesStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificatesStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(_tds__GetCertificatesStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificatesStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificatesStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatus, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(_tds__GetCertificatesStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificatesStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificatesStatus *p;
	size_t k = sizeof(_tds__GetCertificatesStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificatesStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificatesStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificatesStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificatesStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificatesStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificatesStatus(soap, tag ? tag : "tds:GetCertificatesStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificatesStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificatesStatus(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatus * SOAP_FMAC4 soap_get__tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__GetCertificatesResponse::NvtCertificate);
}

void _tds__GetCertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__GetCertificatesResponse::NvtCertificate);
#endif
}

int _tds__GetCertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__GetCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:NvtCertificate");
	if (soap_out_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:NvtCertificate", -1, &a->_tds__GetCertificatesResponse::NvtCertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesResponse(struct soap *soap, const char *tag, _tds__GetCertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(_tds__GetCertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:NvtCertificate", &a->_tds__GetCertificatesResponse::NvtCertificate, "tt:Certificate"))
					continue;
			}
			soap_check_result(soap, "tds:NvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesResponse, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(_tds__GetCertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificatesResponse *p;
	size_t k = sizeof(_tds__GetCertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificatesResponse(soap, tag ? tag : "tds:GetCertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesResponse(struct soap *soap, _tds__GetCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetCertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetCertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificates(struct soap *soap, const char *tag, int id, const _tds__GetCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificates * SOAP_FMAC4 soap_in__tds__GetCertificates(struct soap *soap, const char *tag, _tds__GetCertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificates, sizeof(_tds__GetCertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificates, SOAP_TYPE__tds__GetCertificates, sizeof(_tds__GetCertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificates * SOAP_FMAC2 soap_instantiate__tds__GetCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificates *p;
	size_t k = sizeof(_tds__GetCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificates(soap, tag ? tag : "tds:GetCertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificates * SOAP_FMAC4 soap_get__tds__GetCertificates(struct soap *soap, _tds__GetCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateCertificateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateCertificateResponse::NvtCertificate = NULL;
}

void _tds__CreateCertificateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Certificate(soap, &this->_tds__CreateCertificateResponse::NvtCertificate);
#endif
}

int _tds__CreateCertificateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateCertificateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificateResponse(struct soap *soap, const char *tag, int id, const _tds__CreateCertificateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificateResponse), type))
		return soap->error;
	if (a->NvtCertificate)
		soap_element_result(soap, "tds:NvtCertificate");
	if (!a->_tds__CreateCertificateResponse::NvtCertificate)
	{	if (soap_element_empty(soap, "tds:NvtCertificate"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Certificate(soap, "tds:NvtCertificate", -1, &a->_tds__CreateCertificateResponse::NvtCertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateCertificateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateCertificateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateCertificateResponse * SOAP_FMAC4 soap_in__tds__CreateCertificateResponse(struct soap *soap, const char *tag, _tds__CreateCertificateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateCertificateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(_tds__CreateCertificateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateCertificateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateCertificateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NvtCertificate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NvtCertificate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Certificate(soap, "tds:NvtCertificate", &a->_tds__CreateCertificateResponse::NvtCertificate, "tt:Certificate"))
				{	soap_flag_NvtCertificate1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:NvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__CreateCertificateResponse::NvtCertificate))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificateResponse, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(_tds__CreateCertificateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateCertificateResponse * SOAP_FMAC2 soap_instantiate__tds__CreateCertificateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateCertificateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateCertificateResponse *p;
	size_t k = sizeof(_tds__CreateCertificateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateCertificateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateCertificateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateCertificateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateCertificateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateCertificateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateCertificateResponse(soap, tag ? tag : "tds:CreateCertificateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateCertificateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateCertificateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateCertificateResponse * SOAP_FMAC4 soap_get__tds__CreateCertificateResponse(struct soap *soap, _tds__CreateCertificateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateCertificate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateCertificate::CertificateID = NULL;
	this->_tds__CreateCertificate::Subject = NULL;
	this->_tds__CreateCertificate::ValidNotBefore = NULL;
	this->_tds__CreateCertificate::ValidNotAfter = NULL;
}

void _tds__CreateCertificate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__token(soap, &this->_tds__CreateCertificate::CertificateID);
	soap_serialize_PointerTostd__string(soap, &this->_tds__CreateCertificate::Subject);
	soap_serialize_PointerToxsd__dateTime(soap, &this->_tds__CreateCertificate::ValidNotBefore);
	soap_serialize_PointerToxsd__dateTime(soap, &this->_tds__CreateCertificate::ValidNotAfter);
#endif
}

int _tds__CreateCertificate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateCertificate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificate(struct soap *soap, const char *tag, int id, const _tds__CreateCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificate), type))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tds:CertificateID", -1, &a->_tds__CreateCertificate::CertificateID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tds:Subject", -1, &a->_tds__CreateCertificate::Subject, ""))
		return soap->error;
	if (soap_out_PointerToxsd__dateTime(soap, "tds:ValidNotBefore", -1, &a->_tds__CreateCertificate::ValidNotBefore, ""))
		return soap->error;
	if (soap_out_PointerToxsd__dateTime(soap, "tds:ValidNotAfter", -1, &a->_tds__CreateCertificate::ValidNotAfter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateCertificate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateCertificate(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateCertificate * SOAP_FMAC4 soap_in__tds__CreateCertificate(struct soap *soap, const char *tag, _tds__CreateCertificate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateCertificate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificate, sizeof(_tds__CreateCertificate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateCertificate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateCertificate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Subject1 = 1;
	size_t soap_flag_ValidNotBefore1 = 1;
	size_t soap_flag_ValidNotAfter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__token(soap, "tds:CertificateID", &a->_tds__CreateCertificate::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tds:Subject", &a->_tds__CreateCertificate::Subject, "xsd:string"))
				{	soap_flag_Subject1--;
					continue;
				}
			}
			if (soap_flag_ValidNotBefore1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__dateTime(soap, "tds:ValidNotBefore", &a->_tds__CreateCertificate::ValidNotBefore, "xsd:dateTime"))
				{	soap_flag_ValidNotBefore1--;
					continue;
				}
			}
			if (soap_flag_ValidNotAfter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__dateTime(soap, "tds:ValidNotAfter", &a->_tds__CreateCertificate::ValidNotAfter, "xsd:dateTime"))
				{	soap_flag_ValidNotAfter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificate, SOAP_TYPE__tds__CreateCertificate, sizeof(_tds__CreateCertificate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateCertificate * SOAP_FMAC2 soap_instantiate__tds__CreateCertificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateCertificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateCertificate *p;
	size_t k = sizeof(_tds__CreateCertificate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateCertificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateCertificate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateCertificate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateCertificate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateCertificate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateCertificate(soap, tag ? tag : "tds:CreateCertificate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateCertificate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateCertificate(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateCertificate * SOAP_FMAC4 soap_get__tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetAccessPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetAccessPolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetAccessPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetAccessPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const _tds__SetAccessPolicyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetAccessPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetAccessPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, _tds__SetAccessPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetAccessPolicyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(_tds__SetAccessPolicyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetAccessPolicyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetAccessPolicyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicyResponse, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(_tds__SetAccessPolicyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetAccessPolicyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetAccessPolicyResponse *p;
	size_t k = sizeof(_tds__SetAccessPolicyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetAccessPolicyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetAccessPolicyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetAccessPolicyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetAccessPolicyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetAccessPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetAccessPolicyResponse(soap, tag ? tag : "tds:SetAccessPolicyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetAccessPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetAccessPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__SetAccessPolicyResponse(struct soap *soap, _tds__SetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetAccessPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetAccessPolicy::PolicyFile = NULL;
}

void _tds__SetAccessPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__SetAccessPolicy::PolicyFile);
#endif
}

int _tds__SetAccessPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetAccessPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, const _tds__SetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicy), type))
		return soap->error;
	if (!a->_tds__SetAccessPolicy::PolicyFile)
	{	if (soap_element_empty(soap, "tds:PolicyFile"))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->_tds__SetAccessPolicy::PolicyFile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetAccessPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetAccessPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetAccessPolicy * SOAP_FMAC4 soap_in__tds__SetAccessPolicy(struct soap *soap, const char *tag, _tds__SetAccessPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetAccessPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(_tds__SetAccessPolicy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetAccessPolicy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetAccessPolicy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PolicyFile1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &a->_tds__SetAccessPolicy::PolicyFile, "tt:BinaryData"))
				{	soap_flag_PolicyFile1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__SetAccessPolicy::PolicyFile))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicy, SOAP_TYPE__tds__SetAccessPolicy, sizeof(_tds__SetAccessPolicy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetAccessPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetAccessPolicy *p;
	size_t k = sizeof(_tds__SetAccessPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetAccessPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetAccessPolicy);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetAccessPolicy, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetAccessPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetAccessPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetAccessPolicy(soap, tag ? tag : "tds:SetAccessPolicy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetAccessPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetAccessPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetAccessPolicy * SOAP_FMAC4 soap_get__tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAccessPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetAccessPolicyResponse::PolicyFile = NULL;
}

void _tds__GetAccessPolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__GetAccessPolicyResponse::PolicyFile);
#endif
}

int _tds__GetAccessPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAccessPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const _tds__GetAccessPolicyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAccessPolicyResponse), type))
		return soap->error;
	if (a->PolicyFile)
		soap_element_result(soap, "tds:PolicyFile");
	if (!a->_tds__GetAccessPolicyResponse::PolicyFile)
	{	if (soap_element_empty(soap, "tds:PolicyFile"))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->_tds__GetAccessPolicyResponse::PolicyFile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAccessPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAccessPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, _tds__GetAccessPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAccessPolicyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(_tds__GetAccessPolicyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAccessPolicyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAccessPolicyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PolicyFile1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &a->_tds__GetAccessPolicyResponse::PolicyFile, "tt:BinaryData"))
				{	soap_flag_PolicyFile1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:PolicyFile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetAccessPolicyResponse::PolicyFile))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicyResponse, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(_tds__GetAccessPolicyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAccessPolicyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAccessPolicyResponse *p;
	size_t k = sizeof(_tds__GetAccessPolicyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAccessPolicyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAccessPolicyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAccessPolicyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAccessPolicyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAccessPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAccessPolicyResponse(soap, tag ? tag : "tds:GetAccessPolicyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAccessPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAccessPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__GetAccessPolicyResponse(struct soap *soap, _tds__GetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAccessPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetAccessPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetAccessPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAccessPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, const _tds__GetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAccessPolicy), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAccessPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAccessPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAccessPolicy * SOAP_FMAC4 soap_in__tds__GetAccessPolicy(struct soap *soap, const char *tag, _tds__GetAccessPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAccessPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(_tds__GetAccessPolicy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAccessPolicy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAccessPolicy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicy, SOAP_TYPE__tds__GetAccessPolicy, sizeof(_tds__GetAccessPolicy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAccessPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAccessPolicy *p;
	size_t k = sizeof(_tds__GetAccessPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAccessPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAccessPolicy);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAccessPolicy, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAccessPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAccessPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAccessPolicy(soap, tag ? tag : "tds:GetAccessPolicy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAccessPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAccessPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAccessPolicy * SOAP_FMAC4 soap_get__tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RemoveIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__RemoveIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__RemoveIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RemoveIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RemoveIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RemoveIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(_tds__RemoveIPAddressFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RemoveIPAddressFilterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RemoveIPAddressFilterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__RemoveIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(_tds__RemoveIPAddressFilterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RemoveIPAddressFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RemoveIPAddressFilterResponse *p;
	size_t k = sizeof(_tds__RemoveIPAddressFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RemoveIPAddressFilterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RemoveIPAddressFilterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RemoveIPAddressFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RemoveIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RemoveIPAddressFilterResponse(soap, tag ? tag : "tds:RemoveIPAddressFilterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RemoveIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RemoveIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilterResponse(struct soap *soap, _tds__RemoveIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RemoveIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__RemoveIPAddressFilter::IPAddressFilter = NULL;
}

void _tds__RemoveIPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__RemoveIPAddressFilter::IPAddressFilter);
#endif
}

int _tds__RemoveIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RemoveIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__RemoveIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilter), type))
		return soap->error;
	if (!a->_tds__RemoveIPAddressFilter::IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__RemoveIPAddressFilter::IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RemoveIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RemoveIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, _tds__RemoveIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RemoveIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(_tds__RemoveIPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RemoveIPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RemoveIPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->_tds__RemoveIPAddressFilter::IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__RemoveIPAddressFilter::IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__RemoveIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilter, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(_tds__RemoveIPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RemoveIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RemoveIPAddressFilter *p;
	size_t k = sizeof(_tds__RemoveIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RemoveIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RemoveIPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RemoveIPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RemoveIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RemoveIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RemoveIPAddressFilter(soap, tag ? tag : "tds:RemoveIPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RemoveIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RemoveIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__AddIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__AddIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__AddIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__AddIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__AddIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__AddIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__AddIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__AddIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__AddIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(_tds__AddIPAddressFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__AddIPAddressFilterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__AddIPAddressFilterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__AddIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilterResponse, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(_tds__AddIPAddressFilterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__AddIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__AddIPAddressFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__AddIPAddressFilterResponse *p;
	size_t k = sizeof(_tds__AddIPAddressFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__AddIPAddressFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__AddIPAddressFilterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__AddIPAddressFilterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__AddIPAddressFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__AddIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__AddIPAddressFilterResponse(soap, tag ? tag : "tds:AddIPAddressFilterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__AddIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__AddIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__AddIPAddressFilterResponse(struct soap *soap, _tds__AddIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__AddIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__AddIPAddressFilter::IPAddressFilter = NULL;
}

void _tds__AddIPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__AddIPAddressFilter::IPAddressFilter);
#endif
}

int _tds__AddIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__AddIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__AddIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilter), type))
		return soap->error;
	if (!a->_tds__AddIPAddressFilter::IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__AddIPAddressFilter::IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__AddIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__AddIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilter * SOAP_FMAC4 soap_in__tds__AddIPAddressFilter(struct soap *soap, const char *tag, _tds__AddIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__AddIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(_tds__AddIPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__AddIPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__AddIPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->_tds__AddIPAddressFilter::IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__AddIPAddressFilter::IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__AddIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilter, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(_tds__AddIPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__AddIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__AddIPAddressFilter *p;
	size_t k = sizeof(_tds__AddIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__AddIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__AddIPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__AddIPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__AddIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__AddIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__AddIPAddressFilter(soap, tag ? tag : "tds:AddIPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__AddIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__AddIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilter * SOAP_FMAC4 soap_get__tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__SetIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__SetIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(_tds__SetIPAddressFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetIPAddressFilterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetIPAddressFilterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilterResponse, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(_tds__SetIPAddressFilterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetIPAddressFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetIPAddressFilterResponse *p;
	size_t k = sizeof(_tds__SetIPAddressFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetIPAddressFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetIPAddressFilterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetIPAddressFilterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetIPAddressFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetIPAddressFilterResponse(soap, tag ? tag : "tds:SetIPAddressFilterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__SetIPAddressFilterResponse(struct soap *soap, _tds__SetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetIPAddressFilter::IPAddressFilter = NULL;
}

void _tds__SetIPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__SetIPAddressFilter::IPAddressFilter);
#endif
}

int _tds__SetIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__SetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilter), type))
		return soap->error;
	if (!a->_tds__SetIPAddressFilter::IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__SetIPAddressFilter::IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilter * SOAP_FMAC4 soap_in__tds__SetIPAddressFilter(struct soap *soap, const char *tag, _tds__SetIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(_tds__SetIPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetIPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetIPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->_tds__SetIPAddressFilter::IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__SetIPAddressFilter::IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilter, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(_tds__SetIPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetIPAddressFilter *p;
	size_t k = sizeof(_tds__SetIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetIPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetIPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetIPAddressFilter(soap, tag ? tag : "tds:SetIPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilter * SOAP_FMAC4 soap_get__tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetIPAddressFilterResponse::IPAddressFilter = NULL;
}

void _tds__GetIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__GetIPAddressFilterResponse::IPAddressFilter);
#endif
}

int _tds__GetIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__GetIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse), type))
		return soap->error;
	if (a->IPAddressFilter)
		soap_element_result(soap, "tds:IPAddressFilter");
	if (!a->_tds__GetIPAddressFilterResponse::IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__GetIPAddressFilterResponse::IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__GetIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(_tds__GetIPAddressFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetIPAddressFilterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetIPAddressFilterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->_tds__GetIPAddressFilterResponse::IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:IPAddressFilter");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetIPAddressFilterResponse::IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilterResponse, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(_tds__GetIPAddressFilterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetIPAddressFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetIPAddressFilterResponse *p;
	size_t k = sizeof(_tds__GetIPAddressFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetIPAddressFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetIPAddressFilterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetIPAddressFilterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetIPAddressFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetIPAddressFilterResponse(soap, tag ? tag : "tds:GetIPAddressFilterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__GetIPAddressFilterResponse(struct soap *soap, _tds__GetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetIPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__GetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilter), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilter * SOAP_FMAC4 soap_in__tds__GetIPAddressFilter(struct soap *soap, const char *tag, _tds__GetIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(_tds__GetIPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetIPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetIPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilter, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(_tds__GetIPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetIPAddressFilter *p;
	size_t k = sizeof(_tds__GetIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetIPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetIPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetIPAddressFilter(soap, tag ? tag : "tds:GetIPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilter * SOAP_FMAC4 soap_get__tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetZeroConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetZeroConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetZeroConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetZeroConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetZeroConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetZeroConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetZeroConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, _tds__SetZeroConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetZeroConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(_tds__SetZeroConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetZeroConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetZeroConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfigurationResponse, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(_tds__SetZeroConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetZeroConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetZeroConfigurationResponse *p;
	size_t k = sizeof(_tds__SetZeroConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetZeroConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetZeroConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetZeroConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetZeroConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetZeroConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetZeroConfigurationResponse(soap, tag ? tag : "tds:SetZeroConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetZeroConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetZeroConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetZeroConfigurationResponse(struct soap *soap, _tds__SetZeroConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetZeroConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetZeroConfiguration::InterfaceToken);
	soap_default_bool(soap, &this->_tds__SetZeroConfiguration::Enabled);
}

void _tds__SetZeroConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetZeroConfiguration::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetZeroConfiguration::InterfaceToken);
	soap_embedded(soap, &this->_tds__SetZeroConfiguration::Enabled, SOAP_TYPE_bool);
#endif
}

int _tds__SetZeroConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetZeroConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetZeroConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__SetZeroConfiguration::InterfaceToken, ""))
		return soap->error;
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__SetZeroConfiguration::Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetZeroConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetZeroConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetZeroConfiguration * SOAP_FMAC4 soap_in__tds__SetZeroConfiguration(struct soap *soap, const char *tag, _tds__SetZeroConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetZeroConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(_tds__SetZeroConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetZeroConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetZeroConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	size_t soap_flag_Enabled1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->_tds__SetZeroConfiguration::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__SetZeroConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0 || soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfiguration, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(_tds__SetZeroConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetZeroConfiguration *p;
	size_t k = sizeof(_tds__SetZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetZeroConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetZeroConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetZeroConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetZeroConfiguration(soap, tag ? tag : "tds:SetZeroConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetZeroConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetZeroConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetZeroConfiguration * SOAP_FMAC4 soap_get__tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetZeroConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetZeroConfigurationResponse::ZeroConfiguration = NULL;
}

void _tds__GetZeroConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkZeroConfiguration(soap, &this->_tds__GetZeroConfigurationResponse::ZeroConfiguration);
#endif
}

int _tds__GetZeroConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetZeroConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetZeroConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse), type))
		return soap->error;
	if (a->ZeroConfiguration)
		soap_element_result(soap, "tds:ZeroConfiguration");
	if (!a->_tds__GetZeroConfigurationResponse::ZeroConfiguration)
	{	if (soap_element_empty(soap, "tds:ZeroConfiguration"))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkZeroConfiguration(soap, "tds:ZeroConfiguration", -1, &a->_tds__GetZeroConfigurationResponse::ZeroConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetZeroConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetZeroConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, _tds__GetZeroConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetZeroConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(_tds__GetZeroConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetZeroConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetZeroConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ZeroConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ZeroConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkZeroConfiguration(soap, "tds:ZeroConfiguration", &a->_tds__GetZeroConfigurationResponse::ZeroConfiguration, "tt:NetworkZeroConfiguration"))
				{	soap_flag_ZeroConfiguration1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:ZeroConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetZeroConfigurationResponse::ZeroConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfigurationResponse, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(_tds__GetZeroConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetZeroConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetZeroConfigurationResponse *p;
	size_t k = sizeof(_tds__GetZeroConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetZeroConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetZeroConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetZeroConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetZeroConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetZeroConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetZeroConfigurationResponse(soap, tag ? tag : "tds:GetZeroConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetZeroConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetZeroConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetZeroConfigurationResponse(struct soap *soap, _tds__GetZeroConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetZeroConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetZeroConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetZeroConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetZeroConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetZeroConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetZeroConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetZeroConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetZeroConfiguration * SOAP_FMAC4 soap_in__tds__GetZeroConfiguration(struct soap *soap, const char *tag, _tds__GetZeroConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetZeroConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(_tds__GetZeroConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetZeroConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetZeroConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfiguration, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(_tds__GetZeroConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetZeroConfiguration *p;
	size_t k = sizeof(_tds__GetZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetZeroConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetZeroConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetZeroConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetZeroConfiguration(soap, tag ? tag : "tds:GetZeroConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetZeroConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetZeroConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetZeroConfiguration * SOAP_FMAC4 soap_get__tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkDefaultGatewayResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetNetworkDefaultGatewayResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetNetworkDefaultGatewayResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkDefaultGatewayResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkDefaultGatewayResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(_tds__SetNetworkDefaultGatewayResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkDefaultGatewayResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(_tds__SetNetworkDefaultGatewayResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkDefaultGatewayResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkDefaultGatewayResponse *p;
	size_t k = sizeof(_tds__SetNetworkDefaultGatewayResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkDefaultGatewayResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkDefaultGatewayResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkDefaultGatewayResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkDefaultGatewayResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag ? tag : "tds:SetNetworkDefaultGatewayResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkDefaultGatewayResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkDefaultGatewayResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, _tds__SetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkDefaultGateway::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__IPv4Address(soap, &this->_tds__SetNetworkDefaultGateway::IPv4Address);
	soap_default_std__vectorTemplateOftt__IPv6Address(soap, &this->_tds__SetNetworkDefaultGateway::IPv6Address);
}

void _tds__SetNetworkDefaultGateway::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__IPv4Address(soap, &this->_tds__SetNetworkDefaultGateway::IPv4Address);
	soap_serialize_std__vectorTemplateOftt__IPv6Address(soap, &this->_tds__SetNetworkDefaultGateway::IPv6Address);
#endif
}

int _tds__SetNetworkDefaultGateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkDefaultGateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const _tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv4Address(soap, "tds:IPv4Address", -1, &a->_tds__SetNetworkDefaultGateway::IPv4Address, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv6Address(soap, "tds:IPv6Address", -1, &a->_tds__SetNetworkDefaultGateway::IPv6Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkDefaultGateway::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkDefaultGateway(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkDefaultGateway*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(_tds__SetNetworkDefaultGateway), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkDefaultGateway)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkDefaultGateway *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv4Address(soap, "tds:IPv4Address", &a->_tds__SetNetworkDefaultGateway::IPv4Address, "tt:IPv4Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv6Address(soap, "tds:IPv6Address", &a->_tds__SetNetworkDefaultGateway::IPv6Address, "tt:IPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGateway, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(_tds__SetNetworkDefaultGateway), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkDefaultGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkDefaultGateway *p;
	size_t k = sizeof(_tds__SetNetworkDefaultGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkDefaultGateway);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkDefaultGateway, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkDefaultGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkDefaultGateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkDefaultGateway(soap, tag ? tag : "tds:SetNetworkDefaultGateway", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkDefaultGateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkDefaultGateway(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkDefaultGatewayResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway = NULL;
}

void _tds__GetNetworkDefaultGatewayResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkGateway(soap, &this->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway);
#endif
}

int _tds__GetNetworkDefaultGatewayResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse), type))
		return soap->error;
	if (a->NetworkGateway)
		soap_element_result(soap, "tds:NetworkGateway");
	if (!a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway)
	{	if (soap_element_empty(soap, "tds:NetworkGateway"))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", -1, &a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkDefaultGatewayResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkDefaultGatewayResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(_tds__GetNetworkDefaultGatewayResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkDefaultGatewayResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NetworkGateway1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NetworkGateway1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", &a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway, "tt:NetworkGateway"))
				{	soap_flag_NetworkGateway1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:NetworkGateway");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(_tds__GetNetworkDefaultGatewayResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkDefaultGatewayResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkDefaultGatewayResponse *p;
	size_t k = sizeof(_tds__GetNetworkDefaultGatewayResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkDefaultGatewayResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkDefaultGatewayResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkDefaultGatewayResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkDefaultGatewayResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag ? tag : "tds:GetNetworkDefaultGatewayResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkDefaultGatewayResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkDefaultGatewayResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, _tds__GetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkDefaultGateway::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetNetworkDefaultGateway::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetNetworkDefaultGateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkDefaultGateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const _tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkDefaultGateway::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkDefaultGateway(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkDefaultGateway*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(_tds__GetNetworkDefaultGateway), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkDefaultGateway)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkDefaultGateway *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGateway, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(_tds__GetNetworkDefaultGateway), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkDefaultGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkDefaultGateway *p;
	size_t k = sizeof(_tds__GetNetworkDefaultGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkDefaultGateway);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkDefaultGateway, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkDefaultGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkDefaultGateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkDefaultGateway(soap, tag ? tag : "tds:GetNetworkDefaultGateway", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkDefaultGateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkDefaultGateway(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkProtocolsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetNetworkProtocolsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetNetworkProtocolsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkProtocolsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkProtocolsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkProtocolsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkProtocolsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(_tds__SetNetworkProtocolsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkProtocolsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkProtocolsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocolsResponse, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(_tds__SetNetworkProtocolsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocolsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkProtocolsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkProtocolsResponse *p;
	size_t k = sizeof(_tds__SetNetworkProtocolsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkProtocolsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkProtocolsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkProtocolsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkProtocolsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkProtocolsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkProtocolsResponse(soap, tag ? tag : "tds:SetNetworkProtocolsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkProtocolsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkProtocolsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__SetNetworkProtocolsResponse(struct soap *soap, _tds__SetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkProtocols::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &this->_tds__SetNetworkProtocols::NetworkProtocols);
}

void _tds__SetNetworkProtocols::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &this->_tds__SetNetworkProtocols::NetworkProtocols);
#endif
}

int _tds__SetNetworkProtocols::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkProtocols(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const _tds__SetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocols), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", -1, &a->_tds__SetNetworkProtocols::NetworkProtocols, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkProtocols::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkProtocols(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocols * SOAP_FMAC4 soap_in__tds__SetNetworkProtocols(struct soap *soap, const char *tag, _tds__SetNetworkProtocols *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkProtocols*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(_tds__SetNetworkProtocols), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkProtocols)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkProtocols *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", &a->_tds__SetNetworkProtocols::NetworkProtocols, "tt:NetworkProtocol"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__SetNetworkProtocols::NetworkProtocols.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocols, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(_tds__SetNetworkProtocols), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkProtocols(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkProtocols *p;
	size_t k = sizeof(_tds__SetNetworkProtocols);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkProtocols, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkProtocols);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkProtocols, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkProtocols location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkProtocols::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkProtocols(soap, tag ? tag : "tds:SetNetworkProtocols", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkProtocols::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkProtocols(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocols * SOAP_FMAC4 soap_get__tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkProtocolsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &this->_tds__GetNetworkProtocolsResponse::NetworkProtocols);
}

void _tds__GetNetworkProtocolsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &this->_tds__GetNetworkProtocolsResponse::NetworkProtocols);
#endif
}

int _tds__GetNetworkProtocolsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkProtocolsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:NetworkProtocols");
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", -1, &a->_tds__GetNetworkProtocolsResponse::NetworkProtocols, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkProtocolsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkProtocolsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkProtocolsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(_tds__GetNetworkProtocolsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkProtocolsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkProtocolsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", &a->_tds__GetNetworkProtocolsResponse::NetworkProtocols, "tt:NetworkProtocol"))
					continue;
			}
			soap_check_result(soap, "tds:NetworkProtocols");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocolsResponse, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(_tds__GetNetworkProtocolsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocolsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkProtocolsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkProtocolsResponse *p;
	size_t k = sizeof(_tds__GetNetworkProtocolsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkProtocolsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkProtocolsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkProtocolsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkProtocolsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkProtocolsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkProtocolsResponse(soap, tag ? tag : "tds:GetNetworkProtocolsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkProtocolsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkProtocolsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__GetNetworkProtocolsResponse(struct soap *soap, _tds__GetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkProtocols::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetNetworkProtocols::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetNetworkProtocols::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkProtocols(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const _tds__GetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocols), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkProtocols::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkProtocols(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocols * SOAP_FMAC4 soap_in__tds__GetNetworkProtocols(struct soap *soap, const char *tag, _tds__GetNetworkProtocols *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkProtocols*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(_tds__GetNetworkProtocols), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkProtocols)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkProtocols *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocols, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(_tds__GetNetworkProtocols), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkProtocols(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkProtocols *p;
	size_t k = sizeof(_tds__GetNetworkProtocols);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkProtocols, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkProtocols);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkProtocols, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkProtocols location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkProtocols::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkProtocols(soap, tag ? tag : "tds:GetNetworkProtocols", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkProtocols::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkProtocols(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocols * SOAP_FMAC4 soap_get__tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkInterfacesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetNetworkInterfacesResponse::RebootNeeded);
}

void _tds__SetNetworkInterfacesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetNetworkInterfacesResponse::RebootNeeded, SOAP_TYPE_bool);
#endif
}

int _tds__SetNetworkInterfacesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkInterfacesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_bool(soap, "tds:RebootNeeded", -1, &a->_tds__SetNetworkInterfacesResponse::RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkInterfacesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkInterfacesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkInterfacesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(_tds__SetNetworkInterfacesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkInterfacesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkInterfacesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RebootNeeded1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:RebootNeeded", &a->_tds__SetNetworkInterfacesResponse::RebootNeeded, "xsd:boolean"))
				{	soap_flag_RebootNeeded1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfacesResponse, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(_tds__SetNetworkInterfacesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfacesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkInterfacesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkInterfacesResponse *p;
	size_t k = sizeof(_tds__SetNetworkInterfacesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkInterfacesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkInterfacesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkInterfacesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkInterfacesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkInterfacesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkInterfacesResponse(soap, tag ? tag : "tds:SetNetworkInterfacesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkInterfacesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkInterfacesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__SetNetworkInterfacesResponse(struct soap *soap, _tds__SetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkInterfaces::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetNetworkInterfaces::InterfaceToken);
	this->_tds__SetNetworkInterfaces::NetworkInterface = NULL;
}

void _tds__SetNetworkInterfaces::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetNetworkInterfaces::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetNetworkInterfaces::InterfaceToken);
	soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(soap, &this->_tds__SetNetworkInterfaces::NetworkInterface);
#endif
}

int _tds__SetNetworkInterfaces::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkInterfaces(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const _tds__SetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfaces), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__SetNetworkInterfaces::InterfaceToken, ""))
		return soap->error;
	if (!a->_tds__SetNetworkInterfaces::NetworkInterface)
	{	if (soap_element_empty(soap, "tds:NetworkInterface"))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", -1, &a->_tds__SetNetworkInterfaces::NetworkInterface, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkInterfaces::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkInterfaces(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, _tds__SetNetworkInterfaces *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkInterfaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(_tds__SetNetworkInterfaces), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkInterfaces)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkInterfaces *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	size_t soap_flag_NetworkInterface1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->_tds__SetNetworkInterfaces::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap_flag_NetworkInterface1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", &a->_tds__SetNetworkInterfaces::NetworkInterface, "tt:NetworkInterfaceSetConfiguration"))
				{	soap_flag_NetworkInterface1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0 || !a->_tds__SetNetworkInterfaces::NetworkInterface))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfaces, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(_tds__SetNetworkInterfaces), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkInterfaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkInterfaces *p;
	size_t k = sizeof(_tds__SetNetworkInterfaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkInterfaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkInterfaces);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkInterfaces, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkInterfaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkInterfaces::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkInterfaces(soap, tag ? tag : "tds:SetNetworkInterfaces", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkInterfaces::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkInterfaces(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkInterfacesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkInterface(soap, &this->_tds__GetNetworkInterfacesResponse::NetworkInterfaces);
}

void _tds__GetNetworkInterfacesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkInterface(soap, &this->_tds__GetNetworkInterfacesResponse::NetworkInterfaces);
#endif
}

int _tds__GetNetworkInterfacesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkInterfacesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:NetworkInterfaces");
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkInterface(soap, "tds:NetworkInterfaces", -1, &a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkInterfacesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkInterfacesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkInterfacesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(_tds__GetNetworkInterfacesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkInterfacesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkInterfacesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkInterface(soap, "tds:NetworkInterfaces", &a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces, "tt:NetworkInterface"))
					continue;
			}
			soap_check_result(soap, "tds:NetworkInterfaces");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfacesResponse, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(_tds__GetNetworkInterfacesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfacesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkInterfacesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkInterfacesResponse *p;
	size_t k = sizeof(_tds__GetNetworkInterfacesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkInterfacesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkInterfacesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkInterfacesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkInterfacesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkInterfacesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkInterfacesResponse(soap, tag ? tag : "tds:GetNetworkInterfacesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkInterfacesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkInterfacesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__GetNetworkInterfacesResponse(struct soap *soap, _tds__GetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkInterfaces::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetNetworkInterfaces::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetNetworkInterfaces::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkInterfaces(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const _tds__GetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkInterfaces::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkInterfaces(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, _tds__GetNetworkInterfaces *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkInterfaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(_tds__GetNetworkInterfaces), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkInterfaces)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkInterfaces *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfaces, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(_tds__GetNetworkInterfaces), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkInterfaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkInterfaces *p;
	size_t k = sizeof(_tds__GetNetworkInterfaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkInterfaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkInterfaces);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkInterfaces, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkInterfaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkInterfaces::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkInterfaces(soap, tag ? tag : "tds:GetNetworkInterfaces", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkInterfaces::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkInterfaces(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDynamicDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDynamicDNSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDynamicDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDynamicDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const _tds__SetDynamicDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDynamicDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDynamicDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, _tds__SetDynamicDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDynamicDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(_tds__SetDynamicDNSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDynamicDNSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDynamicDNSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNSResponse, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(_tds__SetDynamicDNSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDynamicDNSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDynamicDNSResponse *p;
	size_t k = sizeof(_tds__SetDynamicDNSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDynamicDNSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDynamicDNSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDynamicDNSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDynamicDNSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDynamicDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDynamicDNSResponse(soap, tag ? tag : "tds:SetDynamicDNSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDynamicDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDynamicDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__SetDynamicDNSResponse(struct soap *soap, _tds__SetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDynamicDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DynamicDNSType(soap, &this->_tds__SetDynamicDNS::Type);
	this->_tds__SetDynamicDNS::Name = NULL;
	this->_tds__SetDynamicDNS::TTL = NULL;
}

void _tds__SetDynamicDNS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DNSName(soap, &this->_tds__SetDynamicDNS::Name);
	soap_serialize_PointerToxsd__duration(soap, &this->_tds__SetDynamicDNS::TTL);
#endif
}

int _tds__SetDynamicDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDynamicDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const _tds__SetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNS), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tds:Type", -1, &a->_tds__SetDynamicDNS::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tds:Name", -1, &a->_tds__SetDynamicDNS::Name, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tds:TTL", -1, &a->_tds__SetDynamicDNS::TTL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDynamicDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDynamicDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDynamicDNS * SOAP_FMAC4 soap_in__tds__SetDynamicDNS(struct soap *soap, const char *tag, _tds__SetDynamicDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDynamicDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(_tds__SetDynamicDNS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDynamicDNS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDynamicDNS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_TTL1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DynamicDNSType(soap, "tds:Type", &a->_tds__SetDynamicDNS::Type, "tt:DynamicDNSType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__DNSName(soap, "tds:Name", &a->_tds__SetDynamicDNS::Name, "tt:DNSName"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_TTL1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__duration(soap, "tds:TTL", &a->_tds__SetDynamicDNS::TTL, "xsd:duration"))
				{	soap_flag_TTL1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNS, SOAP_TYPE__tds__SetDynamicDNS, sizeof(_tds__SetDynamicDNS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDynamicDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDynamicDNS *p;
	size_t k = sizeof(_tds__SetDynamicDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDynamicDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDynamicDNS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDynamicDNS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDynamicDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDynamicDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDynamicDNS(soap, tag ? tag : "tds:SetDynamicDNS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDynamicDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDynamicDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDynamicDNS * SOAP_FMAC4 soap_get__tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDynamicDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDynamicDNSResponse::DynamicDNSInformation = NULL;
}

void _tds__GetDynamicDNSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DynamicDNSInformation(soap, &this->_tds__GetDynamicDNSResponse::DynamicDNSInformation);
#endif
}

int _tds__GetDynamicDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDynamicDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const _tds__GetDynamicDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNSResponse), type))
		return soap->error;
	if (a->DynamicDNSInformation)
		soap_element_result(soap, "tds:DynamicDNSInformation");
	if (!a->_tds__GetDynamicDNSResponse::DynamicDNSInformation)
	{	if (soap_element_empty(soap, "tds:DynamicDNSInformation"))
			return soap->error;
	}
	else if (soap_out_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", -1, &a->_tds__GetDynamicDNSResponse::DynamicDNSInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDynamicDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDynamicDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, _tds__GetDynamicDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDynamicDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(_tds__GetDynamicDNSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDynamicDNSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDynamicDNSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DynamicDNSInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DynamicDNSInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", &a->_tds__GetDynamicDNSResponse::DynamicDNSInformation, "tt:DynamicDNSInformation"))
				{	soap_flag_DynamicDNSInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:DynamicDNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetDynamicDNSResponse::DynamicDNSInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNSResponse, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(_tds__GetDynamicDNSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDynamicDNSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDynamicDNSResponse *p;
	size_t k = sizeof(_tds__GetDynamicDNSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDynamicDNSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDynamicDNSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDynamicDNSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDynamicDNSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDynamicDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDynamicDNSResponse(soap, tag ? tag : "tds:GetDynamicDNSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDynamicDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDynamicDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__GetDynamicDNSResponse(struct soap *soap, _tds__GetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDynamicDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDynamicDNS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDynamicDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDynamicDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const _tds__GetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDynamicDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDynamicDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDynamicDNS * SOAP_FMAC4 soap_in__tds__GetDynamicDNS(struct soap *soap, const char *tag, _tds__GetDynamicDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDynamicDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(_tds__GetDynamicDNS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDynamicDNS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDynamicDNS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNS, SOAP_TYPE__tds__GetDynamicDNS, sizeof(_tds__GetDynamicDNS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDynamicDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDynamicDNS *p;
	size_t k = sizeof(_tds__GetDynamicDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDynamicDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDynamicDNS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDynamicDNS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDynamicDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDynamicDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDynamicDNS(soap, tag ? tag : "tds:GetDynamicDNS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDynamicDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDynamicDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDynamicDNS * SOAP_FMAC4 soap_get__tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNTPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetNTPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetNTPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNTPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTPResponse(struct soap *soap, const char *tag, int id, const _tds__SetNTPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTPResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNTPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNTPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNTPResponse * SOAP_FMAC4 soap_in__tds__SetNTPResponse(struct soap *soap, const char *tag, _tds__SetNTPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNTPResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTPResponse, sizeof(_tds__SetNTPResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNTPResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNTPResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTPResponse, SOAP_TYPE__tds__SetNTPResponse, sizeof(_tds__SetNTPResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__SetNTPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNTPResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNTPResponse *p;
	size_t k = sizeof(_tds__SetNTPResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNTPResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNTPResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNTPResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNTPResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNTPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNTPResponse(soap, tag ? tag : "tds:SetNTPResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNTPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNTPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNTPResponse * SOAP_FMAC4 soap_get__tds__SetNTPResponse(struct soap *soap, _tds__SetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNTP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetNTP::FromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__SetNTP::NTPManual);
}

void _tds__SetNTP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetNTP::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__SetNTP::NTPManual);
#endif
}

int _tds__SetNTP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNTP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTP(struct soap *soap, const char *tag, int id, const _tds__SetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTP), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:FromDHCP", -1, &a->_tds__SetNTP::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:NTPManual", -1, &a->_tds__SetNTP::NTPManual, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNTP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNTP(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNTP * SOAP_FMAC4 soap_in__tds__SetNTP(struct soap *soap, const char *tag, _tds__SetNTP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNTP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTP, sizeof(_tds__SetNTP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNTP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNTP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FromDHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:FromDHCP", &a->_tds__SetNTP::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:NTPManual", &a->_tds__SetNTP::NTPManual, "tt:NetworkHost"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTP, SOAP_TYPE__tds__SetNTP, sizeof(_tds__SetNTP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNTP * SOAP_FMAC2 soap_instantiate__tds__SetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNTP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNTP *p;
	size_t k = sizeof(_tds__SetNTP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNTP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNTP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNTP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNTP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNTP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNTP(soap, tag ? tag : "tds:SetNTP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNTP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNTP(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNTP * SOAP_FMAC4 soap_get__tds__SetNTP(struct soap *soap, _tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNTPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetNTPResponse::NTPInformation = NULL;
}

void _tds__GetNTPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NTPInformation(soap, &this->_tds__GetNTPResponse::NTPInformation);
#endif
}

int _tds__GetNTPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNTPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTPResponse(struct soap *soap, const char *tag, int id, const _tds__GetNTPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTPResponse), type))
		return soap->error;
	if (a->NTPInformation)
		soap_element_result(soap, "tds:NTPInformation");
	if (!a->_tds__GetNTPResponse::NTPInformation)
	{	if (soap_element_empty(soap, "tds:NTPInformation"))
			return soap->error;
	}
	else if (soap_out_PointerTott__NTPInformation(soap, "tds:NTPInformation", -1, &a->_tds__GetNTPResponse::NTPInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNTPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNTPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNTPResponse * SOAP_FMAC4 soap_in__tds__GetNTPResponse(struct soap *soap, const char *tag, _tds__GetNTPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNTPResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTPResponse, sizeof(_tds__GetNTPResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNTPResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNTPResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NTPInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NTPInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NTPInformation(soap, "tds:NTPInformation", &a->_tds__GetNTPResponse::NTPInformation, "tt:NTPInformation"))
				{	soap_flag_NTPInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:NTPInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetNTPResponse::NTPInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTPResponse, SOAP_TYPE__tds__GetNTPResponse, sizeof(_tds__GetNTPResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__GetNTPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNTPResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNTPResponse *p;
	size_t k = sizeof(_tds__GetNTPResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNTPResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNTPResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNTPResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNTPResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNTPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNTPResponse(soap, tag ? tag : "tds:GetNTPResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNTPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNTPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNTPResponse * SOAP_FMAC4 soap_get__tds__GetNTPResponse(struct soap *soap, _tds__GetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNTP::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetNTP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetNTP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNTP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTP(struct soap *soap, const char *tag, int id, const _tds__GetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTP), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNTP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNTP(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNTP * SOAP_FMAC4 soap_in__tds__GetNTP(struct soap *soap, const char *tag, _tds__GetNTP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNTP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTP, sizeof(_tds__GetNTP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNTP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNTP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTP, SOAP_TYPE__tds__GetNTP, sizeof(_tds__GetNTP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNTP * SOAP_FMAC2 soap_instantiate__tds__GetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNTP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNTP *p;
	size_t k = sizeof(_tds__GetNTP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNTP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNTP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNTP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNTP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNTP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNTP(soap, tag ? tag : "tds:GetNTP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNTP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNTP(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNTP * SOAP_FMAC4 soap_get__tds__GetNTP(struct soap *soap, _tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDNSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNSResponse(struct soap *soap, const char *tag, int id, const _tds__SetDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDNSResponse * SOAP_FMAC4 soap_in__tds__SetDNSResponse(struct soap *soap, const char *tag, _tds__SetDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNSResponse, sizeof(_tds__SetDNSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDNSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDNSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNSResponse, SOAP_TYPE__tds__SetDNSResponse, sizeof(_tds__SetDNSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDNSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDNSResponse *p;
	size_t k = sizeof(_tds__SetDNSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDNSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDNSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDNSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDNSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDNSResponse(soap, tag ? tag : "tds:SetDNSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDNSResponse * SOAP_FMAC4 soap_get__tds__SetDNSResponse(struct soap *soap, _tds__SetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetDNS::FromDHCP);
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->_tds__SetDNS::SearchDomain);
	soap_default_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->_tds__SetDNS::DNSManual);
}

void _tds__SetDNS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetDNS::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->_tds__SetDNS::SearchDomain);
	soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->_tds__SetDNS::DNSManual);
#endif
}

int _tds__SetDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNS(struct soap *soap, const char *tag, int id, const _tds__SetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNS), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:FromDHCP", -1, &a->_tds__SetDNS::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tds:SearchDomain", -1, &a->_tds__SetDNS::SearchDomain, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IPAddress(soap, "tds:DNSManual", -1, &a->_tds__SetDNS::DNSManual, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDNS * SOAP_FMAC4 soap_in__tds__SetDNS(struct soap *soap, const char *tag, _tds__SetDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNS, sizeof(_tds__SetDNS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDNS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDNS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FromDHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:FromDHCP", &a->_tds__SetDNS::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__token(soap, "tds:SearchDomain", &a->_tds__SetDNS::SearchDomain, "xsd:token"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__IPAddress(soap, "tds:DNSManual", &a->_tds__SetDNS::DNSManual, "tt:IPAddress"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNS, SOAP_TYPE__tds__SetDNS, sizeof(_tds__SetDNS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDNS * SOAP_FMAC2 soap_instantiate__tds__SetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDNS *p;
	size_t k = sizeof(_tds__SetDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDNS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDNS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDNS(soap, tag ? tag : "tds:SetDNS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDNS * SOAP_FMAC4 soap_get__tds__SetDNS(struct soap *soap, _tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDNSResponse::DNSInformation = NULL;
}

void _tds__GetDNSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DNSInformation(soap, &this->_tds__GetDNSResponse::DNSInformation);
#endif
}

int _tds__GetDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNSResponse(struct soap *soap, const char *tag, int id, const _tds__GetDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNSResponse), type))
		return soap->error;
	if (a->DNSInformation)
		soap_element_result(soap, "tds:DNSInformation");
	if (!a->_tds__GetDNSResponse::DNSInformation)
	{	if (soap_element_empty(soap, "tds:DNSInformation"))
			return soap->error;
	}
	else if (soap_out_PointerTott__DNSInformation(soap, "tds:DNSInformation", -1, &a->_tds__GetDNSResponse::DNSInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDNSResponse * SOAP_FMAC4 soap_in__tds__GetDNSResponse(struct soap *soap, const char *tag, _tds__GetDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNSResponse, sizeof(_tds__GetDNSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDNSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDNSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DNSInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DNSInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DNSInformation(soap, "tds:DNSInformation", &a->_tds__GetDNSResponse::DNSInformation, "tt:DNSInformation"))
				{	soap_flag_DNSInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:DNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetDNSResponse::DNSInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNSResponse, SOAP_TYPE__tds__GetDNSResponse, sizeof(_tds__GetDNSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDNSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDNSResponse *p;
	size_t k = sizeof(_tds__GetDNSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDNSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDNSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDNSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDNSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDNSResponse(soap, tag ? tag : "tds:GetDNSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDNSResponse * SOAP_FMAC4 soap_get__tds__GetDNSResponse(struct soap *soap, _tds__GetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDNS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNS(struct soap *soap, const char *tag, int id, const _tds__GetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDNS * SOAP_FMAC4 soap_in__tds__GetDNS(struct soap *soap, const char *tag, _tds__GetDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNS, sizeof(_tds__GetDNS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDNS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDNS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNS, SOAP_TYPE__tds__GetDNS, sizeof(_tds__GetDNS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDNS * SOAP_FMAC2 soap_instantiate__tds__GetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDNS *p;
	size_t k = sizeof(_tds__GetDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDNS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDNS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDNS(soap, tag ? tag : "tds:GetDNS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDNS * SOAP_FMAC4 soap_get__tds__GetDNS(struct soap *soap, _tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHostnameFromDHCPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetHostnameFromDHCPResponse::RebootNeeded);
}

void _tds__SetHostnameFromDHCPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetHostnameFromDHCPResponse::RebootNeeded, SOAP_TYPE_bool);
#endif
}

int _tds__SetHostnameFromDHCPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostnameFromDHCPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, int id, const _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_bool(soap, "tds:RebootNeeded", -1, &a->_tds__SetHostnameFromDHCPResponse::RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostnameFromDHCPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostnameFromDHCPResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(_tds__SetHostnameFromDHCPResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHostnameFromDHCPResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHostnameFromDHCPResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RebootNeeded1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:RebootNeeded", &a->_tds__SetHostnameFromDHCPResponse::RebootNeeded, "xsd:boolean"))
				{	soap_flag_RebootNeeded1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetHostnameFromDHCPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(_tds__SetHostnameFromDHCPResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostnameFromDHCPResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHostnameFromDHCPResponse *p;
	size_t k = sizeof(_tds__SetHostnameFromDHCPResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHostnameFromDHCPResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHostnameFromDHCPResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHostnameFromDHCPResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHostnameFromDHCPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHostnameFromDHCPResponse(soap, tag ? tag : "tds:SetHostnameFromDHCPResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostnameFromDHCPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostnameFromDHCPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCPResponse(struct soap *soap, _tds__SetHostnameFromDHCPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHostnameFromDHCP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetHostnameFromDHCP::FromDHCP);
}

void _tds__SetHostnameFromDHCP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetHostnameFromDHCP::FromDHCP, SOAP_TYPE_bool);
#endif
}

int _tds__SetHostnameFromDHCP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostnameFromDHCP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const _tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCP), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:FromDHCP", -1, &a->_tds__SetHostnameFromDHCP::FromDHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostnameFromDHCP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHostnameFromDHCP(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, _tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostnameFromDHCP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(_tds__SetHostnameFromDHCP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHostnameFromDHCP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHostnameFromDHCP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FromDHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:FromDHCP", &a->_tds__SetHostnameFromDHCP::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetHostnameFromDHCP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCP, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(_tds__SetHostnameFromDHCP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostnameFromDHCP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHostnameFromDHCP *p;
	size_t k = sizeof(_tds__SetHostnameFromDHCP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHostnameFromDHCP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHostnameFromDHCP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHostnameFromDHCP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHostnameFromDHCP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHostnameFromDHCP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHostnameFromDHCP(soap, tag ? tag : "tds:SetHostnameFromDHCP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostnameFromDHCP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostnameFromDHCP(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHostnameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetHostnameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetHostnameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostnameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameResponse(struct soap *soap, const char *tag, int id, const _tds__SetHostnameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostnameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHostnameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostnameResponse * SOAP_FMAC4 soap_in__tds__SetHostnameResponse(struct soap *soap, const char *tag, _tds__SetHostnameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostnameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(_tds__SetHostnameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHostnameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHostnameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameResponse, SOAP_TYPE__tds__SetHostnameResponse, sizeof(_tds__SetHostnameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostnameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHostnameResponse *p;
	size_t k = sizeof(_tds__SetHostnameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHostnameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHostnameResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHostnameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHostnameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHostnameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHostnameResponse(soap, tag ? tag : "tds:SetHostnameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostnameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostnameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostnameResponse * SOAP_FMAC4 soap_get__tds__SetHostnameResponse(struct soap *soap, _tds__SetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHostname::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__SetHostname::Name);
}

void _tds__SetHostname::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetHostname::Name, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->_tds__SetHostname::Name);
#endif
}

int _tds__SetHostname::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostname(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostname(struct soap *soap, const char *tag, int id, const _tds__SetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostname), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:Name", -1, &a->_tds__SetHostname::Name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostname::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHostname(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostname * SOAP_FMAC4 soap_in__tds__SetHostname(struct soap *soap, const char *tag, _tds__SetHostname *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostname*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostname, sizeof(_tds__SetHostname), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHostname)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHostname *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:Name", &a->_tds__SetHostname::Name, "xsd:token"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostname, SOAP_TYPE__tds__SetHostname, sizeof(_tds__SetHostname), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostname * SOAP_FMAC2 soap_instantiate__tds__SetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostname(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHostname *p;
	size_t k = sizeof(_tds__SetHostname);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHostname, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHostname);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHostname, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHostname location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHostname::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHostname(soap, tag ? tag : "tds:SetHostname", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostname::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostname(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostname * SOAP_FMAC4 soap_get__tds__SetHostname(struct soap *soap, _tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetHostnameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetHostnameResponse::HostnameInformation = NULL;
}

void _tds__GetHostnameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__HostnameInformation(soap, &this->_tds__GetHostnameResponse::HostnameInformation);
#endif
}

int _tds__GetHostnameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetHostnameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostnameResponse(struct soap *soap, const char *tag, int id, const _tds__GetHostnameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostnameResponse), type))
		return soap->error;
	if (a->HostnameInformation)
		soap_element_result(soap, "tds:HostnameInformation");
	if (!a->_tds__GetHostnameResponse::HostnameInformation)
	{	if (soap_element_empty(soap, "tds:HostnameInformation"))
			return soap->error;
	}
	else if (soap_out_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", -1, &a->_tds__GetHostnameResponse::HostnameInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetHostnameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetHostnameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetHostnameResponse * SOAP_FMAC4 soap_in__tds__GetHostnameResponse(struct soap *soap, const char *tag, _tds__GetHostnameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetHostnameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(_tds__GetHostnameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetHostnameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetHostnameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_HostnameInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HostnameInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", &a->_tds__GetHostnameResponse::HostnameInformation, "tt:HostnameInformation"))
				{	soap_flag_HostnameInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:HostnameInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetHostnameResponse::HostnameInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostnameResponse, SOAP_TYPE__tds__GetHostnameResponse, sizeof(_tds__GetHostnameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__GetHostnameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetHostnameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetHostnameResponse *p;
	size_t k = sizeof(_tds__GetHostnameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetHostnameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetHostnameResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetHostnameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetHostnameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetHostnameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetHostnameResponse(soap, tag ? tag : "tds:GetHostnameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetHostnameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetHostnameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetHostnameResponse * SOAP_FMAC4 soap_get__tds__GetHostnameResponse(struct soap *soap, _tds__GetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetHostname::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetHostname::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetHostname::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetHostname(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostname(struct soap *soap, const char *tag, int id, const _tds__GetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostname), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetHostname::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetHostname(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetHostname * SOAP_FMAC4 soap_in__tds__GetHostname(struct soap *soap, const char *tag, _tds__GetHostname *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetHostname*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostname, sizeof(_tds__GetHostname), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetHostname)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetHostname *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostname, SOAP_TYPE__tds__GetHostname, sizeof(_tds__GetHostname), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetHostname * SOAP_FMAC2 soap_instantiate__tds__GetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetHostname(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetHostname *p;
	size_t k = sizeof(_tds__GetHostname);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetHostname, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetHostname);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetHostname, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetHostname location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetHostname::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetHostname(soap, tag ? tag : "tds:GetHostname", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetHostname::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetHostname(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetHostname * SOAP_FMAC4 soap_get__tds__GetHostname(struct soap *soap, _tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetCapabilitiesResponse::Capabilities = NULL;
}

void _tds__GetCapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Capabilities(soap, &this->_tds__GetCapabilitiesResponse::Capabilities);
#endif
}

int _tds__GetCapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tds__GetCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->_tds__GetCapabilitiesResponse::Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Capabilities(soap, "tds:Capabilities", -1, &a->_tds__GetCapabilitiesResponse::Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetCapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(_tds__GetCapabilitiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCapabilitiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCapabilitiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Capabilities(soap, "tds:Capabilities", &a->_tds__GetCapabilitiesResponse::Capabilities, "tt:Capabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetCapabilitiesResponse::Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilitiesResponse, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(_tds__GetCapabilitiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCapabilitiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCapabilitiesResponse *p;
	size_t k = sizeof(_tds__GetCapabilitiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCapabilitiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCapabilitiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCapabilitiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCapabilitiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCapabilitiesResponse(soap, tag ? tag : "tds:GetCapabilitiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetCapabilitiesResponse(struct soap *soap, _tds__GetCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__CapabilityCategory(soap, &this->_tds__GetCapabilities::Category);
}

void _tds__GetCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__CapabilityCategory(soap, &this->_tds__GetCapabilities::Category);
#endif
}

int _tds__GetCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilities(struct soap *soap, const char *tag, int id, const _tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilities), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__CapabilityCategory(soap, "tds:Category", -1, &a->_tds__GetCapabilities::Category, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCapabilities * SOAP_FMAC4 soap_in__tds__GetCapabilities(struct soap *soap, const char *tag, _tds__GetCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilities, sizeof(_tds__GetCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__CapabilityCategory(soap, "tds:Category", &a->_tds__GetCapabilities::Category, "tt:CapabilityCategory"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilities, SOAP_TYPE__tds__GetCapabilities, sizeof(_tds__GetCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCapabilities *p;
	size_t k = sizeof(_tds__GetCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCapabilities(soap, tag ? tag : "tds:GetCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCapabilities * SOAP_FMAC4 soap_get__tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetWsdlUrlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_tds__GetWsdlUrlResponse::WsdlUrl);
}

void _tds__GetWsdlUrlResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetWsdlUrlResponse::WsdlUrl, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->_tds__GetWsdlUrlResponse::WsdlUrl);
#endif
}

int _tds__GetWsdlUrlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetWsdlUrlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, int id, const _tds__GetWsdlUrlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrlResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:WsdlUrl");
	if (soap_out_xsd__anyURI(soap, "tds:WsdlUrl", -1, &a->_tds__GetWsdlUrlResponse::WsdlUrl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetWsdlUrlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetWsdlUrlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_in__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, _tds__GetWsdlUrlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetWsdlUrlResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(_tds__GetWsdlUrlResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetWsdlUrlResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetWsdlUrlResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_WsdlUrl1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WsdlUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:WsdlUrl", &a->_tds__GetWsdlUrlResponse::WsdlUrl, "xsd:anyURI"))
				{	soap_flag_WsdlUrl1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:WsdlUrl");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_WsdlUrl1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetWsdlUrlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrlResponse, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(_tds__GetWsdlUrlResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetWsdlUrlResponse * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetWsdlUrlResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetWsdlUrlResponse *p;
	size_t k = sizeof(_tds__GetWsdlUrlResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetWsdlUrlResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetWsdlUrlResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetWsdlUrlResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetWsdlUrlResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetWsdlUrlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetWsdlUrlResponse(soap, tag ? tag : "tds:GetWsdlUrlResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetWsdlUrlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetWsdlUrlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_get__tds__GetWsdlUrlResponse(struct soap *soap, _tds__GetWsdlUrlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.cpp */
