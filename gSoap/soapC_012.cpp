/* soapC_nnn.cpp
   Generated by gSOAP 2.8.78 for WS/onvifFull.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.cpp ver 2.8.78 2019-03-11 21:45:01 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, std::vector<_wstop__TopicNamespaceType_Topic> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const std::vector<_wstop__TopicNamespaceType_Topic> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_wstop__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const std::vector<_wstop__TopicNamespaceType_Topic> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_wstop__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_wstop__TopicNamespaceType_Topic> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, std::vector<_wstop__TopicNamespaceType_Topic> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_wstop__TopicNamespaceType_Topic));
		}
		else
		{	a->emplace_back();
		}
		_wstop__TopicNamespaceType_Topic *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__wstop__TopicNamespaceType_Topic, SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic, sizeof(_wstop__TopicNamespaceType_Topic), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__wstop__TopicNamespaceType_Topic(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__wstop__TopicNamespaceType_Topic(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_wstop__TopicNamespaceType_Topic>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_wstop__TopicNamespaceType_Topic> *p;
	size_t k = sizeof(std::vector<_wstop__TopicNamespaceType_Topic> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_wstop__TopicNamespaceType_Topic> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_wstop__TopicNamespaceType_Topic> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_wstop__TopicNamespaceType_Topic>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, std::vector<wstop__TopicType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const std::vector<wstop__TopicType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wstop__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowstop__TopicType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const char *tag, int id, const std::vector<wstop__TopicType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wstop__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowstop__TopicType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wstop__TopicType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const char *tag, std::vector<wstop__TopicType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowstop__TopicType(soap)))
			return NULL;
		a->emplace_back();
		wstop__TopicType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_wstop__TopicType, SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType, sizeof(wstop__TopicType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTowstop__TopicType(soap, tag, NULL, "wstop:TopicType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowstop__TopicType(soap, tag, n, "wstop:TopicType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wstop__TopicType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wstop__TopicType *> *p;
	size_t k = sizeof(std::vector<wstop__TopicType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wstop__TopicType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wstop__TopicType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wstop__TopicType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__QName(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		std::string soap_tmp(soap_QName2s(soap, (*i).c_str()));
		if (soap_out_xsd__QName(soap, tag, id, &soap_tmp, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_xsd__QName(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__QName, SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__QName(soap, tag, NULL, "xsd:QName"))
				break;
		}
		else
		{	if (!soap_in_xsd__QName(soap, tag, n, "xsd:QName"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsd__ProbeMatchType(struct soap *soap, std::vector<wsd__ProbeMatchType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsd__ProbeMatchType(struct soap *soap, const std::vector<wsd__ProbeMatchType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsd__ProbeMatchType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsd__ProbeMatchType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsd__ProbeMatchType(struct soap *soap, const char *tag, int id, const std::vector<wsd__ProbeMatchType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsd__ProbeMatchType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsd__ProbeMatchType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsd__ProbeMatchType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsd__ProbeMatchType(struct soap *soap, const char *tag, std::vector<wsd__ProbeMatchType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsd__ProbeMatchType(soap)))
			return NULL;
		a->emplace_back();
		wsd__ProbeMatchType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_wsd__ProbeMatchType, SOAP_TYPE_std__vectorTemplateOfPointerTowsd__ProbeMatchType, sizeof(wsd__ProbeMatchType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTowsd__ProbeMatchType(soap, tag, NULL, "wsd:ProbeMatchType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowsd__ProbeMatchType(soap, tag, n, "wsd:ProbeMatchType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsd__ProbeMatchType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowsd__ProbeMatchType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowsd__ProbeMatchType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsd__ProbeMatchType *> *p;
	size_t k = sizeof(std::vector<wsd__ProbeMatchType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowsd__ProbeMatchType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wsd__ProbeMatchType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wsd__ProbeMatchType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsd__ProbeMatchType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, std::vector<_wsrfbf__BaseFaultType_Description> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const std::vector<_wsrfbf__BaseFaultType_Description> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const std::vector<_wsrfbf__BaseFaultType_Description> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_wsrfbf__BaseFaultType_Description> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, std::vector<_wsrfbf__BaseFaultType_Description> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_wsrfbf__BaseFaultType_Description));
		}
		else
		{	a->emplace_back();
		}
		_wsrfbf__BaseFaultType_Description *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__wsrfbf__BaseFaultType_Description, SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description, sizeof(_wsrfbf__BaseFaultType_Description), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__wsrfbf__BaseFaultType_Description(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__wsrfbf__BaseFaultType_Description(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_wsrfbf__BaseFaultType_Description>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_wsrfbf__BaseFaultType_Description> *p;
	size_t k = sizeof(std::vector<_wsrfbf__BaseFaultType_Description> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_wsrfbf__BaseFaultType_Description> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_wsrfbf__BaseFaultType_Description> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_wsrfbf__BaseFaultType_Description>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, std::vector<wsnt__NotificationMessageHolderType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const std::vector<wsnt__NotificationMessageHolderType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsnt__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const std::vector<wsnt__NotificationMessageHolderType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsnt__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsnt__NotificationMessageHolderType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, std::vector<wsnt__NotificationMessageHolderType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap)))
			return NULL;
		a->emplace_back();
		wsnt__NotificationMessageHolderType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, NULL, "wsnt:NotificationMessageHolderType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, n, "wsnt:NotificationMessageHolderType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsnt__NotificationMessageHolderType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsnt__NotificationMessageHolderType *> *p;
	size_t k = sizeof(std::vector<wsnt__NotificationMessageHolderType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wsnt__NotificationMessageHolderType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wsnt__NotificationMessageHolderType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsnt__NotificationMessageHolderType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom(struct soap *soap, std::vector<wsnt__TopicExpressionTypeCustom> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom(struct soap *soap, const std::vector<wsnt__TopicExpressionTypeCustom> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsnt__TopicExpressionTypeCustom> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom(struct soap *soap, const char *tag, int id, const std::vector<wsnt__TopicExpressionTypeCustom> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsnt__TopicExpressionTypeCustom> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsnt__TopicExpressionTypeCustom> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom(struct soap *soap, const char *tag, std::vector<wsnt__TopicExpressionTypeCustom> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(wsnt__TopicExpressionTypeCustom));
		}
		else
		{	a->emplace_back();
		}
		wsnt__TopicExpressionTypeCustom *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_wsnt__TopicExpressionTypeCustom, SOAP_TYPE_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom, sizeof(wsnt__TopicExpressionTypeCustom), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_wsnt__TopicExpressionTypeCustom(soap, tag, NULL, "wsnt:TopicExpressionTypeCustom"))
				break;
		}
		else
		{	if (!soap_in_wsnt__TopicExpressionTypeCustom(soap, tag, n, "wsnt:TopicExpressionTypeCustom"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsnt__TopicExpressionTypeCustom>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsnt__TopicExpressionTypeCustom> *p;
	size_t k = sizeof(std::vector<wsnt__TopicExpressionTypeCustom> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfwsnt__TopicExpressionTypeCustom, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wsnt__TopicExpressionTypeCustom> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wsnt__TopicExpressionTypeCustom> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsnt__TopicExpressionTypeCustom>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__FileProgress(struct soap *soap, std::vector<tt__FileProgress *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__FileProgress(struct soap *soap, const std::vector<tt__FileProgress *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__FileProgress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__FileProgress(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__FileProgress(struct soap *soap, const char *tag, int id, const std::vector<tt__FileProgress *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__FileProgress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__FileProgress(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__FileProgress *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__FileProgress(struct soap *soap, const char *tag, std::vector<tt__FileProgress *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__FileProgress(soap)))
			return NULL;
		a->emplace_back();
		tt__FileProgress * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__FileProgress, SOAP_TYPE_std__vectorTemplateOfPointerTott__FileProgress, sizeof(tt__FileProgress), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__FileProgress(soap, tag, NULL, "tt:FileProgress"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__FileProgress(soap, tag, n, "tt:FileProgress"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__FileProgress *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__FileProgress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__FileProgress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__FileProgress *> *p;
	size_t k = sizeof(std::vector<tt__FileProgress *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__FileProgress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__FileProgress *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__FileProgress *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__FileProgress *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__OSDType(struct soap *soap, std::vector<tt__OSDType> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__OSDType(struct soap *soap, const std::vector<tt__OSDType> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__OSDType(struct soap *soap, const char *tag, int id, const std::vector<tt__OSDType> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__OSDType> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__OSDType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__OSDType> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__OSDType(struct soap *soap, const char *tag, std::vector<tt__OSDType> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__OSDType(soap)))
			return NULL;
		a->emplace_back();
		tt__OSDType *n = &a->back();
		soap_default_tt__OSDType(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__OSDType, SOAP_TYPE_std__vectorTemplateOftt__OSDType, sizeof(tt__OSDType), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__OSDType(soap, tag, NULL, "tt:OSDType"))
				break;
		}
		else
		{	if (!soap_in_tt__OSDType(soap, tag, n, "tt:OSDType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__OSDType>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__OSDType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__OSDType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__OSDType> *p;
	size_t k = sizeof(std::vector<tt__OSDType> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__OSDType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__OSDType> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__OSDType> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__OSDType>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, std::vector<tt__ColorspaceRange *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const std::vector<tt__ColorspaceRange *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__ColorspaceRange *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__ColorspaceRange(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const char *tag, int id, const std::vector<tt__ColorspaceRange *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ColorspaceRange *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__ColorspaceRange(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ColorspaceRange *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const char *tag, std::vector<tt__ColorspaceRange *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__ColorspaceRange(soap)))
			return NULL;
		a->emplace_back();
		tt__ColorspaceRange * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ColorspaceRange, SOAP_TYPE_std__vectorTemplateOfPointerTott__ColorspaceRange, sizeof(tt__ColorspaceRange), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__ColorspaceRange(soap, tag, NULL, "tt:ColorspaceRange"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__ColorspaceRange(soap, tag, n, "tt:ColorspaceRange"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ColorspaceRange *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__ColorspaceRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ColorspaceRange *> *p;
	size_t k = sizeof(std::vector<tt__ColorspaceRange *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__ColorspaceRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ColorspaceRange *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ColorspaceRange *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ColorspaceRange *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Color(struct soap *soap, std::vector<tt__Color *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Color(struct soap *soap, const std::vector<tt__Color *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Color *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Color(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Color(struct soap *soap, const char *tag, int id, const std::vector<tt__Color *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Color *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Color(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Color *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Color(struct soap *soap, const char *tag, std::vector<tt__Color *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Color(soap)))
			return NULL;
		a->emplace_back();
		tt__Color * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Color, SOAP_TYPE_std__vectorTemplateOfPointerTott__Color, sizeof(tt__Color), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Color(soap, tag, NULL, "tt:Color"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Color(soap, tag, n, "tt:Color"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Color *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Color(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Color(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Color *> *p;
	size_t k = sizeof(std::vector<tt__Color *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Color, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Color *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Color *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Color *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__ActiveConnection(struct soap *soap, std::vector<tt__ActiveConnection *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__ActiveConnection(struct soap *soap, const std::vector<tt__ActiveConnection *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__ActiveConnection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__ActiveConnection(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__ActiveConnection(struct soap *soap, const char *tag, int id, const std::vector<tt__ActiveConnection *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ActiveConnection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__ActiveConnection(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ActiveConnection *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__ActiveConnection(struct soap *soap, const char *tag, std::vector<tt__ActiveConnection *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__ActiveConnection(soap)))
			return NULL;
		a->emplace_back();
		tt__ActiveConnection * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ActiveConnection, SOAP_TYPE_std__vectorTemplateOfPointerTott__ActiveConnection, sizeof(tt__ActiveConnection), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__ActiveConnection(soap, tag, NULL, "tt:ActiveConnection"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__ActiveConnection(soap, tag, n, "tt:ActiveConnection"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ActiveConnection *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__ActiveConnection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__ActiveConnection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ActiveConnection *> *p;
	size_t k = sizeof(std::vector<tt__ActiveConnection *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__ActiveConnection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ActiveConnection *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ActiveConnection *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ActiveConnection *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioClassCandidate(struct soap *soap, std::vector<tt__AudioClassCandidate *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioClassCandidate(struct soap *soap, const std::vector<tt__AudioClassCandidate *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioClassCandidate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioClassCandidate(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioClassCandidate(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioClassCandidate *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioClassCandidate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioClassCandidate(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioClassCandidate *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioClassCandidate(struct soap *soap, const char *tag, std::vector<tt__AudioClassCandidate *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioClassCandidate(soap)))
			return NULL;
		a->emplace_back();
		tt__AudioClassCandidate * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AudioClassCandidate, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioClassCandidate, sizeof(tt__AudioClassCandidate), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioClassCandidate(soap, tag, NULL, "tt:AudioClassCandidate"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioClassCandidate(soap, tag, n, "tt:AudioClassCandidate"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioClassCandidate *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioClassCandidate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioClassCandidate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioClassCandidate *> *p;
	size_t k = sizeof(std::vector<tt__AudioClassCandidate *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioClassCandidate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioClassCandidate *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioClassCandidate *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioClassCandidate *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__EngineConfiguration(struct soap *soap, std::vector<tt__EngineConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__EngineConfiguration(struct soap *soap, const std::vector<tt__EngineConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__EngineConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__EngineConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__EngineConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__EngineConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__EngineConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__EngineConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__EngineConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__EngineConfiguration(struct soap *soap, const char *tag, std::vector<tt__EngineConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__EngineConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__EngineConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__EngineConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__EngineConfiguration, sizeof(tt__EngineConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__EngineConfiguration(soap, tag, NULL, "tt:EngineConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__EngineConfiguration(soap, tag, n, "tt:EngineConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__EngineConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__EngineConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__EngineConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__EngineConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__EngineConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__EngineConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__EngineConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__EngineConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__EngineConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(struct soap *soap, std::vector<tt__RecordingJobStateTrack *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(struct soap *soap, const std::vector<tt__RecordingJobStateTrack *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RecordingJobStateTrack *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RecordingJobStateTrack(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, int id, const std::vector<tt__RecordingJobStateTrack *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RecordingJobStateTrack *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RecordingJobStateTrack(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RecordingJobStateTrack *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, std::vector<tt__RecordingJobStateTrack *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(soap)))
			return NULL;
		a->emplace_back();
		tt__RecordingJobStateTrack * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__RecordingJobStateTrack, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobStateTrack, sizeof(tt__RecordingJobStateTrack), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RecordingJobStateTrack(soap, tag, NULL, "tt:RecordingJobStateTrack"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RecordingJobStateTrack(soap, tag, n, "tt:RecordingJobStateTrack"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RecordingJobStateTrack *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RecordingJobStateTrack *> *p;
	size_t k = sizeof(std::vector<tt__RecordingJobStateTrack *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobStateTrack, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RecordingJobStateTrack *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RecordingJobStateTrack *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RecordingJobStateTrack *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RecordingJobStateSource(struct soap *soap, std::vector<tt__RecordingJobStateSource *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RecordingJobStateSource(struct soap *soap, const std::vector<tt__RecordingJobStateSource *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RecordingJobStateSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RecordingJobStateSource(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, int id, const std::vector<tt__RecordingJobStateSource *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RecordingJobStateSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RecordingJobStateSource(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RecordingJobStateSource *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, std::vector<tt__RecordingJobStateSource *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RecordingJobStateSource(soap)))
			return NULL;
		a->emplace_back();
		tt__RecordingJobStateSource * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__RecordingJobStateSource, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobStateSource, sizeof(tt__RecordingJobStateSource), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RecordingJobStateSource(soap, tag, NULL, "tt:RecordingJobStateSource"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RecordingJobStateSource(soap, tag, n, "tt:RecordingJobStateSource"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RecordingJobStateSource *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobStateSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobStateSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RecordingJobStateSource *> *p;
	size_t k = sizeof(std::vector<tt__RecordingJobStateSource *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobStateSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RecordingJobStateSource *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RecordingJobStateSource *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RecordingJobStateSource *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RecordingJobTrack(struct soap *soap, std::vector<tt__RecordingJobTrack *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RecordingJobTrack(struct soap *soap, const std::vector<tt__RecordingJobTrack *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RecordingJobTrack *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RecordingJobTrack(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RecordingJobTrack(struct soap *soap, const char *tag, int id, const std::vector<tt__RecordingJobTrack *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RecordingJobTrack *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RecordingJobTrack(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RecordingJobTrack *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RecordingJobTrack(struct soap *soap, const char *tag, std::vector<tt__RecordingJobTrack *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RecordingJobTrack(soap)))
			return NULL;
		a->emplace_back();
		tt__RecordingJobTrack * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__RecordingJobTrack, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobTrack, sizeof(tt__RecordingJobTrack), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RecordingJobTrack(soap, tag, NULL, "tt:RecordingJobTrack"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RecordingJobTrack(soap, tag, n, "tt:RecordingJobTrack"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RecordingJobTrack *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobTrack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobTrack(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RecordingJobTrack *> *p;
	size_t k = sizeof(std::vector<tt__RecordingJobTrack *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobTrack, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RecordingJobTrack *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RecordingJobTrack *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RecordingJobTrack *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RecordingJobSource(struct soap *soap, std::vector<tt__RecordingJobSource *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RecordingJobSource(struct soap *soap, const std::vector<tt__RecordingJobSource *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RecordingJobSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RecordingJobSource(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RecordingJobSource(struct soap *soap, const char *tag, int id, const std::vector<tt__RecordingJobSource *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RecordingJobSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RecordingJobSource(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RecordingJobSource *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RecordingJobSource(struct soap *soap, const char *tag, std::vector<tt__RecordingJobSource *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RecordingJobSource(soap)))
			return NULL;
		a->emplace_back();
		tt__RecordingJobSource * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__RecordingJobSource, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobSource, sizeof(tt__RecordingJobSource), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RecordingJobSource(soap, tag, NULL, "tt:RecordingJobSource"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RecordingJobSource(soap, tag, n, "tt:RecordingJobSource"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RecordingJobSource *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RecordingJobSource *> *p;
	size_t k = sizeof(std::vector<tt__RecordingJobSource *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RecordingJobSource *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RecordingJobSource *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RecordingJobSource *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__GetTracksResponseItem(struct soap *soap, std::vector<tt__GetTracksResponseItem *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__GetTracksResponseItem(struct soap *soap, const std::vector<tt__GetTracksResponseItem *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__GetTracksResponseItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__GetTracksResponseItem(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, int id, const std::vector<tt__GetTracksResponseItem *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__GetTracksResponseItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__GetTracksResponseItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__GetTracksResponseItem *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, std::vector<tt__GetTracksResponseItem *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__GetTracksResponseItem(soap)))
			return NULL;
		a->emplace_back();
		tt__GetTracksResponseItem * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__GetTracksResponseItem, SOAP_TYPE_std__vectorTemplateOfPointerTott__GetTracksResponseItem, sizeof(tt__GetTracksResponseItem), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__GetTracksResponseItem(soap, tag, NULL, "tt:GetTracksResponseItem"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__GetTracksResponseItem(soap, tag, n, "tt:GetTracksResponseItem"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__GetTracksResponseItem *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__GetTracksResponseItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__GetTracksResponseItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__GetTracksResponseItem *> *p;
	size_t k = sizeof(std::vector<tt__GetTracksResponseItem *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__GetTracksResponseItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__GetTracksResponseItem *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__GetTracksResponseItem *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__GetTracksResponseItem *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__TrackAttributes(struct soap *soap, std::vector<tt__TrackAttributes *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__TrackAttributes(struct soap *soap, const std::vector<tt__TrackAttributes *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__TrackAttributes *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__TrackAttributes(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__TrackAttributes(struct soap *soap, const char *tag, int id, const std::vector<tt__TrackAttributes *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__TrackAttributes *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__TrackAttributes(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__TrackAttributes *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__TrackAttributes(struct soap *soap, const char *tag, std::vector<tt__TrackAttributes *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__TrackAttributes(soap)))
			return NULL;
		a->emplace_back();
		tt__TrackAttributes * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__TrackAttributes, SOAP_TYPE_std__vectorTemplateOfPointerTott__TrackAttributes, sizeof(tt__TrackAttributes), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__TrackAttributes(soap, tag, NULL, "tt:TrackAttributes"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__TrackAttributes(soap, tag, n, "tt:TrackAttributes"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__TrackAttributes *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__TrackAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__TrackAttributes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__TrackAttributes *> *p;
	size_t k = sizeof(std::vector<tt__TrackAttributes *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__TrackAttributes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__TrackAttributes *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__TrackAttributes *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__TrackAttributes *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__TrackInformation(struct soap *soap, std::vector<tt__TrackInformation *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__TrackInformation(struct soap *soap, const std::vector<tt__TrackInformation *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__TrackInformation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__TrackInformation(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__TrackInformation(struct soap *soap, const char *tag, int id, const std::vector<tt__TrackInformation *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__TrackInformation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__TrackInformation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__TrackInformation *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__TrackInformation(struct soap *soap, const char *tag, std::vector<tt__TrackInformation *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__TrackInformation(soap)))
			return NULL;
		a->emplace_back();
		tt__TrackInformation * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__TrackInformation, SOAP_TYPE_std__vectorTemplateOfPointerTott__TrackInformation, sizeof(tt__TrackInformation), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__TrackInformation(soap, tag, NULL, "tt:TrackInformation"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__TrackInformation(soap, tag, n, "tt:TrackInformation"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__TrackInformation *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__TrackInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__TrackInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__TrackInformation *> *p;
	size_t k = sizeof(std::vector<tt__TrackInformation *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__TrackInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__TrackInformation *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__TrackInformation *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__TrackInformation *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__FindMetadataResult(struct soap *soap, std::vector<tt__FindMetadataResult *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__FindMetadataResult(struct soap *soap, const std::vector<tt__FindMetadataResult *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__FindMetadataResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__FindMetadataResult(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__FindMetadataResult(struct soap *soap, const char *tag, int id, const std::vector<tt__FindMetadataResult *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__FindMetadataResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__FindMetadataResult(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__FindMetadataResult *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__FindMetadataResult(struct soap *soap, const char *tag, std::vector<tt__FindMetadataResult *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__FindMetadataResult(soap)))
			return NULL;
		a->emplace_back();
		tt__FindMetadataResult * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__FindMetadataResult, SOAP_TYPE_std__vectorTemplateOfPointerTott__FindMetadataResult, sizeof(tt__FindMetadataResult), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__FindMetadataResult(soap, tag, NULL, "tt:FindMetadataResult"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__FindMetadataResult(soap, tag, n, "tt:FindMetadataResult"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__FindMetadataResult *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__FindMetadataResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__FindMetadataResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__FindMetadataResult *> *p;
	size_t k = sizeof(std::vector<tt__FindMetadataResult *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__FindMetadataResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__FindMetadataResult *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__FindMetadataResult *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__FindMetadataResult *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__FindPTZPositionResult(struct soap *soap, std::vector<tt__FindPTZPositionResult *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__FindPTZPositionResult(struct soap *soap, const std::vector<tt__FindPTZPositionResult *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__FindPTZPositionResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__FindPTZPositionResult(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, int id, const std::vector<tt__FindPTZPositionResult *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__FindPTZPositionResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__FindPTZPositionResult(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__FindPTZPositionResult *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, std::vector<tt__FindPTZPositionResult *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__FindPTZPositionResult(soap)))
			return NULL;
		a->emplace_back();
		tt__FindPTZPositionResult * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__FindPTZPositionResult, SOAP_TYPE_std__vectorTemplateOfPointerTott__FindPTZPositionResult, sizeof(tt__FindPTZPositionResult), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__FindPTZPositionResult(soap, tag, NULL, "tt:FindPTZPositionResult"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__FindPTZPositionResult(soap, tag, n, "tt:FindPTZPositionResult"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__FindPTZPositionResult *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__FindPTZPositionResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__FindPTZPositionResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__FindPTZPositionResult *> *p;
	size_t k = sizeof(std::vector<tt__FindPTZPositionResult *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__FindPTZPositionResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__FindPTZPositionResult *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__FindPTZPositionResult *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__FindPTZPositionResult *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__FindEventResult(struct soap *soap, std::vector<tt__FindEventResult *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__FindEventResult(struct soap *soap, const std::vector<tt__FindEventResult *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__FindEventResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__FindEventResult(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__FindEventResult(struct soap *soap, const char *tag, int id, const std::vector<tt__FindEventResult *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__FindEventResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__FindEventResult(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__FindEventResult *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__FindEventResult(struct soap *soap, const char *tag, std::vector<tt__FindEventResult *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__FindEventResult(soap)))
			return NULL;
		a->emplace_back();
		tt__FindEventResult * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__FindEventResult, SOAP_TYPE_std__vectorTemplateOfPointerTott__FindEventResult, sizeof(tt__FindEventResult), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__FindEventResult(soap, tag, NULL, "tt:FindEventResult"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__FindEventResult(soap, tag, n, "tt:FindEventResult"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__FindEventResult *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__FindEventResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__FindEventResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__FindEventResult *> *p;
	size_t k = sizeof(std::vector<tt__FindEventResult *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__FindEventResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__FindEventResult *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__FindEventResult *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__FindEventResult *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RecordingInformation(struct soap *soap, std::vector<tt__RecordingInformation *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RecordingInformation(struct soap *soap, const std::vector<tt__RecordingInformation *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RecordingInformation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RecordingInformation(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RecordingInformation(struct soap *soap, const char *tag, int id, const std::vector<tt__RecordingInformation *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RecordingInformation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RecordingInformation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RecordingInformation *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RecordingInformation(struct soap *soap, const char *tag, std::vector<tt__RecordingInformation *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RecordingInformation(soap)))
			return NULL;
		a->emplace_back();
		tt__RecordingInformation * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__RecordingInformation, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingInformation, sizeof(tt__RecordingInformation), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RecordingInformation(soap, tag, NULL, "tt:RecordingInformation"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RecordingInformation(soap, tag, n, "tt:RecordingInformation"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RecordingInformation *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RecordingInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RecordingInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RecordingInformation *> *p;
	size_t k = sizeof(std::vector<tt__RecordingInformation *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RecordingInformation *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RecordingInformation *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RecordingInformation *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__RecordingReference(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__RecordingReference(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__RecordingReference(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__RecordingReference(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__RecordingReference(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__RecordingReference(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__RecordingReference(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_tt__RecordingReference(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__RecordingReference, SOAP_TYPE_std__vectorTemplateOftt__RecordingReference, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__RecordingReference(soap, tag, NULL, "tt:RecordingReference"))
				break;
		}
		else
		{	if (!soap_in_tt__RecordingReference(soap, tag, n, "tt:RecordingReference"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__RecordingReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__RecordingReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__RecordingReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__SourceReference(struct soap *soap, std::vector<tt__SourceReference *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__SourceReference(struct soap *soap, const std::vector<tt__SourceReference *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__SourceReference *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__SourceReference(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__SourceReference(struct soap *soap, const char *tag, int id, const std::vector<tt__SourceReference *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__SourceReference *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__SourceReference(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__SourceReference *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__SourceReference(struct soap *soap, const char *tag, std::vector<tt__SourceReference *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__SourceReference(soap)))
			return NULL;
		a->emplace_back();
		tt__SourceReference * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__SourceReference, SOAP_TYPE_std__vectorTemplateOfPointerTott__SourceReference, sizeof(tt__SourceReference), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__SourceReference(soap, tag, NULL, "tt:SourceReference"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__SourceReference(soap, tag, n, "tt:SourceReference"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__SourceReference *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__SourceReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__SourceReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__SourceReference *> *p;
	size_t k = sizeof(std::vector<tt__SourceReference *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__SourceReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__SourceReference *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__SourceReference *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__SourceReference *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Rectangle(struct soap *soap, std::vector<tt__Rectangle *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Rectangle(struct soap *soap, const std::vector<tt__Rectangle *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Rectangle *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Rectangle(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Rectangle(struct soap *soap, const char *tag, int id, const std::vector<tt__Rectangle *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Rectangle *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Rectangle(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Rectangle *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Rectangle(struct soap *soap, const char *tag, std::vector<tt__Rectangle *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Rectangle(soap)))
			return NULL;
		a->emplace_back();
		tt__Rectangle * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Rectangle, SOAP_TYPE_std__vectorTemplateOfPointerTott__Rectangle, sizeof(tt__Rectangle), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Rectangle(soap, tag, NULL, "tt:Rectangle"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Rectangle(soap, tag, n, "tt:Rectangle"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Rectangle *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Rectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Rectangle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Rectangle *> *p;
	size_t k = sizeof(std::vector<tt__Rectangle *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Rectangle, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Rectangle *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Rectangle *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Rectangle *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PaneLayoutOptions(struct soap *soap, std::vector<tt__PaneLayoutOptions *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PaneLayoutOptions(struct soap *soap, const std::vector<tt__PaneLayoutOptions *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PaneLayoutOptions *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PaneLayoutOptions(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PaneLayoutOptions(struct soap *soap, const char *tag, int id, const std::vector<tt__PaneLayoutOptions *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PaneLayoutOptions *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PaneLayoutOptions(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PaneLayoutOptions *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PaneLayoutOptions(struct soap *soap, const char *tag, std::vector<tt__PaneLayoutOptions *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PaneLayoutOptions(soap)))
			return NULL;
		a->emplace_back();
		tt__PaneLayoutOptions * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__PaneLayoutOptions, SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayoutOptions, sizeof(tt__PaneLayoutOptions), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PaneLayoutOptions(soap, tag, NULL, "tt:PaneLayoutOptions"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PaneLayoutOptions(soap, tag, n, "tt:PaneLayoutOptions"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PaneLayoutOptions *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PaneLayoutOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PaneLayoutOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PaneLayoutOptions *> *p;
	size_t k = sizeof(std::vector<tt__PaneLayoutOptions *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayoutOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PaneLayoutOptions *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PaneLayoutOptions *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PaneLayoutOptions *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PaneLayout(struct soap *soap, std::vector<tt__PaneLayout *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PaneLayout(struct soap *soap, const std::vector<tt__PaneLayout *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PaneLayout *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PaneLayout(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PaneLayout(struct soap *soap, const char *tag, int id, const std::vector<tt__PaneLayout *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PaneLayout *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PaneLayout(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PaneLayout *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PaneLayout(struct soap *soap, const char *tag, std::vector<tt__PaneLayout *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PaneLayout(soap)))
			return NULL;
		a->emplace_back();
		tt__PaneLayout * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__PaneLayout, SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayout, sizeof(tt__PaneLayout), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PaneLayout(soap, tag, NULL, "tt:PaneLayout"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PaneLayout(soap, tag, n, "tt:PaneLayout"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PaneLayout *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PaneLayout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PaneLayout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PaneLayout *> *p;
	size_t k = sizeof(std::vector<tt__PaneLayout *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayout, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PaneLayout *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PaneLayout *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PaneLayout *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Polyline(struct soap *soap, std::vector<tt__Polyline *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Polyline(struct soap *soap, const std::vector<tt__Polyline *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Polyline *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Polyline(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Polyline(struct soap *soap, const char *tag, int id, const std::vector<tt__Polyline *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Polyline *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Polyline(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Polyline *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Polyline(struct soap *soap, const char *tag, std::vector<tt__Polyline *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Polyline(soap)))
			return NULL;
		a->emplace_back();
		tt__Polyline * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Polyline, SOAP_TYPE_std__vectorTemplateOfPointerTott__Polyline, sizeof(tt__Polyline), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Polyline(soap, tag, NULL, "tt:Polyline"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Polyline(soap, tag, n, "tt:Polyline"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Polyline *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Polyline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Polyline(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Polyline *> *p;
	size_t k = sizeof(std::vector<tt__Polyline *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Polyline, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Polyline *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Polyline *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Polyline *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, std::vector<tt__ConfigDescription *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, const std::vector<tt__ConfigDescription *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__ConfigDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__ConfigDescription(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__ConfigDescription *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ConfigDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__ConfigDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ConfigDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, const char *tag, std::vector<tt__ConfigDescription *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__ConfigDescription(soap)))
			return NULL;
		a->emplace_back();
		tt__ConfigDescription * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ConfigDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__ConfigDescription, sizeof(tt__ConfigDescription), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__ConfigDescription(soap, tag, NULL, "tt:ConfigDescription"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__ConfigDescription(soap, tag, n, "tt:ConfigDescription"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ConfigDescription *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__ConfigDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ConfigDescription *> *p;
	size_t k = sizeof(std::vector<tt__ConfigDescription *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__ConfigDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ConfigDescription *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ConfigDescription *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ConfigDescription *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ConfigDescription_Messages(struct soap *soap, std::vector<_tt__ConfigDescription_Messages> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ConfigDescription_Messages(struct soap *soap, const std::vector<_tt__ConfigDescription_Messages> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ConfigDescription_Messages> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ConfigDescription_Messages(struct soap *soap, const char *tag, int id, const std::vector<_tt__ConfigDescription_Messages> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ConfigDescription_Messages> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ConfigDescription_Messages> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ConfigDescription_Messages(struct soap *soap, const char *tag, std::vector<_tt__ConfigDescription_Messages> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ConfigDescription_Messages(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_tt__ConfigDescription_Messages));
		}
		else
		{	a->emplace_back();
		}
		_tt__ConfigDescription_Messages *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__tt__ConfigDescription_Messages, SOAP_TYPE_std__vectorTemplateOf_tt__ConfigDescription_Messages, sizeof(_tt__ConfigDescription_Messages), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ConfigDescription_Messages(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ConfigDescription_Messages(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ConfigDescription_Messages>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ConfigDescription_Messages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ConfigDescription_Messages(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ConfigDescription_Messages> *p;
	size_t k = sizeof(std::vector<_tt__ConfigDescription_Messages> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ConfigDescription_Messages, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ConfigDescription_Messages> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ConfigDescription_Messages> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ConfigDescription_Messages>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Config(struct soap *soap, std::vector<tt__Config *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const std::vector<tt__Config *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Config *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Config(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const char *tag, int id, const std::vector<tt__Config *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Config *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Config(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Config *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const char *tag, std::vector<tt__Config *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Config(soap)))
			return NULL;
		a->emplace_back();
		tt__Config * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Config, SOAP_TYPE_std__vectorTemplateOfPointerTott__Config, sizeof(tt__Config), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Config(soap, tag, NULL, "tt:Config"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Config(soap, tag, n, "tt:Config"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Config *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Config(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Config(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Config *> *p;
	size_t k = sizeof(std::vector<tt__Config *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Config, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Config *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Config *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Config *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, std::vector<tt__Vector *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const std::vector<tt__Vector *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Vector *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Vector(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const char *tag, int id, const std::vector<tt__Vector *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Vector *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Vector(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Vector *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const char *tag, std::vector<tt__Vector *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Vector(soap)))
			return NULL;
		a->emplace_back();
		tt__Vector * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Vector, SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector, sizeof(tt__Vector), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Vector(soap, tag, NULL, "tt:Vector"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Vector(soap, tag, n, "tt:Vector"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Vector *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Vector(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Vector *> *p;
	size_t k = sizeof(std::vector<tt__Vector *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Vector *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Vector *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Vector *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(struct soap *soap, std::vector<_tt__ItemListDescription_ElementItemDescription> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const std::vector<_tt__ItemListDescription_ElementItemDescription> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ItemListDescription_ElementItemDescription> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, const std::vector<_tt__ItemListDescription_ElementItemDescription> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ItemListDescription_ElementItemDescription> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ItemListDescription_ElementItemDescription> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, std::vector<_tt__ItemListDescription_ElementItemDescription> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_tt__ItemListDescription_ElementItemDescription));
		}
		else
		{	a->emplace_back();
		}
		_tt__ItemListDescription_ElementItemDescription *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, SOAP_TYPE_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription, sizeof(_tt__ItemListDescription_ElementItemDescription), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ItemListDescription_ElementItemDescription>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ItemListDescription_ElementItemDescription> *p;
	size_t k = sizeof(std::vector<_tt__ItemListDescription_ElementItemDescription> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ItemListDescription_ElementItemDescription> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ItemListDescription_ElementItemDescription> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ItemListDescription_ElementItemDescription>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, std::vector<_tt__ItemListDescription_SimpleItemDescription> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const std::vector<_tt__ItemListDescription_SimpleItemDescription> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ItemListDescription_SimpleItemDescription> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, const std::vector<_tt__ItemListDescription_SimpleItemDescription> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ItemListDescription_SimpleItemDescription> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ItemListDescription_SimpleItemDescription> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, std::vector<_tt__ItemListDescription_SimpleItemDescription> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_tt__ItemListDescription_SimpleItemDescription));
		}
		else
		{	a->emplace_back();
		}
		_tt__ItemListDescription_SimpleItemDescription *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, SOAP_TYPE_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription, sizeof(_tt__ItemListDescription_SimpleItemDescription), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ItemListDescription_SimpleItemDescription>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ItemListDescription_SimpleItemDescription> *p;
	size_t k = sizeof(std::vector<_tt__ItemListDescription_SimpleItemDescription> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ItemListDescription_SimpleItemDescription> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ItemListDescription_SimpleItemDescription> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ItemListDescription_SimpleItemDescription>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, std::vector<_tt__ItemList_ElementItem> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, const std::vector<_tt__ItemList_ElementItem> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ItemList_ElementItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, const std::vector<_tt__ItemList_ElementItem> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ItemList_ElementItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ItemList_ElementItem> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, const char *tag, std::vector<_tt__ItemList_ElementItem> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ItemList_ElementItem(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_tt__ItemList_ElementItem));
		}
		else
		{	a->emplace_back();
		}
		_tt__ItemList_ElementItem *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__tt__ItemList_ElementItem, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem, sizeof(_tt__ItemList_ElementItem), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ItemList_ElementItem(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ItemList_ElementItem(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ItemList_ElementItem>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ItemList_ElementItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ItemList_ElementItem> *p;
	size_t k = sizeof(std::vector<_tt__ItemList_ElementItem> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ItemList_ElementItem> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ItemList_ElementItem> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ItemList_ElementItem>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, std::vector<_tt__ItemList_SimpleItem> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, const std::vector<_tt__ItemList_SimpleItem> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ItemList_SimpleItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, const std::vector<_tt__ItemList_SimpleItem> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ItemList_SimpleItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ItemList_SimpleItem> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, std::vector<_tt__ItemList_SimpleItem> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_tt__ItemList_SimpleItem));
		}
		else
		{	a->emplace_back();
		}
		_tt__ItemList_SimpleItem *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__tt__ItemList_SimpleItem, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem, sizeof(_tt__ItemList_SimpleItem), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ItemList_SimpleItem(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ItemList_SimpleItem(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ItemList_SimpleItem>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ItemList_SimpleItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ItemList_SimpleItem> *p;
	size_t k = sizeof(std::vector<_tt__ItemList_SimpleItem> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ItemList_SimpleItem> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ItemList_SimpleItem> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ItemList_SimpleItem>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, std::vector<tt__BacklightCompensationMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const std::vector<tt__BacklightCompensationMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const char *tag, int id, const std::vector<tt__BacklightCompensationMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__BacklightCompensationMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__BacklightCompensationMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__BacklightCompensationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const char *tag, std::vector<tt__BacklightCompensationMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__BacklightCompensationMode(soap)))
			return NULL;
		a->emplace_back();
		tt__BacklightCompensationMode *n = &a->back();
		soap_default_tt__BacklightCompensationMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__BacklightCompensationMode, SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode, sizeof(tt__BacklightCompensationMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__BacklightCompensationMode(soap, tag, NULL, "tt:BacklightCompensationMode"))
				break;
		}
		else
		{	if (!soap_in_tt__BacklightCompensationMode(soap, tag, n, "tt:BacklightCompensationMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__BacklightCompensationMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__BacklightCompensationMode> *p;
	size_t k = sizeof(std::vector<tt__BacklightCompensationMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__BacklightCompensationMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__BacklightCompensationMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__BacklightCompensationMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, std::vector<tt__ImageStabilizationMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, const std::vector<tt__ImageStabilizationMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, const char *tag, int id, const std::vector<tt__ImageStabilizationMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ImageStabilizationMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ImageStabilizationMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ImageStabilizationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, const char *tag, std::vector<tt__ImageStabilizationMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ImageStabilizationMode(soap)))
			return NULL;
		a->emplace_back();
		tt__ImageStabilizationMode *n = &a->back();
		soap_default_tt__ImageStabilizationMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ImageStabilizationMode, SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode, sizeof(tt__ImageStabilizationMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ImageStabilizationMode(soap, tag, NULL, "tt:ImageStabilizationMode"))
				break;
		}
		else
		{	if (!soap_in_tt__ImageStabilizationMode(soap, tag, n, "tt:ImageStabilizationMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ImageStabilizationMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ImageStabilizationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ImageStabilizationMode> *p;
	size_t k = sizeof(std::vector<tt__ImageStabilizationMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ImageStabilizationMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ImageStabilizationMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ImageStabilizationMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, std::vector<tt__IrCutFilterAutoAdjustment *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const std::vector<tt__IrCutFilterAutoAdjustment *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__IrCutFilterAutoAdjustment *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__IrCutFilterAutoAdjustment(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, int id, const std::vector<tt__IrCutFilterAutoAdjustment *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__IrCutFilterAutoAdjustment *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__IrCutFilterAutoAdjustment(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__IrCutFilterAutoAdjustment *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, std::vector<tt__IrCutFilterAutoAdjustment *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap)))
			return NULL;
		a->emplace_back();
		tt__IrCutFilterAutoAdjustment * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment, sizeof(tt__IrCutFilterAutoAdjustment), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__IrCutFilterAutoAdjustment(soap, tag, NULL, "tt:IrCutFilterAutoAdjustment"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__IrCutFilterAutoAdjustment(soap, tag, n, "tt:IrCutFilterAutoAdjustment"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__IrCutFilterAutoAdjustment *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__IrCutFilterAutoAdjustment *> *p;
	size_t k = sizeof(std::vector<tt__IrCutFilterAutoAdjustment *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__IrCutFilterAutoAdjustment *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__IrCutFilterAutoAdjustment *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__IrCutFilterAutoAdjustment *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, std::vector<tt__WhiteBalanceMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const std::vector<tt__WhiteBalanceMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const char *tag, int id, const std::vector<tt__WhiteBalanceMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__WhiteBalanceMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__WhiteBalanceMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__WhiteBalanceMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const char *tag, std::vector<tt__WhiteBalanceMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__WhiteBalanceMode(soap)))
			return NULL;
		a->emplace_back();
		tt__WhiteBalanceMode *n = &a->back();
		soap_default_tt__WhiteBalanceMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__WhiteBalanceMode, SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode, sizeof(tt__WhiteBalanceMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__WhiteBalanceMode(soap, tag, NULL, "tt:WhiteBalanceMode"))
				break;
		}
		else
		{	if (!soap_in_tt__WhiteBalanceMode(soap, tag, n, "tt:WhiteBalanceMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__WhiteBalanceMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__WhiteBalanceMode> *p;
	size_t k = sizeof(std::vector<tt__WhiteBalanceMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__WhiteBalanceMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__WhiteBalanceMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__WhiteBalanceMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, std::vector<tt__ExposurePriority> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const std::vector<tt__ExposurePriority> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const char *tag, int id, const std::vector<tt__ExposurePriority> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ExposurePriority> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ExposurePriority(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ExposurePriority> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const char *tag, std::vector<tt__ExposurePriority> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ExposurePriority(soap)))
			return NULL;
		a->emplace_back();
		tt__ExposurePriority *n = &a->back();
		soap_default_tt__ExposurePriority(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ExposurePriority, SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority, sizeof(tt__ExposurePriority), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ExposurePriority(soap, tag, NULL, "tt:ExposurePriority"))
				break;
		}
		else
		{	if (!soap_in_tt__ExposurePriority(soap, tag, n, "tt:ExposurePriority"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ExposurePriority>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ExposurePriority(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ExposurePriority> *p;
	size_t k = sizeof(std::vector<tt__ExposurePriority> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ExposurePriority> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ExposurePriority> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ExposurePriority>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ExposureMode(struct soap *soap, std::vector<tt__ExposureMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const std::vector<tt__ExposureMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const char *tag, int id, const std::vector<tt__ExposureMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ExposureMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ExposureMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ExposureMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const char *tag, std::vector<tt__ExposureMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ExposureMode(soap)))
			return NULL;
		a->emplace_back();
		tt__ExposureMode *n = &a->back();
		soap_default_tt__ExposureMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ExposureMode, SOAP_TYPE_std__vectorTemplateOftt__ExposureMode, sizeof(tt__ExposureMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ExposureMode(soap, tag, NULL, "tt:ExposureMode"))
				break;
		}
		else
		{	if (!soap_in_tt__ExposureMode(soap, tag, n, "tt:ExposureMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ExposureMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ExposureMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ExposureMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ExposureMode> *p;
	size_t k = sizeof(std::vector<tt__ExposureMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ExposureMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ExposureMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ExposureMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ExposureMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, std::vector<tt__AutoFocusMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const std::vector<tt__AutoFocusMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const char *tag, int id, const std::vector<tt__AutoFocusMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AutoFocusMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__AutoFocusMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AutoFocusMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const char *tag, std::vector<tt__AutoFocusMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__AutoFocusMode(soap)))
			return NULL;
		a->emplace_back();
		tt__AutoFocusMode *n = &a->back();
		soap_default_tt__AutoFocusMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AutoFocusMode, SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode, sizeof(tt__AutoFocusMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__AutoFocusMode(soap, tag, NULL, "tt:AutoFocusMode"))
				break;
		}
		else
		{	if (!soap_in_tt__AutoFocusMode(soap, tag, n, "tt:AutoFocusMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AutoFocusMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__AutoFocusMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AutoFocusMode> *p;
	size_t k = sizeof(std::vector<tt__AutoFocusMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AutoFocusMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AutoFocusMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AutoFocusMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, std::vector<tt__WideDynamicMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const std::vector<tt__WideDynamicMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const char *tag, int id, const std::vector<tt__WideDynamicMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__WideDynamicMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__WideDynamicMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__WideDynamicMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const char *tag, std::vector<tt__WideDynamicMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__WideDynamicMode(soap)))
			return NULL;
		a->emplace_back();
		tt__WideDynamicMode *n = &a->back();
		soap_default_tt__WideDynamicMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__WideDynamicMode, SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode, sizeof(tt__WideDynamicMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__WideDynamicMode(soap, tag, NULL, "tt:WideDynamicMode"))
				break;
		}
		else
		{	if (!soap_in_tt__WideDynamicMode(soap, tag, n, "tt:WideDynamicMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__WideDynamicMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__WideDynamicMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__WideDynamicMode> *p;
	size_t k = sizeof(std::vector<tt__WideDynamicMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__WideDynamicMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__WideDynamicMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__WideDynamicMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, std::vector<tt__IrCutFilterMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const std::vector<tt__IrCutFilterMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const char *tag, int id, const std::vector<tt__IrCutFilterMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__IrCutFilterMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IrCutFilterMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__IrCutFilterMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const char *tag, std::vector<tt__IrCutFilterMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__IrCutFilterMode(soap)))
			return NULL;
		a->emplace_back();
		tt__IrCutFilterMode *n = &a->back();
		soap_default_tt__IrCutFilterMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__IrCutFilterMode, SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode, sizeof(tt__IrCutFilterMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__IrCutFilterMode(soap, tag, NULL, "tt:IrCutFilterMode"))
				break;
		}
		else
		{	if (!soap_in_tt__IrCutFilterMode(soap, tag, n, "tt:IrCutFilterMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__IrCutFilterMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IrCutFilterMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__IrCutFilterMode> *p;
	size_t k = sizeof(std::vector<tt__IrCutFilterMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__IrCutFilterMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__IrCutFilterMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__IrCutFilterMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, std::vector<tt__PTZPresetTourDirection> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, const std::vector<tt__PTZPresetTourDirection> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, const char *tag, int id, const std::vector<tt__PTZPresetTourDirection> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PTZPresetTourDirection> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__PTZPresetTourDirection(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PTZPresetTourDirection> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, const char *tag, std::vector<tt__PTZPresetTourDirection> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__PTZPresetTourDirection(soap)))
			return NULL;
		a->emplace_back();
		tt__PTZPresetTourDirection *n = &a->back();
		soap_default_tt__PTZPresetTourDirection(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__PTZPresetTourDirection, SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection, sizeof(tt__PTZPresetTourDirection), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__PTZPresetTourDirection(soap, tag, NULL, "tt:PTZPresetTourDirection"))
				break;
		}
		else
		{	if (!soap_in_tt__PTZPresetTourDirection(soap, tag, n, "tt:PTZPresetTourDirection"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PTZPresetTourDirection>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__PTZPresetTourDirection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PTZPresetTourDirection> *p;
	size_t k = sizeof(std::vector<tt__PTZPresetTourDirection> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PTZPresetTourDirection> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PTZPresetTourDirection> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PTZPresetTourDirection>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, std::vector<tt__PTZPresetTourSpot *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, const std::vector<tt__PTZPresetTourSpot *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PTZPresetTourSpot *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PTZPresetTourSpot(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, const char *tag, int id, const std::vector<tt__PTZPresetTourSpot *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PTZPresetTourSpot *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PTZPresetTourSpot(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PTZPresetTourSpot *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, const char *tag, std::vector<tt__PTZPresetTourSpot *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(soap)))
			return NULL;
		a->emplace_back();
		tt__PTZPresetTourSpot * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__PTZPresetTourSpot, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot, sizeof(tt__PTZPresetTourSpot), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PTZPresetTourSpot(soap, tag, NULL, "tt:PTZPresetTourSpot"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PTZPresetTourSpot(soap, tag, n, "tt:PTZPresetTourSpot"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PTZPresetTourSpot *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PTZPresetTourSpot *> *p;
	size_t k = sizeof(std::vector<tt__PTZPresetTourSpot *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PTZPresetTourSpot *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PTZPresetTourSpot *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PTZPresetTourSpot *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, std::vector<tt__Space1DDescription *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, const std::vector<tt__Space1DDescription *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Space1DDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Space1DDescription(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__Space1DDescription *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Space1DDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Space1DDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Space1DDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, const char *tag, std::vector<tt__Space1DDescription *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Space1DDescription(soap)))
			return NULL;
		a->emplace_back();
		tt__Space1DDescription * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Space1DDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription, sizeof(tt__Space1DDescription), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Space1DDescription(soap, tag, NULL, "tt:Space1DDescription"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Space1DDescription(soap, tag, n, "tt:Space1DDescription"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Space1DDescription *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Space1DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Space1DDescription *> *p;
	size_t k = sizeof(std::vector<tt__Space1DDescription *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Space1DDescription *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Space1DDescription *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Space1DDescription *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, std::vector<tt__Space2DDescription *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, const std::vector<tt__Space2DDescription *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Space2DDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Space2DDescription(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__Space2DDescription *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Space2DDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Space2DDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Space2DDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, const char *tag, std::vector<tt__Space2DDescription *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Space2DDescription(soap)))
			return NULL;
		a->emplace_back();
		tt__Space2DDescription * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Space2DDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription, sizeof(tt__Space2DDescription), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Space2DDescription(soap, tag, NULL, "tt:Space2DDescription"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Space2DDescription(soap, tag, n, "tt:Space2DDescription"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Space2DDescription *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Space2DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Space2DDescription *> *p;
	size_t k = sizeof(std::vector<tt__Space2DDescription *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Space2DDescription *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Space2DDescription *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Space2DDescription *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ReverseMode(struct soap *soap, std::vector<tt__ReverseMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ReverseMode(struct soap *soap, const std::vector<tt__ReverseMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ReverseMode(struct soap *soap, const char *tag, int id, const std::vector<tt__ReverseMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ReverseMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ReverseMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ReverseMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ReverseMode(struct soap *soap, const char *tag, std::vector<tt__ReverseMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ReverseMode(soap)))
			return NULL;
		a->emplace_back();
		tt__ReverseMode *n = &a->back();
		soap_default_tt__ReverseMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ReverseMode, SOAP_TYPE_std__vectorTemplateOftt__ReverseMode, sizeof(tt__ReverseMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ReverseMode(soap, tag, NULL, "tt:ReverseMode"))
				break;
		}
		else
		{	if (!soap_in_tt__ReverseMode(soap, tag, n, "tt:ReverseMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ReverseMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ReverseMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ReverseMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ReverseMode> *p;
	size_t k = sizeof(std::vector<tt__ReverseMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ReverseMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ReverseMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ReverseMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ReverseMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__EFlipMode(struct soap *soap, std::vector<tt__EFlipMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__EFlipMode(struct soap *soap, const std::vector<tt__EFlipMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__EFlipMode(struct soap *soap, const char *tag, int id, const std::vector<tt__EFlipMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__EFlipMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__EFlipMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__EFlipMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__EFlipMode(struct soap *soap, const char *tag, std::vector<tt__EFlipMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__EFlipMode(soap)))
			return NULL;
		a->emplace_back();
		tt__EFlipMode *n = &a->back();
		soap_default_tt__EFlipMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__EFlipMode, SOAP_TYPE_std__vectorTemplateOftt__EFlipMode, sizeof(tt__EFlipMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__EFlipMode(soap, tag, NULL, "tt:EFlipMode"))
				break;
		}
		else
		{	if (!soap_in_tt__EFlipMode(soap, tag, n, "tt:EFlipMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__EFlipMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__EFlipMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__EFlipMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__EFlipMode> *p;
	size_t k = sizeof(std::vector<tt__EFlipMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__EFlipMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__EFlipMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__EFlipMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__EFlipMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, std::vector<tt__PTZPresetTourOperation> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, const std::vector<tt__PTZPresetTourOperation> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, const char *tag, int id, const std::vector<tt__PTZPresetTourOperation> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PTZPresetTourOperation> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__PTZPresetTourOperation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PTZPresetTourOperation> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, const char *tag, std::vector<tt__PTZPresetTourOperation> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__PTZPresetTourOperation(soap)))
			return NULL;
		a->emplace_back();
		tt__PTZPresetTourOperation *n = &a->back();
		soap_default_tt__PTZPresetTourOperation(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__PTZPresetTourOperation, SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation, sizeof(tt__PTZPresetTourOperation), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__PTZPresetTourOperation(soap, tag, NULL, "tt:PTZPresetTourOperation"))
				break;
		}
		else
		{	if (!soap_in_tt__PTZPresetTourOperation(soap, tag, n, "tt:PTZPresetTourOperation"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PTZPresetTourOperation>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__PTZPresetTourOperation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PTZPresetTourOperation> *p;
	size_t k = sizeof(std::vector<tt__PTZPresetTourOperation> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PTZPresetTourOperation> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PTZPresetTourOperation> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PTZPresetTourOperation>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, std::vector<tt__SystemLogUri *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, const std::vector<tt__SystemLogUri *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__SystemLogUri *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__SystemLogUri(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, const char *tag, int id, const std::vector<tt__SystemLogUri *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__SystemLogUri *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__SystemLogUri(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__SystemLogUri *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, const char *tag, std::vector<tt__SystemLogUri *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__SystemLogUri(soap)))
			return NULL;
		a->emplace_back();
		tt__SystemLogUri * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__SystemLogUri, SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri, sizeof(tt__SystemLogUri), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__SystemLogUri(soap, tag, NULL, "tt:SystemLogUri"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__SystemLogUri(soap, tag, n, "tt:SystemLogUri"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__SystemLogUri *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__SystemLogUri(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__SystemLogUri *> *p;
	size_t k = sizeof(std::vector<tt__SystemLogUri *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__SystemLogUri *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__SystemLogUri *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__SystemLogUri *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, std::vector<tt__OnvifVersion *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const std::vector<tt__OnvifVersion *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__OnvifVersion *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__OnvifVersion(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const char *tag, int id, const std::vector<tt__OnvifVersion *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__OnvifVersion *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__OnvifVersion(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__OnvifVersion *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const char *tag, std::vector<tt__OnvifVersion *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__OnvifVersion(soap)))
			return NULL;
		a->emplace_back();
		tt__OnvifVersion * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__OnvifVersion, SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion, sizeof(tt__OnvifVersion), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__OnvifVersion(soap, tag, NULL, "tt:OnvifVersion"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__OnvifVersion(soap, tag, n, "tt:OnvifVersion"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__OnvifVersion *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__OnvifVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__OnvifVersion *> *p;
	size_t k = sizeof(std::vector<tt__OnvifVersion *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__OnvifVersion *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__OnvifVersion *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__OnvifVersion *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__AuxiliaryData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__AuxiliaryData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__AuxiliaryData(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_tt__AuxiliaryData(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AuxiliaryData, SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__AuxiliaryData(soap, tag, NULL, "tt:AuxiliaryData"))
				break;
		}
		else
		{	if (!soap_in_tt__AuxiliaryData(soap, tag, n, "tt:AuxiliaryData"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, std::vector<tt__Dot11Cipher> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, const std::vector<tt__Dot11Cipher> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot11Cipher> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot11Cipher> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__Dot11Cipher(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot11Cipher> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, const char *tag, std::vector<tt__Dot11Cipher> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__Dot11Cipher(soap)))
			return NULL;
		a->emplace_back();
		tt__Dot11Cipher *n = &a->back();
		soap_default_tt__Dot11Cipher(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Dot11Cipher, SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher, sizeof(tt__Dot11Cipher), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__Dot11Cipher(soap, tag, NULL, "tt:Dot11Cipher"))
				break;
		}
		else
		{	if (!soap_in_tt__Dot11Cipher(soap, tag, n, "tt:Dot11Cipher"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot11Cipher>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__Dot11Cipher(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot11Cipher> *p;
	size_t k = sizeof(std::vector<tt__Dot11Cipher> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot11Cipher> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot11Cipher> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot11Cipher>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, std::vector<tt__Dot11AuthAndMangementSuite> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, const std::vector<tt__Dot11AuthAndMangementSuite> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot11AuthAndMangementSuite> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot11AuthAndMangementSuite> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__Dot11AuthAndMangementSuite(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot11AuthAndMangementSuite> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, std::vector<tt__Dot11AuthAndMangementSuite> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap)))
			return NULL;
		a->emplace_back();
		tt__Dot11AuthAndMangementSuite *n = &a->back();
		soap_default_tt__Dot11AuthAndMangementSuite(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite, sizeof(tt__Dot11AuthAndMangementSuite), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, NULL, "tt:Dot11AuthAndMangementSuite"))
				break;
		}
		else
		{	if (!soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, n, "tt:Dot11AuthAndMangementSuite"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot11AuthAndMangementSuite>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot11AuthAndMangementSuite> *p;
	size_t k = sizeof(std::vector<tt__Dot11AuthAndMangementSuite> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot11AuthAndMangementSuite> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot11AuthAndMangementSuite> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot11AuthAndMangementSuite>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, std::vector<tt__NetworkZeroConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, const std::vector<tt__NetworkZeroConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkZeroConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkZeroConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkZeroConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkZeroConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkZeroConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkZeroConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, std::vector<tt__NetworkZeroConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__NetworkZeroConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__NetworkZeroConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, NULL, "tt:NetworkZeroConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, n, "tt:NetworkZeroConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkZeroConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkZeroConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__NetworkZeroConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkZeroConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkZeroConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkZeroConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, std::vector<tt__PrefixedIPv6Address *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const std::vector<tt__PrefixedIPv6Address *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PrefixedIPv6Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PrefixedIPv6Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const std::vector<tt__PrefixedIPv6Address *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PrefixedIPv6Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PrefixedIPv6Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PrefixedIPv6Address *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, std::vector<tt__PrefixedIPv6Address *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap)))
			return NULL;
		a->emplace_back();
		tt__PrefixedIPv6Address * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__PrefixedIPv6Address, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PrefixedIPv6Address(soap, tag, NULL, "tt:PrefixedIPv6Address"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PrefixedIPv6Address(soap, tag, n, "tt:PrefixedIPv6Address"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PrefixedIPv6Address *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PrefixedIPv6Address *> *p;
	size_t k = sizeof(std::vector<tt__PrefixedIPv6Address *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PrefixedIPv6Address *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PrefixedIPv6Address *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PrefixedIPv6Address *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, std::vector<tt__PrefixedIPv4Address *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const std::vector<tt__PrefixedIPv4Address *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PrefixedIPv4Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PrefixedIPv4Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const std::vector<tt__PrefixedIPv4Address *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PrefixedIPv4Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PrefixedIPv4Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PrefixedIPv4Address *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, std::vector<tt__PrefixedIPv4Address *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap)))
			return NULL;
		a->emplace_back();
		tt__PrefixedIPv4Address * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__PrefixedIPv4Address, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PrefixedIPv4Address(soap, tag, NULL, "tt:PrefixedIPv4Address"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PrefixedIPv4Address(soap, tag, n, "tt:PrefixedIPv4Address"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PrefixedIPv4Address *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PrefixedIPv4Address *> *p;
	size_t k = sizeof(std::vector<tt__PrefixedIPv4Address *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PrefixedIPv4Address *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PrefixedIPv4Address *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PrefixedIPv4Address *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, std::vector<tt__Dot11Configuration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, const std::vector<tt__Dot11Configuration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot11Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot11Configuration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot11Configuration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot11Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot11Configuration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot11Configuration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, const char *tag, std::vector<tt__Dot11Configuration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot11Configuration(soap)))
			return NULL;
		a->emplace_back();
		tt__Dot11Configuration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Dot11Configuration, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration, sizeof(tt__Dot11Configuration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot11Configuration(soap, tag, NULL, "tt:Dot11Configuration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot11Configuration(soap, tag, n, "tt:Dot11Configuration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot11Configuration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot11Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot11Configuration *> *p;
	size_t k = sizeof(std::vector<tt__Dot11Configuration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot11Configuration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot11Configuration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot11Configuration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, std::vector<tt__Dot3Configuration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, const std::vector<tt__Dot3Configuration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot3Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot3Configuration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot3Configuration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot3Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot3Configuration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot3Configuration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, const char *tag, std::vector<tt__Dot3Configuration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot3Configuration(soap)))
			return NULL;
		a->emplace_back();
		tt__Dot3Configuration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Dot3Configuration, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration, sizeof(tt__Dot3Configuration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot3Configuration(soap, tag, NULL, "tt:Dot3Configuration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot3Configuration(soap, tag, n, "tt:Dot3Configuration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot3Configuration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot3Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot3Configuration *> *p;
	size_t k = sizeof(std::vector<tt__Dot3Configuration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot3Configuration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot3Configuration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot3Configuration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, std::vector<tt__AudioEncoderConfigurationOption *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, const std::vector<tt__AudioEncoderConfigurationOption *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioEncoderConfigurationOption *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioEncoderConfigurationOption(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioEncoderConfigurationOption *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioEncoderConfigurationOption *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioEncoderConfigurationOption(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioEncoderConfigurationOption *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, std::vector<tt__AudioEncoderConfigurationOption *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap)))
			return NULL;
		a->emplace_back();
		tt__AudioEncoderConfigurationOption * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AudioEncoderConfigurationOption, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption, sizeof(tt__AudioEncoderConfigurationOption), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioEncoderConfigurationOption(soap, tag, NULL, "tt:AudioEncoderConfigurationOption"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioEncoderConfigurationOption(soap, tag, n, "tt:AudioEncoderConfigurationOption"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioEncoderConfigurationOption *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioEncoderConfigurationOption *> *p;
	size_t k = sizeof(std::vector<tt__AudioEncoderConfigurationOption *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioEncoderConfigurationOption *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioEncoderConfigurationOption *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioEncoderConfigurationOption *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoResolution2(struct soap *soap, std::vector<tt__VideoResolution2 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution2(struct soap *soap, const std::vector<tt__VideoResolution2 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoResolution2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoResolution2(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoResolution2(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoResolution2 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoResolution2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoResolution2(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoResolution2 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoResolution2(struct soap *soap, const char *tag, std::vector<tt__VideoResolution2 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoResolution2(soap)))
			return NULL;
		a->emplace_back();
		tt__VideoResolution2 * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__VideoResolution2, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution2, sizeof(tt__VideoResolution2), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoResolution2(soap, tag, NULL, "tt:VideoResolution2"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoResolution2(soap, tag, n, "tt:VideoResolution2"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoResolution2 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoResolution2 *> *p;
	size_t k = sizeof(std::vector<tt__VideoResolution2 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoResolution2 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoResolution2 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoResolution2 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__H264Profile(struct soap *soap, std::vector<tt__H264Profile> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__H264Profile(struct soap *soap, const std::vector<tt__H264Profile> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__H264Profile(struct soap *soap, const char *tag, int id, const std::vector<tt__H264Profile> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__H264Profile> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__H264Profile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__H264Profile> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__H264Profile(struct soap *soap, const char *tag, std::vector<tt__H264Profile> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__H264Profile(soap)))
			return NULL;
		a->emplace_back();
		tt__H264Profile *n = &a->back();
		soap_default_tt__H264Profile(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__H264Profile, SOAP_TYPE_std__vectorTemplateOftt__H264Profile, sizeof(tt__H264Profile), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__H264Profile(soap, tag, NULL, "tt:H264Profile"))
				break;
		}
		else
		{	if (!soap_in_tt__H264Profile(soap, tag, n, "tt:H264Profile"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__H264Profile>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__H264Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__H264Profile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__H264Profile> *p;
	size_t k = sizeof(std::vector<tt__H264Profile> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__H264Profile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__H264Profile> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__H264Profile> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__H264Profile>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, std::vector<tt__Mpeg4Profile> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, const std::vector<tt__Mpeg4Profile> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, const char *tag, int id, const std::vector<tt__Mpeg4Profile> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Mpeg4Profile> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__Mpeg4Profile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Mpeg4Profile> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, const char *tag, std::vector<tt__Mpeg4Profile> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__Mpeg4Profile(soap)))
			return NULL;
		a->emplace_back();
		tt__Mpeg4Profile *n = &a->back();
		soap_default_tt__Mpeg4Profile(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Mpeg4Profile, SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile, sizeof(tt__Mpeg4Profile), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__Mpeg4Profile(soap, tag, NULL, "tt:Mpeg4Profile"))
				break;
		}
		else
		{	if (!soap_in_tt__Mpeg4Profile(soap, tag, n, "tt:Mpeg4Profile"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Mpeg4Profile>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__Mpeg4Profile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Mpeg4Profile> *p;
	size_t k = sizeof(std::vector<tt__Mpeg4Profile> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Mpeg4Profile> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Mpeg4Profile> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Mpeg4Profile>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, std::vector<tt__VideoResolution *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, const std::vector<tt__VideoResolution *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoResolution *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoResolution(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoResolution *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoResolution *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoResolution(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoResolution *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, const char *tag, std::vector<tt__VideoResolution *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoResolution(soap)))
			return NULL;
		a->emplace_back();
		tt__VideoResolution * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__VideoResolution, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution, sizeof(tt__VideoResolution), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoResolution(soap, tag, NULL, "tt:VideoResolution"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoResolution(soap, tag, n, "tt:VideoResolution"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoResolution *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoResolution *> *p;
	size_t k = sizeof(std::vector<tt__VideoResolution *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoResolution *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoResolution *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoResolution *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__RotateMode(struct soap *soap, std::vector<tt__RotateMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__RotateMode(struct soap *soap, const std::vector<tt__RotateMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__RotateMode(struct soap *soap, const char *tag, int id, const std::vector<tt__RotateMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RotateMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__RotateMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RotateMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__RotateMode(struct soap *soap, const char *tag, std::vector<tt__RotateMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__RotateMode(soap)))
			return NULL;
		a->emplace_back();
		tt__RotateMode *n = &a->back();
		soap_default_tt__RotateMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__RotateMode, SOAP_TYPE_std__vectorTemplateOftt__RotateMode, sizeof(tt__RotateMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__RotateMode(soap, tag, NULL, "tt:RotateMode"))
				break;
		}
		else
		{	if (!soap_in_tt__RotateMode(soap, tag, n, "tt:RotateMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RotateMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__RotateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__RotateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RotateMode> *p;
	size_t k = sizeof(std::vector<tt__RotateMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__RotateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RotateMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RotateMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RotateMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, std::vector<tt__SceneOrientationMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, const std::vector<tt__SceneOrientationMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, const char *tag, int id, const std::vector<tt__SceneOrientationMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__SceneOrientationMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__SceneOrientationMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__SceneOrientationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, const char *tag, std::vector<tt__SceneOrientationMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__SceneOrientationMode(soap)))
			return NULL;
		a->emplace_back();
		tt__SceneOrientationMode *n = &a->back();
		soap_default_tt__SceneOrientationMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__SceneOrientationMode, SOAP_TYPE_std__vectorTemplateOftt__SceneOrientationMode, sizeof(tt__SceneOrientationMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__SceneOrientationMode(soap, tag, NULL, "tt:SceneOrientationMode"))
				break;
		}
		else
		{	if (!soap_in_tt__SceneOrientationMode(soap, tag, n, "tt:SceneOrientationMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__SceneOrientationMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__SceneOrientationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__SceneOrientationMode> *p;
	size_t k = sizeof(std::vector<tt__SceneOrientationMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__SceneOrientationMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__SceneOrientationMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__SceneOrientationMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__SceneOrientationMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, std::vector<tt__LensProjection *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, const std::vector<tt__LensProjection *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__LensProjection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__LensProjection(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, const char *tag, int id, const std::vector<tt__LensProjection *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__LensProjection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__LensProjection(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__LensProjection *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, const char *tag, std::vector<tt__LensProjection *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__LensProjection(soap)))
			return NULL;
		a->emplace_back();
		tt__LensProjection * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__LensProjection, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection, sizeof(tt__LensProjection), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__LensProjection(soap, tag, NULL, "tt:LensProjection"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__LensProjection(soap, tag, n, "tt:LensProjection"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__LensProjection *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__LensProjection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__LensProjection *> *p;
	size_t k = sizeof(std::vector<tt__LensProjection *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__LensProjection *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__LensProjection *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__LensProjection *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, std::vector<tt__LensDescription *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, const std::vector<tt__LensDescription *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__LensDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__LensDescription(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__LensDescription *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__LensDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__LensDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__LensDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, const char *tag, std::vector<tt__LensDescription *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__LensDescription(soap)))
			return NULL;
		a->emplace_back();
		tt__LensDescription * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__LensDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription, sizeof(tt__LensDescription), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__LensDescription(soap, tag, NULL, "tt:LensDescription"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__LensDescription(soap, tag, n, "tt:LensDescription"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__LensDescription *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__LensDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__LensDescription *> *p;
	size_t k = sizeof(std::vector<tt__LensDescription *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__LensDescription *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__LensDescription *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__LensDescription *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOffloat(struct soap *soap, std::vector<float> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOffloat(struct soap *soap, const std::vector<float> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOffloat(struct soap *soap, const char *tag, int id, const std::vector<float> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<float> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_float(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<float> * SOAP_FMAC4 soap_in_std__vectorTemplateOffloat(struct soap *soap, const char *tag, std::vector<float> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOffloat(soap)))
			return NULL;
		a->emplace_back();
		float *n = &a->back();
		soap_default_float(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_float, SOAP_TYPE_std__vectorTemplateOffloat, sizeof(float), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_float(soap, tag, NULL, "xsd:float"))
				break;
		}
		else
		{	if (!soap_in_float(soap, tag, n, "xsd:float"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<float>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOffloat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOffloat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<float> *p;
	size_t k = sizeof(std::vector<float> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOffloat, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<float> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<float> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<float>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<int> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int> * SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfint(soap)))
			return NULL;
		a->emplace_back();
		int *n = &a->back();
		soap_default_int(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{	if (!soap_in_int(soap, tag, n, "xsd:int"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<int>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<int> *p;
	size_t k = sizeof(std::vector<int> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<int> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<int> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<int>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, std::vector<tt__LocationEntity *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, const std::vector<tt__LocationEntity *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__LocationEntity *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__LocationEntity(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, const char *tag, int id, const std::vector<tt__LocationEntity *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__LocationEntity *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__LocationEntity(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__LocationEntity *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, const char *tag, std::vector<tt__LocationEntity *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__LocationEntity(soap)))
			return NULL;
		a->emplace_back();
		tt__LocationEntity * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__LocationEntity, SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity, sizeof(tt__LocationEntity), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__LocationEntity(soap, tag, NULL, "tt:LocationEntity"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__LocationEntity(soap, tag, n, "tt:LocationEntity"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__LocationEntity *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__LocationEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__LocationEntity *> *p;
	size_t k = sizeof(std::vector<tt__LocationEntity *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__LocationEntity *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__LocationEntity *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__LocationEntity *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, std::vector<tds__StorageConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, const std::vector<tds__StorageConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tds__StorageConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotds__StorageConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tds__StorageConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tds__StorageConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotds__StorageConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tds__StorageConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, const char *tag, std::vector<tds__StorageConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tds__StorageConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tds__StorageConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration, sizeof(tds__StorageConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotds__StorageConfiguration(soap, tag, NULL, "tds:StorageConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTotds__StorageConfiguration(soap, tag, n, "tds:StorageConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tds__StorageConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotds__StorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tds__StorageConfiguration *> *p;
	size_t k = sizeof(std::vector<tds__StorageConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tds__StorageConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tds__StorageConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tds__StorageConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, std::vector<tt__Dot11AvailableNetworks *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, const std::vector<tt__Dot11AvailableNetworks *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot11AvailableNetworks *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot11AvailableNetworks(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot11AvailableNetworks *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot11AvailableNetworks *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot11AvailableNetworks(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot11AvailableNetworks *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, std::vector<tt__Dot11AvailableNetworks *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap)))
			return NULL;
		a->emplace_back();
		tt__Dot11AvailableNetworks * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Dot11AvailableNetworks, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks, sizeof(tt__Dot11AvailableNetworks), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, NULL, "tt:Dot11AvailableNetworks"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, n, "tt:Dot11AvailableNetworks"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot11AvailableNetworks *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot11AvailableNetworks *> *p;
	size_t k = sizeof(std::vector<tt__Dot11AvailableNetworks *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot11AvailableNetworks *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot11AvailableNetworks *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot11AvailableNetworks *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, std::vector<tt__RelayOutput *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, const std::vector<tt__RelayOutput *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RelayOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RelayOutput(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, const char *tag, int id, const std::vector<tt__RelayOutput *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RelayOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RelayOutput(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RelayOutput *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, const char *tag, std::vector<tt__RelayOutput *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RelayOutput(soap)))
			return NULL;
		a->emplace_back();
		tt__RelayOutput * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__RelayOutput, SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput, sizeof(tt__RelayOutput), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RelayOutput(soap, tag, NULL, "tt:RelayOutput"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RelayOutput(soap, tag, n, "tt:RelayOutput"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RelayOutput *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RelayOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RelayOutput *> *p;
	size_t k = sizeof(std::vector<tt__RelayOutput *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RelayOutput *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RelayOutput *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RelayOutput *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__ReferenceToken(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ReferenceToken(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ReferenceToken(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_tt__ReferenceToken(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ReferenceToken, SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ReferenceToken(soap, tag, NULL, "tt:ReferenceToken"))
				break;
		}
		else
		{	if (!soap_in_tt__ReferenceToken(soap, tag, n, "tt:ReferenceToken"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ReferenceToken(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, std::vector<tt__Dot1XConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, const std::vector<tt__Dot1XConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot1XConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot1XConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot1XConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot1XConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot1XConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot1XConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, std::vector<tt__Dot1XConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__Dot1XConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Dot1XConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration, sizeof(tt__Dot1XConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot1XConfiguration(soap, tag, NULL, "tt:Dot1XConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot1XConfiguration(soap, tag, n, "tt:Dot1XConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot1XConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot1XConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__Dot1XConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot1XConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot1XConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot1XConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, std::vector<tt__CertificateWithPrivateKey *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, const std::vector<tt__CertificateWithPrivateKey *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__CertificateWithPrivateKey *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__CertificateWithPrivateKey(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const std::vector<tt__CertificateWithPrivateKey *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__CertificateWithPrivateKey *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__CertificateWithPrivateKey(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__CertificateWithPrivateKey *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, std::vector<tt__CertificateWithPrivateKey *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap)))
			return NULL;
		a->emplace_back();
		tt__CertificateWithPrivateKey * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__CertificateWithPrivateKey, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey, sizeof(tt__CertificateWithPrivateKey), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, NULL, "tt:CertificateWithPrivateKey"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, n, "tt:CertificateWithPrivateKey"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__CertificateWithPrivateKey *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__CertificateWithPrivateKey *> *p;
	size_t k = sizeof(std::vector<tt__CertificateWithPrivateKey *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__CertificateWithPrivateKey *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__CertificateWithPrivateKey *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__CertificateWithPrivateKey *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, std::vector<tt__CertificateStatus *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, const std::vector<tt__CertificateStatus *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__CertificateStatus *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__CertificateStatus(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, const char *tag, int id, const std::vector<tt__CertificateStatus *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__CertificateStatus *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__CertificateStatus(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__CertificateStatus *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, const char *tag, std::vector<tt__CertificateStatus *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__CertificateStatus(soap)))
			return NULL;
		a->emplace_back();
		tt__CertificateStatus * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__CertificateStatus, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus, sizeof(tt__CertificateStatus), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__CertificateStatus(soap, tag, NULL, "tt:CertificateStatus"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__CertificateStatus(soap, tag, n, "tt:CertificateStatus"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__CertificateStatus *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__CertificateStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__CertificateStatus *> *p;
	size_t k = sizeof(std::vector<tt__CertificateStatus *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__CertificateStatus *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__CertificateStatus *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__CertificateStatus *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, std::vector<tt__Certificate *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, const std::vector<tt__Certificate *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Certificate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Certificate(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, const char *tag, int id, const std::vector<tt__Certificate *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Certificate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Certificate(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Certificate *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, const char *tag, std::vector<tt__Certificate *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Certificate(soap)))
			return NULL;
		a->emplace_back();
		tt__Certificate * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Certificate, SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate, sizeof(tt__Certificate), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Certificate(soap, tag, NULL, "tt:Certificate"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Certificate(soap, tag, n, "tt:Certificate"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Certificate *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Certificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Certificate *> *p;
	size_t k = sizeof(std::vector<tt__Certificate *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Certificate *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Certificate *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Certificate *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IPv6Address(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__IPv6Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IPv6Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__IPv6Address(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_tt__IPv6Address(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__IPv6Address, SOAP_TYPE_std__vectorTemplateOftt__IPv6Address, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__IPv6Address(soap, tag, NULL, "tt:IPv6Address"))
				break;
		}
		else
		{	if (!soap_in_tt__IPv6Address(soap, tag, n, "tt:IPv6Address"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IPv6Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__IPv6Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IPv4Address(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__IPv4Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IPv4Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__IPv4Address(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_tt__IPv4Address(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__IPv4Address, SOAP_TYPE_std__vectorTemplateOftt__IPv4Address, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__IPv4Address(soap, tag, NULL, "tt:IPv4Address"))
				break;
		}
		else
		{	if (!soap_in_tt__IPv4Address(soap, tag, n, "tt:IPv4Address"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IPv4Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__IPv4Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, std::vector<tt__NetworkProtocol *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, const std::vector<tt__NetworkProtocol *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkProtocol *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkProtocol(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkProtocol *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkProtocol *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkProtocol(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkProtocol *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, const char *tag, std::vector<tt__NetworkProtocol *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkProtocol(soap)))
			return NULL;
		a->emplace_back();
		tt__NetworkProtocol * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__NetworkProtocol, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol, sizeof(tt__NetworkProtocol), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkProtocol(soap, tag, NULL, "tt:NetworkProtocol"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkProtocol(soap, tag, n, "tt:NetworkProtocol"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkProtocol *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkProtocol(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkProtocol *> *p;
	size_t k = sizeof(std::vector<tt__NetworkProtocol *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkProtocol *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkProtocol *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkProtocol *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, std::vector<tt__NetworkInterface *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, const std::vector<tt__NetworkInterface *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkInterface *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkInterface(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkInterface *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkInterface *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkInterface(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkInterface *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, const char *tag, std::vector<tt__NetworkInterface *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkInterface(soap)))
			return NULL;
		a->emplace_back();
		tt__NetworkInterface * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__NetworkInterface, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface, sizeof(tt__NetworkInterface), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkInterface(soap, tag, NULL, "tt:NetworkInterface"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkInterface(soap, tag, n, "tt:NetworkInterface"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkInterface *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkInterface *> *p;
	size_t k = sizeof(std::vector<tt__NetworkInterface *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkInterface *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkInterface *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkInterface *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, std::vector<tt__IPAddress *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const std::vector<tt__IPAddress *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__IPAddress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__IPAddress(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const char *tag, int id, const std::vector<tt__IPAddress *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__IPAddress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__IPAddress(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__IPAddress *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const char *tag, std::vector<tt__IPAddress *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__IPAddress(soap)))
			return NULL;
		a->emplace_back();
		tt__IPAddress * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__IPAddress, SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress, sizeof(tt__IPAddress), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__IPAddress(soap, tag, NULL, "tt:IPAddress"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__IPAddress(soap, tag, n, "tt:IPAddress"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__IPAddress *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__IPAddress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__IPAddress *> *p;
	size_t k = sizeof(std::vector<tt__IPAddress *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__IPAddress *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__IPAddress *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__IPAddress *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__token(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__token(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__token(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__token(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__token(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__token(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__token(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_xsd__token(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__token, SOAP_TYPE_std__vectorTemplateOfxsd__token, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__token(soap, tag, NULL, "xsd:token"))
				break;
		}
		else
		{	if (!soap_in_xsd__token(soap, tag, n, "xsd:token"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__token(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__token(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__token, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, std::vector<tt__CapabilityCategory> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, const std::vector<tt__CapabilityCategory> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, const char *tag, int id, const std::vector<tt__CapabilityCategory> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__CapabilityCategory> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__CapabilityCategory(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__CapabilityCategory> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, const char *tag, std::vector<tt__CapabilityCategory> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__CapabilityCategory(soap)))
			return NULL;
		a->emplace_back();
		tt__CapabilityCategory *n = &a->back();
		soap_default_tt__CapabilityCategory(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__CapabilityCategory, SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory, sizeof(tt__CapabilityCategory), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__CapabilityCategory(soap, tag, NULL, "tt:CapabilityCategory"))
				break;
		}
		else
		{	if (!soap_in_tt__CapabilityCategory(soap, tag, n, "tt:CapabilityCategory"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__CapabilityCategory>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__CapabilityCategory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__CapabilityCategory> *p;
	size_t k = sizeof(std::vector<tt__CapabilityCategory> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__CapabilityCategory> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__CapabilityCategory> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__CapabilityCategory>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_std__string(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, n, "xsd:string"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__User(struct soap *soap, std::vector<tt__User *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__User(struct soap *soap, const std::vector<tt__User *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__User *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__User(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__User(struct soap *soap, const char *tag, int id, const std::vector<tt__User *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__User *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__User(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__User *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__User(struct soap *soap, const char *tag, std::vector<tt__User *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__User(soap)))
			return NULL;
		a->emplace_back();
		tt__User * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__User, SOAP_TYPE_std__vectorTemplateOfPointerTott__User, sizeof(tt__User), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__User(soap, tag, NULL, "tt:User"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__User(soap, tag, n, "tt:User"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__User *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__User(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__User *> *p;
	size_t k = sizeof(std::vector<tt__User *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__User, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__User *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__User *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__User *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, std::vector<tt__NetworkHost *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const std::vector<tt__NetworkHost *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkHost *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkHost(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkHost *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkHost *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkHost(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkHost *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const char *tag, std::vector<tt__NetworkHost *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkHost(soap)))
			return NULL;
		a->emplace_back();
		tt__NetworkHost * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__NetworkHost, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost, sizeof(tt__NetworkHost), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkHost(soap, tag, NULL, "tt:NetworkHost"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkHost(soap, tag, n, "tt:NetworkHost"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkHost *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkHost(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkHost *> *p;
	size_t k = sizeof(std::vector<tt__NetworkHost *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkHost *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkHost *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkHost *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyURI(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyURI(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyURI(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyURI(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_xsd__anyURI(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI"))
				break;
		}
		else
		{	if (!soap_in_xsd__anyURI(soap, tag, n, "xsd:anyURI"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyURI(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, std::vector<tt__Scope *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, const std::vector<tt__Scope *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Scope *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Scope(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, const char *tag, int id, const std::vector<tt__Scope *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Scope *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Scope(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Scope *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, const char *tag, std::vector<tt__Scope *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Scope(soap)))
			return NULL;
		a->emplace_back();
		tt__Scope * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Scope, SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope, sizeof(tt__Scope), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Scope(soap, tag, NULL, "tt:Scope"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Scope(soap, tag, n, "tt:Scope"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Scope *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Scope(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Scope *> *p;
	size_t k = sizeof(std::vector<tt__Scope *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Scope *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Scope *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Scope *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, std::vector<tt__BackupFile *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, const std::vector<tt__BackupFile *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__BackupFile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__BackupFile(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, const char *tag, int id, const std::vector<tt__BackupFile *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__BackupFile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__BackupFile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__BackupFile *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, const char *tag, std::vector<tt__BackupFile *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__BackupFile(soap)))
			return NULL;
		a->emplace_back();
		tt__BackupFile * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__BackupFile, SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile, sizeof(tt__BackupFile), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__BackupFile(soap, tag, NULL, "tt:BackupFile"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__BackupFile(soap, tag, n, "tt:BackupFile"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__BackupFile *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__BackupFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__BackupFile *> *p;
	size_t k = sizeof(std::vector<tt__BackupFile *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__BackupFile *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__BackupFile *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__BackupFile *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, std::vector<tds__Service *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, const std::vector<tds__Service *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tds__Service *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotds__Service(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, const char *tag, int id, const std::vector<tds__Service *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tds__Service *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotds__Service(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tds__Service *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, const char *tag, std::vector<tds__Service *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotds__Service(soap)))
			return NULL;
		a->emplace_back();
		tds__Service * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tds__Service, SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service, sizeof(tds__Service), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotds__Service(soap, tag, NULL, "tds:Service"))
				break;
		}
		else
		{	if (!soap_in_PointerTotds__Service(soap, tag, n, "tds:Service"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tds__Service *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotds__Service(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tds__Service *> *p;
	size_t k = sizeof(std::vector<tds__Service *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tds__Service *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tds__Service *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tds__Service *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyType(struct soap *soap, std::vector<struct soap_dom_element> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyType(struct soap *soap, const std::vector<struct soap_dom_element> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<struct soap_dom_element> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyType(struct soap *soap, const char *tag, int id, const std::vector<struct soap_dom_element> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<struct soap_dom_element> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<struct soap_dom_element> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyType(struct soap *soap, const char *tag, std::vector<struct soap_dom_element> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyType(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(struct soap_dom_element));
		}
		else
		{	a->emplace_back();
		}
		struct soap_dom_element *n = &a->back();
		soap_default_xsd__anyType(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__anyType, SOAP_TYPE_std__vectorTemplateOfxsd__anyType, sizeof(struct soap_dom_element), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__anyType(soap, tag, NULL, "xsd:anyType"))
				break;
		}
		else
		{	if (!soap_in_xsd__anyType(soap, tag, n, "xsd:anyType"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<struct soap_dom_element>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<struct soap_dom_element> *p;
	size_t k = sizeof(std::vector<struct soap_dom_element> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__anyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<struct soap_dom_element> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<struct soap_dom_element> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<struct soap_dom_element>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.cpp */
