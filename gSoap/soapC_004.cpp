/* soapC_nnn.cpp
   Generated by gSOAP 2.8.78 for WS/onvifFull.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.cpp ver 2.8.78 2019-03-11 21:45:01 GMT")


void tt__ImagingSettingsExtension202::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, &this->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment);
	this->tt__ImagingSettingsExtension202::Extension = NULL;
}

void tt__ImagingSettingsExtension202::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, &this->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment);
	soap_serialize_PointerTott__ImagingSettingsExtension203(soap, &this->tt__ImagingSettingsExtension202::Extension);
#endif
}

int tt__ImagingSettingsExtension202::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension202(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension202(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension202 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension202), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, "tt:IrCutFilterAutoAdjustment", -1, &a->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension203(soap, "tt:Extension", -1, &a->tt__ImagingSettingsExtension202::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension202::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension202(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension202 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension202(struct soap *soap, const char *tag, tt__ImagingSettingsExtension202 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension202*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(tt__ImagingSettingsExtension202), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension202)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettingsExtension202 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, "tt:IrCutFilterAutoAdjustment", &a->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment, "tt:IrCutFilterAutoAdjustment"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension203(soap, "tt:Extension", &a->tt__ImagingSettingsExtension202::Extension, "tt:ImagingSettingsExtension203"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension202 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension202, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(tt__ImagingSettingsExtension202), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension202 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension202(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettingsExtension202(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension202 *p;
	size_t k = sizeof(tt__ImagingSettingsExtension202);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension202, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension202);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension202, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension202 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension202::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension202(soap, tag ? tag : "tt:ImagingSettingsExtension202", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension202::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension202(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension202 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension202(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingSettingsExtension20::__any);
	this->tt__ImagingSettingsExtension20::ImageStabilization = NULL;
	this->tt__ImagingSettingsExtension20::Extension = NULL;
}

void tt__ImagingSettingsExtension20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingSettingsExtension20::__any);
	soap_serialize_PointerTott__ImageStabilization(soap, &this->tt__ImagingSettingsExtension20::ImageStabilization);
	soap_serialize_PointerTott__ImagingSettingsExtension202(soap, &this->tt__ImagingSettingsExtension20::Extension);
#endif
}

int tt__ImagingSettingsExtension20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension20), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ImagingSettingsExtension20::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilization(soap, "tt:ImageStabilization", -1, &a->tt__ImagingSettingsExtension20::ImageStabilization, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension202(soap, "tt:Extension", -1, &a->tt__ImagingSettingsExtension20::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, tt__ImagingSettingsExtension20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(tt__ImagingSettingsExtension20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettingsExtension20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ImageStabilization1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImageStabilization1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilization(soap, "tt:ImageStabilization", &a->tt__ImagingSettingsExtension20::ImageStabilization, "tt:ImageStabilization"))
				{	soap_flag_ImageStabilization1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension202(soap, "tt:Extension", &a->tt__ImagingSettingsExtension20::Extension, "tt:ImagingSettingsExtension202"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ImagingSettingsExtension20::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension20, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(tt__ImagingSettingsExtension20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettingsExtension20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension20 *p;
	size_t k = sizeof(tt__ImagingSettingsExtension20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension20(soap, tag ? tag : "tt:ImagingSettingsExtension20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettings20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ImagingSettings20::BacklightCompensation = NULL;
	this->tt__ImagingSettings20::Brightness = NULL;
	this->tt__ImagingSettings20::ColorSaturation = NULL;
	this->tt__ImagingSettings20::Contrast = NULL;
	this->tt__ImagingSettings20::Exposure = NULL;
	this->tt__ImagingSettings20::Focus = NULL;
	this->tt__ImagingSettings20::IrCutFilter = NULL;
	this->tt__ImagingSettings20::Sharpness = NULL;
	this->tt__ImagingSettings20::WideDynamicRange = NULL;
	this->tt__ImagingSettings20::WhiteBalance = NULL;
	this->tt__ImagingSettings20::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingSettings20::__anyAttribute);
}

void tt__ImagingSettings20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensation20(soap, &this->tt__ImagingSettings20::BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::Brightness);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::ColorSaturation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::Contrast);
	soap_serialize_PointerTott__Exposure20(soap, &this->tt__ImagingSettings20::Exposure);
	soap_serialize_PointerTott__FocusConfiguration20(soap, &this->tt__ImagingSettings20::Focus);
	soap_serialize_PointerTott__IrCutFilterMode(soap, &this->tt__ImagingSettings20::IrCutFilter);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::Sharpness);
	soap_serialize_PointerTott__WideDynamicRange20(soap, &this->tt__ImagingSettings20::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalance20(soap, &this->tt__ImagingSettings20::WhiteBalance);
	soap_serialize_PointerTott__ImagingSettingsExtension20(soap, &this->tt__ImagingSettings20::Extension);
#endif
}

int tt__ImagingSettings20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettings20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings20(struct soap *soap, const char *tag, int id, const tt__ImagingSettings20 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingSettings20*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettings20), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", -1, &a->tt__ImagingSettings20::BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Brightness", -1, &a->tt__ImagingSettings20::Brightness, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ColorSaturation", -1, &a->tt__ImagingSettings20::ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Contrast", -1, &a->tt__ImagingSettings20::Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__Exposure20(soap, "tt:Exposure", -1, &a->tt__ImagingSettings20::Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration20(soap, "tt:Focus", -1, &a->tt__ImagingSettings20::Focus, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", -1, &a->tt__ImagingSettings20::IrCutFilter, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Sharpness", -1, &a->tt__ImagingSettings20::Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", -1, &a->tt__ImagingSettings20::WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", -1, &a->tt__ImagingSettings20::WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", -1, &a->tt__ImagingSettings20::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettings20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettings20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettings20 * SOAP_FMAC4 soap_in_tt__ImagingSettings20(struct soap *soap, const char *tag, tt__ImagingSettings20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettings20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings20, sizeof(tt__ImagingSettings20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettings20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettings20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingSettings20*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_IrCutFilter1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", &a->tt__ImagingSettings20::BacklightCompensation, "tt:BacklightCompensation20"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Brightness", &a->tt__ImagingSettings20::Brightness, "xsd:float"))
				{	soap_flag_Brightness1--;
					continue;
				}
			}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:ColorSaturation", &a->tt__ImagingSettings20::ColorSaturation, "xsd:float"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Contrast", &a->tt__ImagingSettings20::Contrast, "xsd:float"))
				{	soap_flag_Contrast1--;
					continue;
				}
			}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Exposure20(soap, "tt:Exposure", &a->tt__ImagingSettings20::Exposure, "tt:Exposure20"))
				{	soap_flag_Exposure1--;
					continue;
				}
			}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusConfiguration20(soap, "tt:Focus", &a->tt__ImagingSettings20::Focus, "tt:FocusConfiguration20"))
				{	soap_flag_Focus1--;
					continue;
				}
			}
			if (soap_flag_IrCutFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", &a->tt__ImagingSettings20::IrCutFilter, "tt:IrCutFilterMode"))
				{	soap_flag_IrCutFilter1--;
					continue;
				}
			}
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Sharpness", &a->tt__ImagingSettings20::Sharpness, "xsd:float"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", &a->tt__ImagingSettings20::WideDynamicRange, "tt:WideDynamicRange20"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", &a->tt__ImagingSettings20::WhiteBalance, "tt:WhiteBalance20"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", &a->tt__ImagingSettings20::Extension, "tt:ImagingSettingsExtension20"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettings20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings20, SOAP_TYPE_tt__ImagingSettings20, sizeof(tt__ImagingSettings20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettings20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettings20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettings20 *p;
	size_t k = sizeof(tt__ImagingSettings20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettings20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettings20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettings20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettings20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettings20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettings20(soap, tag ? tag : "tt:ImagingSettings20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettings20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettings20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettings20 * SOAP_FMAC4 soap_get_tt__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettings20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusStatus20Extension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusStatus20Extension::__any);
}

void tt__FocusStatus20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusStatus20Extension::__any);
#endif
}

int tt__FocusStatus20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusStatus20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20Extension(struct soap *soap, const char *tag, int id, const tt__FocusStatus20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__FocusStatus20Extension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusStatus20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusStatus20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusStatus20Extension * SOAP_FMAC4 soap_in_tt__FocusStatus20Extension(struct soap *soap, const char *tag, tt__FocusStatus20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusStatus20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(tt__FocusStatus20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusStatus20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusStatus20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__FocusStatus20Extension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20Extension, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(tt__FocusStatus20Extension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusStatus20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusStatus20Extension *p;
	size_t k = sizeof(tt__FocusStatus20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusStatus20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusStatus20Extension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusStatus20Extension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusStatus20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusStatus20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusStatus20Extension(soap, tag ? tag : "tt:FocusStatus20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusStatus20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusStatus20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusStatus20Extension * SOAP_FMAC4 soap_get_tt__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusStatus20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__FocusStatus20::Position);
	soap_default_tt__MoveStatus(soap, &this->tt__FocusStatus20::MoveStatus);
	this->tt__FocusStatus20::Error = NULL;
	this->tt__FocusStatus20::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__FocusStatus20::__anyAttribute);
}

void tt__FocusStatus20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__FocusStatus20::Position, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FocusStatus20::MoveStatus, SOAP_TYPE_tt__MoveStatus);
	soap_serialize_PointerTostd__string(soap, &this->tt__FocusStatus20::Error);
	soap_serialize_PointerTott__FocusStatus20Extension(soap, &this->tt__FocusStatus20::Extension);
#endif
}

int tt__FocusStatus20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusStatus20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20(struct soap *soap, const char *tag, int id, const tt__FocusStatus20 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__FocusStatus20*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus20), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->tt__FocusStatus20::Position, ""))
		return soap->error;
	if (soap_out_tt__MoveStatus(soap, "tt:MoveStatus", -1, &a->tt__FocusStatus20::MoveStatus, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Error", -1, &a->tt__FocusStatus20::Error, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusStatus20Extension(soap, "tt:Extension", -1, &a->tt__FocusStatus20::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusStatus20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusStatus20(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusStatus20 * SOAP_FMAC4 soap_in_tt__FocusStatus20(struct soap *soap, const char *tag, tt__FocusStatus20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusStatus20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20, sizeof(tt__FocusStatus20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusStatus20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusStatus20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__FocusStatus20*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_MoveStatus1 = 1;
	size_t soap_flag_Error1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Position", &a->tt__FocusStatus20::Position, "xsd:float"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_MoveStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__MoveStatus(soap, "tt:MoveStatus", &a->tt__FocusStatus20::MoveStatus, "tt:MoveStatus"))
				{	soap_flag_MoveStatus1--;
					continue;
				}
			}
			if (soap_flag_Error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Error", &a->tt__FocusStatus20::Error, "xsd:string"))
				{	soap_flag_Error1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusStatus20Extension(soap, "tt:Extension", &a->tt__FocusStatus20::Extension, "tt:FocusStatus20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position1 > 0 || soap_flag_MoveStatus1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FocusStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20, SOAP_TYPE_tt__FocusStatus20, sizeof(tt__FocusStatus20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusStatus20 * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusStatus20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusStatus20 *p;
	size_t k = sizeof(tt__FocusStatus20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusStatus20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusStatus20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusStatus20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusStatus20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusStatus20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusStatus20(soap, tag ? tag : "tt:FocusStatus20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusStatus20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusStatus20(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusStatus20 * SOAP_FMAC4 soap_get_tt__FocusStatus20(struct soap *soap, tt__FocusStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingStatus20Extension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingStatus20Extension::__any);
}

void tt__ImagingStatus20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingStatus20Extension::__any);
#endif
}

int tt__ImagingStatus20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingStatus20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, const tt__ImagingStatus20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ImagingStatus20Extension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingStatus20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingStatus20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingStatus20Extension * SOAP_FMAC4 soap_in_tt__ImagingStatus20Extension(struct soap *soap, const char *tag, tt__ImagingStatus20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingStatus20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(tt__ImagingStatus20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingStatus20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingStatus20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ImagingStatus20Extension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20Extension, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(tt__ImagingStatus20Extension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingStatus20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingStatus20Extension *p;
	size_t k = sizeof(tt__ImagingStatus20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingStatus20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingStatus20Extension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingStatus20Extension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingStatus20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingStatus20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingStatus20Extension(soap, tag ? tag : "tt:ImagingStatus20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingStatus20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingStatus20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingStatus20Extension * SOAP_FMAC4 soap_get_tt__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingStatus20::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ImagingStatus20::FocusStatus20 = NULL;
	this->tt__ImagingStatus20::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingStatus20::__anyAttribute);
}

void tt__ImagingStatus20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FocusStatus20(soap, &this->tt__ImagingStatus20::FocusStatus20);
	soap_serialize_PointerTott__ImagingStatus20Extension(soap, &this->tt__ImagingStatus20::Extension);
#endif
}

int tt__ImagingStatus20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingStatus20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20(struct soap *soap, const char *tag, int id, const tt__ImagingStatus20 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingStatus20*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus20), type))
		return soap->error;
	if (soap_out_PointerTott__FocusStatus20(soap, "tt:FocusStatus20", -1, &a->tt__ImagingStatus20::FocusStatus20, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingStatus20Extension(soap, "tt:Extension", -1, &a->tt__ImagingStatus20::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingStatus20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingStatus20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingStatus20 * SOAP_FMAC4 soap_in_tt__ImagingStatus20(struct soap *soap, const char *tag, tt__ImagingStatus20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingStatus20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20, sizeof(tt__ImagingStatus20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingStatus20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingStatus20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingStatus20*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_FocusStatus201 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FocusStatus201 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusStatus20(soap, "tt:FocusStatus20", &a->tt__ImagingStatus20::FocusStatus20, "tt:FocusStatus20"))
				{	soap_flag_FocusStatus201--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingStatus20Extension(soap, "tt:Extension", &a->tt__ImagingStatus20::Extension, "tt:ImagingStatus20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20, SOAP_TYPE_tt__ImagingStatus20, sizeof(tt__ImagingStatus20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingStatus20 * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingStatus20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingStatus20 *p;
	size_t k = sizeof(tt__ImagingStatus20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingStatus20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingStatus20);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingStatus20, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingStatus20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingStatus20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingStatus20(soap, tag ? tag : "tt:ImagingStatus20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingStatus20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingStatus20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingStatus20 * SOAP_FMAC4 soap_get_tt__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalance::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__WhiteBalanceMode(soap, &this->tt__WhiteBalance::Mode);
	soap_default_float(soap, &this->tt__WhiteBalance::CrGain);
	soap_default_float(soap, &this->tt__WhiteBalance::CbGain);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__WhiteBalance::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__WhiteBalance::__anyAttribute);
}

void tt__WhiteBalance::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__WhiteBalance::CrGain, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__WhiteBalance::CbGain, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__WhiteBalance::__any);
#endif
}

int tt__WhiteBalance::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalance(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance(struct soap *soap, const char *tag, int id, const tt__WhiteBalance *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__WhiteBalance*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance), type))
		return soap->error;
	if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->tt__WhiteBalance::Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CrGain", -1, &a->tt__WhiteBalance::CrGain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CbGain", -1, &a->tt__WhiteBalance::CbGain, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__WhiteBalance::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalance::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalance(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalance * SOAP_FMAC4 soap_in_tt__WhiteBalance(struct soap *soap, const char *tag, tt__WhiteBalance *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalance*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance, sizeof(tt__WhiteBalance), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalance)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalance *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__WhiteBalance*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_CrGain1 = 1;
	size_t soap_flag_CbGain1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", &a->tt__WhiteBalance::Mode, "tt:WhiteBalanceMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_CrGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:CrGain", &a->tt__WhiteBalance::CrGain, "xsd:float"))
				{	soap_flag_CrGain1--;
					continue;
				}
			}
			if (soap_flag_CbGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:CbGain", &a->tt__WhiteBalance::CbGain, "xsd:float"))
				{	soap_flag_CbGain1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__WhiteBalance::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0 || soap_flag_CrGain1 > 0 || soap_flag_CbGain1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WhiteBalance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance, SOAP_TYPE_tt__WhiteBalance, sizeof(tt__WhiteBalance), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalance * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalance(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalance *p;
	size_t k = sizeof(tt__WhiteBalance);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalance, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalance);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalance, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalance location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalance::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalance(soap, tag ? tag : "tt:WhiteBalance", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalance::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalance(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalance * SOAP_FMAC4 soap_get_tt__WhiteBalance(struct soap *soap, tt__WhiteBalance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ContinuousFocusOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ContinuousFocusOptions::Speed = NULL;
}

void tt__ContinuousFocusOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ContinuousFocusOptions::Speed);
#endif
}

int tt__ContinuousFocusOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ContinuousFocusOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, const tt__ContinuousFocusOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ContinuousFocusOptions), type))
		return soap->error;
	if (!a->tt__ContinuousFocusOptions::Speed)
	{	if (soap_element_empty(soap, "tt:Speed"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->tt__ContinuousFocusOptions::Speed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ContinuousFocusOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ContinuousFocusOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ContinuousFocusOptions * SOAP_FMAC4 soap_in_tt__ContinuousFocusOptions(struct soap *soap, const char *tag, tt__ContinuousFocusOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ContinuousFocusOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(tt__ContinuousFocusOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ContinuousFocusOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ContinuousFocusOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->tt__ContinuousFocusOptions::Speed, "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__ContinuousFocusOptions::Speed))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ContinuousFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocusOptions, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(tt__ContinuousFocusOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ContinuousFocusOptions * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocusOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ContinuousFocusOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ContinuousFocusOptions *p;
	size_t k = sizeof(tt__ContinuousFocusOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ContinuousFocusOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ContinuousFocusOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ContinuousFocusOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ContinuousFocusOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ContinuousFocusOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ContinuousFocusOptions(soap, tag ? tag : "tt:ContinuousFocusOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ContinuousFocusOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ContinuousFocusOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ContinuousFocusOptions * SOAP_FMAC4 soap_get_tt__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelativeFocusOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__RelativeFocusOptions::Distance = NULL;
	this->tt__RelativeFocusOptions::Speed = NULL;
}

void tt__RelativeFocusOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__RelativeFocusOptions::Distance);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__RelativeFocusOptions::Speed);
#endif
}

int tt__RelativeFocusOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelativeFocusOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocusOptions(struct soap *soap, const char *tag, int id, const tt__RelativeFocusOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocusOptions), type))
		return soap->error;
	if (!a->tt__RelativeFocusOptions::Distance)
	{	if (soap_element_empty(soap, "tt:Distance"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Distance", -1, &a->tt__RelativeFocusOptions::Distance, ""))
		return soap->error;
	if (!a->tt__RelativeFocusOptions::Speed)
	{	if (soap_element_empty(soap, "tt:Speed"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->tt__RelativeFocusOptions::Speed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelativeFocusOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelativeFocusOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions * SOAP_FMAC4 soap_in_tt__RelativeFocusOptions(struct soap *soap, const char *tag, tt__RelativeFocusOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelativeFocusOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions, sizeof(tt__RelativeFocusOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelativeFocusOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelativeFocusOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Distance1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Distance", &a->tt__RelativeFocusOptions::Distance, "tt:FloatRange"))
				{	soap_flag_Distance1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->tt__RelativeFocusOptions::Speed, "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__RelativeFocusOptions::Distance || !a->tt__RelativeFocusOptions::Speed))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelativeFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions, SOAP_TYPE_tt__RelativeFocusOptions, sizeof(tt__RelativeFocusOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelativeFocusOptions * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelativeFocusOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelativeFocusOptions *p;
	size_t k = sizeof(tt__RelativeFocusOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelativeFocusOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelativeFocusOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelativeFocusOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelativeFocusOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelativeFocusOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelativeFocusOptions(soap, tag ? tag : "tt:RelativeFocusOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelativeFocusOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelativeFocusOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions * SOAP_FMAC4 soap_get_tt__RelativeFocusOptions(struct soap *soap, tt__RelativeFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AbsoluteFocusOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__AbsoluteFocusOptions::Position = NULL;
	this->tt__AbsoluteFocusOptions::Speed = NULL;
}

void tt__AbsoluteFocusOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__AbsoluteFocusOptions::Position);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__AbsoluteFocusOptions::Speed);
#endif
}

int tt__AbsoluteFocusOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AbsoluteFocusOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, const tt__AbsoluteFocusOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AbsoluteFocusOptions), type))
		return soap->error;
	if (!a->tt__AbsoluteFocusOptions::Position)
	{	if (soap_element_empty(soap, "tt:Position"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Position", -1, &a->tt__AbsoluteFocusOptions::Position, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->tt__AbsoluteFocusOptions::Speed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AbsoluteFocusOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AbsoluteFocusOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_in_tt__AbsoluteFocusOptions(struct soap *soap, const char *tag, tt__AbsoluteFocusOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AbsoluteFocusOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(tt__AbsoluteFocusOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AbsoluteFocusOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AbsoluteFocusOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Position", &a->tt__AbsoluteFocusOptions::Position, "tt:FloatRange"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->tt__AbsoluteFocusOptions::Speed, "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__AbsoluteFocusOptions::Position))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AbsoluteFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocusOptions, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(tt__AbsoluteFocusOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AbsoluteFocusOptions * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocusOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AbsoluteFocusOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AbsoluteFocusOptions *p;
	size_t k = sizeof(tt__AbsoluteFocusOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AbsoluteFocusOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AbsoluteFocusOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AbsoluteFocusOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AbsoluteFocusOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AbsoluteFocusOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AbsoluteFocusOptions(soap, tag ? tag : "tt:AbsoluteFocusOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AbsoluteFocusOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AbsoluteFocusOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_get_tt__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MoveOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__MoveOptions::Absolute = NULL;
	this->tt__MoveOptions::Relative = NULL;
	this->tt__MoveOptions::Continuous = NULL;
}

void tt__MoveOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AbsoluteFocusOptions(soap, &this->tt__MoveOptions::Absolute);
	soap_serialize_PointerTott__RelativeFocusOptions(soap, &this->tt__MoveOptions::Relative);
	soap_serialize_PointerTott__ContinuousFocusOptions(soap, &this->tt__MoveOptions::Continuous);
#endif
}

int tt__MoveOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MoveOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveOptions(struct soap *soap, const char *tag, int id, const tt__MoveOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveOptions), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", -1, &a->tt__MoveOptions::Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocusOptions(soap, "tt:Relative", -1, &a->tt__MoveOptions::Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", -1, &a->tt__MoveOptions::Continuous, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MoveOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MoveOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__MoveOptions * SOAP_FMAC4 soap_in_tt__MoveOptions(struct soap *soap, const char *tag, tt__MoveOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MoveOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions, sizeof(tt__MoveOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MoveOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MoveOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Absolute1 = 1;
	size_t soap_flag_Relative1 = 1;
	size_t soap_flag_Continuous1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", &a->tt__MoveOptions::Absolute, "tt:AbsoluteFocusOptions"))
				{	soap_flag_Absolute1--;
					continue;
				}
			}
			if (soap_flag_Relative1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelativeFocusOptions(soap, "tt:Relative", &a->tt__MoveOptions::Relative, "tt:RelativeFocusOptions"))
				{	soap_flag_Relative1--;
					continue;
				}
			}
			if (soap_flag_Continuous1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", &a->tt__MoveOptions::Continuous, "tt:ContinuousFocusOptions"))
				{	soap_flag_Continuous1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MoveOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions, SOAP_TYPE_tt__MoveOptions, sizeof(tt__MoveOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MoveOptions * SOAP_FMAC2 soap_instantiate_tt__MoveOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MoveOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MoveOptions *p;
	size_t k = sizeof(tt__MoveOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MoveOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MoveOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MoveOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MoveOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MoveOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MoveOptions(soap, tag ? tag : "tt:MoveOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MoveOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MoveOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__MoveOptions * SOAP_FMAC4 soap_get_tt__MoveOptions(struct soap *soap, tt__MoveOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ContinuousFocus::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__ContinuousFocus::Speed);
}

void tt__ContinuousFocus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ContinuousFocus::Speed, SOAP_TYPE_float);
#endif
}

int tt__ContinuousFocus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ContinuousFocus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocus(struct soap *soap, const char *tag, int id, const tt__ContinuousFocus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ContinuousFocus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Speed", -1, &a->tt__ContinuousFocus::Speed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ContinuousFocus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ContinuousFocus(soap, tag, this, type);
}

SOAP_FMAC3 tt__ContinuousFocus * SOAP_FMAC4 soap_in_tt__ContinuousFocus(struct soap *soap, const char *tag, tt__ContinuousFocus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ContinuousFocus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocus, sizeof(tt__ContinuousFocus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ContinuousFocus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ContinuousFocus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Speed", &a->tt__ContinuousFocus::Speed, "xsd:float"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Speed1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ContinuousFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocus, SOAP_TYPE_tt__ContinuousFocus, sizeof(tt__ContinuousFocus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ContinuousFocus * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ContinuousFocus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ContinuousFocus *p;
	size_t k = sizeof(tt__ContinuousFocus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ContinuousFocus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ContinuousFocus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ContinuousFocus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ContinuousFocus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ContinuousFocus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ContinuousFocus(soap, tag ? tag : "tt:ContinuousFocus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ContinuousFocus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ContinuousFocus(soap, this, tag, type);
}

SOAP_FMAC3 tt__ContinuousFocus * SOAP_FMAC4 soap_get_tt__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelativeFocus::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__RelativeFocus::Distance);
	this->tt__RelativeFocus::Speed = NULL;
}

void tt__RelativeFocus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RelativeFocus::Distance, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &this->tt__RelativeFocus::Speed);
#endif
}

int tt__RelativeFocus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelativeFocus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocus(struct soap *soap, const char *tag, int id, const tt__RelativeFocus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Distance", -1, &a->tt__RelativeFocus::Distance, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &a->tt__RelativeFocus::Speed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelativeFocus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelativeFocus(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelativeFocus * SOAP_FMAC4 soap_in_tt__RelativeFocus(struct soap *soap, const char *tag, tt__RelativeFocus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelativeFocus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocus, sizeof(tt__RelativeFocus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelativeFocus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelativeFocus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Distance1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Distance", &a->tt__RelativeFocus::Distance, "xsd:float"))
				{	soap_flag_Distance1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Speed", &a->tt__RelativeFocus::Speed, "xsd:float"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelativeFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocus, SOAP_TYPE_tt__RelativeFocus, sizeof(tt__RelativeFocus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelativeFocus * SOAP_FMAC2 soap_instantiate_tt__RelativeFocus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelativeFocus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelativeFocus *p;
	size_t k = sizeof(tt__RelativeFocus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelativeFocus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelativeFocus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelativeFocus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelativeFocus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelativeFocus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelativeFocus(soap, tag ? tag : "tt:RelativeFocus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelativeFocus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelativeFocus(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelativeFocus * SOAP_FMAC4 soap_get_tt__RelativeFocus(struct soap *soap, tt__RelativeFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AbsoluteFocus::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__AbsoluteFocus::Position);
	this->tt__AbsoluteFocus::Speed = NULL;
}

void tt__AbsoluteFocus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AbsoluteFocus::Position, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &this->tt__AbsoluteFocus::Speed);
#endif
}

int tt__AbsoluteFocus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AbsoluteFocus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocus(struct soap *soap, const char *tag, int id, const tt__AbsoluteFocus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AbsoluteFocus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->tt__AbsoluteFocus::Position, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &a->tt__AbsoluteFocus::Speed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AbsoluteFocus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AbsoluteFocus(soap, tag, this, type);
}

SOAP_FMAC3 tt__AbsoluteFocus * SOAP_FMAC4 soap_in_tt__AbsoluteFocus(struct soap *soap, const char *tag, tt__AbsoluteFocus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AbsoluteFocus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(tt__AbsoluteFocus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AbsoluteFocus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AbsoluteFocus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Position", &a->tt__AbsoluteFocus::Position, "xsd:float"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Speed", &a->tt__AbsoluteFocus::Speed, "xsd:float"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AbsoluteFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocus, SOAP_TYPE_tt__AbsoluteFocus, sizeof(tt__AbsoluteFocus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AbsoluteFocus * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AbsoluteFocus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AbsoluteFocus *p;
	size_t k = sizeof(tt__AbsoluteFocus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AbsoluteFocus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AbsoluteFocus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AbsoluteFocus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AbsoluteFocus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AbsoluteFocus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AbsoluteFocus(soap, tag ? tag : "tt:AbsoluteFocus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AbsoluteFocus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AbsoluteFocus(soap, this, tag, type);
}

SOAP_FMAC3 tt__AbsoluteFocus * SOAP_FMAC4 soap_get_tt__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusMove::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__FocusMove::Absolute = NULL;
	this->tt__FocusMove::Relative = NULL;
	this->tt__FocusMove::Continuous = NULL;
}

void tt__FocusMove::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AbsoluteFocus(soap, &this->tt__FocusMove::Absolute);
	soap_serialize_PointerTott__RelativeFocus(soap, &this->tt__FocusMove::Relative);
	soap_serialize_PointerTott__ContinuousFocus(soap, &this->tt__FocusMove::Continuous);
#endif
}

int tt__FocusMove::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusMove(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusMove(struct soap *soap, const char *tag, int id, const tt__FocusMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusMove), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocus(soap, "tt:Absolute", -1, &a->tt__FocusMove::Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocus(soap, "tt:Relative", -1, &a->tt__FocusMove::Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocus(soap, "tt:Continuous", -1, &a->tt__FocusMove::Continuous, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusMove::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusMove(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusMove * SOAP_FMAC4 soap_in_tt__FocusMove(struct soap *soap, const char *tag, tt__FocusMove *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusMove*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusMove, sizeof(tt__FocusMove), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusMove)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusMove *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Absolute1 = 1;
	size_t soap_flag_Relative1 = 1;
	size_t soap_flag_Continuous1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AbsoluteFocus(soap, "tt:Absolute", &a->tt__FocusMove::Absolute, "tt:AbsoluteFocus"))
				{	soap_flag_Absolute1--;
					continue;
				}
			}
			if (soap_flag_Relative1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelativeFocus(soap, "tt:Relative", &a->tt__FocusMove::Relative, "tt:RelativeFocus"))
				{	soap_flag_Relative1--;
					continue;
				}
			}
			if (soap_flag_Continuous1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ContinuousFocus(soap, "tt:Continuous", &a->tt__FocusMove::Continuous, "tt:ContinuousFocus"))
				{	soap_flag_Continuous1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusMove, SOAP_TYPE_tt__FocusMove, sizeof(tt__FocusMove), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusMove * SOAP_FMAC2 soap_instantiate_tt__FocusMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusMove(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusMove *p;
	size_t k = sizeof(tt__FocusMove);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusMove, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusMove);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusMove, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusMove location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusMove::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusMove(soap, tag ? tag : "tt:FocusMove", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusMove::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusMove(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusMove * SOAP_FMAC4 soap_get_tt__FocusMove(struct soap *soap, tt__FocusMove *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalanceOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceOptions::Mode);
	this->tt__WhiteBalanceOptions::YrGain = NULL;
	this->tt__WhiteBalanceOptions::YbGain = NULL;
}

void tt__WhiteBalanceOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceOptions::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WhiteBalanceOptions::YrGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WhiteBalanceOptions::YbGain);
#endif
}

int tt__WhiteBalanceOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalanceOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions(struct soap *soap, const char *tag, int id, const tt__WhiteBalanceOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->tt__WhiteBalanceOptions::Mode, ""))
		return soap->error;
	if (!a->tt__WhiteBalanceOptions::YrGain)
	{	if (soap_element_empty(soap, "tt:YrGain"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:YrGain", -1, &a->tt__WhiteBalanceOptions::YrGain, ""))
		return soap->error;
	if (!a->tt__WhiteBalanceOptions::YbGain)
	{	if (soap_element_empty(soap, "tt:YbGain"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:YbGain", -1, &a->tt__WhiteBalanceOptions::YbGain, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalanceOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalanceOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions(struct soap *soap, const char *tag, tt__WhiteBalanceOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalanceOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions, sizeof(tt__WhiteBalanceOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalanceOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalanceOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_YrGain1 = 1;
	size_t soap_flag_YbGain1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__WhiteBalanceMode(soap, "tt:Mode", &a->tt__WhiteBalanceOptions::Mode, "tt:WhiteBalanceMode"))
					continue;
			}
			if (soap_flag_YrGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YrGain", &a->tt__WhiteBalanceOptions::YrGain, "tt:FloatRange"))
				{	soap_flag_YrGain1--;
					continue;
				}
			}
			if (soap_flag_YbGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YbGain", &a->tt__WhiteBalanceOptions::YbGain, "tt:FloatRange"))
				{	soap_flag_YbGain1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__WhiteBalanceOptions::Mode.size() < 1 || !a->tt__WhiteBalanceOptions::YrGain || !a->tt__WhiteBalanceOptions::YbGain))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WhiteBalanceOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions, SOAP_TYPE_tt__WhiteBalanceOptions, sizeof(tt__WhiteBalanceOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalanceOptions * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalanceOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalanceOptions *p;
	size_t k = sizeof(tt__WhiteBalanceOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalanceOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalanceOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalanceOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalanceOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalanceOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalanceOptions(soap, tag ? tag : "tt:WhiteBalanceOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalanceOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalanceOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions(struct soap *soap, tt__WhiteBalanceOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ExposureOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__ExposureMode(soap, &this->tt__ExposureOptions::Mode);
	soap_default_std__vectorTemplateOftt__ExposurePriority(soap, &this->tt__ExposureOptions::Priority);
	this->tt__ExposureOptions::MinExposureTime = NULL;
	this->tt__ExposureOptions::MaxExposureTime = NULL;
	this->tt__ExposureOptions::MinGain = NULL;
	this->tt__ExposureOptions::MaxGain = NULL;
	this->tt__ExposureOptions::MinIris = NULL;
	this->tt__ExposureOptions::MaxIris = NULL;
	this->tt__ExposureOptions::ExposureTime = NULL;
	this->tt__ExposureOptions::Gain = NULL;
	this->tt__ExposureOptions::Iris = NULL;
}

void tt__ExposureOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ExposureMode(soap, &this->tt__ExposureOptions::Mode);
	soap_serialize_std__vectorTemplateOftt__ExposurePriority(soap, &this->tt__ExposureOptions::Priority);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::MinExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::MaxExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::MinGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::MaxGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::MinIris);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::MaxIris);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::ExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::Gain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::Iris);
#endif
}

int tt__ExposureOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ExposureOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureOptions(struct soap *soap, const char *tag, int id, const tt__ExposureOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ExposureMode(soap, "tt:Mode", -1, &a->tt__ExposureOptions::Mode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ExposurePriority(soap, "tt:Priority", -1, &a->tt__ExposureOptions::Priority, ""))
		return soap->error;
	if (!a->tt__ExposureOptions::MinExposureTime)
	{	if (soap_element_empty(soap, "tt:MinExposureTime"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:MinExposureTime", -1, &a->tt__ExposureOptions::MinExposureTime, ""))
		return soap->error;
	if (!a->tt__ExposureOptions::MaxExposureTime)
	{	if (soap_element_empty(soap, "tt:MaxExposureTime"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:MaxExposureTime", -1, &a->tt__ExposureOptions::MaxExposureTime, ""))
		return soap->error;
	if (!a->tt__ExposureOptions::MinGain)
	{	if (soap_element_empty(soap, "tt:MinGain"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:MinGain", -1, &a->tt__ExposureOptions::MinGain, ""))
		return soap->error;
	if (!a->tt__ExposureOptions::MaxGain)
	{	if (soap_element_empty(soap, "tt:MaxGain"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:MaxGain", -1, &a->tt__ExposureOptions::MaxGain, ""))
		return soap->error;
	if (!a->tt__ExposureOptions::MinIris)
	{	if (soap_element_empty(soap, "tt:MinIris"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:MinIris", -1, &a->tt__ExposureOptions::MinIris, ""))
		return soap->error;
	if (!a->tt__ExposureOptions::MaxIris)
	{	if (soap_element_empty(soap, "tt:MaxIris"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:MaxIris", -1, &a->tt__ExposureOptions::MaxIris, ""))
		return soap->error;
	if (!a->tt__ExposureOptions::ExposureTime)
	{	if (soap_element_empty(soap, "tt:ExposureTime"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:ExposureTime", -1, &a->tt__ExposureOptions::ExposureTime, ""))
		return soap->error;
	if (!a->tt__ExposureOptions::Gain)
	{	if (soap_element_empty(soap, "tt:Gain"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Gain", -1, &a->tt__ExposureOptions::Gain, ""))
		return soap->error;
	if (!a->tt__ExposureOptions::Iris)
	{	if (soap_element_empty(soap, "tt:Iris"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Iris", -1, &a->tt__ExposureOptions::Iris, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ExposureOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ExposureOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ExposureOptions * SOAP_FMAC4 soap_in_tt__ExposureOptions(struct soap *soap, const char *tag, tt__ExposureOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ExposureOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions, sizeof(tt__ExposureOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ExposureOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ExposureOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ExposureMode(soap, "tt:Mode", &a->tt__ExposureOptions::Mode, "tt:ExposureMode"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ExposurePriority(soap, "tt:Priority", &a->tt__ExposureOptions::Priority, "tt:ExposurePriority"))
					continue;
			}
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinExposureTime", &a->tt__ExposureOptions::MinExposureTime, "tt:FloatRange"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxExposureTime", &a->tt__ExposureOptions::MaxExposureTime, "tt:FloatRange"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinGain", &a->tt__ExposureOptions::MinGain, "tt:FloatRange"))
				{	soap_flag_MinGain1--;
					continue;
				}
			}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxGain", &a->tt__ExposureOptions::MaxGain, "tt:FloatRange"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinIris", &a->tt__ExposureOptions::MinIris, "tt:FloatRange"))
				{	soap_flag_MinIris1--;
					continue;
				}
			}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxIris", &a->tt__ExposureOptions::MaxIris, "tt:FloatRange"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:ExposureTime", &a->tt__ExposureOptions::ExposureTime, "tt:FloatRange"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Gain", &a->tt__ExposureOptions::Gain, "tt:FloatRange"))
				{	soap_flag_Gain1--;
					continue;
				}
			}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Iris", &a->tt__ExposureOptions::Iris, "tt:FloatRange"))
				{	soap_flag_Iris1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__ExposureOptions::Mode.size() < 1 || a->tt__ExposureOptions::Priority.size() < 1 || !a->tt__ExposureOptions::MinExposureTime || !a->tt__ExposureOptions::MaxExposureTime || !a->tt__ExposureOptions::MinGain || !a->tt__ExposureOptions::MaxGain || !a->tt__ExposureOptions::MinIris || !a->tt__ExposureOptions::MaxIris || !a->tt__ExposureOptions::ExposureTime || !a->tt__ExposureOptions::Gain || !a->tt__ExposureOptions::Iris))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ExposureOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions, SOAP_TYPE_tt__ExposureOptions, sizeof(tt__ExposureOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ExposureOptions * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ExposureOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ExposureOptions *p;
	size_t k = sizeof(tt__ExposureOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ExposureOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ExposureOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ExposureOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ExposureOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ExposureOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ExposureOptions(soap, tag ? tag : "tt:ExposureOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ExposureOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ExposureOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ExposureOptions * SOAP_FMAC4 soap_get_tt__ExposureOptions(struct soap *soap, tt__ExposureOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__AutoFocusMode(soap, &this->tt__FocusOptions::AutoFocusModes);
	this->tt__FocusOptions::DefaultSpeed = NULL;
	this->tt__FocusOptions::NearLimit = NULL;
	this->tt__FocusOptions::FarLimit = NULL;
}

void tt__FocusOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__AutoFocusMode(soap, &this->tt__FocusOptions::AutoFocusModes);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions::DefaultSpeed);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions::NearLimit);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions::FarLimit);
#endif
}

int tt__FocusOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions(struct soap *soap, const char *tag, int id, const tt__FocusOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__AutoFocusMode(soap, "tt:AutoFocusModes", -1, &a->tt__FocusOptions::AutoFocusModes, ""))
		return soap->error;
	if (!a->tt__FocusOptions::DefaultSpeed)
	{	if (soap_element_empty(soap, "tt:DefaultSpeed"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:DefaultSpeed", -1, &a->tt__FocusOptions::DefaultSpeed, ""))
		return soap->error;
	if (!a->tt__FocusOptions::NearLimit)
	{	if (soap_element_empty(soap, "tt:NearLimit"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:NearLimit", -1, &a->tt__FocusOptions::NearLimit, ""))
		return soap->error;
	if (!a->tt__FocusOptions::FarLimit)
	{	if (soap_element_empty(soap, "tt:FarLimit"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:FarLimit", -1, &a->tt__FocusOptions::FarLimit, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusOptions * SOAP_FMAC4 soap_in_tt__FocusOptions(struct soap *soap, const char *tag, tt__FocusOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions, sizeof(tt__FocusOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__AutoFocusMode(soap, "tt:AutoFocusModes", &a->tt__FocusOptions::AutoFocusModes, "tt:AutoFocusMode"))
					continue;
			}
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:DefaultSpeed", &a->tt__FocusOptions::DefaultSpeed, "tt:FloatRange"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:NearLimit", &a->tt__FocusOptions::NearLimit, "tt:FloatRange"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:FarLimit", &a->tt__FocusOptions::FarLimit, "tt:FloatRange"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__FocusOptions::DefaultSpeed || !a->tt__FocusOptions::NearLimit || !a->tt__FocusOptions::FarLimit))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions, SOAP_TYPE_tt__FocusOptions, sizeof(tt__FocusOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusOptions * SOAP_FMAC2 soap_instantiate_tt__FocusOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusOptions *p;
	size_t k = sizeof(tt__FocusOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusOptions(soap, tag ? tag : "tt:FocusOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusOptions * SOAP_FMAC4 soap_get_tt__FocusOptions(struct soap *soap, tt__FocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BacklightCompensationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__BacklightCompensationOptions::Mode);
	this->tt__BacklightCompensationOptions::Level = NULL;
}

void tt__BacklightCompensationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__BacklightCompensationOptions::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__BacklightCompensationOptions::Level);
#endif
}

int tt__BacklightCompensationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationOptions(struct soap *soap, const char *tag, int id, const tt__BacklightCompensationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", -1, &a->tt__BacklightCompensationOptions::Mode, ""))
		return soap->error;
	if (!a->tt__BacklightCompensationOptions::Level)
	{	if (soap_element_empty(soap, "tt:Level"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__BacklightCompensationOptions::Level, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BacklightCompensationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions * SOAP_FMAC4 soap_in_tt__BacklightCompensationOptions(struct soap *soap, const char *tag, tt__BacklightCompensationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions, sizeof(tt__BacklightCompensationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BacklightCompensationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BacklightCompensationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", &a->tt__BacklightCompensationOptions::Mode, "tt:WideDynamicMode"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->tt__BacklightCompensationOptions::Level, "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__BacklightCompensationOptions::Mode.size() < 1 || !a->tt__BacklightCompensationOptions::Level))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BacklightCompensationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions, SOAP_TYPE_tt__BacklightCompensationOptions, sizeof(tt__BacklightCompensationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BacklightCompensationOptions * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BacklightCompensationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BacklightCompensationOptions *p;
	size_t k = sizeof(tt__BacklightCompensationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BacklightCompensationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BacklightCompensationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BacklightCompensationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BacklightCompensationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BacklightCompensationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BacklightCompensationOptions(soap, tag ? tag : "tt:BacklightCompensationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions * SOAP_FMAC4 soap_get_tt__BacklightCompensationOptions(struct soap *soap, tt__BacklightCompensationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WideDynamicRangeOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__WideDynamicRangeOptions::Mode);
	this->tt__WideDynamicRangeOptions::Level = NULL;
}

void tt__WideDynamicRangeOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__WideDynamicRangeOptions::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WideDynamicRangeOptions::Level);
#endif
}

int tt__WideDynamicRangeOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRangeOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRangeOptions(struct soap *soap, const char *tag, int id, const tt__WideDynamicRangeOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRangeOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", -1, &a->tt__WideDynamicRangeOptions::Mode, ""))
		return soap->error;
	if (!a->tt__WideDynamicRangeOptions::Level)
	{	if (soap_element_empty(soap, "tt:Level"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__WideDynamicRangeOptions::Level, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRangeOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WideDynamicRangeOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions * SOAP_FMAC4 soap_in_tt__WideDynamicRangeOptions(struct soap *soap, const char *tag, tt__WideDynamicRangeOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRangeOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions, sizeof(tt__WideDynamicRangeOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WideDynamicRangeOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WideDynamicRangeOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", &a->tt__WideDynamicRangeOptions::Mode, "tt:WideDynamicMode"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->tt__WideDynamicRangeOptions::Level, "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->tt__WideDynamicRangeOptions::Mode.size() < 1 || !a->tt__WideDynamicRangeOptions::Level))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WideDynamicRangeOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions, SOAP_TYPE_tt__WideDynamicRangeOptions, sizeof(tt__WideDynamicRangeOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WideDynamicRangeOptions * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WideDynamicRangeOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WideDynamicRangeOptions *p;
	size_t k = sizeof(tt__WideDynamicRangeOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WideDynamicRangeOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WideDynamicRangeOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WideDynamicRangeOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WideDynamicRangeOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WideDynamicRangeOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WideDynamicRangeOptions(soap, tag ? tag : "tt:WideDynamicRangeOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRangeOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRangeOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions * SOAP_FMAC4 soap_get_tt__WideDynamicRangeOptions(struct soap *soap, tt__WideDynamicRangeOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRangeOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ImagingOptions::BacklightCompensation = NULL;
	this->tt__ImagingOptions::Brightness = NULL;
	this->tt__ImagingOptions::ColorSaturation = NULL;
	this->tt__ImagingOptions::Contrast = NULL;
	this->tt__ImagingOptions::Exposure = NULL;
	this->tt__ImagingOptions::Focus = NULL;
	soap_default_std__vectorTemplateOftt__IrCutFilterMode(soap, &this->tt__ImagingOptions::IrCutFilterModes);
	this->tt__ImagingOptions::Sharpness = NULL;
	this->tt__ImagingOptions::WideDynamicRange = NULL;
	this->tt__ImagingOptions::WhiteBalance = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingOptions::__anyAttribute);
}

void tt__ImagingOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensationOptions(soap, &this->tt__ImagingOptions::BacklightCompensation);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions::Brightness);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions::ColorSaturation);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions::Contrast);
	soap_serialize_PointerTott__ExposureOptions(soap, &this->tt__ImagingOptions::Exposure);
	soap_serialize_PointerTott__FocusOptions(soap, &this->tt__ImagingOptions::Focus);
	soap_serialize_std__vectorTemplateOftt__IrCutFilterMode(soap, &this->tt__ImagingOptions::IrCutFilterModes);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions::Sharpness);
	soap_serialize_PointerTott__WideDynamicRangeOptions(soap, &this->tt__ImagingOptions::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalanceOptions(soap, &this->tt__ImagingOptions::WhiteBalance);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingOptions::__any);
#endif
}

int tt__ImagingOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions(struct soap *soap, const char *tag, int id, const tt__ImagingOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions), type))
		return soap->error;
	if (!a->tt__ImagingOptions::BacklightCompensation)
	{	if (soap_element_empty(soap, "tt:BacklightCompensation"))
			return soap->error;
	}
	else if (soap_out_PointerTott__BacklightCompensationOptions(soap, "tt:BacklightCompensation", -1, &a->tt__ImagingOptions::BacklightCompensation, ""))
		return soap->error;
	if (!a->tt__ImagingOptions::Brightness)
	{	if (soap_element_empty(soap, "tt:Brightness"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Brightness", -1, &a->tt__ImagingOptions::Brightness, ""))
		return soap->error;
	if (!a->tt__ImagingOptions::ColorSaturation)
	{	if (soap_element_empty(soap, "tt:ColorSaturation"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:ColorSaturation", -1, &a->tt__ImagingOptions::ColorSaturation, ""))
		return soap->error;
	if (!a->tt__ImagingOptions::Contrast)
	{	if (soap_element_empty(soap, "tt:Contrast"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Contrast", -1, &a->tt__ImagingOptions::Contrast, ""))
		return soap->error;
	if (!a->tt__ImagingOptions::Exposure)
	{	if (soap_element_empty(soap, "tt:Exposure"))
			return soap->error;
	}
	else if (soap_out_PointerTott__ExposureOptions(soap, "tt:Exposure", -1, &a->tt__ImagingOptions::Exposure, ""))
		return soap->error;
	if (!a->tt__ImagingOptions::Focus)
	{	if (soap_element_empty(soap, "tt:Focus"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FocusOptions(soap, "tt:Focus", -1, &a->tt__ImagingOptions::Focus, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IrCutFilterMode(soap, "tt:IrCutFilterModes", -1, &a->tt__ImagingOptions::IrCutFilterModes, ""))
		return soap->error;
	if (!a->tt__ImagingOptions::Sharpness)
	{	if (soap_element_empty(soap, "tt:Sharpness"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Sharpness", -1, &a->tt__ImagingOptions::Sharpness, ""))
		return soap->error;
	if (!a->tt__ImagingOptions::WideDynamicRange)
	{	if (soap_element_empty(soap, "tt:WideDynamicRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__WideDynamicRangeOptions(soap, "tt:WideDynamicRange", -1, &a->tt__ImagingOptions::WideDynamicRange, ""))
		return soap->error;
	if (!a->tt__ImagingOptions::WhiteBalance)
	{	if (soap_element_empty(soap, "tt:WhiteBalance"))
			return soap->error;
	}
	else if (soap_out_PointerTott__WhiteBalanceOptions(soap, "tt:WhiteBalance", -1, &a->tt__ImagingOptions::WhiteBalance, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ImagingOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions * SOAP_FMAC4 soap_in_tt__ImagingOptions(struct soap *soap, const char *tag, tt__ImagingOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions, sizeof(tt__ImagingOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BacklightCompensationOptions(soap, "tt:BacklightCompensation", &a->tt__ImagingOptions::BacklightCompensation, "tt:BacklightCompensationOptions"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Brightness", &a->tt__ImagingOptions::Brightness, "tt:FloatRange"))
				{	soap_flag_Brightness1--;
					continue;
				}
			}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:ColorSaturation", &a->tt__ImagingOptions::ColorSaturation, "tt:FloatRange"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Contrast", &a->tt__ImagingOptions::Contrast, "tt:FloatRange"))
				{	soap_flag_Contrast1--;
					continue;
				}
			}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ExposureOptions(soap, "tt:Exposure", &a->tt__ImagingOptions::Exposure, "tt:ExposureOptions"))
				{	soap_flag_Exposure1--;
					continue;
				}
			}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusOptions(soap, "tt:Focus", &a->tt__ImagingOptions::Focus, "tt:FocusOptions"))
				{	soap_flag_Focus1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IrCutFilterMode(soap, "tt:IrCutFilterModes", &a->tt__ImagingOptions::IrCutFilterModes, "tt:IrCutFilterMode"))
					continue;
			}
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Sharpness", &a->tt__ImagingOptions::Sharpness, "tt:FloatRange"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WideDynamicRangeOptions(soap, "tt:WideDynamicRange", &a->tt__ImagingOptions::WideDynamicRange, "tt:WideDynamicRangeOptions"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalanceOptions(soap, "tt:WhiteBalance", &a->tt__ImagingOptions::WhiteBalance, "tt:WhiteBalanceOptions"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ImagingOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__ImagingOptions::BacklightCompensation || !a->tt__ImagingOptions::Brightness || !a->tt__ImagingOptions::ColorSaturation || !a->tt__ImagingOptions::Contrast || !a->tt__ImagingOptions::Exposure || !a->tt__ImagingOptions::Focus || a->tt__ImagingOptions::IrCutFilterModes.size() < 1 || !a->tt__ImagingOptions::Sharpness || !a->tt__ImagingOptions::WideDynamicRange || !a->tt__ImagingOptions::WhiteBalance))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ImagingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions, SOAP_TYPE_tt__ImagingOptions, sizeof(tt__ImagingOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions *p;
	size_t k = sizeof(tt__ImagingOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions(soap, tag ? tag : "tt:ImagingOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions * SOAP_FMAC4 soap_get_tt__ImagingOptions(struct soap *soap, tt__ImagingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BacklightCompensation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__BacklightCompensationMode(soap, &this->tt__BacklightCompensation::Mode);
	soap_default_float(soap, &this->tt__BacklightCompensation::Level);
}

void tt__BacklightCompensation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__BacklightCompensation::Level, SOAP_TYPE_float);
#endif
}

int tt__BacklightCompensation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation(struct soap *soap, const char *tag, int id, const tt__BacklightCompensation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensation), type))
		return soap->error;
	if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->tt__BacklightCompensation::Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &a->tt__BacklightCompensation::Level, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BacklightCompensation(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensation * SOAP_FMAC4 soap_in_tt__BacklightCompensation(struct soap *soap, const char *tag, tt__BacklightCompensation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation, sizeof(tt__BacklightCompensation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BacklightCompensation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BacklightCompensation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", &a->tt__BacklightCompensation::Mode, "tt:BacklightCompensationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Level", &a->tt__BacklightCompensation::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0 || soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BacklightCompensation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation, SOAP_TYPE_tt__BacklightCompensation, sizeof(tt__BacklightCompensation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BacklightCompensation * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BacklightCompensation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BacklightCompensation *p;
	size_t k = sizeof(tt__BacklightCompensation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BacklightCompensation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BacklightCompensation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BacklightCompensation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BacklightCompensation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BacklightCompensation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BacklightCompensation(soap, tag ? tag : "tt:BacklightCompensation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensation(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensation * SOAP_FMAC4 soap_get_tt__BacklightCompensation(struct soap *soap, tt__BacklightCompensation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WideDynamicRange::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__WideDynamicMode(soap, &this->tt__WideDynamicRange::Mode);
	soap_default_float(soap, &this->tt__WideDynamicRange::Level);
}

void tt__WideDynamicRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__WideDynamicRange::Level, SOAP_TYPE_float);
#endif
}

int tt__WideDynamicRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange(struct soap *soap, const char *tag, int id, const tt__WideDynamicRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRange), type))
		return soap->error;
	if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, &a->tt__WideDynamicRange::Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &a->tt__WideDynamicRange::Level, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WideDynamicRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRange * SOAP_FMAC4 soap_in_tt__WideDynamicRange(struct soap *soap, const char *tag, tt__WideDynamicRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange, sizeof(tt__WideDynamicRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WideDynamicRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WideDynamicRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", &a->tt__WideDynamicRange::Mode, "tt:WideDynamicMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Level", &a->tt__WideDynamicRange::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0 || soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WideDynamicRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange, SOAP_TYPE_tt__WideDynamicRange, sizeof(tt__WideDynamicRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WideDynamicRange * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WideDynamicRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WideDynamicRange *p;
	size_t k = sizeof(tt__WideDynamicRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WideDynamicRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WideDynamicRange);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WideDynamicRange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WideDynamicRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WideDynamicRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WideDynamicRange(soap, tag ? tag : "tt:WideDynamicRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRange * SOAP_FMAC4 soap_get_tt__WideDynamicRange(struct soap *soap, tt__WideDynamicRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Exposure::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ExposureMode(soap, &this->tt__Exposure::Mode);
	soap_default_tt__ExposurePriority(soap, &this->tt__Exposure::Priority);
	this->tt__Exposure::Window = NULL;
	soap_default_float(soap, &this->tt__Exposure::MinExposureTime);
	soap_default_float(soap, &this->tt__Exposure::MaxExposureTime);
	soap_default_float(soap, &this->tt__Exposure::MinGain);
	soap_default_float(soap, &this->tt__Exposure::MaxGain);
	soap_default_float(soap, &this->tt__Exposure::MinIris);
	soap_default_float(soap, &this->tt__Exposure::MaxIris);
	soap_default_float(soap, &this->tt__Exposure::ExposureTime);
	soap_default_float(soap, &this->tt__Exposure::Gain);
	soap_default_float(soap, &this->tt__Exposure::Iris);
}

void tt__Exposure::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Exposure::Priority, SOAP_TYPE_tt__ExposurePriority);
	soap_serialize_PointerTott__Rectangle(soap, &this->tt__Exposure::Window);
	soap_embedded(soap, &this->tt__Exposure::MinExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MaxExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MinGain, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MaxGain, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MinIris, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MaxIris, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::ExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::Gain, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::Iris, SOAP_TYPE_float);
#endif
}

int tt__Exposure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Exposure(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure(struct soap *soap, const char *tag, int id, const tt__Exposure *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Exposure), type))
		return soap->error;
	if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, &a->tt__Exposure::Mode, ""))
		return soap->error;
	if (soap_out_tt__ExposurePriority(soap, "tt:Priority", -1, &a->tt__Exposure::Priority, ""))
		return soap->error;
	if (!a->tt__Exposure::Window)
	{	if (soap_element_empty(soap, "tt:Window"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Rectangle(soap, "tt:Window", -1, &a->tt__Exposure::Window, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinExposureTime", -1, &a->tt__Exposure::MinExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxExposureTime", -1, &a->tt__Exposure::MaxExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinGain", -1, &a->tt__Exposure::MinGain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxGain", -1, &a->tt__Exposure::MaxGain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinIris", -1, &a->tt__Exposure::MinIris, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxIris", -1, &a->tt__Exposure::MaxIris, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:ExposureTime", -1, &a->tt__Exposure::ExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Gain", -1, &a->tt__Exposure::Gain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Iris", -1, &a->tt__Exposure::Iris, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Exposure::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Exposure(soap, tag, this, type);
}

SOAP_FMAC3 tt__Exposure * SOAP_FMAC4 soap_in_tt__Exposure(struct soap *soap, const char *tag, tt__Exposure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Exposure*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure, sizeof(tt__Exposure), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Exposure)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Exposure *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Priority1 = 1;
	size_t soap_flag_Window1 = 1;
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ExposureMode(soap, "tt:Mode", &a->tt__Exposure::Mode, "tt:ExposureMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Priority1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ExposurePriority(soap, "tt:Priority", &a->tt__Exposure::Priority, "tt:ExposurePriority"))
				{	soap_flag_Priority1--;
					continue;
				}
			}
			if (soap_flag_Window1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rectangle(soap, "tt:Window", &a->tt__Exposure::Window, "tt:Rectangle"))
				{	soap_flag_Window1--;
					continue;
				}
			}
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MinExposureTime", &a->tt__Exposure::MinExposureTime, "xsd:float"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MaxExposureTime", &a->tt__Exposure::MaxExposureTime, "xsd:float"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MinGain", &a->tt__Exposure::MinGain, "xsd:float"))
				{	soap_flag_MinGain1--;
					continue;
				}
			}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MaxGain", &a->tt__Exposure::MaxGain, "xsd:float"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MinIris", &a->tt__Exposure::MinIris, "xsd:float"))
				{	soap_flag_MinIris1--;
					continue;
				}
			}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MaxIris", &a->tt__Exposure::MaxIris, "xsd:float"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:ExposureTime", &a->tt__Exposure::ExposureTime, "xsd:float"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Gain", &a->tt__Exposure::Gain, "xsd:float"))
				{	soap_flag_Gain1--;
					continue;
				}
			}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Iris", &a->tt__Exposure::Iris, "xsd:float"))
				{	soap_flag_Iris1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0 || soap_flag_Priority1 > 0 || !a->tt__Exposure::Window || soap_flag_MinExposureTime1 > 0 || soap_flag_MaxExposureTime1 > 0 || soap_flag_MinGain1 > 0 || soap_flag_MaxGain1 > 0 || soap_flag_MinIris1 > 0 || soap_flag_MaxIris1 > 0 || soap_flag_ExposureTime1 > 0 || soap_flag_Gain1 > 0 || soap_flag_Iris1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Exposure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure, SOAP_TYPE_tt__Exposure, sizeof(tt__Exposure), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Exposure * SOAP_FMAC2 soap_instantiate_tt__Exposure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Exposure(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Exposure *p;
	size_t k = sizeof(tt__Exposure);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Exposure, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Exposure);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Exposure, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Exposure location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Exposure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Exposure(soap, tag ? tag : "tt:Exposure", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Exposure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Exposure(soap, this, tag, type);
}

SOAP_FMAC3 tt__Exposure * SOAP_FMAC4 soap_get_tt__Exposure(struct soap *soap, tt__Exposure *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Exposure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingSettingsExtension::__any);
}

void tt__ImagingSettingsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingSettingsExtension::__any);
#endif
}

int tt__ImagingSettingsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ImagingSettingsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension(struct soap *soap, const char *tag, tt__ImagingSettingsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(tt__ImagingSettingsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettingsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ImagingSettingsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(tt__ImagingSettingsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettingsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension *p;
	size_t k = sizeof(tt__ImagingSettingsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension(soap, tag ? tag : "tt:ImagingSettingsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension(struct soap *soap, tt__ImagingSettingsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettings::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ImagingSettings::BacklightCompensation = NULL;
	this->tt__ImagingSettings::Brightness = NULL;
	this->tt__ImagingSettings::ColorSaturation = NULL;
	this->tt__ImagingSettings::Contrast = NULL;
	this->tt__ImagingSettings::Exposure = NULL;
	this->tt__ImagingSettings::Focus = NULL;
	this->tt__ImagingSettings::IrCutFilter = NULL;
	this->tt__ImagingSettings::Sharpness = NULL;
	this->tt__ImagingSettings::WideDynamicRange = NULL;
	this->tt__ImagingSettings::WhiteBalance = NULL;
	this->tt__ImagingSettings::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingSettings::__anyAttribute);
}

void tt__ImagingSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensation(soap, &this->tt__ImagingSettings::BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings::Brightness);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings::ColorSaturation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings::Contrast);
	soap_serialize_PointerTott__Exposure(soap, &this->tt__ImagingSettings::Exposure);
	soap_serialize_PointerTott__FocusConfiguration(soap, &this->tt__ImagingSettings::Focus);
	soap_serialize_PointerTott__IrCutFilterMode(soap, &this->tt__ImagingSettings::IrCutFilter);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings::Sharpness);
	soap_serialize_PointerTott__WideDynamicRange(soap, &this->tt__ImagingSettings::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalance(soap, &this->tt__ImagingSettings::WhiteBalance);
	soap_serialize_PointerTott__ImagingSettingsExtension(soap, &this->tt__ImagingSettings::Extension);
#endif
}

int tt__ImagingSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings(struct soap *soap, const char *tag, int id, const tt__ImagingSettings *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingSettings*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettings), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensation(soap, "tt:BacklightCompensation", -1, &a->tt__ImagingSettings::BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Brightness", -1, &a->tt__ImagingSettings::Brightness, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ColorSaturation", -1, &a->tt__ImagingSettings::ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Contrast", -1, &a->tt__ImagingSettings::Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__Exposure(soap, "tt:Exposure", -1, &a->tt__ImagingSettings::Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration(soap, "tt:Focus", -1, &a->tt__ImagingSettings::Focus, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", -1, &a->tt__ImagingSettings::IrCutFilter, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Sharpness", -1, &a->tt__ImagingSettings::Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRange(soap, "tt:WideDynamicRange", -1, &a->tt__ImagingSettings::WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance(soap, "tt:WhiteBalance", -1, &a->tt__ImagingSettings::WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension(soap, "tt:Extension", -1, &a->tt__ImagingSettings::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettings(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettings * SOAP_FMAC4 soap_in_tt__ImagingSettings(struct soap *soap, const char *tag, tt__ImagingSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings, sizeof(tt__ImagingSettings), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettings)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettings *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingSettings*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_IrCutFilter1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BacklightCompensation(soap, "tt:BacklightCompensation", &a->tt__ImagingSettings::BacklightCompensation, "tt:BacklightCompensation"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Brightness", &a->tt__ImagingSettings::Brightness, "xsd:float"))
				{	soap_flag_Brightness1--;
					continue;
				}
			}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:ColorSaturation", &a->tt__ImagingSettings::ColorSaturation, "xsd:float"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Contrast", &a->tt__ImagingSettings::Contrast, "xsd:float"))
				{	soap_flag_Contrast1--;
					continue;
				}
			}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Exposure(soap, "tt:Exposure", &a->tt__ImagingSettings::Exposure, "tt:Exposure"))
				{	soap_flag_Exposure1--;
					continue;
				}
			}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusConfiguration(soap, "tt:Focus", &a->tt__ImagingSettings::Focus, "tt:FocusConfiguration"))
				{	soap_flag_Focus1--;
					continue;
				}
			}
			if (soap_flag_IrCutFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", &a->tt__ImagingSettings::IrCutFilter, "tt:IrCutFilterMode"))
				{	soap_flag_IrCutFilter1--;
					continue;
				}
			}
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Sharpness", &a->tt__ImagingSettings::Sharpness, "xsd:float"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WideDynamicRange(soap, "tt:WideDynamicRange", &a->tt__ImagingSettings::WideDynamicRange, "tt:WideDynamicRange"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalance(soap, "tt:WhiteBalance", &a->tt__ImagingSettings::WhiteBalance, "tt:WhiteBalance"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension(soap, "tt:Extension", &a->tt__ImagingSettings::Extension, "tt:ImagingSettingsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings, SOAP_TYPE_tt__ImagingSettings, sizeof(tt__ImagingSettings), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettings * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettings *p;
	size_t k = sizeof(tt__ImagingSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettings);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettings, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettings(soap, tag ? tag : "tt:ImagingSettings", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettings(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettings * SOAP_FMAC4 soap_get_tt__ImagingSettings(struct soap *soap, tt__ImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__AutoFocusMode(soap, &this->tt__FocusConfiguration::AutoFocusMode);
	soap_default_float(soap, &this->tt__FocusConfiguration::DefaultSpeed);
	soap_default_float(soap, &this->tt__FocusConfiguration::NearLimit);
	soap_default_float(soap, &this->tt__FocusConfiguration::FarLimit);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__FocusConfiguration::__anyAttribute);
}

void tt__FocusConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__FocusConfiguration::DefaultSpeed, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FocusConfiguration::NearLimit, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FocusConfiguration::FarLimit, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusConfiguration::__any);
#endif
}

int tt__FocusConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration(struct soap *soap, const char *tag, int id, const tt__FocusConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__FocusConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration), type))
		return soap->error;
	if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusMode", -1, &a->tt__FocusConfiguration::AutoFocusMode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:DefaultSpeed", -1, &a->tt__FocusConfiguration::DefaultSpeed, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:NearLimit", -1, &a->tt__FocusConfiguration::NearLimit, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:FarLimit", -1, &a->tt__FocusConfiguration::FarLimit, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__FocusConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusConfiguration * SOAP_FMAC4 soap_in_tt__FocusConfiguration(struct soap *soap, const char *tag, tt__FocusConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration, sizeof(tt__FocusConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__FocusConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_AutoFocusMode1 = 1;
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusMode", &a->tt__FocusConfiguration::AutoFocusMode, "tt:AutoFocusMode"))
				{	soap_flag_AutoFocusMode1--;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:DefaultSpeed", &a->tt__FocusConfiguration::DefaultSpeed, "xsd:float"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:NearLimit", &a->tt__FocusConfiguration::NearLimit, "xsd:float"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:FarLimit", &a->tt__FocusConfiguration::FarLimit, "xsd:float"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__FocusConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode1 > 0 || soap_flag_DefaultSpeed1 > 0 || soap_flag_NearLimit1 > 0 || soap_flag_FarLimit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FocusConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration, SOAP_TYPE_tt__FocusConfiguration, sizeof(tt__FocusConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusConfiguration * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusConfiguration *p;
	size_t k = sizeof(tt__FocusConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusConfiguration(soap, tag ? tag : "tt:FocusConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusConfiguration * SOAP_FMAC4 soap_get_tt__FocusConfiguration(struct soap *soap, tt__FocusConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusStatus::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->tt__FocusStatus::Position);
	soap_default_tt__MoveStatus(soap, &this->tt__FocusStatus::MoveStatus);
	soap_default_std__string(soap, &this->tt__FocusStatus::Error);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusStatus::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__FocusStatus::__anyAttribute);
}

void tt__FocusStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__FocusStatus::Position, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FocusStatus::MoveStatus, SOAP_TYPE_tt__MoveStatus);
	soap_embedded(soap, &this->tt__FocusStatus::Error, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__FocusStatus::Error);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusStatus::__any);
#endif
}

int tt__FocusStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus(struct soap *soap, const char *tag, int id, const tt__FocusStatus *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__FocusStatus*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->tt__FocusStatus::Position, ""))
		return soap->error;
	if (soap_out_tt__MoveStatus(soap, "tt:MoveStatus", -1, &a->tt__FocusStatus::MoveStatus, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Error", -1, &a->tt__FocusStatus::Error, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__FocusStatus::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusStatus * SOAP_FMAC4 soap_in_tt__FocusStatus(struct soap *soap, const char *tag, tt__FocusStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus, sizeof(tt__FocusStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__FocusStatus*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_MoveStatus1 = 1;
	size_t soap_flag_Error1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Position", &a->tt__FocusStatus::Position, "xsd:float"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_MoveStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__MoveStatus(soap, "tt:MoveStatus", &a->tt__FocusStatus::MoveStatus, "tt:MoveStatus"))
				{	soap_flag_MoveStatus1--;
					continue;
				}
			}
			if (soap_flag_Error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Error", &a->tt__FocusStatus::Error, "xsd:string"))
				{	soap_flag_Error1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__FocusStatus::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position1 > 0 || soap_flag_MoveStatus1 > 0 || soap_flag_Error1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FocusStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus, SOAP_TYPE_tt__FocusStatus, sizeof(tt__FocusStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusStatus * SOAP_FMAC2 soap_instantiate_tt__FocusStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusStatus *p;
	size_t k = sizeof(tt__FocusStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusStatus(soap, tag ? tag : "tt:FocusStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusStatus * SOAP_FMAC4 soap_get_tt__FocusStatus(struct soap *soap, tt__FocusStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingStatus::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ImagingStatus::FocusStatus = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingStatus::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingStatus::__anyAttribute);
}

void tt__ImagingStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FocusStatus(soap, &this->tt__ImagingStatus::FocusStatus);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingStatus::__any);
#endif
}

int tt__ImagingStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus(struct soap *soap, const char *tag, int id, const tt__ImagingStatus *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingStatus*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus), type))
		return soap->error;
	if (!a->tt__ImagingStatus::FocusStatus)
	{	if (soap_element_empty(soap, "tt:FocusStatus"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FocusStatus(soap, "tt:FocusStatus", -1, &a->tt__ImagingStatus::FocusStatus, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ImagingStatus::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingStatus * SOAP_FMAC4 soap_in_tt__ImagingStatus(struct soap *soap, const char *tag, tt__ImagingStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus, sizeof(tt__ImagingStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingStatus*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_FocusStatus1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FocusStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusStatus(soap, "tt:FocusStatus", &a->tt__ImagingStatus::FocusStatus, "tt:FocusStatus"))
				{	soap_flag_FocusStatus1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ImagingStatus::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__ImagingStatus::FocusStatus))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ImagingStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus, SOAP_TYPE_tt__ImagingStatus, sizeof(tt__ImagingStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingStatus * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingStatus *p;
	size_t k = sizeof(tt__ImagingStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingStatus(soap, tag ? tag : "tt:ImagingStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingStatus * SOAP_FMAC4 soap_get_tt__ImagingStatus(struct soap *soap, tt__ImagingStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourStartingConditionOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourStartingConditionOptionsExtension::__any);
}

void tt__PTZPresetTourStartingConditionOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourStartingConditionOptionsExtension::__any);
#endif
}

int tt__PTZPresetTourStartingConditionOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourStartingConditionOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZPresetTourStartingConditionOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourStartingConditionOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const char *tag, tt__PTZPresetTourStartingConditionOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourStartingConditionOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, sizeof(tt__PTZPresetTourStartingConditionOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourStartingConditionOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZPresetTourStartingConditionOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourStartingConditionOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, sizeof(tt__PTZPresetTourStartingConditionOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourStartingConditionOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourStartingConditionOptionsExtension *p;
	size_t k = sizeof(tt__PTZPresetTourStartingConditionOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourStartingConditionOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourStartingConditionOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourStartingConditionOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourStartingConditionOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag ? tag : "tt:PTZPresetTourStartingConditionOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourStartingConditionOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourStartingConditionOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, tt__PTZPresetTourStartingConditionOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourStartingConditionOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTZPresetTourStartingConditionOptions::RecurringTime = NULL;
	this->tt__PTZPresetTourStartingConditionOptions::RecurringDuration = NULL;
	soap_default_std__vectorTemplateOftt__PTZPresetTourDirection(soap, &this->tt__PTZPresetTourStartingConditionOptions::Direction);
	this->tt__PTZPresetTourStartingConditionOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZPresetTourStartingConditionOptions::__anyAttribute);
}

void tt__PTZPresetTourStartingConditionOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__PTZPresetTourStartingConditionOptions::RecurringTime);
	soap_serialize_PointerTott__DurationRange(soap, &this->tt__PTZPresetTourStartingConditionOptions::RecurringDuration);
	soap_serialize_std__vectorTemplateOftt__PTZPresetTourDirection(soap, &this->tt__PTZPresetTourStartingConditionOptions::Direction);
	soap_serialize_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, &this->tt__PTZPresetTourStartingConditionOptions::Extension);
#endif
}

int tt__PTZPresetTourStartingConditionOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourStartingConditionOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourStartingConditionOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZPresetTourStartingConditionOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions), type))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:RecurringTime", -1, &a->tt__PTZPresetTourStartingConditionOptions::RecurringTime, ""))
		return soap->error;
	if (soap_out_PointerTott__DurationRange(soap, "tt:RecurringDuration", -1, &a->tt__PTZPresetTourStartingConditionOptions::RecurringDuration, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__PTZPresetTourDirection(soap, "tt:Direction", -1, &a->tt__PTZPresetTourStartingConditionOptions::Direction, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, "tt:Extension", -1, &a->tt__PTZPresetTourStartingConditionOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourStartingConditionOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourStartingConditionOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, const char *tag, tt__PTZPresetTourStartingConditionOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourStartingConditionOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, sizeof(tt__PTZPresetTourStartingConditionOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourStartingConditionOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZPresetTourStartingConditionOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RecurringTime1 = 1;
	size_t soap_flag_RecurringDuration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecurringTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:RecurringTime", &a->tt__PTZPresetTourStartingConditionOptions::RecurringTime, "tt:IntRange"))
				{	soap_flag_RecurringTime1--;
					continue;
				}
			}
			if (soap_flag_RecurringDuration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:RecurringDuration", &a->tt__PTZPresetTourStartingConditionOptions::RecurringDuration, "tt:DurationRange"))
				{	soap_flag_RecurringDuration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__PTZPresetTourDirection(soap, "tt:Direction", &a->tt__PTZPresetTourStartingConditionOptions::Direction, "tt:PTZPresetTourDirection"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, "tt:Extension", &a->tt__PTZPresetTourStartingConditionOptions::Extension, "tt:PTZPresetTourStartingConditionOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourStartingConditionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, sizeof(tt__PTZPresetTourStartingConditionOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourStartingConditionOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourStartingConditionOptions *p;
	size_t k = sizeof(tt__PTZPresetTourStartingConditionOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourStartingConditionOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourStartingConditionOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourStartingConditionOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourStartingConditionOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourStartingConditionOptions(soap, tag ? tag : "tt:PTZPresetTourStartingConditionOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourStartingConditionOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourStartingConditionOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, tt__PTZPresetTourStartingConditionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingConditionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourPresetDetailOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourPresetDetailOptionsExtension::__any);
}

void tt__PTZPresetTourPresetDetailOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourPresetDetailOptionsExtension::__any);
#endif
}

int tt__PTZPresetTourPresetDetailOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourPresetDetailOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZPresetTourPresetDetailOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourPresetDetailOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const char *tag, tt__PTZPresetTourPresetDetailOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourPresetDetailOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, sizeof(tt__PTZPresetTourPresetDetailOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourPresetDetailOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZPresetTourPresetDetailOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourPresetDetailOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, sizeof(tt__PTZPresetTourPresetDetailOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourPresetDetailOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourPresetDetailOptionsExtension *p;
	size_t k = sizeof(tt__PTZPresetTourPresetDetailOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourPresetDetailOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourPresetDetailOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourPresetDetailOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourPresetDetailOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag ? tag : "tt:PTZPresetTourPresetDetailOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourPresetDetailOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourPresetDetailOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, tt__PTZPresetTourPresetDetailOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourPresetDetailOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__PTZPresetTourPresetDetailOptions::PresetToken);
	this->tt__PTZPresetTourPresetDetailOptions::Home = NULL;
	this->tt__PTZPresetTourPresetDetailOptions::PanTiltPositionSpace = NULL;
	this->tt__PTZPresetTourPresetDetailOptions::ZoomPositionSpace = NULL;
	this->tt__PTZPresetTourPresetDetailOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZPresetTourPresetDetailOptions::__anyAttribute);
}

void tt__PTZPresetTourPresetDetailOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__PTZPresetTourPresetDetailOptions::PresetToken);
	soap_serialize_PointerTobool(soap, &this->tt__PTZPresetTourPresetDetailOptions::Home);
	soap_serialize_PointerTott__Space2DDescription(soap, &this->tt__PTZPresetTourPresetDetailOptions::PanTiltPositionSpace);
	soap_serialize_PointerTott__Space1DDescription(soap, &this->tt__PTZPresetTourPresetDetailOptions::ZoomPositionSpace);
	soap_serialize_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, &this->tt__PTZPresetTourPresetDetailOptions::Extension);
#endif
}

int tt__PTZPresetTourPresetDetailOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourPresetDetailOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourPresetDetailOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZPresetTourPresetDetailOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:PresetToken", -1, &a->tt__PTZPresetTourPresetDetailOptions::PresetToken, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Home", -1, &a->tt__PTZPresetTourPresetDetailOptions::Home, ""))
		return soap->error;
	if (soap_out_PointerTott__Space2DDescription(soap, "tt:PanTiltPositionSpace", -1, &a->tt__PTZPresetTourPresetDetailOptions::PanTiltPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerTott__Space1DDescription(soap, "tt:ZoomPositionSpace", -1, &a->tt__PTZPresetTourPresetDetailOptions::ZoomPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, "tt:Extension", -1, &a->tt__PTZPresetTourPresetDetailOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourPresetDetailOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourPresetDetailOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC4 soap_in_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, const char *tag, tt__PTZPresetTourPresetDetailOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourPresetDetailOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, sizeof(tt__PTZPresetTourPresetDetailOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourPresetDetailOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZPresetTourPresetDetailOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Home1 = 1;
	size_t soap_flag_PanTiltPositionSpace1 = 1;
	size_t soap_flag_ZoomPositionSpace1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:PresetToken", &a->tt__PTZPresetTourPresetDetailOptions::PresetToken, "tt:ReferenceToken"))
					continue;
			}
			if (soap_flag_Home1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Home", &a->tt__PTZPresetTourPresetDetailOptions::Home, "xsd:boolean"))
				{	soap_flag_Home1--;
					continue;
				}
			}
			if (soap_flag_PanTiltPositionSpace1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space2DDescription(soap, "tt:PanTiltPositionSpace", &a->tt__PTZPresetTourPresetDetailOptions::PanTiltPositionSpace, "tt:Space2DDescription"))
				{	soap_flag_PanTiltPositionSpace1--;
					continue;
				}
			}
			if (soap_flag_ZoomPositionSpace1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space1DDescription(soap, "tt:ZoomPositionSpace", &a->tt__PTZPresetTourPresetDetailOptions::ZoomPositionSpace, "tt:Space1DDescription"))
				{	soap_flag_ZoomPositionSpace1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, "tt:Extension", &a->tt__PTZPresetTourPresetDetailOptions::Extension, "tt:PTZPresetTourPresetDetailOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourPresetDetailOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, sizeof(tt__PTZPresetTourPresetDetailOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourPresetDetailOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourPresetDetailOptions *p;
	size_t k = sizeof(tt__PTZPresetTourPresetDetailOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourPresetDetailOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourPresetDetailOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourPresetDetailOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourPresetDetailOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourPresetDetailOptions(soap, tag ? tag : "tt:PTZPresetTourPresetDetailOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourPresetDetailOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourPresetDetailOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC4 soap_get_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, tt__PTZPresetTourPresetDetailOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourPresetDetailOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourSpotOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTZPresetTourSpotOptions::PresetDetail = NULL;
	this->tt__PTZPresetTourSpotOptions::StayTime = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourSpotOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZPresetTourSpotOptions::__anyAttribute);
}

void tt__PTZPresetTourSpotOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourPresetDetailOptions(soap, &this->tt__PTZPresetTourSpotOptions::PresetDetail);
	soap_serialize_PointerTott__DurationRange(soap, &this->tt__PTZPresetTourSpotOptions::StayTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourSpotOptions::__any);
#endif
}

int tt__PTZPresetTourSpotOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourSpotOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSpotOptions(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourSpotOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZPresetTourSpotOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSpotOptions), type))
		return soap->error;
	if (!a->tt__PTZPresetTourSpotOptions::PresetDetail)
	{	if (soap_element_empty(soap, "tt:PresetDetail"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourPresetDetailOptions(soap, "tt:PresetDetail", -1, &a->tt__PTZPresetTourSpotOptions::PresetDetail, ""))
		return soap->error;
	if (!a->tt__PTZPresetTourSpotOptions::StayTime)
	{	if (soap_element_empty(soap, "tt:StayTime"))
			return soap->error;
	}
	else if (soap_out_PointerTott__DurationRange(soap, "tt:StayTime", -1, &a->tt__PTZPresetTourSpotOptions::StayTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZPresetTourSpotOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourSpotOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourSpotOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourSpotOptions * SOAP_FMAC4 soap_in_tt__PTZPresetTourSpotOptions(struct soap *soap, const char *tag, tt__PTZPresetTourSpotOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourSpotOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpotOptions, sizeof(tt__PTZPresetTourSpotOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourSpotOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourSpotOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZPresetTourSpotOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_PresetDetail1 = 1;
	size_t soap_flag_StayTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetDetail1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourPresetDetailOptions(soap, "tt:PresetDetail", &a->tt__PTZPresetTourSpotOptions::PresetDetail, "tt:PTZPresetTourPresetDetailOptions"))
				{	soap_flag_PresetDetail1--;
					continue;
				}
			}
			if (soap_flag_StayTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:StayTime", &a->tt__PTZPresetTourSpotOptions::StayTime, "tt:DurationRange"))
				{	soap_flag_StayTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZPresetTourSpotOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PTZPresetTourSpotOptions::PresetDetail || !a->tt__PTZPresetTourSpotOptions::StayTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZPresetTourSpotOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpotOptions, SOAP_TYPE_tt__PTZPresetTourSpotOptions, sizeof(tt__PTZPresetTourSpotOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourSpotOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourSpotOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourSpotOptions *p;
	size_t k = sizeof(tt__PTZPresetTourSpotOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourSpotOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourSpotOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourSpotOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourSpotOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourSpotOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourSpotOptions(soap, tag ? tag : "tt:PTZPresetTourSpotOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourSpotOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourSpotOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourSpotOptions * SOAP_FMAC4 soap_get_tt__PTZPresetTourSpotOptions(struct soap *soap, tt__PTZPresetTourSpotOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSpotOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__PTZPresetTourOptions::AutoStart);
	this->tt__PTZPresetTourOptions::StartingCondition = NULL;
	this->tt__PTZPresetTourOptions::TourSpot = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZPresetTourOptions::__anyAttribute);
}

void tt__PTZPresetTourOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZPresetTourOptions::AutoStart, SOAP_TYPE_bool);
	soap_serialize_PointerTott__PTZPresetTourStartingConditionOptions(soap, &this->tt__PTZPresetTourOptions::StartingCondition);
	soap_serialize_PointerTott__PTZPresetTourSpotOptions(soap, &this->tt__PTZPresetTourOptions::TourSpot);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourOptions::__any);
#endif
}

int tt__PTZPresetTourOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourOptions(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZPresetTourOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourOptions), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoStart", -1, &a->tt__PTZPresetTourOptions::AutoStart, ""))
		return soap->error;
	if (!a->tt__PTZPresetTourOptions::StartingCondition)
	{	if (soap_element_empty(soap, "tt:StartingCondition"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourStartingConditionOptions(soap, "tt:StartingCondition", -1, &a->tt__PTZPresetTourOptions::StartingCondition, ""))
		return soap->error;
	if (!a->tt__PTZPresetTourOptions::TourSpot)
	{	if (soap_element_empty(soap, "tt:TourSpot"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourSpotOptions(soap, "tt:TourSpot", -1, &a->tt__PTZPresetTourOptions::TourSpot, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZPresetTourOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourOptions * SOAP_FMAC4 soap_in_tt__PTZPresetTourOptions(struct soap *soap, const char *tag, tt__PTZPresetTourOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(tt__PTZPresetTourOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZPresetTourOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_AutoStart1 = 1;
	size_t soap_flag_StartingCondition1 = 1;
	size_t soap_flag_TourSpot1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoStart1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AutoStart", &a->tt__PTZPresetTourOptions::AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart1--;
					continue;
				}
			}
			if (soap_flag_StartingCondition1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStartingConditionOptions(soap, "tt:StartingCondition", &a->tt__PTZPresetTourOptions::StartingCondition, "tt:PTZPresetTourStartingConditionOptions"))
				{	soap_flag_StartingCondition1--;
					continue;
				}
			}
			if (soap_flag_TourSpot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSpotOptions(soap, "tt:TourSpot", &a->tt__PTZPresetTourOptions::TourSpot, "tt:PTZPresetTourSpotOptions"))
				{	soap_flag_TourSpot1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZPresetTourOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoStart1 > 0 || !a->tt__PTZPresetTourOptions::StartingCondition || !a->tt__PTZPresetTourOptions::TourSpot))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZPresetTourOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourOptions, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(tt__PTZPresetTourOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourOptions *p;
	size_t k = sizeof(tt__PTZPresetTourOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourOptions(soap, tag ? tag : "tt:PTZPresetTourOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourOptions * SOAP_FMAC4 soap_get_tt__PTZPresetTourOptions(struct soap *soap, tt__PTZPresetTourOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourStartingConditionExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourStartingConditionExtension::__any);
}

void tt__PTZPresetTourStartingConditionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourStartingConditionExtension::__any);
#endif
}

int tt__PTZPresetTourStartingConditionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourStartingConditionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourStartingConditionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZPresetTourStartingConditionExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourStartingConditionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourStartingConditionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, const char *tag, tt__PTZPresetTourStartingConditionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourStartingConditionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, sizeof(tt__PTZPresetTourStartingConditionExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourStartingConditionExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZPresetTourStartingConditionExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourStartingConditionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, sizeof(tt__PTZPresetTourStartingConditionExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourStartingConditionExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourStartingConditionExtension *p;
	size_t k = sizeof(tt__PTZPresetTourStartingConditionExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourStartingConditionExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourStartingConditionExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourStartingConditionExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourStartingConditionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourStartingConditionExtension(soap, tag ? tag : "tt:PTZPresetTourStartingConditionExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourStartingConditionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourStartingConditionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, tt__PTZPresetTourStartingConditionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingConditionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourStartingCondition::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTZPresetTourStartingCondition::RecurringTime = NULL;
	this->tt__PTZPresetTourStartingCondition::RecurringDuration = NULL;
	this->tt__PTZPresetTourStartingCondition::Direction = NULL;
	this->tt__PTZPresetTourStartingCondition::Extension = NULL;
	this->tt__PTZPresetTourStartingCondition::RandomPresetOrder = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZPresetTourStartingCondition::__anyAttribute);
}

void tt__PTZPresetTourStartingCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->tt__PTZPresetTourStartingCondition::RecurringTime);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__PTZPresetTourStartingCondition::RecurringDuration);
	soap_serialize_PointerTott__PTZPresetTourDirection(soap, &this->tt__PTZPresetTourStartingCondition::Direction);
	soap_serialize_PointerTott__PTZPresetTourStartingConditionExtension(soap, &this->tt__PTZPresetTourStartingCondition::Extension);
#endif
}

int tt__PTZPresetTourStartingCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourStartingCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourStartingCondition *a, const char *type)
{
	if (((tt__PTZPresetTourStartingCondition*)a)->RandomPresetOrder)
	{	soap_set_attr(soap, "RandomPresetOrder", soap_bool2s(soap, *((tt__PTZPresetTourStartingCondition*)a)->RandomPresetOrder), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZPresetTourStartingCondition*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingCondition), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:RecurringTime", -1, &a->tt__PTZPresetTourStartingCondition::RecurringTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:RecurringDuration", -1, &a->tt__PTZPresetTourStartingCondition::RecurringDuration, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourDirection(soap, "tt:Direction", -1, &a->tt__PTZPresetTourStartingCondition::Direction, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourStartingConditionExtension(soap, "tt:Extension", -1, &a->tt__PTZPresetTourStartingCondition::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourStartingCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourStartingCondition(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingCondition * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, tt__PTZPresetTourStartingCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourStartingCondition*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(tt__PTZPresetTourStartingCondition), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourStartingCondition)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourStartingCondition *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "RandomPresetOrder", 5, 0);
		if (t)
		{
			if (!(((tt__PTZPresetTourStartingCondition*)a)->RandomPresetOrder = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__PTZPresetTourStartingCondition*)a)->RandomPresetOrder))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZPresetTourStartingCondition*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RecurringTime1 = 1;
	size_t soap_flag_RecurringDuration1 = 1;
	size_t soap_flag_Direction1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecurringTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:RecurringTime", &a->tt__PTZPresetTourStartingCondition::RecurringTime, "xsd:int"))
				{	soap_flag_RecurringTime1--;
					continue;
				}
			}
			if (soap_flag_RecurringDuration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__duration(soap, "tt:RecurringDuration", &a->tt__PTZPresetTourStartingCondition::RecurringDuration, "xsd:duration"))
				{	soap_flag_RecurringDuration1--;
					continue;
				}
			}
			if (soap_flag_Direction1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourDirection(soap, "tt:Direction", &a->tt__PTZPresetTourStartingCondition::Direction, "tt:PTZPresetTourDirection"))
				{	soap_flag_Direction1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStartingConditionExtension(soap, "tt:Extension", &a->tt__PTZPresetTourStartingCondition::Extension, "tt:PTZPresetTourStartingConditionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourStartingCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingCondition, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(tt__PTZPresetTourStartingCondition), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourStartingCondition * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourStartingCondition(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourStartingCondition *p;
	size_t k = sizeof(tt__PTZPresetTourStartingCondition);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourStartingCondition, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourStartingCondition);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourStartingCondition, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourStartingCondition location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourStartingCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourStartingCondition(soap, tag ? tag : "tt:PTZPresetTourStartingCondition", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourStartingCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourStartingCondition(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingCondition * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingCondition(struct soap *soap, tt__PTZPresetTourStartingCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourStatusExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourStatusExtension::__any);
}

void tt__PTZPresetTourStatusExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourStatusExtension::__any);
#endif
}

int tt__PTZPresetTourStatusExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourStatusExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStatusExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourStatusExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStatusExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZPresetTourStatusExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourStatusExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourStatusExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourStatusExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourStatusExtension(struct soap *soap, const char *tag, tt__PTZPresetTourStatusExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourStatusExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStatusExtension, sizeof(tt__PTZPresetTourStatusExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourStatusExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourStatusExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZPresetTourStatusExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourStatusExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStatusExtension, SOAP_TYPE_tt__PTZPresetTourStatusExtension, sizeof(tt__PTZPresetTourStatusExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourStatusExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatusExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourStatusExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourStatusExtension *p;
	size_t k = sizeof(tt__PTZPresetTourStatusExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourStatusExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourStatusExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourStatusExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourStatusExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourStatusExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourStatusExtension(soap, tag ? tag : "tt:PTZPresetTourStatusExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourStatusExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourStatusExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourStatusExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourStatusExtension(struct soap *soap, tt__PTZPresetTourStatusExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourStatus::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__PTZPresetTourState(soap, &this->tt__PTZPresetTourStatus::State);
	this->tt__PTZPresetTourStatus::CurrentTourSpot = NULL;
	this->tt__PTZPresetTourStatus::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZPresetTourStatus::__anyAttribute);
}

void tt__PTZPresetTourStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourSpot(soap, &this->tt__PTZPresetTourStatus::CurrentTourSpot);
	soap_serialize_PointerTott__PTZPresetTourStatusExtension(soap, &this->tt__PTZPresetTourStatus::Extension);
#endif
}

int tt__PTZPresetTourStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStatus(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourStatus *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZPresetTourStatus*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStatus), type))
		return soap->error;
	if (soap_out_tt__PTZPresetTourState(soap, "tt:State", -1, &a->tt__PTZPresetTourStatus::State, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSpot(soap, "tt:CurrentTourSpot", -1, &a->tt__PTZPresetTourStatus::CurrentTourSpot, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourStatusExtension(soap, "tt:Extension", -1, &a->tt__PTZPresetTourStatus::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourStatus * SOAP_FMAC4 soap_in_tt__PTZPresetTourStatus(struct soap *soap, const char *tag, tt__PTZPresetTourStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(tt__PTZPresetTourStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZPresetTourStatus*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_State1 = 1;
	size_t soap_flag_CurrentTourSpot1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__PTZPresetTourState(soap, "tt:State", &a->tt__PTZPresetTourStatus::State, "tt:PTZPresetTourState"))
				{	soap_flag_State1--;
					continue;
				}
			}
			if (soap_flag_CurrentTourSpot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSpot(soap, "tt:CurrentTourSpot", &a->tt__PTZPresetTourStatus::CurrentTourSpot, "tt:PTZPresetTourSpot"))
				{	soap_flag_CurrentTourSpot1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStatusExtension(soap, "tt:Extension", &a->tt__PTZPresetTourStatus::Extension, "tt:PTZPresetTourStatusExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZPresetTourStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStatus, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(tt__PTZPresetTourStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourStatus * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourStatus *p;
	size_t k = sizeof(tt__PTZPresetTourStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourStatus(soap, tag ? tag : "tt:PTZPresetTourStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourStatus * SOAP_FMAC4 soap_get_tt__PTZPresetTourStatus(struct soap *soap, tt__PTZPresetTourStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourTypeExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourTypeExtension::__any);
}

void tt__PTZPresetTourTypeExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourTypeExtension::__any);
#endif
}

int tt__PTZPresetTourTypeExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourTypeExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourTypeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourTypeExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZPresetTourTypeExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourTypeExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourTypeExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourTypeExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, tt__PTZPresetTourTypeExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourTypeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(tt__PTZPresetTourTypeExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourTypeExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourTypeExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZPresetTourTypeExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourTypeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourTypeExtension, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(tt__PTZPresetTourTypeExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourTypeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourTypeExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourTypeExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourTypeExtension *p;
	size_t k = sizeof(tt__PTZPresetTourTypeExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourTypeExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourTypeExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourTypeExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourTypeExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourTypeExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourTypeExtension(soap, tag ? tag : "tt:PTZPresetTourTypeExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourTypeExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourTypeExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourTypeExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourTypeExtension(struct soap *soap, tt__PTZPresetTourTypeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourTypeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourPresetDetail::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTZPresetTourPresetDetail::__union_PTZPresetTourPresetDetail = 0;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourPresetDetail::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZPresetTourPresetDetail::__anyAttribute);
}

void tt__PTZPresetTourPresetDetail::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_PTZPresetTourPresetDetail(soap, this->tt__PTZPresetTourPresetDetail::__union_PTZPresetTourPresetDetail, &this->tt__PTZPresetTourPresetDetail::union_PTZPresetTourPresetDetail);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourPresetDetail::__any);
#endif
}

int tt__PTZPresetTourPresetDetail::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourPresetDetail(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourPresetDetail *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZPresetTourPresetDetail*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetail), type))
		return soap->error;
	if (soap_out__tt__union_PTZPresetTourPresetDetail(soap, a->tt__PTZPresetTourPresetDetail::__union_PTZPresetTourPresetDetail, &a->tt__PTZPresetTourPresetDetail::union_PTZPresetTourPresetDetail))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZPresetTourPresetDetail::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourPresetDetail::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourPresetDetail(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetail * SOAP_FMAC4 soap_in_tt__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, tt__PTZPresetTourPresetDetail *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourPresetDetail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(tt__PTZPresetTourPresetDetail), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourPresetDetail)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourPresetDetail *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZPresetTourPresetDetail*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_union_PTZPresetTourPresetDetail1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_PTZPresetTourPresetDetail1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__tt__union_PTZPresetTourPresetDetail(soap, &a->tt__PTZPresetTourPresetDetail::__union_PTZPresetTourPresetDetail, &a->tt__PTZPresetTourPresetDetail::union_PTZPresetTourPresetDetail))
				{	soap_flag_union_PTZPresetTourPresetDetail1 = 0;
					continue;
				}
		}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZPresetTourPresetDetail::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourPresetDetail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetail, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(tt__PTZPresetTourPresetDetail), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourPresetDetail * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourPresetDetail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourPresetDetail *p;
	size_t k = sizeof(tt__PTZPresetTourPresetDetail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourPresetDetail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourPresetDetail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourPresetDetail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourPresetDetail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourPresetDetail::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourPresetDetail(soap, tag ? tag : "tt:PTZPresetTourPresetDetail", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourPresetDetail::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourPresetDetail(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetail * SOAP_FMAC4 soap_get_tt__PTZPresetTourPresetDetail(struct soap *soap, tt__PTZPresetTourPresetDetail *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourPresetDetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourSpotExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourSpotExtension::__any);
}

void tt__PTZPresetTourSpotExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourSpotExtension::__any);
#endif
}

int tt__PTZPresetTourSpotExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourSpotExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourSpotExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSpotExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZPresetTourSpotExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourSpotExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourSpotExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourSpotExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, tt__PTZPresetTourSpotExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourSpotExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(tt__PTZPresetTourSpotExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourSpotExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourSpotExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZPresetTourSpotExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourSpotExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpotExtension, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(tt__PTZPresetTourSpotExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourSpotExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourSpotExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourSpotExtension *p;
	size_t k = sizeof(tt__PTZPresetTourSpotExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourSpotExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourSpotExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourSpotExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourSpotExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourSpotExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourSpotExtension(soap, tag ? tag : "tt:PTZPresetTourSpotExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourSpotExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourSpotExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourSpotExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourSpotExtension(struct soap *soap, tt__PTZPresetTourSpotExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSpotExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourSpot::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTZPresetTourSpot::PresetDetail = NULL;
	this->tt__PTZPresetTourSpot::Speed = NULL;
	this->tt__PTZPresetTourSpot::StayTime = NULL;
	this->tt__PTZPresetTourSpot::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZPresetTourSpot::__anyAttribute);
}

void tt__PTZPresetTourSpot::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourPresetDetail(soap, &this->tt__PTZPresetTourSpot::PresetDetail);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->tt__PTZPresetTourSpot::Speed);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__PTZPresetTourSpot::StayTime);
	soap_serialize_PointerTott__PTZPresetTourSpotExtension(soap, &this->tt__PTZPresetTourSpot::Extension);
#endif
}

int tt__PTZPresetTourSpot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourSpot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSpot(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourSpot *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZPresetTourSpot*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSpot), type))
		return soap->error;
	if (!a->tt__PTZPresetTourSpot::PresetDetail)
	{	if (soap_element_empty(soap, "tt:PresetDetail"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourPresetDetail(soap, "tt:PresetDetail", -1, &a->tt__PTZPresetTourSpot::PresetDetail, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tt:Speed", -1, &a->tt__PTZPresetTourSpot::Speed, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:StayTime", -1, &a->tt__PTZPresetTourSpot::StayTime, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSpotExtension(soap, "tt:Extension", -1, &a->tt__PTZPresetTourSpot::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourSpot::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourSpot(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourSpot * SOAP_FMAC4 soap_in_tt__PTZPresetTourSpot(struct soap *soap, const char *tag, tt__PTZPresetTourSpot *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourSpot*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(tt__PTZPresetTourSpot), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourSpot)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourSpot *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZPresetTourSpot*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_PresetDetail1 = 1;
	size_t soap_flag_Speed1 = 1;
	size_t soap_flag_StayTime1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetDetail1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourPresetDetail(soap, "tt:PresetDetail", &a->tt__PTZPresetTourSpot::PresetDetail, "tt:PTZPresetTourPresetDetail"))
				{	soap_flag_PresetDetail1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tt:Speed", &a->tt__PTZPresetTourSpot::Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_StayTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__duration(soap, "tt:StayTime", &a->tt__PTZPresetTourSpot::StayTime, "xsd:duration"))
				{	soap_flag_StayTime1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSpotExtension(soap, "tt:Extension", &a->tt__PTZPresetTourSpot::Extension, "tt:PTZPresetTourSpotExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PTZPresetTourSpot::PresetDetail))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZPresetTourSpot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpot, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(tt__PTZPresetTourSpot), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourSpot * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourSpot(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourSpot *p;
	size_t k = sizeof(tt__PTZPresetTourSpot);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourSpot, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourSpot);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourSpot, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourSpot location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourSpot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourSpot(soap, tag ? tag : "tt:PTZPresetTourSpot", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourSpot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourSpot(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourSpot * SOAP_FMAC4 soap_get_tt__PTZPresetTourSpot(struct soap *soap, tt__PTZPresetTourSpot *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSpot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourExtension::__any);
}

void tt__PTZPresetTourExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourExtension::__any);
#endif
}

int tt__PTZPresetTourExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZPresetTourExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourExtension(struct soap *soap, const char *tag, tt__PTZPresetTourExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(tt__PTZPresetTourExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZPresetTourExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourExtension, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(tt__PTZPresetTourExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourExtension *p;
	size_t k = sizeof(tt__PTZPresetTourExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourExtension(soap, tag ? tag : "tt:PTZPresetTourExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourExtension(struct soap *soap, tt__PTZPresetTourExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PresetTour::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PresetTour::Name = NULL;
	this->tt__PresetTour::Status = NULL;
	soap_default_bool(soap, &this->tt__PresetTour::AutoStart);
	this->tt__PresetTour::StartingCondition = NULL;
	soap_default_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(soap, &this->tt__PresetTour::TourSpot);
	this->tt__PresetTour::Extension = NULL;
	this->tt__PresetTour::token = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PresetTour::__anyAttribute);
}

void tt__PresetTour::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Name(soap, &this->tt__PresetTour::Name);
	soap_serialize_PointerTott__PTZPresetTourStatus(soap, &this->tt__PresetTour::Status);
	soap_embedded(soap, &this->tt__PresetTour::AutoStart, SOAP_TYPE_bool);
	soap_serialize_PointerTott__PTZPresetTourStartingCondition(soap, &this->tt__PresetTour::StartingCondition);
	soap_serialize_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(soap, &this->tt__PresetTour::TourSpot);
	soap_serialize_PointerTott__PTZPresetTourExtension(soap, &this->tt__PresetTour::Extension);
#endif
}

int tt__PresetTour::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PresetTour(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PresetTour(struct soap *soap, const char *tag, int id, const tt__PresetTour *a, const char *type)
{
	if (((tt__PresetTour*)a)->token)
	{	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, *((tt__PresetTour*)a)->token), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PresetTour*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PresetTour), type))
		return soap->error;
	if (soap_out_PointerTott__Name(soap, "tt:Name", -1, &a->tt__PresetTour::Name, ""))
		return soap->error;
	if (!a->tt__PresetTour::Status)
	{	if (soap_element_empty(soap, "tt:Status"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourStatus(soap, "tt:Status", -1, &a->tt__PresetTour::Status, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoStart", -1, &a->tt__PresetTour::AutoStart, ""))
		return soap->error;
	if (!a->tt__PresetTour::StartingCondition)
	{	if (soap_element_empty(soap, "tt:StartingCondition"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourStartingCondition(soap, "tt:StartingCondition", -1, &a->tt__PresetTour::StartingCondition, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(soap, "tt:TourSpot", -1, &a->tt__PresetTour::TourSpot, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourExtension(soap, "tt:Extension", -1, &a->tt__PresetTour::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PresetTour::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PresetTour(soap, tag, this, type);
}

SOAP_FMAC3 tt__PresetTour * SOAP_FMAC4 soap_in_tt__PresetTour(struct soap *soap, const char *tag, tt__PresetTour *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PresetTour, sizeof(tt__PresetTour), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PresetTour)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PresetTour *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "token", 1, 0);
		if (t)
		{
			if (!(((tt__PresetTour*)a)->token = soap_new_tt__ReferenceToken(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__ReferenceToken(soap, t, ((tt__PresetTour*)a)->token))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PresetTour*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_AutoStart1 = 1;
	size_t soap_flag_StartingCondition1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__Name(soap, "tt:Name", &a->tt__PresetTour::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStatus(soap, "tt:Status", &a->tt__PresetTour::Status, "tt:PTZPresetTourStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap_flag_AutoStart1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AutoStart", &a->tt__PresetTour::AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart1--;
					continue;
				}
			}
			if (soap_flag_StartingCondition1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStartingCondition(soap, "tt:StartingCondition", &a->tt__PresetTour::StartingCondition, "tt:PTZPresetTourStartingCondition"))
				{	soap_flag_StartingCondition1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(soap, "tt:TourSpot", &a->tt__PresetTour::TourSpot, "tt:PTZPresetTourSpot"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourExtension(soap, "tt:Extension", &a->tt__PresetTour::Extension, "tt:PTZPresetTourExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PresetTour::Status || soap_flag_AutoStart1 > 0 || !a->tt__PresetTour::StartingCondition))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PresetTour, SOAP_TYPE_tt__PresetTour, sizeof(tt__PresetTour), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PresetTour * SOAP_FMAC2 soap_instantiate_tt__PresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PresetTour *p;
	size_t k = sizeof(tt__PresetTour);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PresetTour);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PresetTour, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PresetTour location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PresetTour::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PresetTour(soap, tag ? tag : "tt:PresetTour", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PresetTour::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PresetTour(soap, this, tag, type);
}

SOAP_FMAC3 tt__PresetTour * SOAP_FMAC4 soap_get_tt__PresetTour(struct soap *soap, tt__PresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPreset::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTZPreset::Name = NULL;
	this->tt__PTZPreset::PTZPosition = NULL;
	this->tt__PTZPreset::token = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZPreset::__anyAttribute);
}

void tt__PTZPreset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Name(soap, &this->tt__PTZPreset::Name);
	soap_serialize_PointerTott__PTZVector(soap, &this->tt__PTZPreset::PTZPosition);
#endif
}

int tt__PTZPreset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPreset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPreset(struct soap *soap, const char *tag, int id, const tt__PTZPreset *a, const char *type)
{
	if (((tt__PTZPreset*)a)->token)
	{	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, *((tt__PTZPreset*)a)->token), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZPreset*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPreset), type))
		return soap->error;
	if (soap_out_PointerTott__Name(soap, "tt:Name", -1, &a->tt__PTZPreset::Name, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:PTZPosition", -1, &a->tt__PTZPreset::PTZPosition, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPreset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPreset(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPreset * SOAP_FMAC4 soap_in_tt__PTZPreset(struct soap *soap, const char *tag, tt__PTZPreset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPreset, sizeof(tt__PTZPreset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPreset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPreset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "token", 1, 0);
		if (t)
		{
			if (!(((tt__PTZPreset*)a)->token = soap_new_tt__ReferenceToken(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__ReferenceToken(soap, t, ((tt__PTZPreset*)a)->token))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZPreset*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_PTZPosition1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__Name(soap, "tt:Name", &a->tt__PTZPreset::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_PTZPosition1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &a->tt__PTZPreset::PTZPosition, "tt:PTZVector"))
				{	soap_flag_PTZPosition1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPreset, SOAP_TYPE_tt__PTZPreset, sizeof(tt__PTZPreset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPreset * SOAP_FMAC2 soap_instantiate_tt__PTZPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPreset *p;
	size_t k = sizeof(tt__PTZPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPreset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPreset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPreset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPreset(soap, tag ? tag : "tt:PTZPreset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPreset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPreset(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPreset * SOAP_FMAC4 soap_get_tt__PTZPreset(struct soap *soap, tt__PTZPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZSpeed::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTZSpeed::PanTilt = NULL;
	this->tt__PTZSpeed::Zoom = NULL;
}

void tt__PTZSpeed::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector2D(soap, &this->tt__PTZSpeed::PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &this->tt__PTZSpeed::Zoom);
#endif
}

int tt__PTZSpeed::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZSpeed(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpeed(struct soap *soap, const char *tag, int id, const tt__PTZSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpeed), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->tt__PTZSpeed::PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->tt__PTZSpeed::Zoom, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZSpeed::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZSpeed(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZSpeed * SOAP_FMAC4 soap_in_tt__PTZSpeed(struct soap *soap, const char *tag, tt__PTZSpeed *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZSpeed*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZSpeed)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZSpeed *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_PanTilt1 = 1;
	size_t soap_flag_Zoom1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->tt__PTZSpeed::PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt1--;
					continue;
				}
			}
			if (soap_flag_Zoom1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->tt__PTZSpeed::Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpeed, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 soap_instantiate_tt__PTZSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZSpeed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZSpeed *p;
	size_t k = sizeof(tt__PTZSpeed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZSpeed, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZSpeed);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZSpeed, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZSpeed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZSpeed::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZSpeed(soap, tag ? tag : "tt:PTZSpeed", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZSpeed::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZSpeed(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZSpeed * SOAP_FMAC4 soap_get_tt__PTZSpeed(struct soap *soap, tt__PTZSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Space1DDescription::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__Space1DDescription::URI);
	this->tt__Space1DDescription::XRange = NULL;
}

void tt__Space1DDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Space1DDescription::URI, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Space1DDescription::URI);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space1DDescription::XRange);
#endif
}

int tt__Space1DDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Space1DDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space1DDescription(struct soap *soap, const char *tag, int id, const tt__Space1DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space1DDescription), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:URI", -1, &a->tt__Space1DDescription::URI, ""))
		return soap->error;
	if (!a->tt__Space1DDescription::XRange)
	{	if (soap_element_empty(soap, "tt:XRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->tt__Space1DDescription::XRange, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Space1DDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Space1DDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__Space1DDescription * SOAP_FMAC4 soap_in_tt__Space1DDescription(struct soap *soap, const char *tag, tt__Space1DDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Space1DDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Space1DDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Space1DDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_URI1 = 1;
	size_t soap_flag_XRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:URI", &a->tt__Space1DDescription::URI, "xsd:anyURI"))
				{	soap_flag_URI1--;
					continue;
				}
			}
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->tt__Space1DDescription::XRange, "tt:FloatRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI1 > 0 || !a->tt__Space1DDescription::XRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Space1DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space1DDescription, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 soap_instantiate_tt__Space1DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Space1DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Space1DDescription *p;
	size_t k = sizeof(tt__Space1DDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Space1DDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Space1DDescription);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Space1DDescription, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Space1DDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Space1DDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Space1DDescription(soap, tag ? tag : "tt:Space1DDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Space1DDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Space1DDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__Space1DDescription * SOAP_FMAC4 soap_get_tt__Space1DDescription(struct soap *soap, tt__Space1DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Space2DDescription::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__Space2DDescription::URI);
	this->tt__Space2DDescription::XRange = NULL;
	this->tt__Space2DDescription::YRange = NULL;
}

void tt__Space2DDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Space2DDescription::URI, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Space2DDescription::URI);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space2DDescription::XRange);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space2DDescription::YRange);
#endif
}

int tt__Space2DDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Space2DDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space2DDescription(struct soap *soap, const char *tag, int id, const tt__Space2DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space2DDescription), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:URI", -1, &a->tt__Space2DDescription::URI, ""))
		return soap->error;
	if (!a->tt__Space2DDescription::XRange)
	{	if (soap_element_empty(soap, "tt:XRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->tt__Space2DDescription::XRange, ""))
		return soap->error;
	if (!a->tt__Space2DDescription::YRange)
	{	if (soap_element_empty(soap, "tt:YRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:YRange", -1, &a->tt__Space2DDescription::YRange, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Space2DDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Space2DDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__Space2DDescription * SOAP_FMAC4 soap_in_tt__Space2DDescription(struct soap *soap, const char *tag, tt__Space2DDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Space2DDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Space2DDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Space2DDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_URI1 = 1;
	size_t soap_flag_XRange1 = 1;
	size_t soap_flag_YRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:URI", &a->tt__Space2DDescription::URI, "xsd:anyURI"))
				{	soap_flag_URI1--;
					continue;
				}
			}
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->tt__Space2DDescription::XRange, "tt:FloatRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			}
			if (soap_flag_YRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YRange", &a->tt__Space2DDescription::YRange, "tt:FloatRange"))
				{	soap_flag_YRange1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI1 > 0 || !a->tt__Space2DDescription::XRange || !a->tt__Space2DDescription::YRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Space2DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space2DDescription, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 soap_instantiate_tt__Space2DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Space2DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Space2DDescription *p;
	size_t k = sizeof(tt__Space2DDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Space2DDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Space2DDescription);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Space2DDescription, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Space2DDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Space2DDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Space2DDescription(soap, tag ? tag : "tt:Space2DDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Space2DDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Space2DDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__Space2DDescription * SOAP_FMAC4 soap_get_tt__Space2DDescription(struct soap *soap, tt__Space2DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZSpacesExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZSpacesExtension::__any);
}

void tt__PTZSpacesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZSpacesExtension::__any);
#endif
}

int tt__PTZSpacesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZSpacesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpacesExtension(struct soap *soap, const char *tag, int id, const tt__PTZSpacesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpacesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZSpacesExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZSpacesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZSpacesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZSpacesExtension * SOAP_FMAC4 soap_in_tt__PTZSpacesExtension(struct soap *soap, const char *tag, tt__PTZSpacesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZSpacesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(tt__PTZSpacesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZSpacesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZSpacesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZSpacesExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZSpacesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpacesExtension, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(tt__PTZSpacesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZSpacesExtension * SOAP_FMAC2 soap_instantiate_tt__PTZSpacesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZSpacesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZSpacesExtension *p;
	size_t k = sizeof(tt__PTZSpacesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZSpacesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZSpacesExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZSpacesExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZSpacesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZSpacesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZSpacesExtension(soap, tag ? tag : "tt:PTZSpacesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZSpacesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZSpacesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZSpacesExtension * SOAP_FMAC4 soap_get_tt__PTZSpacesExtension(struct soap *soap, tt__PTZSpacesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpacesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZSpaces::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::AbsolutePanTiltPositionSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::AbsoluteZoomPositionSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::RelativePanTiltTranslationSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::RelativeZoomTranslationSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::ContinuousPanTiltVelocitySpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::ContinuousZoomVelocitySpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::PanTiltSpeedSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::ZoomSpeedSpace);
	this->tt__PTZSpaces::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZSpaces::__anyAttribute);
}

void tt__PTZSpaces::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::AbsolutePanTiltPositionSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::AbsoluteZoomPositionSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::RelativePanTiltTranslationSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::RelativeZoomTranslationSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::ContinuousPanTiltVelocitySpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::ContinuousZoomVelocitySpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::PanTiltSpeedSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::ZoomSpeedSpace);
	soap_serialize_PointerTott__PTZSpacesExtension(soap, &this->tt__PTZSpaces::Extension);
#endif
}

int tt__PTZSpaces::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZSpaces(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpaces(struct soap *soap, const char *tag, int id, const tt__PTZSpaces *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZSpaces*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpaces), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:AbsolutePanTiltPositionSpace", -1, &a->tt__PTZSpaces::AbsolutePanTiltPositionSpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:AbsoluteZoomPositionSpace", -1, &a->tt__PTZSpaces::AbsoluteZoomPositionSpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:RelativePanTiltTranslationSpace", -1, &a->tt__PTZSpaces::RelativePanTiltTranslationSpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:RelativeZoomTranslationSpace", -1, &a->tt__PTZSpaces::RelativeZoomTranslationSpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", -1, &a->tt__PTZSpaces::ContinuousPanTiltVelocitySpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", -1, &a->tt__PTZSpaces::ContinuousZoomVelocitySpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:PanTiltSpeedSpace", -1, &a->tt__PTZSpaces::PanTiltSpeedSpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:ZoomSpeedSpace", -1, &a->tt__PTZSpaces::ZoomSpeedSpace, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpacesExtension(soap, "tt:Extension", -1, &a->tt__PTZSpaces::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZSpaces::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZSpaces(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZSpaces * SOAP_FMAC4 soap_in_tt__PTZSpaces(struct soap *soap, const char *tag, tt__PTZSpaces *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZSpaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpaces, sizeof(tt__PTZSpaces), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZSpaces)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZSpaces *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZSpaces*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:AbsolutePanTiltPositionSpace", &a->tt__PTZSpaces::AbsolutePanTiltPositionSpace, "tt:Space2DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:AbsoluteZoomPositionSpace", &a->tt__PTZSpaces::AbsoluteZoomPositionSpace, "tt:Space1DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:RelativePanTiltTranslationSpace", &a->tt__PTZSpaces::RelativePanTiltTranslationSpace, "tt:Space2DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:RelativeZoomTranslationSpace", &a->tt__PTZSpaces::RelativeZoomTranslationSpace, "tt:Space1DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", &a->tt__PTZSpaces::ContinuousPanTiltVelocitySpace, "tt:Space2DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", &a->tt__PTZSpaces::ContinuousZoomVelocitySpace, "tt:Space1DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:PanTiltSpeedSpace", &a->tt__PTZSpaces::PanTiltSpeedSpace, "tt:Space1DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:ZoomSpeedSpace", &a->tt__PTZSpaces::ZoomSpeedSpace, "tt:Space1DDescription"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpacesExtension(soap, "tt:Extension", &a->tt__PTZSpaces::Extension, "tt:PTZSpacesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZSpaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpaces, SOAP_TYPE_tt__PTZSpaces, sizeof(tt__PTZSpaces), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZSpaces * SOAP_FMAC2 soap_instantiate_tt__PTZSpaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZSpaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZSpaces *p;
	size_t k = sizeof(tt__PTZSpaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZSpaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZSpaces);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZSpaces, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZSpaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZSpaces::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZSpaces(soap, tag ? tag : "tt:PTZSpaces", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZSpaces::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZSpaces(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZSpaces * SOAP_FMAC4 soap_get_tt__PTZSpaces(struct soap *soap, tt__PTZSpaces *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ZoomLimits::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ZoomLimits::Range = NULL;
}

void tt__ZoomLimits::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space1DDescription(soap, &this->tt__ZoomLimits::Range);
#endif
}

int tt__ZoomLimits::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ZoomLimits(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ZoomLimits(struct soap *soap, const char *tag, int id, const tt__ZoomLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ZoomLimits), type))
		return soap->error;
	if (!a->tt__ZoomLimits::Range)
	{	if (soap_element_empty(soap, "tt:Range"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Space1DDescription(soap, "tt:Range", -1, &a->tt__ZoomLimits::Range, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ZoomLimits::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ZoomLimits(soap, tag, this, type);
}

SOAP_FMAC3 tt__ZoomLimits * SOAP_FMAC4 soap_in_tt__ZoomLimits(struct soap *soap, const char *tag, tt__ZoomLimits *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ZoomLimits*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ZoomLimits)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ZoomLimits *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Range1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space1DDescription(soap, "tt:Range", &a->tt__ZoomLimits::Range, "tt:Space1DDescription"))
				{	soap_flag_Range1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__ZoomLimits::Range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ZoomLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ZoomLimits, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 soap_instantiate_tt__ZoomLimits(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ZoomLimits(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ZoomLimits *p;
	size_t k = sizeof(tt__ZoomLimits);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ZoomLimits, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ZoomLimits);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ZoomLimits, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ZoomLimits location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ZoomLimits::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ZoomLimits::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ZoomLimits(soap, this, tag, type);
}

SOAP_FMAC3 tt__ZoomLimits * SOAP_FMAC4 soap_get_tt__ZoomLimits(struct soap *soap, tt__ZoomLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PanTiltLimits::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PanTiltLimits::Range = NULL;
}

void tt__PanTiltLimits::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space2DDescription(soap, &this->tt__PanTiltLimits::Range);
#endif
}

int tt__PanTiltLimits::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PanTiltLimits(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PanTiltLimits(struct soap *soap, const char *tag, int id, const tt__PanTiltLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PanTiltLimits), type))
		return soap->error;
	if (!a->tt__PanTiltLimits::Range)
	{	if (soap_element_empty(soap, "tt:Range"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Space2DDescription(soap, "tt:Range", -1, &a->tt__PanTiltLimits::Range, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PanTiltLimits::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PanTiltLimits(soap, tag, this, type);
}

SOAP_FMAC3 tt__PanTiltLimits * SOAP_FMAC4 soap_in_tt__PanTiltLimits(struct soap *soap, const char *tag, tt__PanTiltLimits *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PanTiltLimits*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PanTiltLimits)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PanTiltLimits *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Range1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space2DDescription(soap, "tt:Range", &a->tt__PanTiltLimits::Range, "tt:Space2DDescription"))
				{	soap_flag_Range1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PanTiltLimits::Range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PanTiltLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PanTiltLimits, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 soap_instantiate_tt__PanTiltLimits(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PanTiltLimits(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PanTiltLimits *p;
	size_t k = sizeof(tt__PanTiltLimits);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PanTiltLimits, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PanTiltLimits);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PanTiltLimits, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PanTiltLimits location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PanTiltLimits::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PanTiltLimits::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PanTiltLimits(soap, this, tag, type);
}

SOAP_FMAC3 tt__PanTiltLimits * SOAP_FMAC4 soap_get_tt__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReverseOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ReverseOptionsExtension::__any);
}

void tt__ReverseOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ReverseOptionsExtension::__any);
#endif
}

int tt__ReverseOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReverseOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseOptionsExtension(struct soap *soap, const char *tag, int id, const tt__ReverseOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReverseOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ReverseOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReverseOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReverseOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReverseOptionsExtension * SOAP_FMAC4 soap_in_tt__ReverseOptionsExtension(struct soap *soap, const char *tag, tt__ReverseOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReverseOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(tt__ReverseOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReverseOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReverseOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ReverseOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ReverseOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseOptionsExtension, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(tt__ReverseOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReverseOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ReverseOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReverseOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReverseOptionsExtension *p;
	size_t k = sizeof(tt__ReverseOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReverseOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReverseOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReverseOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReverseOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReverseOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReverseOptionsExtension(soap, tag ? tag : "tt:ReverseOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReverseOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReverseOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReverseOptionsExtension * SOAP_FMAC4 soap_get_tt__ReverseOptionsExtension(struct soap *soap, tt__ReverseOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReverseOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__ReverseMode(soap, &this->tt__ReverseOptions::Mode);
	this->tt__ReverseOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ReverseOptions::__anyAttribute);
}

void tt__ReverseOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ReverseMode(soap, &this->tt__ReverseOptions::Mode);
	soap_serialize_PointerTott__ReverseOptionsExtension(soap, &this->tt__ReverseOptions::Extension);
#endif
}

int tt__ReverseOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReverseOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseOptions(struct soap *soap, const char *tag, int id, const tt__ReverseOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ReverseOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReverseOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReverseMode(soap, "tt:Mode", -1, &a->tt__ReverseOptions::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__ReverseOptionsExtension(soap, "tt:Extension", -1, &a->tt__ReverseOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReverseOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReverseOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReverseOptions * SOAP_FMAC4 soap_in_tt__ReverseOptions(struct soap *soap, const char *tag, tt__ReverseOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReverseOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseOptions, sizeof(tt__ReverseOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReverseOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReverseOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ReverseOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReverseMode(soap, "tt:Mode", &a->tt__ReverseOptions::Mode, "tt:ReverseMode"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReverseOptionsExtension(soap, "tt:Extension", &a->tt__ReverseOptions::Extension, "tt:ReverseOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ReverseOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseOptions, SOAP_TYPE_tt__ReverseOptions, sizeof(tt__ReverseOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReverseOptions * SOAP_FMAC2 soap_instantiate_tt__ReverseOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReverseOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReverseOptions *p;
	size_t k = sizeof(tt__ReverseOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReverseOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReverseOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReverseOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReverseOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReverseOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReverseOptions(soap, tag ? tag : "tt:ReverseOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReverseOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReverseOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReverseOptions * SOAP_FMAC4 soap_get_tt__ReverseOptions(struct soap *soap, tt__ReverseOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EFlipOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EFlipOptionsExtension::__any);
}

void tt__EFlipOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EFlipOptionsExtension::__any);
#endif
}

int tt__EFlipOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EFlipOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipOptionsExtension(struct soap *soap, const char *tag, int id, const tt__EFlipOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlipOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__EFlipOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EFlipOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EFlipOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__EFlipOptionsExtension * SOAP_FMAC4 soap_in_tt__EFlipOptionsExtension(struct soap *soap, const char *tag, tt__EFlipOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EFlipOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(tt__EFlipOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EFlipOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EFlipOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__EFlipOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EFlipOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipOptionsExtension, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(tt__EFlipOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EFlipOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__EFlipOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EFlipOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EFlipOptionsExtension *p;
	size_t k = sizeof(tt__EFlipOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EFlipOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EFlipOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EFlipOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EFlipOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EFlipOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EFlipOptionsExtension(soap, tag ? tag : "tt:EFlipOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EFlipOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EFlipOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__EFlipOptionsExtension * SOAP_FMAC4 soap_get_tt__EFlipOptionsExtension(struct soap *soap, tt__EFlipOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EFlipOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__EFlipMode(soap, &this->tt__EFlipOptions::Mode);
	this->tt__EFlipOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__EFlipOptions::__anyAttribute);
}

void tt__EFlipOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__EFlipMode(soap, &this->tt__EFlipOptions::Mode);
	soap_serialize_PointerTott__EFlipOptionsExtension(soap, &this->tt__EFlipOptions::Extension);
#endif
}

int tt__EFlipOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EFlipOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipOptions(struct soap *soap, const char *tag, int id, const tt__EFlipOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__EFlipOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlipOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__EFlipMode(soap, "tt:Mode", -1, &a->tt__EFlipOptions::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__EFlipOptionsExtension(soap, "tt:Extension", -1, &a->tt__EFlipOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EFlipOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EFlipOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__EFlipOptions * SOAP_FMAC4 soap_in_tt__EFlipOptions(struct soap *soap, const char *tag, tt__EFlipOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EFlipOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipOptions, sizeof(tt__EFlipOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EFlipOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EFlipOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__EFlipOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__EFlipMode(soap, "tt:Mode", &a->tt__EFlipOptions::Mode, "tt:EFlipMode"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EFlipOptionsExtension(soap, "tt:Extension", &a->tt__EFlipOptions::Extension, "tt:EFlipOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EFlipOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipOptions, SOAP_TYPE_tt__EFlipOptions, sizeof(tt__EFlipOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EFlipOptions * SOAP_FMAC2 soap_instantiate_tt__EFlipOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EFlipOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EFlipOptions *p;
	size_t k = sizeof(tt__EFlipOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EFlipOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EFlipOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EFlipOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EFlipOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EFlipOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EFlipOptions(soap, tag ? tag : "tt:EFlipOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EFlipOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EFlipOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__EFlipOptions * SOAP_FMAC4 soap_get_tt__EFlipOptions(struct soap *soap, tt__EFlipOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTControlDirectionOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTControlDirectionOptionsExtension::__any);
}

void tt__PTControlDirectionOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTControlDirectionOptionsExtension::__any);
#endif
}

int tt__PTControlDirectionOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTControlDirectionOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, int id, const tt__PTControlDirectionOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTControlDirectionOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTControlDirectionOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTControlDirectionOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTControlDirectionOptionsExtension * SOAP_FMAC4 soap_in_tt__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, tt__PTControlDirectionOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTControlDirectionOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(tt__PTControlDirectionOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTControlDirectionOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTControlDirectionOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTControlDirectionOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTControlDirectionOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(tt__PTControlDirectionOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirectionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTControlDirectionOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTControlDirectionOptionsExtension *p;
	size_t k = sizeof(tt__PTControlDirectionOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTControlDirectionOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTControlDirectionOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTControlDirectionOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTControlDirectionOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTControlDirectionOptionsExtension(soap, tag ? tag : "tt:PTControlDirectionOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTControlDirectionOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTControlDirectionOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTControlDirectionOptionsExtension * SOAP_FMAC4 soap_get_tt__PTControlDirectionOptionsExtension(struct soap *soap, tt__PTControlDirectionOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTControlDirectionOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTControlDirectionOptions::EFlip = NULL;
	this->tt__PTControlDirectionOptions::Reverse = NULL;
	this->tt__PTControlDirectionOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTControlDirectionOptions::__anyAttribute);
}

void tt__PTControlDirectionOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__EFlipOptions(soap, &this->tt__PTControlDirectionOptions::EFlip);
	soap_serialize_PointerTott__ReverseOptions(soap, &this->tt__PTControlDirectionOptions::Reverse);
	soap_serialize_PointerTott__PTControlDirectionOptionsExtension(soap, &this->tt__PTControlDirectionOptions::Extension);
#endif
}

int tt__PTControlDirectionOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTControlDirectionOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionOptions(struct soap *soap, const char *tag, int id, const tt__PTControlDirectionOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTControlDirectionOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionOptions), type))
		return soap->error;
	if (soap_out_PointerTott__EFlipOptions(soap, "tt:EFlip", -1, &a->tt__PTControlDirectionOptions::EFlip, ""))
		return soap->error;
	if (soap_out_PointerTott__ReverseOptions(soap, "tt:Reverse", -1, &a->tt__PTControlDirectionOptions::Reverse, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionOptionsExtension(soap, "tt:Extension", -1, &a->tt__PTControlDirectionOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTControlDirectionOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTControlDirectionOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTControlDirectionOptions * SOAP_FMAC4 soap_in_tt__PTControlDirectionOptions(struct soap *soap, const char *tag, tt__PTControlDirectionOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTControlDirectionOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(tt__PTControlDirectionOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTControlDirectionOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTControlDirectionOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTControlDirectionOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_EFlip1 = 1;
	size_t soap_flag_Reverse1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EFlip1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EFlipOptions(soap, "tt:EFlip", &a->tt__PTControlDirectionOptions::EFlip, "tt:EFlipOptions"))
				{	soap_flag_EFlip1--;
					continue;
				}
			}
			if (soap_flag_Reverse1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReverseOptions(soap, "tt:Reverse", &a->tt__PTControlDirectionOptions::Reverse, "tt:ReverseOptions"))
				{	soap_flag_Reverse1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirectionOptionsExtension(soap, "tt:Extension", &a->tt__PTControlDirectionOptions::Extension, "tt:PTControlDirectionOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTControlDirectionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionOptions, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(tt__PTControlDirectionOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirectionOptions * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTControlDirectionOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTControlDirectionOptions *p;
	size_t k = sizeof(tt__PTControlDirectionOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTControlDirectionOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTControlDirectionOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTControlDirectionOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTControlDirectionOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTControlDirectionOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTControlDirectionOptions(soap, tag ? tag : "tt:PTControlDirectionOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTControlDirectionOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTControlDirectionOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTControlDirectionOptions * SOAP_FMAC4 soap_get_tt__PTControlDirectionOptions(struct soap *soap, tt__PTControlDirectionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfigurationOptions2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZConfigurationOptions2::__any);
}

void tt__PTZConfigurationOptions2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZConfigurationOptions2::__any);
#endif
}

int tt__PTZConfigurationOptions2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationOptions2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationOptions2(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationOptions2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationOptions2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZConfigurationOptions2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationOptions2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfigurationOptions2(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationOptions2 * SOAP_FMAC4 soap_in_tt__PTZConfigurationOptions2(struct soap *soap, const char *tag, tt__PTZConfigurationOptions2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationOptions2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(tt__PTZConfigurationOptions2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfigurationOptions2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfigurationOptions2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZConfigurationOptions2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZConfigurationOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationOptions2, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(tt__PTZConfigurationOptions2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationOptions2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfigurationOptions2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfigurationOptions2 *p;
	size_t k = sizeof(tt__PTZConfigurationOptions2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfigurationOptions2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfigurationOptions2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfigurationOptions2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfigurationOptions2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfigurationOptions2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfigurationOptions2(soap, tag ? tag : "tt:PTZConfigurationOptions2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationOptions2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationOptions2(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationOptions2 * SOAP_FMAC4 soap_get_tt__PTZConfigurationOptions2(struct soap *soap, tt__PTZConfigurationOptions2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTZConfigurationOptions::Spaces = NULL;
	this->tt__PTZConfigurationOptions::PTZTimeout = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZConfigurationOptions::__any);
	this->tt__PTZConfigurationOptions::PTControlDirection = NULL;
	this->tt__PTZConfigurationOptions::Extension = NULL;
	this->tt__PTZConfigurationOptions::PTZRamps = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZConfigurationOptions::__anyAttribute);
}

void tt__PTZConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZSpaces(soap, &this->tt__PTZConfigurationOptions::Spaces);
	soap_serialize_PointerTott__DurationRange(soap, &this->tt__PTZConfigurationOptions::PTZTimeout);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZConfigurationOptions::__any);
	soap_serialize_PointerTott__PTControlDirectionOptions(soap, &this->tt__PTZConfigurationOptions::PTControlDirection);
	soap_serialize_PointerTott__PTZConfigurationOptions2(soap, &this->tt__PTZConfigurationOptions::Extension);
#endif
}

int tt__PTZConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationOptions *a, const char *type)
{
	if (((tt__PTZConfigurationOptions*)a)->PTZRamps)
	{	soap_set_attr(soap, "PTZRamps", soap_tt__IntAttrList2s(soap, *((tt__PTZConfigurationOptions*)a)->PTZRamps), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationOptions), type))
		return soap->error;
	if (!a->tt__PTZConfigurationOptions::Spaces)
	{	if (soap_element_empty(soap, "tt:Spaces"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZSpaces(soap, "tt:Spaces", -1, &a->tt__PTZConfigurationOptions::Spaces, ""))
		return soap->error;
	if (!a->tt__PTZConfigurationOptions::PTZTimeout)
	{	if (soap_element_empty(soap, "tt:PTZTimeout"))
			return soap->error;
	}
	else if (soap_out_PointerTott__DurationRange(soap, "tt:PTZTimeout", -1, &a->tt__PTZConfigurationOptions::PTZTimeout, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZConfigurationOptions::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionOptions(soap, "tt:PTControlDirection", -1, &a->tt__PTZConfigurationOptions::PTControlDirection, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationOptions2(soap, "tt:Extension", -1, &a->tt__PTZConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationOptions * SOAP_FMAC4 soap_in_tt__PTZConfigurationOptions(struct soap *soap, const char *tag, tt__PTZConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(tt__PTZConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "PTZRamps", 1, 0);
		if (t)
		{
			if (!(((tt__PTZConfigurationOptions*)a)->PTZRamps = soap_new_tt__IntAttrList(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__IntAttrList(soap, t, ((tt__PTZConfigurationOptions*)a)->PTZRamps))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Spaces1 = 1;
	size_t soap_flag_PTZTimeout1 = 1;
	size_t soap_flag_PTControlDirection1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Spaces1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpaces(soap, "tt:Spaces", &a->tt__PTZConfigurationOptions::Spaces, "tt:PTZSpaces"))
				{	soap_flag_Spaces1--;
					continue;
				}
			}
			if (soap_flag_PTZTimeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:PTZTimeout", &a->tt__PTZConfigurationOptions::PTZTimeout, "tt:DurationRange"))
				{	soap_flag_PTZTimeout1--;
					continue;
				}
			}
			if (soap_flag_PTControlDirection1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirectionOptions(soap, "tt:PTControlDirection", &a->tt__PTZConfigurationOptions::PTControlDirection, "tt:PTControlDirectionOptions"))
				{	soap_flag_PTControlDirection1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationOptions2(soap, "tt:Extension", &a->tt__PTZConfigurationOptions::Extension, "tt:PTZConfigurationOptions2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZConfigurationOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PTZConfigurationOptions::Spaces || !a->tt__PTZConfigurationOptions::PTZTimeout))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationOptions, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(tt__PTZConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfigurationOptions *p;
	size_t k = sizeof(tt__PTZConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfigurationOptions(soap, tag ? tag : "tt:PTZConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationOptions * SOAP_FMAC4 soap_get_tt__PTZConfigurationOptions(struct soap *soap, tt__PTZConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Reverse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReverseMode(soap, &this->tt__Reverse::Mode);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Reverse::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__Reverse::__anyAttribute);
}

void tt__Reverse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Reverse::__any);
#endif
}

int tt__Reverse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Reverse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Reverse(struct soap *soap, const char *tag, int id, const tt__Reverse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Reverse*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Reverse), type))
		return soap->error;
	if (soap_out_tt__ReverseMode(soap, "tt:Mode", -1, &a->tt__Reverse::Mode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__Reverse::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Reverse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Reverse(soap, tag, this, type);
}

SOAP_FMAC3 tt__Reverse * SOAP_FMAC4 soap_in_tt__Reverse(struct soap *soap, const char *tag, tt__Reverse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Reverse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Reverse, sizeof(tt__Reverse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Reverse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Reverse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Reverse*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ReverseMode(soap, "tt:Mode", &a->tt__Reverse::Mode, "tt:ReverseMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__Reverse::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Reverse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Reverse, SOAP_TYPE_tt__Reverse, sizeof(tt__Reverse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Reverse * SOAP_FMAC2 soap_instantiate_tt__Reverse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Reverse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Reverse *p;
	size_t k = sizeof(tt__Reverse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Reverse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Reverse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Reverse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Reverse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Reverse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Reverse(soap, tag ? tag : "tt:Reverse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Reverse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Reverse(soap, this, tag, type);
}

SOAP_FMAC3 tt__Reverse * SOAP_FMAC4 soap_get_tt__Reverse(struct soap *soap, tt__Reverse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Reverse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EFlip::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__EFlipMode(soap, &this->tt__EFlip::Mode);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EFlip::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__EFlip::__anyAttribute);
}

void tt__EFlip::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EFlip::__any);
#endif
}

int tt__EFlip::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EFlip(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlip(struct soap *soap, const char *tag, int id, const tt__EFlip *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__EFlip*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlip), type))
		return soap->error;
	if (soap_out_tt__EFlipMode(soap, "tt:Mode", -1, &a->tt__EFlip::Mode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__EFlip::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EFlip::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EFlip(soap, tag, this, type);
}

SOAP_FMAC3 tt__EFlip * SOAP_FMAC4 soap_in_tt__EFlip(struct soap *soap, const char *tag, tt__EFlip *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EFlip*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlip, sizeof(tt__EFlip), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EFlip)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EFlip *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__EFlip*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__EFlipMode(soap, "tt:Mode", &a->tt__EFlip::Mode, "tt:EFlipMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__EFlip::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__EFlip *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlip, SOAP_TYPE_tt__EFlip, sizeof(tt__EFlip), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EFlip * SOAP_FMAC2 soap_instantiate_tt__EFlip(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EFlip(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EFlip *p;
	size_t k = sizeof(tt__EFlip);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EFlip, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EFlip);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EFlip, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EFlip location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EFlip::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EFlip(soap, tag ? tag : "tt:EFlip", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EFlip::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EFlip(soap, this, tag, type);
}

SOAP_FMAC3 tt__EFlip * SOAP_FMAC4 soap_get_tt__EFlip(struct soap *soap, tt__EFlip *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlip(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTControlDirectionExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTControlDirectionExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTControlDirectionExtension::__anyAttribute);
}

void tt__PTControlDirectionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTControlDirectionExtension::__any);
#endif
}

int tt__PTControlDirectionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTControlDirectionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionExtension(struct soap *soap, const char *tag, int id, const tt__PTControlDirectionExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTControlDirectionExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTControlDirectionExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTControlDirectionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTControlDirectionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTControlDirectionExtension * SOAP_FMAC4 soap_in_tt__PTControlDirectionExtension(struct soap *soap, const char *tag, tt__PTControlDirectionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTControlDirectionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(tt__PTControlDirectionExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTControlDirectionExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTControlDirectionExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTControlDirectionExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTControlDirectionExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTControlDirectionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionExtension, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(tt__PTControlDirectionExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirectionExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTControlDirectionExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTControlDirectionExtension *p;
	size_t k = sizeof(tt__PTControlDirectionExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTControlDirectionExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTControlDirectionExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTControlDirectionExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTControlDirectionExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTControlDirectionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTControlDirectionExtension(soap, tag ? tag : "tt:PTControlDirectionExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTControlDirectionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTControlDirectionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTControlDirectionExtension * SOAP_FMAC4 soap_get_tt__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTControlDirection::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__PTControlDirection::EFlip = NULL;
	this->tt__PTControlDirection::Reverse = NULL;
	this->tt__PTControlDirection::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTControlDirection::__anyAttribute);
}

void tt__PTControlDirection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__EFlip(soap, &this->tt__PTControlDirection::EFlip);
	soap_serialize_PointerTott__Reverse(soap, &this->tt__PTControlDirection::Reverse);
	soap_serialize_PointerTott__PTControlDirectionExtension(soap, &this->tt__PTControlDirection::Extension);
#endif
}

int tt__PTControlDirection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTControlDirection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirection(struct soap *soap, const char *tag, int id, const tt__PTControlDirection *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTControlDirection*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirection), type))
		return soap->error;
	if (soap_out_PointerTott__EFlip(soap, "tt:EFlip", -1, &a->tt__PTControlDirection::EFlip, ""))
		return soap->error;
	if (soap_out_PointerTott__Reverse(soap, "tt:Reverse", -1, &a->tt__PTControlDirection::Reverse, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionExtension(soap, "tt:Extension", -1, &a->tt__PTControlDirection::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTControlDirection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTControlDirection(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTControlDirection * SOAP_FMAC4 soap_in_tt__PTControlDirection(struct soap *soap, const char *tag, tt__PTControlDirection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTControlDirection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirection, sizeof(tt__PTControlDirection), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTControlDirection)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTControlDirection *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTControlDirection*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_EFlip1 = 1;
	size_t soap_flag_Reverse1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EFlip1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EFlip(soap, "tt:EFlip", &a->tt__PTControlDirection::EFlip, "tt:EFlip"))
				{	soap_flag_EFlip1--;
					continue;
				}
			}
			if (soap_flag_Reverse1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Reverse(soap, "tt:Reverse", &a->tt__PTControlDirection::Reverse, "tt:Reverse"))
				{	soap_flag_Reverse1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirectionExtension(soap, "tt:Extension", &a->tt__PTControlDirection::Extension, "tt:PTControlDirectionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTControlDirection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirection, SOAP_TYPE_tt__PTControlDirection, sizeof(tt__PTControlDirection), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirection * SOAP_FMAC2 soap_instantiate_tt__PTControlDirection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTControlDirection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTControlDirection *p;
	size_t k = sizeof(tt__PTControlDirection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTControlDirection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTControlDirection);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTControlDirection, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTControlDirection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTControlDirection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTControlDirection(soap, tag ? tag : "tt:PTControlDirection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTControlDirection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTControlDirection(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTControlDirection * SOAP_FMAC4 soap_get_tt__PTControlDirection(struct soap *soap, tt__PTControlDirection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfigurationExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZConfigurationExtension2::__any);
}

void tt__PTZConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZConfigurationExtension2::__any);
#endif
}

int tt__PTZConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZConfigurationExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension2(struct soap *soap, const char *tag, tt__PTZConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(tt__PTZConfigurationExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfigurationExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfigurationExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZConfigurationExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension2, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(tt__PTZConfigurationExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfigurationExtension2 *p;
	size_t k = sizeof(tt__PTZConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfigurationExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfigurationExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfigurationExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfigurationExtension2(soap, tag ? tag : "tt:PTZConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZConfigurationExtension::__any);
	this->tt__PTZConfigurationExtension::PTControlDirection = NULL;
	this->tt__PTZConfigurationExtension::Extension = NULL;
}

void tt__PTZConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZConfigurationExtension::__any);
	soap_serialize_PointerTott__PTControlDirection(soap, &this->tt__PTZConfigurationExtension::PTControlDirection);
	soap_serialize_PointerTott__PTZConfigurationExtension2(soap, &this->tt__PTZConfigurationExtension::Extension);
#endif
}

int tt__PTZConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirection(soap, "tt:PTControlDirection", -1, &a->tt__PTZConfigurationExtension::PTControlDirection, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__PTZConfigurationExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, tt__PTZConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_PTControlDirection1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTControlDirection1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirection(soap, "tt:PTControlDirection", &a->tt__PTZConfigurationExtension::PTControlDirection, "tt:PTControlDirection"))
				{	soap_flag_PTControlDirection1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationExtension2(soap, "tt:Extension", &a->tt__PTZConfigurationExtension::Extension, "tt:PTZConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfigurationExtension *p;
	size_t k = sizeof(tt__PTZConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfigurationExtension(soap, tag ? tag : "tt:PTZConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__PTZConfiguration::NodeToken);
	this->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace = NULL;
	this->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace = NULL;
	this->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace = NULL;
	this->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace = NULL;
	this->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace = NULL;
	this->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace = NULL;
	this->tt__PTZConfiguration::DefaultPTZSpeed = NULL;
	this->tt__PTZConfiguration::DefaultPTZTimeout = NULL;
	this->tt__PTZConfiguration::PanTiltLimits = NULL;
	this->tt__PTZConfiguration::ZoomLimits = NULL;
	this->tt__PTZConfiguration::Extension = NULL;
	this->tt__PTZConfiguration::MoveRamp = NULL;
	this->tt__PTZConfiguration::PresetRamp = NULL;
	this->tt__PTZConfiguration::PresetTourRamp = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZConfiguration::__anyAttribute);
}

void tt__PTZConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZConfiguration::NodeToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__PTZConfiguration::NodeToken);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->tt__PTZConfiguration::DefaultPTZSpeed);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__PTZConfiguration::DefaultPTZTimeout);
	soap_serialize_PointerTott__PanTiltLimits(soap, &this->tt__PTZConfiguration::PanTiltLimits);
	soap_serialize_PointerTott__ZoomLimits(soap, &this->tt__PTZConfiguration::ZoomLimits);
	soap_serialize_PointerTott__PTZConfigurationExtension(soap, &this->tt__PTZConfiguration::Extension);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__PTZConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfiguration(struct soap *soap, const char *tag, int id, const tt__PTZConfiguration *a, const char *type)
{
	if (((tt__PTZConfiguration*)a)->MoveRamp)
	{	soap_set_attr(soap, "MoveRamp", soap_int2s(soap, *((tt__PTZConfiguration*)a)->MoveRamp), 1);
	}
	if (((tt__PTZConfiguration*)a)->PresetRamp)
	{	soap_set_attr(soap, "PresetRamp", soap_int2s(soap, *((tt__PTZConfiguration*)a)->PresetRamp), 1);
	}
	if (((tt__PTZConfiguration*)a)->PresetTourRamp)
	{	soap_set_attr(soap, "PresetTourRamp", soap_int2s(soap, *((tt__PTZConfiguration*)a)->PresetTourRamp), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfiguration), type ? type : "tt:PTZConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:NodeToken", -1, &a->tt__PTZConfiguration::NodeToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultAbsolutePantTiltPositionSpace", -1, &a->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultAbsoluteZoomPositionSpace", -1, &a->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultRelativePanTiltTranslationSpace", -1, &a->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultRelativeZoomTranslationSpace", -1, &a->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultContinuousPanTiltVelocitySpace", -1, &a->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultContinuousZoomVelocitySpace", -1, &a->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", -1, &a->tt__PTZConfiguration::DefaultPTZSpeed, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:DefaultPTZTimeout", -1, &a->tt__PTZConfiguration::DefaultPTZTimeout, ""))
		return soap->error;
	if (soap_out_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", -1, &a->tt__PTZConfiguration::PanTiltLimits, ""))
		return soap->error;
	if (soap_out_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", -1, &a->tt__PTZConfiguration::ZoomLimits, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", -1, &a->tt__PTZConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfiguration * SOAP_FMAC4 soap_in_tt__PTZConfiguration(struct soap *soap, const char *tag, tt__PTZConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfiguration, sizeof(tt__PTZConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "MoveRamp", 5, 0);
		if (t)
		{
			if (!(((tt__PTZConfiguration*)a)->MoveRamp = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__PTZConfiguration*)a)->MoveRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PresetRamp", 5, 0);
		if (t)
		{
			if (!(((tt__PTZConfiguration*)a)->PresetRamp = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__PTZConfiguration*)a)->PresetRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PresetTourRamp", 5, 0);
		if (t)
		{
			if (!(((tt__PTZConfiguration*)a)->PresetTourRamp = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__PTZConfiguration*)a)->PresetTourRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_NodeToken1 = 1;
	size_t soap_flag_DefaultAbsolutePantTiltPositionSpace1 = 1;
	size_t soap_flag_DefaultAbsoluteZoomPositionSpace1 = 1;
	size_t soap_flag_DefaultRelativePanTiltTranslationSpace1 = 1;
	size_t soap_flag_DefaultRelativeZoomTranslationSpace1 = 1;
	size_t soap_flag_DefaultContinuousPanTiltVelocitySpace1 = 1;
	size_t soap_flag_DefaultContinuousZoomVelocitySpace1 = 1;
	size_t soap_flag_DefaultPTZSpeed1 = 1;
	size_t soap_flag_DefaultPTZTimeout1 = 1;
	size_t soap_flag_PanTiltLimits1 = 1;
	size_t soap_flag_ZoomLimits1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_NodeToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:NodeToken", &a->tt__PTZConfiguration::NodeToken, "tt:ReferenceToken"))
				{	soap_flag_NodeToken1--;
					continue;
				}
			}
			if (soap_flag_DefaultAbsolutePantTiltPositionSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultAbsolutePantTiltPositionSpace", &a->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace, "xsd:anyURI"))
				{	soap_flag_DefaultAbsolutePantTiltPositionSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultAbsoluteZoomPositionSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultAbsoluteZoomPositionSpace", &a->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace, "xsd:anyURI"))
				{	soap_flag_DefaultAbsoluteZoomPositionSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultRelativePanTiltTranslationSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultRelativePanTiltTranslationSpace", &a->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace, "xsd:anyURI"))
				{	soap_flag_DefaultRelativePanTiltTranslationSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultRelativeZoomTranslationSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultRelativeZoomTranslationSpace", &a->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace, "xsd:anyURI"))
				{	soap_flag_DefaultRelativeZoomTranslationSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultContinuousPanTiltVelocitySpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultContinuousPanTiltVelocitySpace", &a->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace, "xsd:anyURI"))
				{	soap_flag_DefaultContinuousPanTiltVelocitySpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultContinuousZoomVelocitySpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultContinuousZoomVelocitySpace", &a->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace, "xsd:anyURI"))
				{	soap_flag_DefaultContinuousZoomVelocitySpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultPTZSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", &a->tt__PTZConfiguration::DefaultPTZSpeed, "tt:PTZSpeed"))
				{	soap_flag_DefaultPTZSpeed1--;
					continue;
				}
			}
			if (soap_flag_DefaultPTZTimeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__duration(soap, "tt:DefaultPTZTimeout", &a->tt__PTZConfiguration::DefaultPTZTimeout, "xsd:duration"))
				{	soap_flag_DefaultPTZTimeout1--;
					continue;
				}
			}
			if (soap_flag_PanTiltLimits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", &a->tt__PTZConfiguration::PanTiltLimits, "tt:PanTiltLimits"))
				{	soap_flag_PanTiltLimits1--;
					continue;
				}
			}
			if (soap_flag_ZoomLimits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", &a->tt__PTZConfiguration::ZoomLimits, "tt:ZoomLimits"))
				{	soap_flag_ZoomLimits1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", &a->tt__PTZConfiguration::Extension, "tt:PTZConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_NodeToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfiguration, SOAP_TYPE_tt__PTZConfiguration, sizeof(tt__PTZConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 soap_instantiate_tt__PTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfiguration *p;
	size_t k = sizeof(tt__PTZConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfiguration(soap, tag ? tag : "tt:PTZConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfiguration * SOAP_FMAC4 soap_get_tt__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourSupportedExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourSupportedExtension::__any);
}

void tt__PTZPresetTourSupportedExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZPresetTourSupportedExtension::__any);
#endif
}

int tt__PTZPresetTourSupportedExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourSupportedExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourSupportedExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZPresetTourSupportedExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourSupportedExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourSupportedExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourSupportedExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, tt__PTZPresetTourSupportedExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourSupportedExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(tt__PTZPresetTourSupportedExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourSupportedExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourSupportedExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZPresetTourSupportedExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourSupportedExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(tt__PTZPresetTourSupportedExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourSupportedExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupportedExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourSupportedExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourSupportedExtension *p;
	size_t k = sizeof(tt__PTZPresetTourSupportedExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourSupportedExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourSupportedExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourSupportedExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourSupportedExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourSupportedExtension(soap, tag ? tag : "tt:PTZPresetTourSupportedExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourSupportedExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourSupportedExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourSupportedExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourSupportedExtension(struct soap *soap, tt__PTZPresetTourSupportedExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSupportedExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourSupported::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__PTZPresetTourSupported::MaximumNumberOfPresetTours);
	soap_default_std__vectorTemplateOftt__PTZPresetTourOperation(soap, &this->tt__PTZPresetTourSupported::PTZPresetTourOperation);
	this->tt__PTZPresetTourSupported::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZPresetTourSupported::__anyAttribute);
}

void tt__PTZPresetTourSupported::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZPresetTourSupported::MaximumNumberOfPresetTours, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOftt__PTZPresetTourOperation(soap, &this->tt__PTZPresetTourSupported::PTZPresetTourOperation);
	soap_serialize_PointerTott__PTZPresetTourSupportedExtension(soap, &this->tt__PTZPresetTourSupported::Extension);
#endif
}

int tt__PTZPresetTourSupported::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourSupported(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSupported(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourSupported *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZPresetTourSupported*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSupported), type))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfPresetTours", -1, &a->tt__PTZPresetTourSupported::MaximumNumberOfPresetTours, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__PTZPresetTourOperation(soap, "tt:PTZPresetTourOperation", -1, &a->tt__PTZPresetTourSupported::PTZPresetTourOperation, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSupportedExtension(soap, "tt:Extension", -1, &a->tt__PTZPresetTourSupported::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourSupported::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourSupported(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourSupported * SOAP_FMAC4 soap_in_tt__PTZPresetTourSupported(struct soap *soap, const char *tag, tt__PTZPresetTourSupported *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourSupported*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(tt__PTZPresetTourSupported), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourSupported)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourSupported *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZPresetTourSupported*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_MaximumNumberOfPresetTours1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfPresetTours1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumNumberOfPresetTours", &a->tt__PTZPresetTourSupported::MaximumNumberOfPresetTours, "xsd:int"))
				{	soap_flag_MaximumNumberOfPresetTours1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__PTZPresetTourOperation(soap, "tt:PTZPresetTourOperation", &a->tt__PTZPresetTourSupported::PTZPresetTourOperation, "tt:PTZPresetTourOperation"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSupportedExtension(soap, "tt:Extension", &a->tt__PTZPresetTourSupported::Extension, "tt:PTZPresetTourSupportedExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfPresetTours1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZPresetTourSupported *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSupported, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(tt__PTZPresetTourSupported), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourSupported * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupported(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourSupported(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourSupported *p;
	size_t k = sizeof(tt__PTZPresetTourSupported);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourSupported, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourSupported);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourSupported, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourSupported location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourSupported::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourSupported(soap, tag ? tag : "tt:PTZPresetTourSupported", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourSupported::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourSupported(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourSupported * SOAP_FMAC4 soap_get_tt__PTZPresetTourSupported(struct soap *soap, tt__PTZPresetTourSupported *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSupported(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZNodeExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZNodeExtension2::__any);
}

void tt__PTZNodeExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZNodeExtension2::__any);
#endif
}

int tt__PTZNodeExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZNodeExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNodeExtension2(struct soap *soap, const char *tag, int id, const tt__PTZNodeExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNodeExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZNodeExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZNodeExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZNodeExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZNodeExtension2 * SOAP_FMAC4 soap_in_tt__PTZNodeExtension2(struct soap *soap, const char *tag, tt__PTZNodeExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZNodeExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(tt__PTZNodeExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZNodeExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZNodeExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZNodeExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZNodeExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNodeExtension2, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(tt__PTZNodeExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZNodeExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZNodeExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZNodeExtension2 *p;
	size_t k = sizeof(tt__PTZNodeExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZNodeExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZNodeExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZNodeExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZNodeExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZNodeExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZNodeExtension2(soap, tag ? tag : "tt:PTZNodeExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZNodeExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZNodeExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZNodeExtension2 * SOAP_FMAC4 soap_get_tt__PTZNodeExtension2(struct soap *soap, tt__PTZNodeExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNodeExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZNodeExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZNodeExtension::__any);
	this->tt__PTZNodeExtension::SupportedPresetTour = NULL;
	this->tt__PTZNodeExtension::Extension = NULL;
}

void tt__PTZNodeExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZNodeExtension::__any);
	soap_serialize_PointerTott__PTZPresetTourSupported(soap, &this->tt__PTZNodeExtension::SupportedPresetTour);
	soap_serialize_PointerTott__PTZNodeExtension2(soap, &this->tt__PTZNodeExtension::Extension);
#endif
}

int tt__PTZNodeExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZNodeExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNodeExtension(struct soap *soap, const char *tag, int id, const tt__PTZNodeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNodeExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZNodeExtension::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSupported(soap, "tt:SupportedPresetTour", -1, &a->tt__PTZNodeExtension::SupportedPresetTour, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZNodeExtension2(soap, "tt:Extension", -1, &a->tt__PTZNodeExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZNodeExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZNodeExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZNodeExtension * SOAP_FMAC4 soap_in_tt__PTZNodeExtension(struct soap *soap, const char *tag, tt__PTZNodeExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZNodeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(tt__PTZNodeExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZNodeExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZNodeExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SupportedPresetTour1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportedPresetTour1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSupported(soap, "tt:SupportedPresetTour", &a->tt__PTZNodeExtension::SupportedPresetTour, "tt:PTZPresetTourSupported"))
				{	soap_flag_SupportedPresetTour1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZNodeExtension2(soap, "tt:Extension", &a->tt__PTZNodeExtension::Extension, "tt:PTZNodeExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZNodeExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZNodeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNodeExtension, SOAP_TYPE_tt__PTZNodeExtension, sizeof(tt__PTZNodeExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZNodeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZNodeExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZNodeExtension *p;
	size_t k = sizeof(tt__PTZNodeExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZNodeExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZNodeExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZNodeExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZNodeExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZNodeExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZNodeExtension(soap, tag ? tag : "tt:PTZNodeExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZNodeExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZNodeExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZNodeExtension * SOAP_FMAC4 soap_get_tt__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZNode::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__DeviceEntity::soap_default(soap);
	this->tt__PTZNode::Name = NULL;
	this->tt__PTZNode::SupportedPTZSpaces = NULL;
	soap_default_int(soap, &this->tt__PTZNode::MaximumNumberOfPresets);
	soap_default_bool(soap, &this->tt__PTZNode::HomeSupported);
	soap_default_std__vectorTemplateOftt__AuxiliaryData(soap, &this->tt__PTZNode::AuxiliaryCommands);
	this->tt__PTZNode::Extension = NULL;
	this->tt__PTZNode::FixedHomePosition = NULL;
	this->tt__PTZNode::GeoMove = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZNode::__anyAttribute);
}

void tt__PTZNode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Name(soap, &this->tt__PTZNode::Name);
	soap_serialize_PointerTott__PTZSpaces(soap, &this->tt__PTZNode::SupportedPTZSpaces);
	soap_embedded(soap, &this->tt__PTZNode::MaximumNumberOfPresets, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__PTZNode::HomeSupported, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOftt__AuxiliaryData(soap, &this->tt__PTZNode::AuxiliaryCommands);
	soap_serialize_PointerTott__PTZNodeExtension(soap, &this->tt__PTZNode::Extension);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__PTZNode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZNode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNode(struct soap *soap, const char *tag, int id, const tt__PTZNode *a, const char *type)
{
	if (((tt__PTZNode*)a)->FixedHomePosition)
	{	soap_set_attr(soap, "FixedHomePosition", soap_bool2s(soap, *((tt__PTZNode*)a)->FixedHomePosition), 1);
	}
	if (((tt__PTZNode*)a)->GeoMove)
	{	soap_set_attr(soap, "GeoMove", soap_bool2s(soap, *((tt__PTZNode*)a)->GeoMove), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZNode*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNode), type ? type : "tt:PTZNode"))
		return soap->error;
	if (soap_out_PointerTott__Name(soap, "tt:Name", -1, &a->tt__PTZNode::Name, ""))
		return soap->error;
	if (!a->tt__PTZNode::SupportedPTZSpaces)
	{	if (soap_element_empty(soap, "tt:SupportedPTZSpaces"))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", -1, &a->tt__PTZNode::SupportedPTZSpaces, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfPresets", -1, &a->tt__PTZNode::MaximumNumberOfPresets, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:HomeSupported", -1, &a->tt__PTZNode::HomeSupported, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__AuxiliaryData(soap, "tt:AuxiliaryCommands", -1, &a->tt__PTZNode::AuxiliaryCommands, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZNodeExtension(soap, "tt:Extension", -1, &a->tt__PTZNode::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZNode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZNode(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZNode * SOAP_FMAC4 soap_in_tt__PTZNode(struct soap *soap, const char *tag, tt__PTZNode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZNode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNode, sizeof(tt__PTZNode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZNode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZNode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "FixedHomePosition", 5, 0);
		if (t)
		{
			if (!(((tt__PTZNode*)a)->FixedHomePosition = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__PTZNode*)a)->FixedHomePosition))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoMove", 5, 0);
		if (t)
		{
			if (!(((tt__PTZNode*)a)->GeoMove = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__PTZNode*)a)->GeoMove))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZNode*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_SupportedPTZSpaces1 = 1;
	size_t soap_flag_MaximumNumberOfPresets1 = 1;
	size_t soap_flag_HomeSupported1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__Name(soap, "tt:Name", &a->tt__PTZNode::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_SupportedPTZSpaces1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", &a->tt__PTZNode::SupportedPTZSpaces, "tt:PTZSpaces"))
				{	soap_flag_SupportedPTZSpaces1--;
					continue;
				}
			}
			if (soap_flag_MaximumNumberOfPresets1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumNumberOfPresets", &a->tt__PTZNode::MaximumNumberOfPresets, "xsd:int"))
				{	soap_flag_MaximumNumberOfPresets1--;
					continue;
				}
			}
			if (soap_flag_HomeSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:HomeSupported", &a->tt__PTZNode::HomeSupported, "xsd:boolean"))
				{	soap_flag_HomeSupported1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__AuxiliaryData(soap, "tt:AuxiliaryCommands", &a->tt__PTZNode::AuxiliaryCommands, "tt:AuxiliaryData"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZNodeExtension(soap, "tt:Extension", &a->tt__PTZNode::Extension, "tt:PTZNodeExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PTZNode::SupportedPTZSpaces || soap_flag_MaximumNumberOfPresets1 > 0 || soap_flag_HomeSupported1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNode, SOAP_TYPE_tt__PTZNode, sizeof(tt__PTZNode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZNode * SOAP_FMAC2 soap_instantiate_tt__PTZNode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZNode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZNode *p;
	size_t k = sizeof(tt__PTZNode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZNode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZNode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZNode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZNode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZNode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZNode(soap, tag ? tag : "tt:PTZNode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZNode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZNode(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZNode * SOAP_FMAC4 soap_get_tt__PTZNode(struct soap *soap, tt__PTZNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DigitalInput::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__DeviceEntity::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DigitalInput::__any);
	this->tt__DigitalInput::IdleState = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__DigitalInput::__anyAttribute);
}

void tt__DigitalInput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DigitalInput::__any);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__DigitalInput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DigitalInput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DigitalInput(struct soap *soap, const char *tag, int id, const tt__DigitalInput *a, const char *type)
{
	if (((tt__DigitalInput*)a)->IdleState)
	{	soap_set_attr(soap, "IdleState", soap_tt__DigitalIdleState2s(soap, *((tt__DigitalInput*)a)->IdleState), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__DigitalInput*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DigitalInput), type ? type : "tt:DigitalInput"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__DigitalInput::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DigitalInput::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DigitalInput(soap, tag, this, type);
}

SOAP_FMAC3 tt__DigitalInput * SOAP_FMAC4 soap_in_tt__DigitalInput(struct soap *soap, const char *tag, tt__DigitalInput *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DigitalInput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DigitalInput, sizeof(tt__DigitalInput), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DigitalInput)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DigitalInput *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "IdleState", 5, 0);
		if (t)
		{
			if (!(((tt__DigitalInput*)a)->IdleState = (tt__DigitalIdleState *)soap_malloc(soap, sizeof(tt__DigitalIdleState))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__DigitalIdleState(soap, t, ((tt__DigitalInput*)a)->IdleState))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__DigitalInput*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__DigitalInput::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DigitalInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DigitalInput, SOAP_TYPE_tt__DigitalInput, sizeof(tt__DigitalInput), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DigitalInput * SOAP_FMAC2 soap_instantiate_tt__DigitalInput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DigitalInput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DigitalInput *p;
	size_t k = sizeof(tt__DigitalInput);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DigitalInput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DigitalInput);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DigitalInput, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DigitalInput location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DigitalInput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DigitalInput(soap, tag ? tag : "tt:DigitalInput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DigitalInput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DigitalInput(soap, this, tag, type);
}

SOAP_FMAC3 tt__DigitalInput * SOAP_FMAC4 soap_get_tt__DigitalInput(struct soap *soap, tt__DigitalInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DigitalInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelayOutput::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__DeviceEntity::soap_default(soap);
	this->tt__RelayOutput::Properties = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RelayOutput::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__RelayOutput::__anyAttribute);
}

void tt__RelayOutput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RelayOutputSettings(soap, &this->tt__RelayOutput::Properties);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RelayOutput::__any);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__RelayOutput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelayOutput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutput(struct soap *soap, const char *tag, int id, const tt__RelayOutput *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RelayOutput*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutput), type ? type : "tt:RelayOutput"))
		return soap->error;
	if (!a->tt__RelayOutput::Properties)
	{	if (soap_element_empty(soap, "tt:Properties"))
			return soap->error;
	}
	else if (soap_out_PointerTott__RelayOutputSettings(soap, "tt:Properties", -1, &a->tt__RelayOutput::Properties, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RelayOutput::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelayOutput::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelayOutput(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelayOutput * SOAP_FMAC4 soap_in_tt__RelayOutput(struct soap *soap, const char *tag, tt__RelayOutput *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelayOutput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutput, sizeof(tt__RelayOutput), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelayOutput)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelayOutput *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RelayOutput*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Properties1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelayOutputSettings(soap, "tt:Properties", &a->tt__RelayOutput::Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RelayOutput::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__RelayOutput::Properties))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelayOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutput, SOAP_TYPE_tt__RelayOutput, sizeof(tt__RelayOutput), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelayOutput * SOAP_FMAC2 soap_instantiate_tt__RelayOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelayOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelayOutput *p;
	size_t k = sizeof(tt__RelayOutput);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelayOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelayOutput);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelayOutput, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelayOutput location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelayOutput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelayOutput(soap, tag ? tag : "tt:RelayOutput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelayOutput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelayOutput(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelayOutput * SOAP_FMAC4 soap_get_tt__RelayOutput(struct soap *soap, tt__RelayOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelayOutputSettings::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__RelayMode(soap, &this->tt__RelayOutputSettings::Mode);
	soap_default_xsd__duration(soap, &this->tt__RelayOutputSettings::DelayTime);
	soap_default_tt__RelayIdleState(soap, &this->tt__RelayOutputSettings::IdleState);
}

void tt__RelayOutputSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RelayOutputSettings::DelayTime, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__RelayOutputSettings::DelayTime);
#endif
}

int tt__RelayOutputSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelayOutputSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutputSettings(struct soap *soap, const char *tag, int id, const tt__RelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutputSettings), type))
		return soap->error;
	if (soap_out_tt__RelayMode(soap, "tt:Mode", -1, &a->tt__RelayOutputSettings::Mode, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:DelayTime", -1, &a->tt__RelayOutputSettings::DelayTime, ""))
		return soap->error;
	if (soap_out_tt__RelayIdleState(soap, "tt:IdleState", -1, &a->tt__RelayOutputSettings::IdleState, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelayOutputSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelayOutputSettings(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelayOutputSettings * SOAP_FMAC4 soap_in_tt__RelayOutputSettings(struct soap *soap, const char *tag, tt__RelayOutputSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelayOutputSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(tt__RelayOutputSettings), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelayOutputSettings)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelayOutputSettings *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_DelayTime1 = 1;
	size_t soap_flag_IdleState1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RelayMode(soap, "tt:Mode", &a->tt__RelayOutputSettings::Mode, "tt:RelayMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_DelayTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:DelayTime", &a->tt__RelayOutputSettings::DelayTime, "xsd:duration"))
				{	soap_flag_DelayTime1--;
					continue;
				}
			}
			if (soap_flag_IdleState1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RelayIdleState(soap, "tt:IdleState", &a->tt__RelayOutputSettings::IdleState, "tt:RelayIdleState"))
				{	soap_flag_IdleState1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0 || soap_flag_DelayTime1 > 0 || soap_flag_IdleState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutputSettings, SOAP_TYPE_tt__RelayOutputSettings, sizeof(tt__RelayOutputSettings), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelayOutputSettings * SOAP_FMAC2 soap_instantiate_tt__RelayOutputSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelayOutputSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelayOutputSettings *p;
	size_t k = sizeof(tt__RelayOutputSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelayOutputSettings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelayOutputSettings);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelayOutputSettings, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelayOutputSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelayOutputSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelayOutputSettings(soap, tag ? tag : "tt:RelayOutputSettings", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelayOutputSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelayOutputSettings(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelayOutputSettings * SOAP_FMAC4 soap_get_tt__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__GenericEapPwdConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__GenericEapPwdConfigurationExtension::__any);
}

void tt__GenericEapPwdConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__GenericEapPwdConfigurationExtension::__any);
#endif
}

int tt__GenericEapPwdConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__GenericEapPwdConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__GenericEapPwdConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__GenericEapPwdConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__GenericEapPwdConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__GenericEapPwdConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__GenericEapPwdConfigurationExtension * SOAP_FMAC4 soap_in_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const char *tag, tt__GenericEapPwdConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__GenericEapPwdConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, sizeof(tt__GenericEapPwdConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__GenericEapPwdConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__GenericEapPwdConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__GenericEapPwdConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__GenericEapPwdConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, sizeof(tt__GenericEapPwdConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__GenericEapPwdConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__GenericEapPwdConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__GenericEapPwdConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__GenericEapPwdConfigurationExtension *p;
	size_t k = sizeof(tt__GenericEapPwdConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__GenericEapPwdConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__GenericEapPwdConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__GenericEapPwdConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__GenericEapPwdConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__GenericEapPwdConfigurationExtension(soap, tag ? tag : "tt:GenericEapPwdConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__GenericEapPwdConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__GenericEapPwdConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__GenericEapPwdConfigurationExtension * SOAP_FMAC4 soap_get_tt__GenericEapPwdConfigurationExtension(struct soap *soap, tt__GenericEapPwdConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GenericEapPwdConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TLSConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &this->tt__TLSConfiguration::CertificateID);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__TLSConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__TLSConfiguration::__anyAttribute);
}

void tt__TLSConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__TLSConfiguration::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__TLSConfiguration::CertificateID);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__TLSConfiguration::__any);
#endif
}

int tt__TLSConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TLSConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TLSConfiguration(struct soap *soap, const char *tag, int id, const tt__TLSConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__TLSConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TLSConfiguration), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->tt__TLSConfiguration::CertificateID, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__TLSConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__TLSConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TLSConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__TLSConfiguration * SOAP_FMAC4 soap_in_tt__TLSConfiguration(struct soap *soap, const char *tag, tt__TLSConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TLSConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TLSConfiguration, sizeof(tt__TLSConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TLSConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__TLSConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__TLSConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_CertificateID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", &a->tt__TLSConfiguration::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__TLSConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__TLSConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TLSConfiguration, SOAP_TYPE_tt__TLSConfiguration, sizeof(tt__TLSConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TLSConfiguration * SOAP_FMAC2 soap_instantiate_tt__TLSConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TLSConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TLSConfiguration *p;
	size_t k = sizeof(tt__TLSConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TLSConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TLSConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TLSConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TLSConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TLSConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TLSConfiguration(soap, tag ? tag : "tt:TLSConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TLSConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TLSConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__TLSConfiguration * SOAP_FMAC4 soap_get_tt__TLSConfiguration(struct soap *soap, tt__TLSConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TLSConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EapMethodExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EapMethodExtension::__any);
}

void tt__EapMethodExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EapMethodExtension::__any);
#endif
}

int tt__EapMethodExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EapMethodExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EapMethodExtension(struct soap *soap, const char *tag, int id, const tt__EapMethodExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EapMethodExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__EapMethodExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EapMethodExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EapMethodExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__EapMethodExtension * SOAP_FMAC4 soap_in_tt__EapMethodExtension(struct soap *soap, const char *tag, tt__EapMethodExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EapMethodExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EapMethodExtension, sizeof(tt__EapMethodExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EapMethodExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EapMethodExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__EapMethodExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EapMethodExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EapMethodExtension, SOAP_TYPE_tt__EapMethodExtension, sizeof(tt__EapMethodExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EapMethodExtension * SOAP_FMAC2 soap_instantiate_tt__EapMethodExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EapMethodExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EapMethodExtension *p;
	size_t k = sizeof(tt__EapMethodExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EapMethodExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EapMethodExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EapMethodExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EapMethodExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EapMethodExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EapMethodExtension(soap, tag ? tag : "tt:EapMethodExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EapMethodExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EapMethodExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__EapMethodExtension * SOAP_FMAC4 soap_get_tt__EapMethodExtension(struct soap *soap, tt__EapMethodExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EapMethodExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EAPMethodConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__EAPMethodConfiguration::TLSConfiguration = NULL;
	this->tt__EAPMethodConfiguration::Password = NULL;
	this->tt__EAPMethodConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__EAPMethodConfiguration::__anyAttribute);
}

void tt__EAPMethodConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__TLSConfiguration(soap, &this->tt__EAPMethodConfiguration::TLSConfiguration);
	soap_serialize_PointerTostd__string(soap, &this->tt__EAPMethodConfiguration::Password);
	soap_serialize_PointerTott__EapMethodExtension(soap, &this->tt__EAPMethodConfiguration::Extension);
#endif
}

int tt__EAPMethodConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EAPMethodConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EAPMethodConfiguration(struct soap *soap, const char *tag, int id, const tt__EAPMethodConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__EAPMethodConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EAPMethodConfiguration), type))
		return soap->error;
	if (soap_out_PointerTott__TLSConfiguration(soap, "tt:TLSConfiguration", -1, &a->tt__EAPMethodConfiguration::TLSConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Password", -1, &a->tt__EAPMethodConfiguration::Password, ""))
		return soap->error;
	if (soap_out_PointerTott__EapMethodExtension(soap, "tt:Extension", -1, &a->tt__EAPMethodConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EAPMethodConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EAPMethodConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__EAPMethodConfiguration * SOAP_FMAC4 soap_in_tt__EAPMethodConfiguration(struct soap *soap, const char *tag, tt__EAPMethodConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EAPMethodConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(tt__EAPMethodConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EAPMethodConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EAPMethodConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__EAPMethodConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_TLSConfiguration1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLSConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TLSConfiguration(soap, "tt:TLSConfiguration", &a->tt__EAPMethodConfiguration::TLSConfiguration, "tt:TLSConfiguration"))
				{	soap_flag_TLSConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Password", &a->tt__EAPMethodConfiguration::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EapMethodExtension(soap, "tt:Extension", &a->tt__EAPMethodConfiguration::Extension, "tt:EapMethodExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EAPMethodConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EAPMethodConfiguration, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(tt__EAPMethodConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EAPMethodConfiguration * SOAP_FMAC2 soap_instantiate_tt__EAPMethodConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EAPMethodConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EAPMethodConfiguration *p;
	size_t k = sizeof(tt__EAPMethodConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EAPMethodConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EAPMethodConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EAPMethodConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EAPMethodConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EAPMethodConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EAPMethodConfiguration(soap, tag ? tag : "tt:EAPMethodConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EAPMethodConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EAPMethodConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__EAPMethodConfiguration * SOAP_FMAC4 soap_get_tt__EAPMethodConfiguration(struct soap *soap, tt__EAPMethodConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EAPMethodConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot1XConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot1XConfigurationExtension::__any);
}

void tt__Dot1XConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot1XConfigurationExtension::__any);
#endif
}

int tt__Dot1XConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot1XConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot1XConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__Dot1XConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot1XConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__Dot1XConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot1XConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot1XConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_in_tt__Dot1XConfigurationExtension(struct soap *soap, const char *tag, tt__Dot1XConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot1XConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(tt__Dot1XConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot1XConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot1XConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__Dot1XConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot1XConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfigurationExtension, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(tt__Dot1XConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot1XConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot1XConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot1XConfigurationExtension *p;
	size_t k = sizeof(tt__Dot1XConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot1XConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot1XConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot1XConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot1XConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot1XConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot1XConfigurationExtension(soap, tag ? tag : "tt:Dot1XConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot1XConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot1XConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_get_tt__Dot1XConfigurationExtension(struct soap *soap, tt__Dot1XConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot1XConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot1XConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &this->tt__Dot1XConfiguration::Dot1XConfigurationToken);
	soap_default_std__string(soap, &this->tt__Dot1XConfiguration::Identity);
	this->tt__Dot1XConfiguration::AnonymousID = NULL;
	soap_default_int(soap, &this->tt__Dot1XConfiguration::EAPMethod);
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->tt__Dot1XConfiguration::CACertificateID);
	this->tt__Dot1XConfiguration::EAPMethodConfiguration = NULL;
	this->tt__Dot1XConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Dot1XConfiguration::__anyAttribute);
}

void tt__Dot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Dot1XConfiguration::Dot1XConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__Dot1XConfiguration::Dot1XConfigurationToken);
	soap_embedded(soap, &this->tt__Dot1XConfiguration::Identity, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__Dot1XConfiguration::Identity);
	soap_serialize_PointerTostd__string(soap, &this->tt__Dot1XConfiguration::AnonymousID);
	soap_embedded(soap, &this->tt__Dot1XConfiguration::EAPMethod, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->tt__Dot1XConfiguration::CACertificateID);
	soap_serialize_PointerTott__EAPMethodConfiguration(soap, &this->tt__Dot1XConfiguration::EAPMethodConfiguration);
	soap_serialize_PointerTott__Dot1XConfigurationExtension(soap, &this->tt__Dot1XConfiguration::Extension);
#endif
}

int tt__Dot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot1XConfiguration(struct soap *soap, const char *tag, int id, const tt__Dot1XConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Dot1XConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot1XConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:Dot1XConfigurationToken", -1, &a->tt__Dot1XConfiguration::Dot1XConfigurationToken, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Identity", -1, &a->tt__Dot1XConfiguration::Identity, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:AnonymousID", -1, &a->tt__Dot1XConfiguration::AnonymousID, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EAPMethod", -1, &a->tt__Dot1XConfiguration::EAPMethod, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tt:CACertificateID", -1, &a->tt__Dot1XConfiguration::CACertificateID, ""))
		return soap->error;
	if (soap_out_PointerTott__EAPMethodConfiguration(soap, "tt:EAPMethodConfiguration", -1, &a->tt__Dot1XConfiguration::EAPMethodConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot1XConfigurationExtension(soap, "tt:Extension", -1, &a->tt__Dot1XConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot1XConfiguration * SOAP_FMAC4 soap_in_tt__Dot1XConfiguration(struct soap *soap, const char *tag, tt__Dot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(tt__Dot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Dot1XConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Dot1XConfigurationToken1 = 1;
	size_t soap_flag_Identity1 = 1;
	size_t soap_flag_AnonymousID1 = 1;
	size_t soap_flag_EAPMethod1 = 1;
	size_t soap_flag_EAPMethodConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:Dot1XConfigurationToken", &a->tt__Dot1XConfiguration::Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken1--;
					continue;
				}
			}
			if (soap_flag_Identity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Identity", &a->tt__Dot1XConfiguration::Identity, "xsd:string"))
				{	soap_flag_Identity1--;
					continue;
				}
			}
			if (soap_flag_AnonymousID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:AnonymousID", &a->tt__Dot1XConfiguration::AnonymousID, "xsd:string"))
				{	soap_flag_AnonymousID1--;
					continue;
				}
			}
			if (soap_flag_EAPMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:EAPMethod", &a->tt__Dot1XConfiguration::EAPMethod, "xsd:int"))
				{	soap_flag_EAPMethod1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__token(soap, "tt:CACertificateID", &a->tt__Dot1XConfiguration::CACertificateID, "xsd:token"))
					continue;
			}
			if (soap_flag_EAPMethodConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EAPMethodConfiguration(soap, "tt:EAPMethodConfiguration", &a->tt__Dot1XConfiguration::EAPMethodConfiguration, "tt:EAPMethodConfiguration"))
				{	soap_flag_EAPMethodConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfigurationExtension(soap, "tt:Extension", &a->tt__Dot1XConfiguration::Extension, "tt:Dot1XConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfigurationToken1 > 0 || soap_flag_Identity1 > 0 || soap_flag_EAPMethod1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfiguration, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(tt__Dot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot1XConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot1XConfiguration *p;
	size_t k = sizeof(tt__Dot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot1XConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot1XConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot1XConfiguration(soap, tag ? tag : "tt:Dot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot1XConfiguration * SOAP_FMAC4 soap_get_tt__Dot1XConfiguration(struct soap *soap, tt__Dot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateInformationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CertificateInformationExtension::__any);
}

void tt__CertificateInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CertificateInformationExtension::__any);
#endif
}

int tt__CertificateInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateInformationExtension(struct soap *soap, const char *tag, int id, const tt__CertificateInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateInformationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__CertificateInformationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateInformationExtension * SOAP_FMAC4 soap_in_tt__CertificateInformationExtension(struct soap *soap, const char *tag, tt__CertificateInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(tt__CertificateInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateInformationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateInformationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__CertificateInformationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CertificateInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformationExtension, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(tt__CertificateInformationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateInformationExtension *p;
	size_t k = sizeof(tt__CertificateInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateInformationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateInformationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateInformationExtension(soap, tag ? tag : "tt:CertificateInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateInformationExtension * SOAP_FMAC4 soap_get_tt__CertificateInformationExtension(struct soap *soap, tt__CertificateInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateUsage::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__CertificateUsage::__item);
	soap_default_bool(soap, &this->tt__CertificateUsage::Critical);
}

void tt__CertificateUsage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__CertificateUsage::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__CertificateUsage::__item);
#endif
}

int tt__CertificateUsage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateUsage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateUsage(struct soap *soap, const char *tag, int id, const tt__CertificateUsage *a, const char *type)
{
	soap_set_attr(soap, "Critical", soap_bool2s(soap, ((tt__CertificateUsage*)a)->Critical), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_std__string(soap, tag, id, &a->tt__CertificateUsage::__item, "");
}

void *tt__CertificateUsage::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateUsage(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateUsage * SOAP_FMAC4 soap_in_tt__CertificateUsage(struct soap *soap, const char *tag, tt__CertificateUsage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__CertificateUsage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateUsage, sizeof(tt__CertificateUsage), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateUsage)
		return (tt__CertificateUsage *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "Critical", 5, 1), &((tt__CertificateUsage*)a)->Critical))
		return NULL;
	if (!soap_in_std__string(soap, tag, &a->tt__CertificateUsage::__item, "tt:CertificateUsage"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__CertificateUsage * SOAP_FMAC2 soap_instantiate_tt__CertificateUsage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateUsage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateUsage *p;
	size_t k = sizeof(tt__CertificateUsage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateUsage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateUsage);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateUsage, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateUsage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateUsage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateUsage(soap, tag ? tag : "tt:CertificateUsage", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateUsage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateUsage(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateUsage * SOAP_FMAC4 soap_get_tt__CertificateUsage(struct soap *soap, tt__CertificateUsage *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateInformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &this->tt__CertificateInformation::CertificateID);
	this->tt__CertificateInformation::IssuerDN = NULL;
	this->tt__CertificateInformation::SubjectDN = NULL;
	this->tt__CertificateInformation::KeyUsage = NULL;
	this->tt__CertificateInformation::ExtendedKeyUsage = NULL;
	this->tt__CertificateInformation::KeyLength = NULL;
	this->tt__CertificateInformation::Version = NULL;
	this->tt__CertificateInformation::SerialNum = NULL;
	this->tt__CertificateInformation::SignatureAlgorithm = NULL;
	this->tt__CertificateInformation::Validity = NULL;
	this->tt__CertificateInformation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__CertificateInformation::__anyAttribute);
}

void tt__CertificateInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__CertificateInformation::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__CertificateInformation::CertificateID);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::IssuerDN);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::SubjectDN);
	soap_serialize_PointerTott__CertificateUsage(soap, &this->tt__CertificateInformation::KeyUsage);
	soap_serialize_PointerTott__CertificateUsage(soap, &this->tt__CertificateInformation::ExtendedKeyUsage);
	soap_serialize_PointerToint(soap, &this->tt__CertificateInformation::KeyLength);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::Version);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::SerialNum);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::SignatureAlgorithm);
	soap_serialize_PointerTott__DateTimeRange(soap, &this->tt__CertificateInformation::Validity);
	soap_serialize_PointerTott__CertificateInformationExtension(soap, &this->tt__CertificateInformation::Extension);
#endif
}

int tt__CertificateInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateInformation(struct soap *soap, const char *tag, int id, const tt__CertificateInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__CertificateInformation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateInformation), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->tt__CertificateInformation::CertificateID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:IssuerDN", -1, &a->tt__CertificateInformation::IssuerDN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:SubjectDN", -1, &a->tt__CertificateInformation::SubjectDN, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateUsage(soap, "tt:KeyUsage", -1, &a->tt__CertificateInformation::KeyUsage, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateUsage(soap, "tt:ExtendedKeyUsage", -1, &a->tt__CertificateInformation::ExtendedKeyUsage, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:KeyLength", -1, &a->tt__CertificateInformation::KeyLength, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Version", -1, &a->tt__CertificateInformation::Version, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:SerialNum", -1, &a->tt__CertificateInformation::SerialNum, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:SignatureAlgorithm", -1, &a->tt__CertificateInformation::SignatureAlgorithm, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTimeRange(soap, "tt:Validity", -1, &a->tt__CertificateInformation::Validity, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateInformationExtension(soap, "tt:Extension", -1, &a->tt__CertificateInformation::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateInformation * SOAP_FMAC4 soap_in_tt__CertificateInformation(struct soap *soap, const char *tag, tt__CertificateInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformation, sizeof(tt__CertificateInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__CertificateInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_IssuerDN1 = 1;
	size_t soap_flag_SubjectDN1 = 1;
	size_t soap_flag_KeyUsage1 = 1;
	size_t soap_flag_ExtendedKeyUsage1 = 1;
	size_t soap_flag_KeyLength1 = 1;
	size_t soap_flag_Version1 = 1;
	size_t soap_flag_SerialNum1 = 1;
	size_t soap_flag_SignatureAlgorithm1 = 1;
	size_t soap_flag_Validity1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", &a->tt__CertificateInformation::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_IssuerDN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:IssuerDN", &a->tt__CertificateInformation::IssuerDN, "xsd:string"))
				{	soap_flag_IssuerDN1--;
					continue;
				}
			}
			if (soap_flag_SubjectDN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:SubjectDN", &a->tt__CertificateInformation::SubjectDN, "xsd:string"))
				{	soap_flag_SubjectDN1--;
					continue;
				}
			}
			if (soap_flag_KeyUsage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateUsage(soap, "tt:KeyUsage", &a->tt__CertificateInformation::KeyUsage, "tt:CertificateUsage"))
				{	soap_flag_KeyUsage1--;
					continue;
				}
			}
			if (soap_flag_ExtendedKeyUsage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateUsage(soap, "tt:ExtendedKeyUsage", &a->tt__CertificateInformation::ExtendedKeyUsage, "tt:CertificateUsage"))
				{	soap_flag_ExtendedKeyUsage1--;
					continue;
				}
			}
			if (soap_flag_KeyLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:KeyLength", &a->tt__CertificateInformation::KeyLength, "xsd:int"))
				{	soap_flag_KeyLength1--;
					continue;
				}
			}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Version", &a->tt__CertificateInformation::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			}
			if (soap_flag_SerialNum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:SerialNum", &a->tt__CertificateInformation::SerialNum, "xsd:string"))
				{	soap_flag_SerialNum1--;
					continue;
				}
			}
			if (soap_flag_SignatureAlgorithm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:SignatureAlgorithm", &a->tt__CertificateInformation::SignatureAlgorithm, "xsd:string"))
				{	soap_flag_SignatureAlgorithm1--;
					continue;
				}
			}
			if (soap_flag_Validity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTimeRange(soap, "tt:Validity", &a->tt__CertificateInformation::Validity, "tt:DateTimeRange"))
				{	soap_flag_Validity1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateInformationExtension(soap, "tt:Extension", &a->tt__CertificateInformation::Extension, "tt:CertificateInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__CertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformation, SOAP_TYPE_tt__CertificateInformation, sizeof(tt__CertificateInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateInformation * SOAP_FMAC2 soap_instantiate_tt__CertificateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateInformation *p;
	size_t k = sizeof(tt__CertificateInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateInformation(soap, tag ? tag : "tt:CertificateInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateInformation * SOAP_FMAC4 soap_get_tt__CertificateInformation(struct soap *soap, tt__CertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateWithPrivateKey::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__CertificateWithPrivateKey::CertificateID = NULL;
	this->tt__CertificateWithPrivateKey::Certificate = NULL;
	this->tt__CertificateWithPrivateKey::PrivateKey = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CertificateWithPrivateKey::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__CertificateWithPrivateKey::__anyAttribute);
}

void tt__CertificateWithPrivateKey::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__token(soap, &this->tt__CertificateWithPrivateKey::CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &this->tt__CertificateWithPrivateKey::Certificate);
	soap_serialize_PointerTott__BinaryData(soap, &this->tt__CertificateWithPrivateKey::PrivateKey);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CertificateWithPrivateKey::__any);
#endif
}

int tt__CertificateWithPrivateKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateWithPrivateKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const tt__CertificateWithPrivateKey *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__CertificateWithPrivateKey*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateWithPrivateKey), type))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:CertificateID", -1, &a->tt__CertificateWithPrivateKey::CertificateID, ""))
		return soap->error;
	if (!a->tt__CertificateWithPrivateKey::Certificate)
	{	if (soap_element_empty(soap, "tt:Certificate"))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->tt__CertificateWithPrivateKey::Certificate, ""))
		return soap->error;
	if (!a->tt__CertificateWithPrivateKey::PrivateKey)
	{	if (soap_element_empty(soap, "tt:PrivateKey"))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tt:PrivateKey", -1, &a->tt__CertificateWithPrivateKey::PrivateKey, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__CertificateWithPrivateKey::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateWithPrivateKey::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateWithPrivateKey(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_in_tt__CertificateWithPrivateKey(struct soap *soap, const char *tag, tt__CertificateWithPrivateKey *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateWithPrivateKey*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(tt__CertificateWithPrivateKey), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateWithPrivateKey)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateWithPrivateKey *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__CertificateWithPrivateKey*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Certificate1 = 1;
	size_t soap_flag_PrivateKey1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__token(soap, "tt:CertificateID", &a->tt__CertificateWithPrivateKey::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Certificate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &a->tt__CertificateWithPrivateKey::Certificate, "tt:BinaryData"))
				{	soap_flag_Certificate1--;
					continue;
				}
			}
			if (soap_flag_PrivateKey1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tt:PrivateKey", &a->tt__CertificateWithPrivateKey::PrivateKey, "tt:BinaryData"))
				{	soap_flag_PrivateKey1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__CertificateWithPrivateKey::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__CertificateWithPrivateKey::Certificate || !a->tt__CertificateWithPrivateKey::PrivateKey))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__CertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateWithPrivateKey, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(tt__CertificateWithPrivateKey), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate_tt__CertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateWithPrivateKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateWithPrivateKey *p;
	size_t k = sizeof(tt__CertificateWithPrivateKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateWithPrivateKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateWithPrivateKey);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateWithPrivateKey, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateWithPrivateKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateWithPrivateKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateWithPrivateKey(soap, tag ? tag : "tt:CertificateWithPrivateKey", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateWithPrivateKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateWithPrivateKey(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_get_tt__CertificateWithPrivateKey(struct soap *soap, tt__CertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateStatus::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &this->tt__CertificateStatus::CertificateID);
	soap_default_bool(soap, &this->tt__CertificateStatus::Status);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CertificateStatus::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__CertificateStatus::__anyAttribute);
}

void tt__CertificateStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__CertificateStatus::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__CertificateStatus::CertificateID);
	soap_embedded(soap, &this->tt__CertificateStatus::Status, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CertificateStatus::__any);
#endif
}

int tt__CertificateStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateStatus(struct soap *soap, const char *tag, int id, const tt__CertificateStatus *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__CertificateStatus*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateStatus), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->tt__CertificateStatus::CertificateID, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Status", -1, &a->tt__CertificateStatus::Status, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__CertificateStatus::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateStatus * SOAP_FMAC4 soap_in_tt__CertificateStatus(struct soap *soap, const char *tag, tt__CertificateStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateStatus, sizeof(tt__CertificateStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__CertificateStatus*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Status1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", &a->tt__CertificateStatus::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Status", &a->tt__CertificateStatus::Status, "xsd:boolean"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__CertificateStatus::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0 || soap_flag_Status1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__CertificateStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateStatus, SOAP_TYPE_tt__CertificateStatus, sizeof(tt__CertificateStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateStatus * SOAP_FMAC2 soap_instantiate_tt__CertificateStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateStatus *p;
	size_t k = sizeof(tt__CertificateStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateStatus(soap, tag ? tag : "tt:CertificateStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateStatus * SOAP_FMAC4 soap_get_tt__CertificateStatus(struct soap *soap, tt__CertificateStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Certificate::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &this->tt__Certificate::CertificateID);
	this->tt__Certificate::Certificate = NULL;
}

void tt__Certificate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Certificate::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__Certificate::CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &this->tt__Certificate::Certificate);
#endif
}

int tt__Certificate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Certificate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Certificate(struct soap *soap, const char *tag, int id, const tt__Certificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Certificate), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->tt__Certificate::CertificateID, ""))
		return soap->error;
	if (!a->tt__Certificate::Certificate)
	{	if (soap_element_empty(soap, "tt:Certificate"))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->tt__Certificate::Certificate, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Certificate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Certificate(soap, tag, this, type);
}

SOAP_FMAC3 tt__Certificate * SOAP_FMAC4 soap_in_tt__Certificate(struct soap *soap, const char *tag, tt__Certificate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Certificate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Certificate, sizeof(tt__Certificate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Certificate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Certificate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Certificate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", &a->tt__Certificate::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Certificate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &a->tt__Certificate::Certificate, "tt:BinaryData"))
				{	soap_flag_Certificate1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0 || !a->tt__Certificate::Certificate))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Certificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Certificate, SOAP_TYPE_tt__Certificate, sizeof(tt__Certificate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Certificate * SOAP_FMAC2 soap_instantiate_tt__Certificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Certificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Certificate *p;
	size_t k = sizeof(tt__Certificate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Certificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Certificate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Certificate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Certificate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Certificate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Certificate(soap, tag ? tag : "tt:Certificate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Certificate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Certificate(soap, this, tag, type);
}

SOAP_FMAC3 tt__Certificate * SOAP_FMAC4 soap_get_tt__Certificate(struct soap *soap, tt__Certificate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateGenerationParametersExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CertificateGenerationParametersExtension::__any);
}

void tt__CertificateGenerationParametersExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CertificateGenerationParametersExtension::__any);
#endif
}

int tt__CertificateGenerationParametersExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateGenerationParametersExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, int id, const tt__CertificateGenerationParametersExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateGenerationParametersExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__CertificateGenerationParametersExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateGenerationParametersExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateGenerationParametersExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_in_tt__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, tt__CertificateGenerationParametersExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateGenerationParametersExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(tt__CertificateGenerationParametersExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateGenerationParametersExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateGenerationParametersExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__CertificateGenerationParametersExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CertificateGenerationParametersExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateGenerationParametersExtension, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(tt__CertificateGenerationParametersExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateGenerationParametersExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateGenerationParametersExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateGenerationParametersExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateGenerationParametersExtension *p;
	size_t k = sizeof(tt__CertificateGenerationParametersExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateGenerationParametersExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateGenerationParametersExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateGenerationParametersExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateGenerationParametersExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateGenerationParametersExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateGenerationParametersExtension(soap, tag ? tag : "tt:CertificateGenerationParametersExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateGenerationParametersExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateGenerationParametersExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_get_tt__CertificateGenerationParametersExtension(struct soap *soap, tt__CertificateGenerationParametersExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateGenerationParametersExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateGenerationParameters::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__CertificateGenerationParameters::CertificateID = NULL;
	this->tt__CertificateGenerationParameters::Subject = NULL;
	this->tt__CertificateGenerationParameters::ValidNotBefore = NULL;
	this->tt__CertificateGenerationParameters::ValidNotAfter = NULL;
	this->tt__CertificateGenerationParameters::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__CertificateGenerationParameters::__anyAttribute);
}

void tt__CertificateGenerationParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__token(soap, &this->tt__CertificateGenerationParameters::CertificateID);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateGenerationParameters::Subject);
	soap_serialize_PointerToxsd__token(soap, &this->tt__CertificateGenerationParameters::ValidNotBefore);
	soap_serialize_PointerToxsd__token(soap, &this->tt__CertificateGenerationParameters::ValidNotAfter);
	soap_serialize_PointerTott__CertificateGenerationParametersExtension(soap, &this->tt__CertificateGenerationParameters::Extension);
#endif
}

int tt__CertificateGenerationParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateGenerationParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateGenerationParameters(struct soap *soap, const char *tag, int id, const tt__CertificateGenerationParameters *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__CertificateGenerationParameters*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateGenerationParameters), type))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:CertificateID", -1, &a->tt__CertificateGenerationParameters::CertificateID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Subject", -1, &a->tt__CertificateGenerationParameters::Subject, ""))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:ValidNotBefore", -1, &a->tt__CertificateGenerationParameters::ValidNotBefore, ""))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:ValidNotAfter", -1, &a->tt__CertificateGenerationParameters::ValidNotAfter, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateGenerationParametersExtension(soap, "tt:Extension", -1, &a->tt__CertificateGenerationParameters::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateGenerationParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateGenerationParameters(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateGenerationParameters * SOAP_FMAC4 soap_in_tt__CertificateGenerationParameters(struct soap *soap, const char *tag, tt__CertificateGenerationParameters *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateGenerationParameters*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateGenerationParameters, sizeof(tt__CertificateGenerationParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateGenerationParameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateGenerationParameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__CertificateGenerationParameters*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Subject1 = 1;
	size_t soap_flag_ValidNotBefore1 = 1;
	size_t soap_flag_ValidNotAfter1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__token(soap, "tt:CertificateID", &a->tt__CertificateGenerationParameters::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Subject", &a->tt__CertificateGenerationParameters::Subject, "xsd:string"))
				{	soap_flag_Subject1--;
					continue;
				}
			}
			if (soap_flag_ValidNotBefore1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__token(soap, "tt:ValidNotBefore", &a->tt__CertificateGenerationParameters::ValidNotBefore, "xsd:token"))
				{	soap_flag_ValidNotBefore1--;
					continue;
				}
			}
			if (soap_flag_ValidNotAfter1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__token(soap, "tt:ValidNotAfter", &a->tt__CertificateGenerationParameters::ValidNotAfter, "xsd:token"))
				{	soap_flag_ValidNotAfter1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateGenerationParametersExtension(soap, "tt:Extension", &a->tt__CertificateGenerationParameters::Extension, "tt:CertificateGenerationParametersExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CertificateGenerationParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateGenerationParameters, SOAP_TYPE_tt__CertificateGenerationParameters, sizeof(tt__CertificateGenerationParameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateGenerationParameters * SOAP_FMAC2 soap_instantiate_tt__CertificateGenerationParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateGenerationParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateGenerationParameters *p;
	size_t k = sizeof(tt__CertificateGenerationParameters);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateGenerationParameters, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateGenerationParameters);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateGenerationParameters, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateGenerationParameters location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateGenerationParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateGenerationParameters(soap, tag ? tag : "tt:CertificateGenerationParameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateGenerationParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateGenerationParameters(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateGenerationParameters * SOAP_FMAC4 soap_get_tt__CertificateGenerationParameters(struct soap *soap, tt__CertificateGenerationParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateGenerationParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__UserExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__UserExtension::__any);
}

void tt__UserExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__UserExtension::__any);
#endif
}

int tt__UserExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__UserExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserExtension(struct soap *soap, const char *tag, int id, const tt__UserExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__UserExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__UserExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__UserExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__UserExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__UserExtension * SOAP_FMAC4 soap_in_tt__UserExtension(struct soap *soap, const char *tag, tt__UserExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__UserExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserExtension, sizeof(tt__UserExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__UserExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__UserExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__UserExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__UserExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserExtension, SOAP_TYPE_tt__UserExtension, sizeof(tt__UserExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__UserExtension * SOAP_FMAC2 soap_instantiate_tt__UserExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__UserExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__UserExtension *p;
	size_t k = sizeof(tt__UserExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__UserExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__UserExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__UserExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__UserExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__UserExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__UserExtension(soap, tag ? tag : "tt:UserExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__UserExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__UserExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__UserExtension * SOAP_FMAC4 soap_get_tt__UserExtension(struct soap *soap, tt__UserExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__User::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__User::Username);
	this->tt__User::Password = NULL;
	soap_default_tt__UserLevel(soap, &this->tt__User::UserLevel);
	this->tt__User::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__User::__anyAttribute);
}

void tt__User::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__User::Username, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__User::Username);
	soap_serialize_PointerTostd__string(soap, &this->tt__User::Password);
	soap_serialize_PointerTott__UserExtension(soap, &this->tt__User::Extension);
#endif
}

int tt__User::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__User(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__User(struct soap *soap, const char *tag, int id, const tt__User *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__User*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__User), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Username", -1, &a->tt__User::Username, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Password", -1, &a->tt__User::Password, ""))
		return soap->error;
	if (soap_out_tt__UserLevel(soap, "tt:UserLevel", -1, &a->tt__User::UserLevel, ""))
		return soap->error;
	if (soap_out_PointerTott__UserExtension(soap, "tt:Extension", -1, &a->tt__User::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__User::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__User(soap, tag, this, type);
}

SOAP_FMAC3 tt__User * SOAP_FMAC4 soap_in_tt__User(struct soap *soap, const char *tag, tt__User *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__User*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__User, sizeof(tt__User), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__User)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__User *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__User*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_UserLevel1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Username", &a->tt__User::Username, "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Password", &a->tt__User::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_UserLevel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__UserLevel(soap, "tt:UserLevel", &a->tt__User::UserLevel, "tt:UserLevel"))
				{	soap_flag_UserLevel1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__UserExtension(soap, "tt:Extension", &a->tt__User::Extension, "tt:UserExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username1 > 0 || soap_flag_UserLevel1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__User, SOAP_TYPE_tt__User, sizeof(tt__User), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__User * SOAP_FMAC2 soap_instantiate_tt__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__User(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__User *p;
	size_t k = sizeof(tt__User);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__User, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__User);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__User, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__User location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__User::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__User(soap, tag ? tag : "tt:User", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__User::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__User(soap, this, tag, type);
}

SOAP_FMAC3 tt__User * SOAP_FMAC4 soap_get_tt__User(struct soap *soap, tt__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RemoteUser::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__RemoteUser::Username);
	this->tt__RemoteUser::Password = NULL;
	soap_default_bool(soap, &this->tt__RemoteUser::UseDerivedPassword);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RemoteUser::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__RemoteUser::__anyAttribute);
}

void tt__RemoteUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RemoteUser::Username, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__RemoteUser::Username);
	soap_serialize_PointerTostd__string(soap, &this->tt__RemoteUser::Password);
	soap_embedded(soap, &this->tt__RemoteUser::UseDerivedPassword, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RemoteUser::__any);
#endif
}

int tt__RemoteUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RemoteUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RemoteUser(struct soap *soap, const char *tag, int id, const tt__RemoteUser *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RemoteUser*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RemoteUser), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Username", -1, &a->tt__RemoteUser::Username, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Password", -1, &a->tt__RemoteUser::Password, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:UseDerivedPassword", -1, &a->tt__RemoteUser::UseDerivedPassword, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RemoteUser::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RemoteUser::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RemoteUser(soap, tag, this, type);
}

SOAP_FMAC3 tt__RemoteUser * SOAP_FMAC4 soap_in_tt__RemoteUser(struct soap *soap, const char *tag, tt__RemoteUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RemoteUser, sizeof(tt__RemoteUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RemoteUser)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RemoteUser *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RemoteUser*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_UseDerivedPassword1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Username", &a->tt__RemoteUser::Username, "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Password", &a->tt__RemoteUser::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_UseDerivedPassword1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:UseDerivedPassword", &a->tt__RemoteUser::UseDerivedPassword, "xsd:boolean"))
				{	soap_flag_UseDerivedPassword1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RemoteUser::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username1 > 0 || soap_flag_UseDerivedPassword1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RemoteUser, SOAP_TYPE_tt__RemoteUser, sizeof(tt__RemoteUser), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RemoteUser * SOAP_FMAC2 soap_instantiate_tt__RemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RemoteUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RemoteUser *p;
	size_t k = sizeof(tt__RemoteUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RemoteUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RemoteUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RemoteUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RemoteUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RemoteUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RemoteUser(soap, tag ? tag : "tt:RemoteUser", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RemoteUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RemoteUser(soap, this, tag, type);
}

SOAP_FMAC3 tt__RemoteUser * SOAP_FMAC4 soap_get_tt__RemoteUser(struct soap *soap, tt__RemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TimeZone::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &this->tt__TimeZone::TZ);
}

void tt__TimeZone::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__TimeZone::TZ, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__TimeZone::TZ);
#endif
}

int tt__TimeZone::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TimeZone(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TimeZone(struct soap *soap, const char *tag, int id, const tt__TimeZone *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TimeZone), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:TZ", -1, &a->tt__TimeZone::TZ, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__TimeZone::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TimeZone(soap, tag, this, type);
}

SOAP_FMAC3 tt__TimeZone * SOAP_FMAC4 soap_in_tt__TimeZone(struct soap *soap, const char *tag, tt__TimeZone *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TimeZone*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TimeZone, sizeof(tt__TimeZone), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TimeZone)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__TimeZone *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_TZ1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TZ1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:TZ", &a->tt__TimeZone::TZ, "xsd:token"))
				{	soap_flag_TZ1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TZ1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__TimeZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TimeZone, SOAP_TYPE_tt__TimeZone, sizeof(tt__TimeZone), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TimeZone * SOAP_FMAC2 soap_instantiate_tt__TimeZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TimeZone(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TimeZone *p;
	size_t k = sizeof(tt__TimeZone);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TimeZone, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TimeZone);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TimeZone, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TimeZone location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TimeZone::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TimeZone(soap, tag ? tag : "tt:TimeZone", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TimeZone::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TimeZone(soap, this, tag, type);
}

SOAP_FMAC3 tt__TimeZone * SOAP_FMAC4 soap_get_tt__TimeZone(struct soap *soap, tt__TimeZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Time::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__Time::Hour);
	soap_default_int(soap, &this->tt__Time::Minute);
	soap_default_int(soap, &this->tt__Time::Second);
}

void tt__Time::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Time::Hour, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Time::Minute, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Time::Second, SOAP_TYPE_int);
#endif
}

int tt__Time::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Time(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Time(struct soap *soap, const char *tag, int id, const tt__Time *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Time), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Hour", -1, &a->tt__Time::Hour, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minute", -1, &a->tt__Time::Minute, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Second", -1, &a->tt__Time::Second, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Time::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Time(soap, tag, this, type);
}

SOAP_FMAC3 tt__Time * SOAP_FMAC4 soap_in_tt__Time(struct soap *soap, const char *tag, tt__Time *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Time*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Time, sizeof(tt__Time), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Time)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Time *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Hour1 = 1;
	size_t soap_flag_Minute1 = 1;
	size_t soap_flag_Second1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Hour1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Hour", &a->tt__Time::Hour, "xsd:int"))
				{	soap_flag_Hour1--;
					continue;
				}
			}
			if (soap_flag_Minute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Minute", &a->tt__Time::Minute, "xsd:int"))
				{	soap_flag_Minute1--;
					continue;
				}
			}
			if (soap_flag_Second1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Second", &a->tt__Time::Second, "xsd:int"))
				{	soap_flag_Second1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Hour1 > 0 || soap_flag_Minute1 > 0 || soap_flag_Second1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Time *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Time, SOAP_TYPE_tt__Time, sizeof(tt__Time), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Time * SOAP_FMAC2 soap_instantiate_tt__Time(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Time(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Time *p;
	size_t k = sizeof(tt__Time);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Time, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Time);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Time, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Time location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Time::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Time(soap, tag ? tag : "tt:Time", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Time::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Time(soap, this, tag, type);
}

SOAP_FMAC3 tt__Time * SOAP_FMAC4 soap_get_tt__Time(struct soap *soap, tt__Time *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Date::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__Date::Year);
	soap_default_int(soap, &this->tt__Date::Month);
	soap_default_int(soap, &this->tt__Date::Day);
}

void tt__Date::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Date::Year, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Date::Month, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Date::Day, SOAP_TYPE_int);
#endif
}

int tt__Date::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Date(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Date(struct soap *soap, const char *tag, int id, const tt__Date *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Date), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Year", -1, &a->tt__Date::Year, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Month", -1, &a->tt__Date::Month, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Day", -1, &a->tt__Date::Day, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Date::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Date(soap, tag, this, type);
}

SOAP_FMAC3 tt__Date * SOAP_FMAC4 soap_in_tt__Date(struct soap *soap, const char *tag, tt__Date *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Date*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Date, sizeof(tt__Date), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Date)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Date *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Year1 = 1;
	size_t soap_flag_Month1 = 1;
	size_t soap_flag_Day1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Year1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Year", &a->tt__Date::Year, "xsd:int"))
				{	soap_flag_Year1--;
					continue;
				}
			}
			if (soap_flag_Month1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Month", &a->tt__Date::Month, "xsd:int"))
				{	soap_flag_Month1--;
					continue;
				}
			}
			if (soap_flag_Day1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Day", &a->tt__Date::Day, "xsd:int"))
				{	soap_flag_Day1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Year1 > 0 || soap_flag_Month1 > 0 || soap_flag_Day1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Date *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Date, SOAP_TYPE_tt__Date, sizeof(tt__Date), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Date * SOAP_FMAC2 soap_instantiate_tt__Date(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Date(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Date *p;
	size_t k = sizeof(tt__Date);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Date, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Date);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Date, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Date location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Date::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Date(soap, tag ? tag : "tt:Date", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Date::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Date(soap, this, tag, type);
}

SOAP_FMAC3 tt__Date * SOAP_FMAC4 soap_get_tt__Date(struct soap *soap, tt__Date *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DateTime::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__DateTime::Time = NULL;
	this->tt__DateTime::Date = NULL;
}

void tt__DateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Time(soap, &this->tt__DateTime::Time);
	soap_serialize_PointerTott__Date(soap, &this->tt__DateTime::Date);
#endif
}

int tt__DateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTime(struct soap *soap, const char *tag, int id, const tt__DateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTime), type))
		return soap->error;
	if (!a->tt__DateTime::Time)
	{	if (soap_element_empty(soap, "tt:Time"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Time(soap, "tt:Time", -1, &a->tt__DateTime::Time, ""))
		return soap->error;
	if (!a->tt__DateTime::Date)
	{	if (soap_element_empty(soap, "tt:Date"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Date(soap, "tt:Date", -1, &a->tt__DateTime::Date, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DateTime(soap, tag, this, type);
}

SOAP_FMAC3 tt__DateTime * SOAP_FMAC4 soap_in_tt__DateTime(struct soap *soap, const char *tag, tt__DateTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DateTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTime, sizeof(tt__DateTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DateTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DateTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Time1 = 1;
	size_t soap_flag_Date1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Time1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Time(soap, "tt:Time", &a->tt__DateTime::Time, "tt:Time"))
				{	soap_flag_Time1--;
					continue;
				}
			}
			if (soap_flag_Date1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Date(soap, "tt:Date", &a->tt__DateTime::Date, "tt:Date"))
				{	soap_flag_Date1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__DateTime::Time || !a->tt__DateTime::Date))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTime, SOAP_TYPE_tt__DateTime, sizeof(tt__DateTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DateTime * SOAP_FMAC2 soap_instantiate_tt__DateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DateTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DateTime *p;
	size_t k = sizeof(tt__DateTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DateTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DateTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DateTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DateTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DateTime(soap, tag ? tag : "tt:DateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DateTime(soap, this, tag, type);
}

SOAP_FMAC3 tt__DateTime * SOAP_FMAC4 soap_get_tt__DateTime(struct soap *soap, tt__DateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemDateTimeExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SystemDateTimeExtension::__any);
}

void tt__SystemDateTimeExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SystemDateTimeExtension::__any);
#endif
}

int tt__SystemDateTimeExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemDateTimeExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, const tt__SystemDateTimeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTimeExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__SystemDateTimeExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemDateTimeExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemDateTimeExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemDateTimeExtension * SOAP_FMAC4 soap_in_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, tt__SystemDateTimeExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemDateTimeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(tt__SystemDateTimeExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemDateTimeExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemDateTimeExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__SystemDateTimeExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemDateTimeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTimeExtension, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(tt__SystemDateTimeExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemDateTimeExtension * SOAP_FMAC2 soap_instantiate_tt__SystemDateTimeExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemDateTimeExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemDateTimeExtension *p;
	size_t k = sizeof(tt__SystemDateTimeExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemDateTimeExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemDateTimeExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemDateTimeExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemDateTimeExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemDateTimeExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemDateTimeExtension(soap, tag ? tag : "tt:SystemDateTimeExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemDateTimeExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemDateTimeExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemDateTimeExtension * SOAP_FMAC4 soap_get_tt__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemDateTime::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__SetDateTimeType(soap, &this->tt__SystemDateTime::DateTimeType);
	soap_default_bool(soap, &this->tt__SystemDateTime::DaylightSavings);
	this->tt__SystemDateTime::TimeZone = NULL;
	this->tt__SystemDateTime::UTCDateTime = NULL;
	this->tt__SystemDateTime::LocalDateTime = NULL;
	this->tt__SystemDateTime::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__SystemDateTime::__anyAttribute);
}

void tt__SystemDateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SystemDateTime::DaylightSavings, SOAP_TYPE_bool);
	soap_serialize_PointerTott__TimeZone(soap, &this->tt__SystemDateTime::TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &this->tt__SystemDateTime::UTCDateTime);
	soap_serialize_PointerTott__DateTime(soap, &this->tt__SystemDateTime::LocalDateTime);
	soap_serialize_PointerTott__SystemDateTimeExtension(soap, &this->tt__SystemDateTime::Extension);
#endif
}

int tt__SystemDateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemDateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTime(struct soap *soap, const char *tag, int id, const tt__SystemDateTime *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SystemDateTime*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tt:DateTimeType", -1, &a->tt__SystemDateTime::DateTimeType, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DaylightSavings", -1, &a->tt__SystemDateTime::DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tt:TimeZone", -1, &a->tt__SystemDateTime::TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:UTCDateTime", -1, &a->tt__SystemDateTime::UTCDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:LocalDateTime", -1, &a->tt__SystemDateTime::LocalDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", -1, &a->tt__SystemDateTime::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemDateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemDateTime(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemDateTime * SOAP_FMAC4 soap_in_tt__SystemDateTime(struct soap *soap, const char *tag, tt__SystemDateTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemDateTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTime, sizeof(tt__SystemDateTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemDateTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemDateTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SystemDateTime*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_DateTimeType1 = 1;
	size_t soap_flag_DaylightSavings1 = 1;
	size_t soap_flag_TimeZone1 = 1;
	size_t soap_flag_UTCDateTime1 = 1;
	size_t soap_flag_LocalDateTime1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SetDateTimeType(soap, "tt:DateTimeType", &a->tt__SystemDateTime::DateTimeType, "tt:SetDateTimeType"))
				{	soap_flag_DateTimeType1--;
					continue;
				}
			}
			if (soap_flag_DaylightSavings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DaylightSavings", &a->tt__SystemDateTime::DaylightSavings, "xsd:boolean"))
				{	soap_flag_DaylightSavings1--;
					continue;
				}
			}
			if (soap_flag_TimeZone1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TimeZone(soap, "tt:TimeZone", &a->tt__SystemDateTime::TimeZone, "tt:TimeZone"))
				{	soap_flag_TimeZone1--;
					continue;
				}
			}
			if (soap_flag_UTCDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTime(soap, "tt:UTCDateTime", &a->tt__SystemDateTime::UTCDateTime, "tt:DateTime"))
				{	soap_flag_UTCDateTime1--;
					continue;
				}
			}
			if (soap_flag_LocalDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTime(soap, "tt:LocalDateTime", &a->tt__SystemDateTime::LocalDateTime, "tt:DateTime"))
				{	soap_flag_LocalDateTime1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", &a->tt__SystemDateTime::Extension, "tt:SystemDateTimeExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType1 > 0 || soap_flag_DaylightSavings1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SystemDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTime, SOAP_TYPE_tt__SystemDateTime, sizeof(tt__SystemDateTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemDateTime * SOAP_FMAC2 soap_instantiate_tt__SystemDateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemDateTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemDateTime *p;
	size_t k = sizeof(tt__SystemDateTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemDateTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemDateTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemDateTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemDateTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemDateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemDateTime(soap, tag ? tag : "tt:SystemDateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemDateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemDateTime(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemDateTime * SOAP_FMAC4 soap_get_tt__SystemDateTime(struct soap *soap, tt__SystemDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemLogUri::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__SystemLogType(soap, &this->tt__SystemLogUri::Type);
	soap_default_xsd__anyURI(soap, &this->tt__SystemLogUri::Uri);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SystemLogUri::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__SystemLogUri::__anyAttribute);
}

void tt__SystemLogUri::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SystemLogUri::Uri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__SystemLogUri::Uri);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SystemLogUri::__any);
#endif
}

int tt__SystemLogUri::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemLogUri(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogUri(struct soap *soap, const char *tag, int id, const tt__SystemLogUri *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SystemLogUri*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogUri), type))
		return soap->error;
	if (soap_out_tt__SystemLogType(soap, "tt:Type", -1, &a->tt__SystemLogUri::Type, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:Uri", -1, &a->tt__SystemLogUri::Uri, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__SystemLogUri::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemLogUri::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemLogUri(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemLogUri * SOAP_FMAC4 soap_in_tt__SystemLogUri(struct soap *soap, const char *tag, tt__SystemLogUri *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemLogUri*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUri, sizeof(tt__SystemLogUri), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemLogUri)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemLogUri *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SystemLogUri*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Uri1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SystemLogType(soap, "tt:Type", &a->tt__SystemLogUri::Type, "tt:SystemLogType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Uri", &a->tt__SystemLogUri::Uri, "xsd:anyURI"))
				{	soap_flag_Uri1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__SystemLogUri::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0 || soap_flag_Uri1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SystemLogUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUri, SOAP_TYPE_tt__SystemLogUri, sizeof(tt__SystemLogUri), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemLogUri * SOAP_FMAC2 soap_instantiate_tt__SystemLogUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemLogUri(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemLogUri *p;
	size_t k = sizeof(tt__SystemLogUri);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemLogUri, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemLogUri);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemLogUri, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemLogUri location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemLogUri::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemLogUri(soap, tag ? tag : "tt:SystemLogUri", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemLogUri::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemLogUri(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemLogUri * SOAP_FMAC4 soap_get_tt__SystemLogUri(struct soap *soap, tt__SystemLogUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemLogUriList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__SystemLogUri(soap, &this->tt__SystemLogUriList::SystemLog);
}

void tt__SystemLogUriList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__SystemLogUri(soap, &this->tt__SystemLogUriList::SystemLog);
#endif
}

int tt__SystemLogUriList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemLogUriList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogUriList(struct soap *soap, const char *tag, int id, const tt__SystemLogUriList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogUriList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__SystemLogUri(soap, "tt:SystemLog", -1, &a->tt__SystemLogUriList::SystemLog, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemLogUriList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemLogUriList(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemLogUriList * SOAP_FMAC4 soap_in_tt__SystemLogUriList(struct soap *soap, const char *tag, tt__SystemLogUriList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemLogUriList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUriList, sizeof(tt__SystemLogUriList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemLogUriList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemLogUriList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__SystemLogUri(soap, "tt:SystemLog", &a->tt__SystemLogUriList::SystemLog, "tt:SystemLogUri"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemLogUriList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUriList, SOAP_TYPE_tt__SystemLogUriList, sizeof(tt__SystemLogUriList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemLogUriList * SOAP_FMAC2 soap_instantiate_tt__SystemLogUriList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemLogUriList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemLogUriList *p;
	size_t k = sizeof(tt__SystemLogUriList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemLogUriList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemLogUriList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemLogUriList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemLogUriList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemLogUriList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemLogUriList(soap, tag ? tag : "tt:SystemLogUriList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemLogUriList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemLogUriList(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemLogUriList * SOAP_FMAC4 soap_get_tt__SystemLogUriList(struct soap *soap, tt__SystemLogUriList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogUriList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BackupFile::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->tt__BackupFile::Name);
	this->tt__BackupFile::Data = NULL;
}

void tt__BackupFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__BackupFile::Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__BackupFile::Name);
	soap_serialize_PointerTott__AttachmentData(soap, &this->tt__BackupFile::Data);
#endif
}

int tt__BackupFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BackupFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BackupFile(struct soap *soap, const char *tag, int id, const tt__BackupFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BackupFile), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Name", -1, &a->tt__BackupFile::Name, ""))
		return soap->error;
	if (!a->tt__BackupFile::Data)
	{	if (soap_element_empty(soap, "tt:Data"))
			return soap->error;
	}
	else if (soap_out_PointerTott__AttachmentData(soap, "tt:Data", -1, &a->tt__BackupFile::Data, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BackupFile::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BackupFile(soap, tag, this, type);
}

SOAP_FMAC3 tt__BackupFile * SOAP_FMAC4 soap_in_tt__BackupFile(struct soap *soap, const char *tag, tt__BackupFile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BackupFile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BackupFile, sizeof(tt__BackupFile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BackupFile)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BackupFile *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Name", &a->tt__BackupFile::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Data", &a->tt__BackupFile::Data, "tt:AttachmentData"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || !a->tt__BackupFile::Data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BackupFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BackupFile, SOAP_TYPE_tt__BackupFile, sizeof(tt__BackupFile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BackupFile * SOAP_FMAC2 soap_instantiate_tt__BackupFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BackupFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BackupFile *p;
	size_t k = sizeof(tt__BackupFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BackupFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BackupFile);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BackupFile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BackupFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BackupFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BackupFile(soap, tag ? tag : "tt:BackupFile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BackupFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BackupFile(soap, this, tag, type);
}

SOAP_FMAC3 tt__BackupFile * SOAP_FMAC4 soap_get_tt__BackupFile(struct soap *soap, tt__BackupFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AttachmentData::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__AttachmentData::xop__Include_ = NULL;
	this->tt__AttachmentData::xmime__contentType = NULL;
}

void tt__AttachmentData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxop__Include(soap, &this->tt__AttachmentData::xop__Include_);
#endif
}

int tt__AttachmentData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AttachmentData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AttachmentData(struct soap *soap, const char *tag, int id, const tt__AttachmentData *a, const char *type)
{
	if (((tt__AttachmentData*)a)->xmime__contentType)
	{	soap_set_attr(soap, "xmime:contentType", soap__xmime__contentType2s(soap, *((tt__AttachmentData*)a)->xmime__contentType), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AttachmentData), type))
		return soap->error;
	if (!a->tt__AttachmentData::xop__Include_)
	{	if (soap_element_empty(soap, "xop:Include"))
			return soap->error;
	}
	else if (soap_out_PointerToxop__Include(soap, "xop:Include", -1, &a->tt__AttachmentData::xop__Include_, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AttachmentData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AttachmentData(soap, tag, this, type);
}

SOAP_FMAC3 tt__AttachmentData * SOAP_FMAC4 soap_in_tt__AttachmentData(struct soap *soap, const char *tag, tt__AttachmentData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AttachmentData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AttachmentData, sizeof(tt__AttachmentData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AttachmentData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AttachmentData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "xmime:contentType", 1, 0);
		if (t)
		{
			if (!(((tt__AttachmentData*)a)->xmime__contentType = soap_new__xmime__contentType(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_xmime__contentType(soap, t, ((tt__AttachmentData*)a)->xmime__contentType))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_xop__Include_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xop__Include_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxop__Include(soap, "xop:Include", &a->tt__AttachmentData::xop__Include_, "xop:Include"))
				{	soap_flag_xop__Include_1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__AttachmentData::xop__Include_))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AttachmentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AttachmentData, SOAP_TYPE_tt__AttachmentData, sizeof(tt__AttachmentData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AttachmentData * SOAP_FMAC2 soap_instantiate_tt__AttachmentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AttachmentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AttachmentData *p;
	size_t k = sizeof(tt__AttachmentData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AttachmentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AttachmentData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AttachmentData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AttachmentData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AttachmentData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AttachmentData(soap, tag ? tag : "tt:AttachmentData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AttachmentData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AttachmentData(soap, this, tag, type);
}

SOAP_FMAC3 tt__AttachmentData * SOAP_FMAC4 soap_get_tt__AttachmentData(struct soap *soap, tt__AttachmentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BinaryData::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__BinaryData::Data.xsd__base64Binary::soap_default(soap);
	this->tt__BinaryData::xmime__contentType = NULL;
}

void tt__BinaryData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__BinaryData::Data, SOAP_TYPE_xsd__base64Binary);
	this->tt__BinaryData::Data.soap_serialize(soap);
#endif
}

int tt__BinaryData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BinaryData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BinaryData(struct soap *soap, const char *tag, int id, const tt__BinaryData *a, const char *type)
{
	if (((tt__BinaryData*)a)->xmime__contentType)
	{	soap_set_attr(soap, "xmime:contentType", soap__xmime__contentType2s(soap, *((tt__BinaryData*)a)->xmime__contentType), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BinaryData), type))
		return soap->error;
	if ((a->tt__BinaryData::Data).soap_out(soap, "tt:Data", -1, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BinaryData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BinaryData(soap, tag, this, type);
}

SOAP_FMAC3 tt__BinaryData * SOAP_FMAC4 soap_in_tt__BinaryData(struct soap *soap, const char *tag, tt__BinaryData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BinaryData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BinaryData, sizeof(tt__BinaryData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BinaryData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BinaryData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "xmime:contentType", 1, 0);
		if (t)
		{
			if (!(((tt__BinaryData*)a)->xmime__contentType = soap_new__xmime__contentType(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_xmime__contentType(soap, t, ((tt__BinaryData*)a)->xmime__contentType))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->tt__BinaryData::Data).soap_in(soap, "tt:Data", "xsd:base64Binary"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BinaryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BinaryData, SOAP_TYPE_tt__BinaryData, sizeof(tt__BinaryData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BinaryData * SOAP_FMAC2 soap_instantiate_tt__BinaryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BinaryData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BinaryData *p;
	size_t k = sizeof(tt__BinaryData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BinaryData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BinaryData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BinaryData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BinaryData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BinaryData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BinaryData(soap, tag ? tag : "tt:BinaryData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BinaryData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BinaryData(soap, this, tag, type);
}

SOAP_FMAC3 tt__BinaryData * SOAP_FMAC4 soap_get_tt__BinaryData(struct soap *soap, tt__BinaryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SupportInformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__SupportInformation::Binary = NULL;
	this->tt__SupportInformation::String = NULL;
}

void tt__SupportInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &this->tt__SupportInformation::Binary);
	soap_serialize_PointerTostd__string(soap, &this->tt__SupportInformation::String);
#endif
}

int tt__SupportInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SupportInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportInformation(struct soap *soap, const char *tag, int id, const tt__SupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportInformation), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->tt__SupportInformation::Binary, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:String", -1, &a->tt__SupportInformation::String, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SupportInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SupportInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__SupportInformation * SOAP_FMAC4 soap_in_tt__SupportInformation(struct soap *soap, const char *tag, tt__SupportInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SupportInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportInformation, sizeof(tt__SupportInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SupportInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SupportInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Binary1 = 1;
	size_t soap_flag_String1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->tt__SupportInformation::Binary, "tt:AttachmentData"))
				{	soap_flag_Binary1--;
					continue;
				}
			}
			if (soap_flag_String1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:String", &a->tt__SupportInformation::String, "xsd:string"))
				{	soap_flag_String1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportInformation, SOAP_TYPE_tt__SupportInformation, sizeof(tt__SupportInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SupportInformation * SOAP_FMAC2 soap_instantiate_tt__SupportInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SupportInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SupportInformation *p;
	size_t k = sizeof(tt__SupportInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SupportInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SupportInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SupportInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SupportInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SupportInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SupportInformation(soap, tag ? tag : "tt:SupportInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SupportInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SupportInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__SupportInformation * SOAP_FMAC4 soap_get_tt__SupportInformation(struct soap *soap, tt__SupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemLog::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__SystemLog::Binary = NULL;
	this->tt__SystemLog::String = NULL;
}

void tt__SystemLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &this->tt__SystemLog::Binary);
	soap_serialize_PointerTostd__string(soap, &this->tt__SystemLog::String);
#endif
}

int tt__SystemLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLog(struct soap *soap, const char *tag, int id, const tt__SystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLog), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->tt__SystemLog::Binary, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:String", -1, &a->tt__SystemLog::String, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemLog::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemLog(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemLog * SOAP_FMAC4 soap_in_tt__SystemLog(struct soap *soap, const char *tag, tt__SystemLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemLog*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLog, sizeof(tt__SystemLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemLog)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemLog *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Binary1 = 1;
	size_t soap_flag_String1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->tt__SystemLog::Binary, "tt:AttachmentData"))
				{	soap_flag_Binary1--;
					continue;
				}
			}
			if (soap_flag_String1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:String", &a->tt__SystemLog::String, "xsd:string"))
				{	soap_flag_String1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLog, SOAP_TYPE_tt__SystemLog, sizeof(tt__SystemLog), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemLog * SOAP_FMAC2 soap_instantiate_tt__SystemLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemLog *p;
	size_t k = sizeof(tt__SystemLog);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemLog, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemLog location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemLog(soap, tag ? tag : "tt:SystemLog", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemLog(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemLog * SOAP_FMAC4 soap_get_tt__SystemLog(struct soap *soap, tt__SystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsDeviceExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsDeviceExtension::__any);
}

void tt__AnalyticsDeviceExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsDeviceExtension::__any);
#endif
}

int tt__AnalyticsDeviceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsDeviceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceExtension(struct soap *soap, const char *tag, int id, const tt__AnalyticsDeviceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AnalyticsDeviceExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsDeviceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsDeviceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceExtension(struct soap *soap, const char *tag, tt__AnalyticsDeviceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsDeviceExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(tt__AnalyticsDeviceExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsDeviceExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsDeviceExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AnalyticsDeviceExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsDeviceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceExtension, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(tt__AnalyticsDeviceExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsDeviceExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsDeviceExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsDeviceExtension *p;
	size_t k = sizeof(tt__AnalyticsDeviceExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsDeviceExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsDeviceExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsDeviceExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsDeviceExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsDeviceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsDeviceExtension(soap, tag ? tag : "tt:AnalyticsDeviceExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsDeviceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsDeviceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceExtension(struct soap *soap, tt__AnalyticsDeviceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsDeviceCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__AnalyticsDeviceCapabilities::XAddr);
	this->tt__AnalyticsDeviceCapabilities::RuleSupport = NULL;
	this->tt__AnalyticsDeviceCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__AnalyticsDeviceCapabilities::__anyAttribute);
}

void tt__AnalyticsDeviceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AnalyticsDeviceCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__AnalyticsDeviceCapabilities::XAddr);
	soap_serialize_PointerTobool(soap, &this->tt__AnalyticsDeviceCapabilities::RuleSupport);
	soap_serialize_PointerTott__AnalyticsDeviceExtension(soap, &this->tt__AnalyticsDeviceCapabilities::Extension);
#endif
}

int tt__AnalyticsDeviceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsDeviceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, int id, const tt__AnalyticsDeviceCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnalyticsDeviceCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__AnalyticsDeviceCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RuleSupport", -1, &a->tt__AnalyticsDeviceCapabilities::RuleSupport, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsDeviceExtension(soap, "tt:Extension", -1, &a->tt__AnalyticsDeviceCapabilities::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsDeviceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsDeviceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceCapabilities * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, tt__AnalyticsDeviceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsDeviceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(tt__AnalyticsDeviceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsDeviceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsDeviceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnalyticsDeviceCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_RuleSupport1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__AnalyticsDeviceCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_RuleSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RuleSupport", &a->tt__AnalyticsDeviceCapabilities::RuleSupport, "xsd:boolean"))
				{	soap_flag_RuleSupport1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsDeviceExtension(soap, "tt:Extension", &a->tt__AnalyticsDeviceCapabilities::Extension, "tt:AnalyticsDeviceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AnalyticsDeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(tt__AnalyticsDeviceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsDeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsDeviceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsDeviceCapabilities *p;
	size_t k = sizeof(tt__AnalyticsDeviceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsDeviceCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsDeviceCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsDeviceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsDeviceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsDeviceCapabilities(soap, tag ? tag : "tt:AnalyticsDeviceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsDeviceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsDeviceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceCapabilities * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceCapabilities(struct soap *soap, tt__AnalyticsDeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReceiverCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__ReceiverCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__ReceiverCapabilities::RTP_USCOREMulticast);
	soap_default_bool(soap, &this->tt__ReceiverCapabilities::RTP_USCORETCP);
	soap_default_bool(soap, &this->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP);
	soap_default_int(soap, &this->tt__ReceiverCapabilities::SupportedReceivers);
	soap_default_int(soap, &this->tt__ReceiverCapabilities::MaximumRTSPURILength);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ReceiverCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ReceiverCapabilities::__anyAttribute);
}

void tt__ReceiverCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ReceiverCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ReceiverCapabilities::XAddr);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::RTP_USCOREMulticast, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::RTP_USCORETCP, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::SupportedReceivers, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::MaximumRTSPURILength, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ReceiverCapabilities::__any);
#endif
}

int tt__ReceiverCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReceiverCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverCapabilities(struct soap *soap, const char *tag, int id, const tt__ReceiverCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ReceiverCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__ReceiverCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RTP_Multicast", -1, &a->tt__ReceiverCapabilities::RTP_USCOREMulticast, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RTP_TCP", -1, &a->tt__ReceiverCapabilities::RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RTP_RTSP_TCP", -1, &a->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SupportedReceivers", -1, &a->tt__ReceiverCapabilities::SupportedReceivers, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumRTSPURILength", -1, &a->tt__ReceiverCapabilities::MaximumRTSPURILength, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ReceiverCapabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReceiverCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReceiverCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReceiverCapabilities * SOAP_FMAC4 soap_in_tt__ReceiverCapabilities(struct soap *soap, const char *tag, tt__ReceiverCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReceiverCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(tt__ReceiverCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReceiverCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReceiverCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ReceiverCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_RTP_USCOREMulticast1 = 1;
	size_t soap_flag_RTP_USCORETCP1 = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP1 = 1;
	size_t soap_flag_SupportedReceivers1 = 1;
	size_t soap_flag_MaximumRTSPURILength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__ReceiverCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCOREMulticast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RTP_Multicast", &a->tt__ReceiverCapabilities::RTP_USCOREMulticast, "xsd:boolean"))
				{	soap_flag_RTP_USCOREMulticast1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RTP_TCP", &a->tt__ReceiverCapabilities::RTP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORERTSP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RTP_RTSP_TCP", &a->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP1--;
					continue;
				}
			}
			if (soap_flag_SupportedReceivers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:SupportedReceivers", &a->tt__ReceiverCapabilities::SupportedReceivers, "xsd:int"))
				{	soap_flag_SupportedReceivers1--;
					continue;
				}
			}
			if (soap_flag_MaximumRTSPURILength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumRTSPURILength", &a->tt__ReceiverCapabilities::MaximumRTSPURILength, "xsd:int"))
				{	soap_flag_MaximumRTSPURILength1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ReceiverCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_RTP_USCOREMulticast1 > 0 || soap_flag_RTP_USCORETCP1 > 0 || soap_flag_RTP_USCORERTSP_USCORETCP1 > 0 || soap_flag_SupportedReceivers1 > 0 || soap_flag_MaximumRTSPURILength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ReceiverCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverCapabilities, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(tt__ReceiverCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReceiverCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReceiverCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReceiverCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReceiverCapabilities *p;
	size_t k = sizeof(tt__ReceiverCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReceiverCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReceiverCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReceiverCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReceiverCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReceiverCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReceiverCapabilities(soap, tag ? tag : "tt:ReceiverCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReceiverCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReceiverCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReceiverCapabilities * SOAP_FMAC4 soap_get_tt__ReceiverCapabilities(struct soap *soap, tt__ReceiverCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReplayCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__ReplayCapabilities::XAddr);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ReplayCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ReplayCapabilities::__anyAttribute);
}

void tt__ReplayCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ReplayCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ReplayCapabilities::XAddr);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ReplayCapabilities::__any);
#endif
}

int tt__ReplayCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReplayCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReplayCapabilities(struct soap *soap, const char *tag, int id, const tt__ReplayCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ReplayCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReplayCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__ReplayCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ReplayCapabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReplayCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReplayCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReplayCapabilities * SOAP_FMAC4 soap_in_tt__ReplayCapabilities(struct soap *soap, const char *tag, tt__ReplayCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReplayCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(tt__ReplayCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReplayCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReplayCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ReplayCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__ReplayCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ReplayCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ReplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReplayCapabilities, SOAP_TYPE_tt__ReplayCapabilities, sizeof(tt__ReplayCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReplayCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReplayCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReplayCapabilities *p;
	size_t k = sizeof(tt__ReplayCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReplayCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReplayCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReplayCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReplayCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReplayCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReplayCapabilities(soap, tag ? tag : "tt:ReplayCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReplayCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReplayCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReplayCapabilities * SOAP_FMAC4 soap_get_tt__ReplayCapabilities(struct soap *soap, tt__ReplayCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SearchCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__SearchCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__SearchCapabilities::MetadataSearch);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SearchCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__SearchCapabilities::__anyAttribute);
}

void tt__SearchCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SearchCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__SearchCapabilities::XAddr);
	soap_embedded(soap, &this->tt__SearchCapabilities::MetadataSearch, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SearchCapabilities::__any);
#endif
}

int tt__SearchCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SearchCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchCapabilities(struct soap *soap, const char *tag, int id, const tt__SearchCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SearchCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__SearchCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:MetadataSearch", -1, &a->tt__SearchCapabilities::MetadataSearch, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__SearchCapabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SearchCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SearchCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__SearchCapabilities * SOAP_FMAC4 soap_in_tt__SearchCapabilities(struct soap *soap, const char *tag, tt__SearchCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SearchCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchCapabilities, sizeof(tt__SearchCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SearchCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SearchCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SearchCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_MetadataSearch1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__SearchCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_MetadataSearch1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:MetadataSearch", &a->tt__SearchCapabilities::MetadataSearch, "xsd:boolean"))
				{	soap_flag_MetadataSearch1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__SearchCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_MetadataSearch1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SearchCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchCapabilities, SOAP_TYPE_tt__SearchCapabilities, sizeof(tt__SearchCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SearchCapabilities * SOAP_FMAC2 soap_instantiate_tt__SearchCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SearchCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SearchCapabilities *p;
	size_t k = sizeof(tt__SearchCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SearchCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SearchCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SearchCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SearchCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SearchCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SearchCapabilities(soap, tag ? tag : "tt:SearchCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SearchCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SearchCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__SearchCapabilities * SOAP_FMAC4 soap_get_tt__SearchCapabilities(struct soap *soap, tt__SearchCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__RecordingCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__RecordingCapabilities::ReceiverSource);
	soap_default_bool(soap, &this->tt__RecordingCapabilities::MediaProfileSource);
	soap_default_bool(soap, &this->tt__RecordingCapabilities::DynamicRecordings);
	soap_default_bool(soap, &this->tt__RecordingCapabilities::DynamicTracks);
	soap_default_int(soap, &this->tt__RecordingCapabilities::MaxStringLength);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__RecordingCapabilities::__anyAttribute);
}

void tt__RecordingCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RecordingCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__RecordingCapabilities::XAddr);
	soap_embedded(soap, &this->tt__RecordingCapabilities::ReceiverSource, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__RecordingCapabilities::MediaProfileSource, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__RecordingCapabilities::DynamicRecordings, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__RecordingCapabilities::DynamicTracks, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__RecordingCapabilities::MaxStringLength, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RecordingCapabilities::__any);
#endif
}

int tt__RecordingCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingCapabilities(struct soap *soap, const char *tag, int id, const tt__RecordingCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RecordingCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__RecordingCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:ReceiverSource", -1, &a->tt__RecordingCapabilities::ReceiverSource, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:MediaProfileSource", -1, &a->tt__RecordingCapabilities::MediaProfileSource, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DynamicRecordings", -1, &a->tt__RecordingCapabilities::DynamicRecordings, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DynamicTracks", -1, &a->tt__RecordingCapabilities::DynamicTracks, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaxStringLength", -1, &a->tt__RecordingCapabilities::MaxStringLength, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RecordingCapabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingCapabilities * SOAP_FMAC4 soap_in_tt__RecordingCapabilities(struct soap *soap, const char *tag, tt__RecordingCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(tt__RecordingCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RecordingCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_ReceiverSource1 = 1;
	size_t soap_flag_MediaProfileSource1 = 1;
	size_t soap_flag_DynamicRecordings1 = 1;
	size_t soap_flag_DynamicTracks1 = 1;
	size_t soap_flag_MaxStringLength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__RecordingCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_ReceiverSource1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:ReceiverSource", &a->tt__RecordingCapabilities::ReceiverSource, "xsd:boolean"))
				{	soap_flag_ReceiverSource1--;
					continue;
				}
			}
			if (soap_flag_MediaProfileSource1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:MediaProfileSource", &a->tt__RecordingCapabilities::MediaProfileSource, "xsd:boolean"))
				{	soap_flag_MediaProfileSource1--;
					continue;
				}
			}
			if (soap_flag_DynamicRecordings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DynamicRecordings", &a->tt__RecordingCapabilities::DynamicRecordings, "xsd:boolean"))
				{	soap_flag_DynamicRecordings1--;
					continue;
				}
			}
			if (soap_flag_DynamicTracks1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DynamicTracks", &a->tt__RecordingCapabilities::DynamicTracks, "xsd:boolean"))
				{	soap_flag_DynamicTracks1--;
					continue;
				}
			}
			if (soap_flag_MaxStringLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaxStringLength", &a->tt__RecordingCapabilities::MaxStringLength, "xsd:int"))
				{	soap_flag_MaxStringLength1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RecordingCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_ReceiverSource1 > 0 || soap_flag_MediaProfileSource1 > 0 || soap_flag_DynamicRecordings1 > 0 || soap_flag_DynamicTracks1 > 0 || soap_flag_MaxStringLength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RecordingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingCapabilities, SOAP_TYPE_tt__RecordingCapabilities, sizeof(tt__RecordingCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RecordingCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingCapabilities *p;
	size_t k = sizeof(tt__RecordingCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingCapabilities(soap, tag ? tag : "tt:RecordingCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingCapabilities * SOAP_FMAC4 soap_get_tt__RecordingCapabilities(struct soap *soap, tt__RecordingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DisplayCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__DisplayCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__DisplayCapabilities::FixedLayout);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DisplayCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__DisplayCapabilities::__anyAttribute);
}

void tt__DisplayCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DisplayCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__DisplayCapabilities::XAddr);
	soap_embedded(soap, &this->tt__DisplayCapabilities::FixedLayout, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DisplayCapabilities::__any);
#endif
}

int tt__DisplayCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DisplayCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DisplayCapabilities(struct soap *soap, const char *tag, int id, const tt__DisplayCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__DisplayCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DisplayCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__DisplayCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:FixedLayout", -1, &a->tt__DisplayCapabilities::FixedLayout, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__DisplayCapabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DisplayCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DisplayCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__DisplayCapabilities * SOAP_FMAC4 soap_in_tt__DisplayCapabilities(struct soap *soap, const char *tag, tt__DisplayCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DisplayCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(tt__DisplayCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DisplayCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DisplayCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__DisplayCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_FixedLayout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__DisplayCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_FixedLayout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FixedLayout", &a->tt__DisplayCapabilities::FixedLayout, "xsd:boolean"))
				{	soap_flag_FixedLayout1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__DisplayCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_FixedLayout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DisplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DisplayCapabilities, SOAP_TYPE_tt__DisplayCapabilities, sizeof(tt__DisplayCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DisplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__DisplayCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DisplayCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DisplayCapabilities *p;
	size_t k = sizeof(tt__DisplayCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DisplayCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DisplayCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DisplayCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DisplayCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DisplayCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DisplayCapabilities(soap, tag ? tag : "tt:DisplayCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DisplayCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DisplayCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__DisplayCapabilities * SOAP_FMAC4 soap_get_tt__DisplayCapabilities(struct soap *soap, tt__DisplayCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DisplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceIOCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__DeviceIOCapabilities::XAddr);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::VideoSources);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::VideoOutputs);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::AudioSources);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::AudioOutputs);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::RelayOutputs);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DeviceIOCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__DeviceIOCapabilities::__anyAttribute);
}

void tt__DeviceIOCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__DeviceIOCapabilities::XAddr);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::VideoSources, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::VideoOutputs, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::AudioSources, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::AudioOutputs, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::RelayOutputs, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DeviceIOCapabilities::__any);
#endif
}

int tt__DeviceIOCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceIOCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceIOCapabilities(struct soap *soap, const char *tag, int id, const tt__DeviceIOCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__DeviceIOCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceIOCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__DeviceIOCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:VideoSources", -1, &a->tt__DeviceIOCapabilities::VideoSources, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:VideoOutputs", -1, &a->tt__DeviceIOCapabilities::VideoOutputs, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:AudioSources", -1, &a->tt__DeviceIOCapabilities::AudioSources, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:AudioOutputs", -1, &a->tt__DeviceIOCapabilities::AudioOutputs, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:RelayOutputs", -1, &a->tt__DeviceIOCapabilities::RelayOutputs, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__DeviceIOCapabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceIOCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceIOCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceIOCapabilities * SOAP_FMAC4 soap_in_tt__DeviceIOCapabilities(struct soap *soap, const char *tag, tt__DeviceIOCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceIOCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(tt__DeviceIOCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceIOCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceIOCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__DeviceIOCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_VideoSources1 = 1;
	size_t soap_flag_VideoOutputs1 = 1;
	size_t soap_flag_AudioSources1 = 1;
	size_t soap_flag_AudioOutputs1 = 1;
	size_t soap_flag_RelayOutputs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__DeviceIOCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_VideoSources1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:VideoSources", &a->tt__DeviceIOCapabilities::VideoSources, "xsd:int"))
				{	soap_flag_VideoSources1--;
					continue;
				}
			}
			if (soap_flag_VideoOutputs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:VideoOutputs", &a->tt__DeviceIOCapabilities::VideoOutputs, "xsd:int"))
				{	soap_flag_VideoOutputs1--;
					continue;
				}
			}
			if (soap_flag_AudioSources1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:AudioSources", &a->tt__DeviceIOCapabilities::AudioSources, "xsd:int"))
				{	soap_flag_AudioSources1--;
					continue;
				}
			}
			if (soap_flag_AudioOutputs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:AudioOutputs", &a->tt__DeviceIOCapabilities::AudioOutputs, "xsd:int"))
				{	soap_flag_AudioOutputs1--;
					continue;
				}
			}
			if (soap_flag_RelayOutputs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:RelayOutputs", &a->tt__DeviceIOCapabilities::RelayOutputs, "xsd:int"))
				{	soap_flag_RelayOutputs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__DeviceIOCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_VideoSources1 > 0 || soap_flag_VideoOutputs1 > 0 || soap_flag_AudioSources1 > 0 || soap_flag_AudioOutputs1 > 0 || soap_flag_RelayOutputs1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DeviceIOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceIOCapabilities, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(tt__DeviceIOCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceIOCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceIOCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceIOCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DeviceIOCapabilities *p;
	size_t k = sizeof(tt__DeviceIOCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceIOCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceIOCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceIOCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceIOCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceIOCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceIOCapabilities(soap, tag ? tag : "tt:DeviceIOCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceIOCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceIOCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceIOCapabilities * SOAP_FMAC4 soap_get_tt__DeviceIOCapabilities(struct soap *soap, tt__DeviceIOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceIOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__PTZCapabilities::XAddr);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZCapabilities::__anyAttribute);
}

void tt__PTZCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__PTZCapabilities::XAddr);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZCapabilities::__any);
#endif
}

int tt__PTZCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZCapabilities(struct soap *soap, const char *tag, int id, const tt__PTZCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__PTZCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__PTZCapabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZCapabilities * SOAP_FMAC4 soap_in_tt__PTZCapabilities(struct soap *soap, const char *tag, tt__PTZCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZCapabilities, sizeof(tt__PTZCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__PTZCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__PTZCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZCapabilities, SOAP_TYPE_tt__PTZCapabilities, sizeof(tt__PTZCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZCapabilities * SOAP_FMAC2 soap_instantiate_tt__PTZCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZCapabilities *p;
	size_t k = sizeof(tt__PTZCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZCapabilities(soap, tag ? tag : "tt:PTZCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZCapabilities * SOAP_FMAC4 soap_get_tt__PTZCapabilities(struct soap *soap, tt__PTZCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__ImagingCapabilities::XAddr);
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingCapabilities::__anyAttribute);
}

void tt__ImagingCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ImagingCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ImagingCapabilities::XAddr);
#endif
}

int tt__ImagingCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingCapabilities(struct soap *soap, const char *tag, int id, const tt__ImagingCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__ImagingCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingCapabilities * SOAP_FMAC4 soap_in_tt__ImagingCapabilities(struct soap *soap, const char *tag, tt__ImagingCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(tt__ImagingCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__ImagingCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ImagingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingCapabilities, SOAP_TYPE_tt__ImagingCapabilities, sizeof(tt__ImagingCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingCapabilities * SOAP_FMAC2 soap_instantiate_tt__ImagingCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingCapabilities *p;
	size_t k = sizeof(tt__ImagingCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingCapabilities(soap, tag ? tag : "tt:ImagingCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingCapabilities * SOAP_FMAC4 soap_get_tt__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OnvifVersion::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__OnvifVersion::Major);
	soap_default_int(soap, &this->tt__OnvifVersion::Minor);
}

void tt__OnvifVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__OnvifVersion::Major, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__OnvifVersion::Minor, SOAP_TYPE_int);
#endif
}

int tt__OnvifVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OnvifVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OnvifVersion(struct soap *soap, const char *tag, int id, const tt__OnvifVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OnvifVersion), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Major", -1, &a->tt__OnvifVersion::Major, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minor", -1, &a->tt__OnvifVersion::Minor, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OnvifVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OnvifVersion(soap, tag, this, type);
}

SOAP_FMAC3 tt__OnvifVersion * SOAP_FMAC4 soap_in_tt__OnvifVersion(struct soap *soap, const char *tag, tt__OnvifVersion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OnvifVersion*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OnvifVersion, sizeof(tt__OnvifVersion), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OnvifVersion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OnvifVersion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Major1 = 1;
	size_t soap_flag_Minor1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Major1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Major", &a->tt__OnvifVersion::Major, "xsd:int"))
				{	soap_flag_Major1--;
					continue;
				}
			}
			if (soap_flag_Minor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Minor", &a->tt__OnvifVersion::Minor, "xsd:int"))
				{	soap_flag_Minor1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Major1 > 0 || soap_flag_Minor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OnvifVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OnvifVersion, SOAP_TYPE_tt__OnvifVersion, sizeof(tt__OnvifVersion), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OnvifVersion * SOAP_FMAC2 soap_instantiate_tt__OnvifVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OnvifVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OnvifVersion *p;
	size_t k = sizeof(tt__OnvifVersion);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OnvifVersion, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OnvifVersion);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OnvifVersion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OnvifVersion location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OnvifVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OnvifVersion(soap, tag ? tag : "tt:OnvifVersion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OnvifVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OnvifVersion(soap, this, tag, type);
}

SOAP_FMAC3 tt__OnvifVersion * SOAP_FMAC4 soap_get_tt__OnvifVersion(struct soap *soap, tt__OnvifVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemCapabilitiesExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SystemCapabilitiesExtension2::__any);
}

void tt__SystemCapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SystemCapabilitiesExtension2::__any);
#endif
}

int tt__SystemCapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemCapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__SystemCapabilitiesExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemCapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemCapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(tt__SystemCapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemCapabilitiesExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemCapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__SystemCapabilitiesExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension2, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(tt__SystemCapabilitiesExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemCapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemCapabilitiesExtension2 *p;
	size_t k = sizeof(tt__SystemCapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemCapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemCapabilitiesExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemCapabilitiesExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemCapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemCapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemCapabilitiesExtension2(soap, tag ? tag : "tt:SystemCapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemCapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemCapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension2(struct soap *soap, tt__SystemCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemCapabilitiesExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SystemCapabilitiesExtension::__any);
	this->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade = NULL;
	this->tt__SystemCapabilitiesExtension::HttpSystemBackup = NULL;
	this->tt__SystemCapabilitiesExtension::HttpSystemLogging = NULL;
	this->tt__SystemCapabilitiesExtension::HttpSupportInformation = NULL;
	this->tt__SystemCapabilitiesExtension::Extension = NULL;
}

void tt__SystemCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SystemCapabilitiesExtension::__any);
	soap_serialize_PointerTobool(soap, &this->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade);
	soap_serialize_PointerTobool(soap, &this->tt__SystemCapabilitiesExtension::HttpSystemBackup);
	soap_serialize_PointerTobool(soap, &this->tt__SystemCapabilitiesExtension::HttpSystemLogging);
	soap_serialize_PointerTobool(soap, &this->tt__SystemCapabilitiesExtension::HttpSupportInformation);
	soap_serialize_PointerTott__SystemCapabilitiesExtension2(soap, &this->tt__SystemCapabilitiesExtension::Extension);
#endif
}

int tt__SystemCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__SystemCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__SystemCapabilitiesExtension::__any, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:HttpFirmwareUpgrade", -1, &a->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:HttpSystemBackup", -1, &a->tt__SystemCapabilitiesExtension::HttpSystemBackup, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:HttpSystemLogging", -1, &a->tt__SystemCapabilitiesExtension::HttpSystemLogging, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:HttpSupportInformation", -1, &a->tt__SystemCapabilitiesExtension::HttpSupportInformation, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", -1, &a->tt__SystemCapabilitiesExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, tt__SystemCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(tt__SystemCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_HttpFirmwareUpgrade1 = 1;
	size_t soap_flag_HttpSystemBackup1 = 1;
	size_t soap_flag_HttpSystemLogging1 = 1;
	size_t soap_flag_HttpSupportInformation1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HttpFirmwareUpgrade1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:HttpFirmwareUpgrade", &a->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade, "xsd:boolean"))
				{	soap_flag_HttpFirmwareUpgrade1--;
					continue;
				}
			}
			if (soap_flag_HttpSystemBackup1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:HttpSystemBackup", &a->tt__SystemCapabilitiesExtension::HttpSystemBackup, "xsd:boolean"))
				{	soap_flag_HttpSystemBackup1--;
					continue;
				}
			}
			if (soap_flag_HttpSystemLogging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:HttpSystemLogging", &a->tt__SystemCapabilitiesExtension::HttpSystemLogging, "xsd:boolean"))
				{	soap_flag_HttpSystemLogging1--;
					continue;
				}
			}
			if (soap_flag_HttpSupportInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:HttpSupportInformation", &a->tt__SystemCapabilitiesExtension::HttpSupportInformation, "xsd:boolean"))
				{	soap_flag_HttpSupportInformation1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", &a->tt__SystemCapabilitiesExtension::Extension, "tt:SystemCapabilitiesExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__SystemCapabilitiesExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(tt__SystemCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemCapabilitiesExtension *p;
	size_t k = sizeof(tt__SystemCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemCapabilitiesExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemCapabilitiesExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemCapabilitiesExtension(soap, tag ? tag : "tt:SystemCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__SystemCapabilities::DiscoveryResolve);
	soap_default_bool(soap, &this->tt__SystemCapabilities::DiscoveryBye);
	soap_default_bool(soap, &this->tt__SystemCapabilities::RemoteDiscovery);
	soap_default_bool(soap, &this->tt__SystemCapabilities::SystemBackup);
	soap_default_bool(soap, &this->tt__SystemCapabilities::SystemLogging);
	soap_default_bool(soap, &this->tt__SystemCapabilities::FirmwareUpgrade);
	soap_default_std__vectorTemplateOfPointerTott__OnvifVersion(soap, &this->tt__SystemCapabilities::SupportedVersions);
	this->tt__SystemCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__SystemCapabilities::__anyAttribute);
}

void tt__SystemCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SystemCapabilities::DiscoveryResolve, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::DiscoveryBye, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::RemoteDiscovery, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::SystemBackup, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::SystemLogging, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::FirmwareUpgrade, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfPointerTott__OnvifVersion(soap, &this->tt__SystemCapabilities::SupportedVersions);
	soap_serialize_PointerTott__SystemCapabilitiesExtension(soap, &this->tt__SystemCapabilities::Extension);
#endif
}

int tt__SystemCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilities(struct soap *soap, const char *tag, int id, const tt__SystemCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SystemCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilities), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:DiscoveryResolve", -1, &a->tt__SystemCapabilities::DiscoveryResolve, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DiscoveryBye", -1, &a->tt__SystemCapabilities::DiscoveryBye, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RemoteDiscovery", -1, &a->tt__SystemCapabilities::RemoteDiscovery, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:SystemBackup", -1, &a->tt__SystemCapabilities::SystemBackup, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:SystemLogging", -1, &a->tt__SystemCapabilities::SystemLogging, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:FirmwareUpgrade", -1, &a->tt__SystemCapabilities::FirmwareUpgrade, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__OnvifVersion(soap, "tt:SupportedVersions", -1, &a->tt__SystemCapabilities::SupportedVersions, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__SystemCapabilities::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemCapabilities * SOAP_FMAC4 soap_in_tt__SystemCapabilities(struct soap *soap, const char *tag, tt__SystemCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilities, sizeof(tt__SystemCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SystemCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_DiscoveryResolve1 = 1;
	size_t soap_flag_DiscoveryBye1 = 1;
	size_t soap_flag_RemoteDiscovery1 = 1;
	size_t soap_flag_SystemBackup1 = 1;
	size_t soap_flag_SystemLogging1 = 1;
	size_t soap_flag_FirmwareUpgrade1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryResolve1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DiscoveryResolve", &a->tt__SystemCapabilities::DiscoveryResolve, "xsd:boolean"))
				{	soap_flag_DiscoveryResolve1--;
					continue;
				}
			}
			if (soap_flag_DiscoveryBye1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DiscoveryBye", &a->tt__SystemCapabilities::DiscoveryBye, "xsd:boolean"))
				{	soap_flag_DiscoveryBye1--;
					continue;
				}
			}
			if (soap_flag_RemoteDiscovery1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RemoteDiscovery", &a->tt__SystemCapabilities::RemoteDiscovery, "xsd:boolean"))
				{	soap_flag_RemoteDiscovery1--;
					continue;
				}
			}
			if (soap_flag_SystemBackup1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:SystemBackup", &a->tt__SystemCapabilities::SystemBackup, "xsd:boolean"))
				{	soap_flag_SystemBackup1--;
					continue;
				}
			}
			if (soap_flag_SystemLogging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:SystemLogging", &a->tt__SystemCapabilities::SystemLogging, "xsd:boolean"))
				{	soap_flag_SystemLogging1--;
					continue;
				}
			}
			if (soap_flag_FirmwareUpgrade1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FirmwareUpgrade", &a->tt__SystemCapabilities::FirmwareUpgrade, "xsd:boolean"))
				{	soap_flag_FirmwareUpgrade1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__OnvifVersion(soap, "tt:SupportedVersions", &a->tt__SystemCapabilities::SupportedVersions, "tt:OnvifVersion"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", &a->tt__SystemCapabilities::Extension, "tt:SystemCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryResolve1 > 0 || soap_flag_DiscoveryBye1 > 0 || soap_flag_RemoteDiscovery1 > 0 || soap_flag_SystemBackup1 > 0 || soap_flag_SystemLogging1 > 0 || soap_flag_FirmwareUpgrade1 > 0 || a->tt__SystemCapabilities::SupportedVersions.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilities, SOAP_TYPE_tt__SystemCapabilities, sizeof(tt__SystemCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemCapabilities *p;
	size_t k = sizeof(tt__SystemCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemCapabilities(soap, tag ? tag : "tt:SystemCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemCapabilities * SOAP_FMAC4 soap_get_tt__SystemCapabilities(struct soap *soap, tt__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SecurityCapabilitiesExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__SecurityCapabilitiesExtension2::Dot1X);
	soap_default_std__vectorTemplateOfint(soap, &this->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod);
	soap_default_bool(soap, &this->tt__SecurityCapabilitiesExtension2::RemoteUserHandling);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SecurityCapabilitiesExtension2::__any);
}

void tt__SecurityCapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SecurityCapabilitiesExtension2::Dot1X, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfint(soap, &this->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod);
	soap_embedded(soap, &this->tt__SecurityCapabilitiesExtension2::RemoteUserHandling, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SecurityCapabilitiesExtension2::__any);
#endif
}

int tt__SecurityCapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SecurityCapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:Dot1X", -1, &a->tt__SecurityCapabilitiesExtension2::Dot1X, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "tt:SupportedEAPMethod", -1, &a->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RemoteUserHandling", -1, &a->tt__SecurityCapabilitiesExtension2::RemoteUserHandling, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__SecurityCapabilitiesExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SecurityCapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SecurityCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(tt__SecurityCapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SecurityCapabilitiesExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SecurityCapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Dot1X1 = 1;
	size_t soap_flag_RemoteUserHandling1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1X1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Dot1X", &a->tt__SecurityCapabilitiesExtension2::Dot1X, "xsd:boolean"))
				{	soap_flag_Dot1X1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfint(soap, "tt:SupportedEAPMethod", &a->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod, "xsd:int"))
					continue;
			}
			if (soap_flag_RemoteUserHandling1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RemoteUserHandling", &a->tt__SecurityCapabilitiesExtension2::RemoteUserHandling, "xsd:boolean"))
				{	soap_flag_RemoteUserHandling1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__SecurityCapabilitiesExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1X1 > 0 || soap_flag_RemoteUserHandling1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SecurityCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(tt__SecurityCapabilitiesExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SecurityCapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SecurityCapabilitiesExtension2 *p;
	size_t k = sizeof(tt__SecurityCapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SecurityCapabilitiesExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SecurityCapabilitiesExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SecurityCapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SecurityCapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SecurityCapabilitiesExtension2(soap, tag ? tag : "tt:SecurityCapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SecurityCapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SecurityCapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension2(struct soap *soap, tt__SecurityCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SecurityCapabilitiesExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__SecurityCapabilitiesExtension::TLS1_x002e0);
	this->tt__SecurityCapabilitiesExtension::Extension = NULL;
}

void tt__SecurityCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SecurityCapabilitiesExtension::TLS1_x002e0, SOAP_TYPE_bool);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension2(soap, &this->tt__SecurityCapabilitiesExtension::Extension);
#endif
}

int tt__SecurityCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SecurityCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__SecurityCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:TLS1.0", -1, &a->tt__SecurityCapabilitiesExtension::TLS1_x002e0, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", -1, &a->tt__SecurityCapabilitiesExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SecurityCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SecurityCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, tt__SecurityCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SecurityCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(tt__SecurityCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SecurityCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SecurityCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_TLS1_x002e01 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:TLS1.0", &a->tt__SecurityCapabilitiesExtension::TLS1_x002e0, "xsd:boolean"))
				{	soap_flag_TLS1_x002e01--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", &a->tt__SecurityCapabilitiesExtension::Extension, "tt:SecurityCapabilitiesExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SecurityCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(tt__SecurityCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SecurityCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SecurityCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SecurityCapabilitiesExtension *p;
	size_t k = sizeof(tt__SecurityCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SecurityCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SecurityCapabilitiesExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SecurityCapabilitiesExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SecurityCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SecurityCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SecurityCapabilitiesExtension(soap, tag ? tag : "tt:SecurityCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SecurityCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SecurityCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SecurityCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__SecurityCapabilities::TLS1_x002e1);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::TLS1_x002e2);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::OnboardKeyGeneration);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::AccessPolicyConfig);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::X_x002e509Token);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::SAMLToken);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::KerberosToken);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::RELToken);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SecurityCapabilities::__any);
	this->tt__SecurityCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__SecurityCapabilities::__anyAttribute);
}

void tt__SecurityCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SecurityCapabilities::TLS1_x002e1, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::TLS1_x002e2, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::OnboardKeyGeneration, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::AccessPolicyConfig, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::X_x002e509Token, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::SAMLToken, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::KerberosToken, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::RELToken, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SecurityCapabilities::__any);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension(soap, &this->tt__SecurityCapabilities::Extension);
#endif
}

int tt__SecurityCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SecurityCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilities(struct soap *soap, const char *tag, int id, const tt__SecurityCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SecurityCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilities), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:TLS1.1", -1, &a->tt__SecurityCapabilities::TLS1_x002e1, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:TLS1.2", -1, &a->tt__SecurityCapabilities::TLS1_x002e2, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:OnboardKeyGeneration", -1, &a->tt__SecurityCapabilities::OnboardKeyGeneration, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AccessPolicyConfig", -1, &a->tt__SecurityCapabilities::AccessPolicyConfig, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:X.509Token", -1, &a->tt__SecurityCapabilities::X_x002e509Token, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:SAMLToken", -1, &a->tt__SecurityCapabilities::SAMLToken, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:KerberosToken", -1, &a->tt__SecurityCapabilities::KerberosToken, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RELToken", -1, &a->tt__SecurityCapabilities::RELToken, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__SecurityCapabilities::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__SecurityCapabilities::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SecurityCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SecurityCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__SecurityCapabilities * SOAP_FMAC4 soap_in_tt__SecurityCapabilities(struct soap *soap, const char *tag, tt__SecurityCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SecurityCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(tt__SecurityCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SecurityCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SecurityCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SecurityCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_TLS1_x002e11 = 1;
	size_t soap_flag_TLS1_x002e21 = 1;
	size_t soap_flag_OnboardKeyGeneration1 = 1;
	size_t soap_flag_AccessPolicyConfig1 = 1;
	size_t soap_flag_X_x002e509Token1 = 1;
	size_t soap_flag_SAMLToken1 = 1;
	size_t soap_flag_KerberosToken1 = 1;
	size_t soap_flag_RELToken1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:TLS1.1", &a->tt__SecurityCapabilities::TLS1_x002e1, "xsd:boolean"))
				{	soap_flag_TLS1_x002e11--;
					continue;
				}
			}
			if (soap_flag_TLS1_x002e21 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:TLS1.2", &a->tt__SecurityCapabilities::TLS1_x002e2, "xsd:boolean"))
				{	soap_flag_TLS1_x002e21--;
					continue;
				}
			}
			if (soap_flag_OnboardKeyGeneration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:OnboardKeyGeneration", &a->tt__SecurityCapabilities::OnboardKeyGeneration, "xsd:boolean"))
				{	soap_flag_OnboardKeyGeneration1--;
					continue;
				}
			}
			if (soap_flag_AccessPolicyConfig1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AccessPolicyConfig", &a->tt__SecurityCapabilities::AccessPolicyConfig, "xsd:boolean"))
				{	soap_flag_AccessPolicyConfig1--;
					continue;
				}
			}
			if (soap_flag_X_x002e509Token1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:X.509Token", &a->tt__SecurityCapabilities::X_x002e509Token, "xsd:boolean"))
				{	soap_flag_X_x002e509Token1--;
					continue;
				}
			}
			if (soap_flag_SAMLToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:SAMLToken", &a->tt__SecurityCapabilities::SAMLToken, "xsd:boolean"))
				{	soap_flag_SAMLToken1--;
					continue;
				}
			}
			if (soap_flag_KerberosToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:KerberosToken", &a->tt__SecurityCapabilities::KerberosToken, "xsd:boolean"))
				{	soap_flag_KerberosToken1--;
					continue;
				}
			}
			if (soap_flag_RELToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RELToken", &a->tt__SecurityCapabilities::RELToken, "xsd:boolean"))
				{	soap_flag_RELToken1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", &a->tt__SecurityCapabilities::Extension, "tt:SecurityCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__SecurityCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e11 > 0 || soap_flag_TLS1_x002e21 > 0 || soap_flag_OnboardKeyGeneration1 > 0 || soap_flag_AccessPolicyConfig1 > 0 || soap_flag_X_x002e509Token1 > 0 || soap_flag_SAMLToken1 > 0 || soap_flag_KerberosToken1 > 0 || soap_flag_RELToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilities, SOAP_TYPE_tt__SecurityCapabilities, sizeof(tt__SecurityCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SecurityCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SecurityCapabilities *p;
	size_t k = sizeof(tt__SecurityCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SecurityCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SecurityCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SecurityCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SecurityCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SecurityCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SecurityCapabilities(soap, tag ? tag : "tt:SecurityCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SecurityCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SecurityCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__SecurityCapabilities * SOAP_FMAC4 soap_get_tt__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkCapabilitiesExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkCapabilitiesExtension2::__any);
}

void tt__NetworkCapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkCapabilitiesExtension2::__any);
#endif
}

int tt__NetworkCapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkCapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NetworkCapabilitiesExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkCapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(tt__NetworkCapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkCapabilitiesExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkCapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NetworkCapabilitiesExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(tt__NetworkCapabilitiesExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkCapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkCapabilitiesExtension2 *p;
	size_t k = sizeof(tt__NetworkCapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkCapabilitiesExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkCapabilitiesExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkCapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkCapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkCapabilitiesExtension2(soap, tag ? tag : "tt:NetworkCapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkCapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkCapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension2(struct soap *soap, tt__NetworkCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkCapabilitiesExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkCapabilitiesExtension::__any);
	this->tt__NetworkCapabilitiesExtension::Dot11Configuration = NULL;
	this->tt__NetworkCapabilitiesExtension::Extension = NULL;
}

void tt__NetworkCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkCapabilitiesExtension::__any);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilitiesExtension::Dot11Configuration);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension2(soap, &this->tt__NetworkCapabilitiesExtension::Extension);
#endif
}

int tt__NetworkCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__NetworkCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NetworkCapabilitiesExtension::__any, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Dot11Configuration", -1, &a->tt__NetworkCapabilitiesExtension::Dot11Configuration, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", -1, &a->tt__NetworkCapabilitiesExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, tt__NetworkCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(tt__NetworkCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Dot11Configuration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot11Configuration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Dot11Configuration", &a->tt__NetworkCapabilitiesExtension::Dot11Configuration, "xsd:boolean"))
				{	soap_flag_Dot11Configuration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", &a->tt__NetworkCapabilitiesExtension::Extension, "tt:NetworkCapabilitiesExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NetworkCapabilitiesExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(tt__NetworkCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkCapabilitiesExtension *p;
	size_t k = sizeof(tt__NetworkCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkCapabilitiesExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkCapabilitiesExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkCapabilitiesExtension(soap, tag ? tag : "tt:NetworkCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__NetworkCapabilities::IPFilter = NULL;
	this->tt__NetworkCapabilities::ZeroConfiguration = NULL;
	this->tt__NetworkCapabilities::IPVersion6 = NULL;
	this->tt__NetworkCapabilities::DynDNS = NULL;
	this->tt__NetworkCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NetworkCapabilities::__anyAttribute);
}

void tt__NetworkCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::IPFilter);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::ZeroConfiguration);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::IPVersion6);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::DynDNS);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension(soap, &this->tt__NetworkCapabilities::Extension);
#endif
}

int tt__NetworkCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilities(struct soap *soap, const char *tag, int id, const tt__NetworkCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NetworkCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilities), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:IPFilter", -1, &a->tt__NetworkCapabilities::IPFilter, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:ZeroConfiguration", -1, &a->tt__NetworkCapabilities::ZeroConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:IPVersion6", -1, &a->tt__NetworkCapabilities::IPVersion6, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:DynDNS", -1, &a->tt__NetworkCapabilities::DynDNS, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__NetworkCapabilities::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkCapabilities * SOAP_FMAC4 soap_in_tt__NetworkCapabilities(struct soap *soap, const char *tag, tt__NetworkCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(tt__NetworkCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NetworkCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_IPFilter1 = 1;
	size_t soap_flag_ZeroConfiguration1 = 1;
	size_t soap_flag_IPVersion61 = 1;
	size_t soap_flag_DynDNS1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:IPFilter", &a->tt__NetworkCapabilities::IPFilter, "xsd:boolean"))
				{	soap_flag_IPFilter1--;
					continue;
				}
			}
			if (soap_flag_ZeroConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:ZeroConfiguration", &a->tt__NetworkCapabilities::ZeroConfiguration, "xsd:boolean"))
				{	soap_flag_ZeroConfiguration1--;
					continue;
				}
			}
			if (soap_flag_IPVersion61 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:IPVersion6", &a->tt__NetworkCapabilities::IPVersion6, "xsd:boolean"))
				{	soap_flag_IPVersion61--;
					continue;
				}
			}
			if (soap_flag_DynDNS1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:DynDNS", &a->tt__NetworkCapabilities::DynDNS, "xsd:boolean"))
				{	soap_flag_DynDNS1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", &a->tt__NetworkCapabilities::Extension, "tt:NetworkCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilities, SOAP_TYPE_tt__NetworkCapabilities, sizeof(tt__NetworkCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkCapabilities *p;
	size_t k = sizeof(tt__NetworkCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkCapabilities(soap, tag ? tag : "tt:NetworkCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkCapabilities * SOAP_FMAC4 soap_get_tt__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ProfileCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->tt__ProfileCapabilities::MaximumNumberOfProfiles);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ProfileCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ProfileCapabilities::__anyAttribute);
}

void tt__ProfileCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ProfileCapabilities::MaximumNumberOfProfiles, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ProfileCapabilities::__any);
#endif
}

int tt__ProfileCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileCapabilities(struct soap *soap, const char *tag, int id, const tt__ProfileCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ProfileCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileCapabilities), type))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfProfiles", -1, &a->tt__ProfileCapabilities::MaximumNumberOfProfiles, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__ProfileCapabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ProfileCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ProfileCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileCapabilities * SOAP_FMAC4 soap_in_tt__ProfileCapabilities(struct soap *soap, const char *tag, tt__ProfileCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ProfileCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(tt__ProfileCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ProfileCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ProfileCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ProfileCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_MaximumNumberOfProfiles1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfProfiles1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumNumberOfProfiles", &a->tt__ProfileCapabilities::MaximumNumberOfProfiles, "xsd:int"))
				{	soap_flag_MaximumNumberOfProfiles1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__ProfileCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfProfiles1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileCapabilities, SOAP_TYPE_tt__ProfileCapabilities, sizeof(tt__ProfileCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_tt__ProfileCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ProfileCapabilities *p;
	size_t k = sizeof(tt__ProfileCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ProfileCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ProfileCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ProfileCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ProfileCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ProfileCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ProfileCapabilities(soap, tag ? tag : "tt:ProfileCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileCapabilities * SOAP_FMAC4 soap_get_tt__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RealTimeStreamingCapabilitiesExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RealTimeStreamingCapabilitiesExtension::__any);
}

void tt__RealTimeStreamingCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RealTimeStreamingCapabilitiesExtension::__any);
#endif
}

int tt__RealTimeStreamingCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__RealTimeStreamingCapabilitiesExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RealTimeStreamingCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RealTimeStreamingCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(tt__RealTimeStreamingCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RealTimeStreamingCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__RealTimeStreamingCapabilitiesExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RealTimeStreamingCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(tt__RealTimeStreamingCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RealTimeStreamingCapabilitiesExtension *p;
	size_t k = sizeof(tt__RealTimeStreamingCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RealTimeStreamingCapabilitiesExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RealTimeStreamingCapabilitiesExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RealTimeStreamingCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RealTimeStreamingCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag ? tag : "tt:RealTimeStreamingCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RealTimeStreamingCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RealTimeStreamingCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RealTimeStreamingCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__RealTimeStreamingCapabilities::RTPMulticast = NULL;
	this->tt__RealTimeStreamingCapabilities::RTP_USCORETCP = NULL;
	this->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP = NULL;
	this->tt__RealTimeStreamingCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__RealTimeStreamingCapabilities::__anyAttribute);
}

void tt__RealTimeStreamingCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__RealTimeStreamingCapabilities::RTPMulticast);
	soap_serialize_PointerTobool(soap, &this->tt__RealTimeStreamingCapabilities::RTP_USCORETCP);
	soap_serialize_PointerTobool(soap, &this->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP);
	soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, &this->tt__RealTimeStreamingCapabilities::Extension);
#endif
}

int tt__RealTimeStreamingCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RealTimeStreamingCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, const tt__RealTimeStreamingCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RealTimeStreamingCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RTPMulticast", -1, &a->tt__RealTimeStreamingCapabilities::RTPMulticast, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RTP_TCP", -1, &a->tt__RealTimeStreamingCapabilities::RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RTP_RTSP_TCP", -1, &a->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__RealTimeStreamingCapabilities::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RealTimeStreamingCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RealTimeStreamingCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RealTimeStreamingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(tt__RealTimeStreamingCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RealTimeStreamingCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RealTimeStreamingCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RealTimeStreamingCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RTPMulticast1 = 1;
	size_t soap_flag_RTP_USCORETCP1 = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RTPMulticast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RTPMulticast", &a->tt__RealTimeStreamingCapabilities::RTPMulticast, "xsd:boolean"))
				{	soap_flag_RTPMulticast1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RTP_TCP", &a->tt__RealTimeStreamingCapabilities::RTP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORERTSP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RTP_RTSP_TCP", &a->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", &a->tt__RealTimeStreamingCapabilities::Extension, "tt:RealTimeStreamingCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RealTimeStreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilities, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(tt__RealTimeStreamingCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RealTimeStreamingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RealTimeStreamingCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RealTimeStreamingCapabilities *p;
	size_t k = sizeof(tt__RealTimeStreamingCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RealTimeStreamingCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RealTimeStreamingCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RealTimeStreamingCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RealTimeStreamingCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RealTimeStreamingCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RealTimeStreamingCapabilities(soap, tag ? tag : "tt:RealTimeStreamingCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RealTimeStreamingCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RealTimeStreamingCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MediaCapabilitiesExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__MediaCapabilitiesExtension::ProfileCapabilities = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaCapabilitiesExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__MediaCapabilitiesExtension::__anyAttribute);
}

void tt__MediaCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ProfileCapabilities(soap, &this->tt__MediaCapabilitiesExtension::ProfileCapabilities);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaCapabilitiesExtension::__any);
#endif
}

int tt__MediaCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__MediaCapabilitiesExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MediaCapabilitiesExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension), type))
		return soap->error;
	if (!a->tt__MediaCapabilitiesExtension::ProfileCapabilities)
	{	if (soap_element_empty(soap, "tt:ProfileCapabilities"))
			return soap->error;
	}
	else if (soap_out_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", -1, &a->tt__MediaCapabilitiesExtension::ProfileCapabilities, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MediaCapabilitiesExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MediaCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MediaCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, tt__MediaCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(tt__MediaCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MediaCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MediaCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MediaCapabilitiesExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ProfileCapabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", &a->tt__MediaCapabilitiesExtension::ProfileCapabilities, "tt:ProfileCapabilities"))
				{	soap_flag_ProfileCapabilities1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MediaCapabilitiesExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__MediaCapabilitiesExtension::ProfileCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MediaCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilitiesExtension, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(tt__MediaCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MediaCapabilitiesExtension *p;
	size_t k = sizeof(tt__MediaCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MediaCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MediaCapabilitiesExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MediaCapabilitiesExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MediaCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MediaCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MediaCapabilitiesExtension(soap, tag ? tag : "tt:MediaCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MediaCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__MediaCapabilities::XAddr);
	this->tt__MediaCapabilities::StreamingCapabilities = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaCapabilities::__any);
	this->tt__MediaCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__MediaCapabilities::__anyAttribute);
}

void tt__MediaCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__MediaCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__MediaCapabilities::XAddr);
	soap_serialize_PointerTott__RealTimeStreamingCapabilities(soap, &this->tt__MediaCapabilities::StreamingCapabilities);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaCapabilities::__any);
	soap_serialize_PointerTott__MediaCapabilitiesExtension(soap, &this->tt__MediaCapabilities::Extension);
#endif
}

int tt__MediaCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilities(struct soap *soap, const char *tag, int id, const tt__MediaCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MediaCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__MediaCapabilities::XAddr, ""))
		return soap->error;
	if (!a->tt__MediaCapabilities::StreamingCapabilities)
	{	if (soap_element_empty(soap, "tt:StreamingCapabilities"))
			return soap->error;
	}
	else if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", -1, &a->tt__MediaCapabilities::StreamingCapabilities, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MediaCapabilities::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__MediaCapabilities::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MediaCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MediaCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaCapabilities * SOAP_FMAC4 soap_in_tt__MediaCapabilities(struct soap *soap, const char *tag, tt__MediaCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilities, sizeof(tt__MediaCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MediaCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MediaCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MediaCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_StreamingCapabilities1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__MediaCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_StreamingCapabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", &a->tt__MediaCapabilities::StreamingCapabilities, "tt:RealTimeStreamingCapabilities"))
				{	soap_flag_StreamingCapabilities1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", &a->tt__MediaCapabilities::Extension, "tt:MediaCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MediaCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || !a->tt__MediaCapabilities::StreamingCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MediaCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilities, SOAP_TYPE_tt__MediaCapabilities, sizeof(tt__MediaCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaCapabilities * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MediaCapabilities *p;
	size_t k = sizeof(tt__MediaCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MediaCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MediaCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MediaCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MediaCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MediaCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MediaCapabilities(soap, tag ? tag : "tt:MediaCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaCapabilities * SOAP_FMAC4 soap_get_tt__MediaCapabilities(struct soap *soap, tt__MediaCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IOCapabilitiesExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IOCapabilitiesExtension2::__any);
}

void tt__IOCapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IOCapabilitiesExtension2::__any);
#endif
}

int tt__IOCapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IOCapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__IOCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilitiesExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__IOCapabilitiesExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IOCapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IOCapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension2(struct soap *soap, const char *tag, tt__IOCapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IOCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(tt__IOCapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IOCapabilitiesExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IOCapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__IOCapabilitiesExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IOCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension2, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(tt__IOCapabilitiesExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IOCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IOCapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IOCapabilitiesExtension2 *p;
	size_t k = sizeof(tt__IOCapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IOCapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IOCapabilitiesExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IOCapabilitiesExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IOCapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IOCapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IOCapabilitiesExtension2(soap, tag ? tag : "tt:IOCapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IOCapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IOCapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension2(struct soap *soap, tt__IOCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IOCapabilitiesExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IOCapabilitiesExtension::__any);
	this->tt__IOCapabilitiesExtension::Auxiliary = NULL;
	soap_default_std__vectorTemplateOftt__AuxiliaryData(soap, &this->tt__IOCapabilitiesExtension::AuxiliaryCommands);
	this->tt__IOCapabilitiesExtension::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__IOCapabilitiesExtension::__anyAttribute);
}

void tt__IOCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IOCapabilitiesExtension::__any);
	soap_serialize_PointerTobool(soap, &this->tt__IOCapabilitiesExtension::Auxiliary);
	soap_serialize_std__vectorTemplateOftt__AuxiliaryData(soap, &this->tt__IOCapabilitiesExtension::AuxiliaryCommands);
	soap_serialize_PointerTott__IOCapabilitiesExtension2(soap, &this->tt__IOCapabilitiesExtension::Extension);
#endif
}

int tt__IOCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IOCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__IOCapabilitiesExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__IOCapabilitiesExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__IOCapabilitiesExtension::__any, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Auxiliary", -1, &a->tt__IOCapabilitiesExtension::Auxiliary, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__AuxiliaryData(soap, "tt:AuxiliaryCommands", -1, &a->tt__IOCapabilitiesExtension::AuxiliaryCommands, ""))
		return soap->error;
	if (!a->tt__IOCapabilitiesExtension::Extension)
	{	if (soap_element_empty(soap, "tt:Extension"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IOCapabilitiesExtension2(soap, "tt:Extension", -1, &a->tt__IOCapabilitiesExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IOCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IOCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, tt__IOCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IOCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(tt__IOCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IOCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IOCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__IOCapabilitiesExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Auxiliary1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auxiliary1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Auxiliary", &a->tt__IOCapabilitiesExtension::Auxiliary, "xsd:boolean"))
				{	soap_flag_Auxiliary1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__AuxiliaryData(soap, "tt:AuxiliaryCommands", &a->tt__IOCapabilitiesExtension::AuxiliaryCommands, "tt:AuxiliaryData"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IOCapabilitiesExtension2(soap, "tt:Extension", &a->tt__IOCapabilitiesExtension::Extension, "tt:IOCapabilitiesExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__IOCapabilitiesExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__IOCapabilitiesExtension::Extension))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IOCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(tt__IOCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IOCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IOCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IOCapabilitiesExtension *p;
	size_t k = sizeof(tt__IOCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IOCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IOCapabilitiesExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IOCapabilitiesExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IOCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IOCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IOCapabilitiesExtension(soap, tag ? tag : "tt:IOCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IOCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IOCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IOCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__IOCapabilities::InputConnectors = NULL;
	this->tt__IOCapabilities::RelayOutputs = NULL;
	this->tt__IOCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__IOCapabilities::__anyAttribute);
}

void tt__IOCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->tt__IOCapabilities::InputConnectors);
	soap_serialize_PointerToint(soap, &this->tt__IOCapabilities::RelayOutputs);
	soap_serialize_PointerTott__IOCapabilitiesExtension(soap, &this->tt__IOCapabilities::Extension);
#endif
}

int tt__IOCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IOCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilities(struct soap *soap, const char *tag, int id, const tt__IOCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__IOCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilities), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:InputConnectors", -1, &a->tt__IOCapabilities::InputConnectors, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:RelayOutputs", -1, &a->tt__IOCapabilities::RelayOutputs, ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__IOCapabilities::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IOCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IOCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__IOCapabilities * SOAP_FMAC4 soap_in_tt__IOCapabilities(struct soap *soap, const char *tag, tt__IOCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IOCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilities, sizeof(tt__IOCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IOCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IOCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__IOCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_InputConnectors1 = 1;
	size_t soap_flag_RelayOutputs1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputConnectors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:InputConnectors", &a->tt__IOCapabilities::InputConnectors, "xsd:int"))
				{	soap_flag_InputConnectors1--;
					continue;
				}
			}
			if (soap_flag_RelayOutputs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:RelayOutputs", &a->tt__IOCapabilities::RelayOutputs, "xsd:int"))
				{	soap_flag_RelayOutputs1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", &a->tt__IOCapabilities::Extension, "tt:IOCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilities, SOAP_TYPE_tt__IOCapabilities, sizeof(tt__IOCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IOCapabilities * SOAP_FMAC2 soap_instantiate_tt__IOCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IOCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IOCapabilities *p;
	size_t k = sizeof(tt__IOCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IOCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IOCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IOCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IOCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IOCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IOCapabilities(soap, tag ? tag : "tt:IOCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IOCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IOCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__IOCapabilities * SOAP_FMAC4 soap_get_tt__IOCapabilities(struct soap *soap, tt__IOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EventCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__EventCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__EventCapabilities::WSSubscriptionPolicySupport);
	soap_default_bool(soap, &this->tt__EventCapabilities::WSPullPointSupport);
	soap_default_bool(soap, &this->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EventCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__EventCapabilities::__anyAttribute);
}

void tt__EventCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__EventCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__EventCapabilities::XAddr);
	soap_embedded(soap, &this->tt__EventCapabilities::WSSubscriptionPolicySupport, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__EventCapabilities::WSPullPointSupport, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EventCapabilities::__any);
#endif
}

int tt__EventCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EventCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventCapabilities(struct soap *soap, const char *tag, int id, const tt__EventCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__EventCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__EventCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WSSubscriptionPolicySupport", -1, &a->tt__EventCapabilities::WSSubscriptionPolicySupport, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WSPullPointSupport", -1, &a->tt__EventCapabilities::WSPullPointSupport, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", -1, &a->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__EventCapabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EventCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EventCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__EventCapabilities * SOAP_FMAC4 soap_in_tt__EventCapabilities(struct soap *soap, const char *tag, tt__EventCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EventCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventCapabilities, sizeof(tt__EventCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EventCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EventCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__EventCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_WSSubscriptionPolicySupport1 = 1;
	size_t soap_flag_WSPullPointSupport1 = 1;
	size_t soap_flag_WSPausableSubscriptionManagerInterfaceSupport1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__EventCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_WSSubscriptionPolicySupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:WSSubscriptionPolicySupport", &a->tt__EventCapabilities::WSSubscriptionPolicySupport, "xsd:boolean"))
				{	soap_flag_WSSubscriptionPolicySupport1--;
					continue;
				}
			}
			if (soap_flag_WSPullPointSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:WSPullPointSupport", &a->tt__EventCapabilities::WSPullPointSupport, "xsd:boolean"))
				{	soap_flag_WSPullPointSupport1--;
					continue;
				}
			}
			if (soap_flag_WSPausableSubscriptionManagerInterfaceSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", &a->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport, "xsd:boolean"))
				{	soap_flag_WSPausableSubscriptionManagerInterfaceSupport1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__EventCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_WSSubscriptionPolicySupport1 > 0 || soap_flag_WSPullPointSupport1 > 0 || soap_flag_WSPausableSubscriptionManagerInterfaceSupport1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__EventCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventCapabilities, SOAP_TYPE_tt__EventCapabilities, sizeof(tt__EventCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EventCapabilities * SOAP_FMAC2 soap_instantiate_tt__EventCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EventCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EventCapabilities *p;
	size_t k = sizeof(tt__EventCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EventCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EventCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EventCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EventCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EventCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EventCapabilities(soap, tag ? tag : "tt:EventCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EventCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EventCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__EventCapabilities * SOAP_FMAC4 soap_get_tt__EventCapabilities(struct soap *soap, tt__EventCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceCapabilitiesExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DeviceCapabilitiesExtension::__any);
}

void tt__DeviceCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DeviceCapabilitiesExtension::__any);
#endif
}

int tt__DeviceCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__DeviceCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__DeviceCapabilitiesExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, tt__DeviceCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(tt__DeviceCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__DeviceCapabilitiesExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DeviceCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilitiesExtension, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(tt__DeviceCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DeviceCapabilitiesExtension *p;
	size_t k = sizeof(tt__DeviceCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceCapabilitiesExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceCapabilitiesExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceCapabilitiesExtension(soap, tag ? tag : "tt:DeviceCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__DeviceCapabilities::XAddr);
	this->tt__DeviceCapabilities::Network = NULL;
	this->tt__DeviceCapabilities::System = NULL;
	this->tt__DeviceCapabilities::IO = NULL;
	this->tt__DeviceCapabilities::Security = NULL;
	this->tt__DeviceCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__DeviceCapabilities::__anyAttribute);
}

void tt__DeviceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DeviceCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__DeviceCapabilities::XAddr);
	soap_serialize_PointerTott__NetworkCapabilities(soap, &this->tt__DeviceCapabilities::Network);
	soap_serialize_PointerTott__SystemCapabilities(soap, &this->tt__DeviceCapabilities::System);
	soap_serialize_PointerTott__IOCapabilities(soap, &this->tt__DeviceCapabilities::IO);
	soap_serialize_PointerTott__SecurityCapabilities(soap, &this->tt__DeviceCapabilities::Security);
	soap_serialize_PointerTott__DeviceCapabilitiesExtension(soap, &this->tt__DeviceCapabilities::Extension);
#endif
}

int tt__DeviceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilities(struct soap *soap, const char *tag, int id, const tt__DeviceCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__DeviceCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__DeviceCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilities(soap, "tt:Network", -1, &a->tt__DeviceCapabilities::Network, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilities(soap, "tt:System", -1, &a->tt__DeviceCapabilities::System, ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilities(soap, "tt:IO", -1, &a->tt__DeviceCapabilities::IO, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilities(soap, "tt:Security", -1, &a->tt__DeviceCapabilities::Security, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__DeviceCapabilities::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceCapabilities * SOAP_FMAC4 soap_in_tt__DeviceCapabilities(struct soap *soap, const char *tag, tt__DeviceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(tt__DeviceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__DeviceCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_Network1 = 1;
	size_t soap_flag_System1 = 1;
	size_t soap_flag_IO1 = 1;
	size_t soap_flag_Security1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__DeviceCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_Network1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkCapabilities(soap, "tt:Network", &a->tt__DeviceCapabilities::Network, "tt:NetworkCapabilities"))
				{	soap_flag_Network1--;
					continue;
				}
			}
			if (soap_flag_System1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemCapabilities(soap, "tt:System", &a->tt__DeviceCapabilities::System, "tt:SystemCapabilities"))
				{	soap_flag_System1--;
					continue;
				}
			}
			if (soap_flag_IO1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IOCapabilities(soap, "tt:IO", &a->tt__DeviceCapabilities::IO, "tt:IOCapabilities"))
				{	soap_flag_IO1--;
					continue;
				}
			}
			if (soap_flag_Security1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SecurityCapabilities(soap, "tt:Security", &a->tt__DeviceCapabilities::Security, "tt:SecurityCapabilities"))
				{	soap_flag_Security1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", &a->tt__DeviceCapabilities::Extension, "tt:DeviceCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilities, SOAP_TYPE_tt__DeviceCapabilities, sizeof(tt__DeviceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DeviceCapabilities *p;
	size_t k = sizeof(tt__DeviceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceCapabilities(soap, tag ? tag : "tt:DeviceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceCapabilities * SOAP_FMAC4 soap_get_tt__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsCapabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__AnalyticsCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__AnalyticsCapabilities::RuleSupport);
	soap_default_bool(soap, &this->tt__AnalyticsCapabilities::AnalyticsModuleSupport);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AnalyticsCapabilities::__anyAttribute);
}

void tt__AnalyticsCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AnalyticsCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__AnalyticsCapabilities::XAddr);
	soap_embedded(soap, &this->tt__AnalyticsCapabilities::RuleSupport, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__AnalyticsCapabilities::AnalyticsModuleSupport, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsCapabilities::__any);
#endif
}

int tt__AnalyticsCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, const tt__AnalyticsCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnalyticsCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__AnalyticsCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RuleSupport", -1, &a->tt__AnalyticsCapabilities::RuleSupport, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AnalyticsModuleSupport", -1, &a->tt__AnalyticsCapabilities::AnalyticsModuleSupport, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AnalyticsCapabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsCapabilities * SOAP_FMAC4 soap_in_tt__AnalyticsCapabilities(struct soap *soap, const char *tag, tt__AnalyticsCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(tt__AnalyticsCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnalyticsCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_RuleSupport1 = 1;
	size_t soap_flag_AnalyticsModuleSupport1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__AnalyticsCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_RuleSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RuleSupport", &a->tt__AnalyticsCapabilities::RuleSupport, "xsd:boolean"))
				{	soap_flag_RuleSupport1--;
					continue;
				}
			}
			if (soap_flag_AnalyticsModuleSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AnalyticsModuleSupport", &a->tt__AnalyticsCapabilities::AnalyticsModuleSupport, "xsd:boolean"))
				{	soap_flag_AnalyticsModuleSupport1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AnalyticsCapabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_RuleSupport1 > 0 || soap_flag_AnalyticsModuleSupport1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AnalyticsCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsCapabilities, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(tt__AnalyticsCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsCapabilities *p;
	size_t k = sizeof(tt__AnalyticsCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsCapabilities(soap, tag ? tag : "tt:AnalyticsCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsCapabilities * SOAP_FMAC4 soap_get_tt__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CapabilitiesExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CapabilitiesExtension2::__any);
}

void tt__CapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CapabilitiesExtension2::__any);
#endif
}

int tt__CapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__CapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilitiesExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__CapabilitiesExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension2(struct soap *soap, const char *tag, tt__CapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(tt__CapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CapabilitiesExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__CapabilitiesExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension2, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(tt__CapabilitiesExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CapabilitiesExtension2 *p;
	size_t k = sizeof(tt__CapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CapabilitiesExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CapabilitiesExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CapabilitiesExtension2(soap, tag ? tag : "tt:CapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension2(struct soap *soap, tt__CapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CapabilitiesExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CapabilitiesExtension::__any);
	this->tt__CapabilitiesExtension::DeviceIO = NULL;
	this->tt__CapabilitiesExtension::Display = NULL;
	this->tt__CapabilitiesExtension::Recording = NULL;
	this->tt__CapabilitiesExtension::Search = NULL;
	this->tt__CapabilitiesExtension::Replay = NULL;
	this->tt__CapabilitiesExtension::Receiver = NULL;
	this->tt__CapabilitiesExtension::AnalyticsDevice = NULL;
	this->tt__CapabilitiesExtension::Extensions = NULL;
}

void tt__CapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CapabilitiesExtension::__any);
	soap_serialize_PointerTott__DeviceIOCapabilities(soap, &this->tt__CapabilitiesExtension::DeviceIO);
	soap_serialize_PointerTott__DisplayCapabilities(soap, &this->tt__CapabilitiesExtension::Display);
	soap_serialize_PointerTott__RecordingCapabilities(soap, &this->tt__CapabilitiesExtension::Recording);
	soap_serialize_PointerTott__SearchCapabilities(soap, &this->tt__CapabilitiesExtension::Search);
	soap_serialize_PointerTott__ReplayCapabilities(soap, &this->tt__CapabilitiesExtension::Replay);
	soap_serialize_PointerTott__ReceiverCapabilities(soap, &this->tt__CapabilitiesExtension::Receiver);
	soap_serialize_PointerTott__AnalyticsDeviceCapabilities(soap, &this->tt__CapabilitiesExtension::AnalyticsDevice);
	soap_serialize_PointerTott__CapabilitiesExtension2(soap, &this->tt__CapabilitiesExtension::Extensions);
#endif
}

int tt__CapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__CapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilitiesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__CapabilitiesExtension::__any, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceIOCapabilities(soap, "tt:DeviceIO", -1, &a->tt__CapabilitiesExtension::DeviceIO, ""))
		return soap->error;
	if (soap_out_PointerTott__DisplayCapabilities(soap, "tt:Display", -1, &a->tt__CapabilitiesExtension::Display, ""))
		return soap->error;
	if (soap_out_PointerTott__RecordingCapabilities(soap, "tt:Recording", -1, &a->tt__CapabilitiesExtension::Recording, ""))
		return soap->error;
	if (soap_out_PointerTott__SearchCapabilities(soap, "tt:Search", -1, &a->tt__CapabilitiesExtension::Search, ""))
		return soap->error;
	if (soap_out_PointerTott__ReplayCapabilities(soap, "tt:Replay", -1, &a->tt__CapabilitiesExtension::Replay, ""))
		return soap->error;
	if (soap_out_PointerTott__ReceiverCapabilities(soap, "tt:Receiver", -1, &a->tt__CapabilitiesExtension::Receiver, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsDeviceCapabilities(soap, "tt:AnalyticsDevice", -1, &a->tt__CapabilitiesExtension::AnalyticsDevice, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension2(soap, "tt:Extensions", -1, &a->tt__CapabilitiesExtension::Extensions, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension(struct soap *soap, const char *tag, tt__CapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(tt__CapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_DeviceIO1 = 1;
	size_t soap_flag_Display1 = 1;
	size_t soap_flag_Recording1 = 1;
	size_t soap_flag_Search1 = 1;
	size_t soap_flag_Replay1 = 1;
	size_t soap_flag_Receiver1 = 1;
	size_t soap_flag_AnalyticsDevice1 = 1;
	size_t soap_flag_Extensions1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeviceIO1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceIOCapabilities(soap, "tt:DeviceIO", &a->tt__CapabilitiesExtension::DeviceIO, "tt:DeviceIOCapabilities"))
				{	soap_flag_DeviceIO1--;
					continue;
				}
			}
			if (soap_flag_Display1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DisplayCapabilities(soap, "tt:Display", &a->tt__CapabilitiesExtension::Display, "tt:DisplayCapabilities"))
				{	soap_flag_Display1--;
					continue;
				}
			}
			if (soap_flag_Recording1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingCapabilities(soap, "tt:Recording", &a->tt__CapabilitiesExtension::Recording, "tt:RecordingCapabilities"))
				{	soap_flag_Recording1--;
					continue;
				}
			}
			if (soap_flag_Search1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SearchCapabilities(soap, "tt:Search", &a->tt__CapabilitiesExtension::Search, "tt:SearchCapabilities"))
				{	soap_flag_Search1--;
					continue;
				}
			}
			if (soap_flag_Replay1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReplayCapabilities(soap, "tt:Replay", &a->tt__CapabilitiesExtension::Replay, "tt:ReplayCapabilities"))
				{	soap_flag_Replay1--;
					continue;
				}
			}
			if (soap_flag_Receiver1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReceiverCapabilities(soap, "tt:Receiver", &a->tt__CapabilitiesExtension::Receiver, "tt:ReceiverCapabilities"))
				{	soap_flag_Receiver1--;
					continue;
				}
			}
			if (soap_flag_AnalyticsDevice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsDeviceCapabilities(soap, "tt:AnalyticsDevice", &a->tt__CapabilitiesExtension::AnalyticsDevice, "tt:AnalyticsDeviceCapabilities"))
				{	soap_flag_AnalyticsDevice1--;
					continue;
				}
			}
			if (soap_flag_Extensions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CapabilitiesExtension2(soap, "tt:Extensions", &a->tt__CapabilitiesExtension::Extensions, "tt:CapabilitiesExtension2"))
				{	soap_flag_Extensions1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__CapabilitiesExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(tt__CapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CapabilitiesExtension *p;
	size_t k = sizeof(tt__CapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CapabilitiesExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CapabilitiesExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CapabilitiesExtension(soap, tag ? tag : "tt:CapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Capabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__Capabilities::Analytics = NULL;
	this->tt__Capabilities::Device = NULL;
	this->tt__Capabilities::Events = NULL;
	this->tt__Capabilities::Imaging = NULL;
	this->tt__Capabilities::Media = NULL;
	this->tt__Capabilities::PTZ = NULL;
	this->tt__Capabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Capabilities::__anyAttribute);
}

void tt__Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsCapabilities(soap, &this->tt__Capabilities::Analytics);
	soap_serialize_PointerTott__DeviceCapabilities(soap, &this->tt__Capabilities::Device);
	soap_serialize_PointerTott__EventCapabilities(soap, &this->tt__Capabilities::Events);
	soap_serialize_PointerTott__ImagingCapabilities(soap, &this->tt__Capabilities::Imaging);
	soap_serialize_PointerTott__MediaCapabilities(soap, &this->tt__Capabilities::Media);
	soap_serialize_PointerTott__PTZCapabilities(soap, &this->tt__Capabilities::PTZ);
	soap_serialize_PointerTott__CapabilitiesExtension(soap, &this->tt__Capabilities::Extension);
#endif
}

int tt__Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Capabilities(struct soap *soap, const char *tag, int id, const tt__Capabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Capabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Capabilities), type))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", -1, &a->tt__Capabilities::Analytics, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilities(soap, "tt:Device", -1, &a->tt__Capabilities::Device, ""))
		return soap->error;
	if (soap_out_PointerTott__EventCapabilities(soap, "tt:Events", -1, &a->tt__Capabilities::Events, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingCapabilities(soap, "tt:Imaging", -1, &a->tt__Capabilities::Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilities(soap, "tt:Media", -1, &a->tt__Capabilities::Media, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZCapabilities(soap, "tt:PTZ", -1, &a->tt__Capabilities::PTZ, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__Capabilities::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__Capabilities * SOAP_FMAC4 soap_in_tt__Capabilities(struct soap *soap, const char *tag, tt__Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Capabilities, sizeof(tt__Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Capabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Analytics1 = 1;
	size_t soap_flag_Device1 = 1;
	size_t soap_flag_Events1 = 1;
	size_t soap_flag_Imaging1 = 1;
	size_t soap_flag_Media1 = 1;
	size_t soap_flag_PTZ1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Analytics1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", &a->tt__Capabilities::Analytics, "tt:AnalyticsCapabilities"))
				{	soap_flag_Analytics1--;
					continue;
				}
			}
			if (soap_flag_Device1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceCapabilities(soap, "tt:Device", &a->tt__Capabilities::Device, "tt:DeviceCapabilities"))
				{	soap_flag_Device1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EventCapabilities(soap, "tt:Events", &a->tt__Capabilities::Events, "tt:EventCapabilities"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap_flag_Imaging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingCapabilities(soap, "tt:Imaging", &a->tt__Capabilities::Imaging, "tt:ImagingCapabilities"))
				{	soap_flag_Imaging1--;
					continue;
				}
			}
			if (soap_flag_Media1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaCapabilities(soap, "tt:Media", &a->tt__Capabilities::Media, "tt:MediaCapabilities"))
				{	soap_flag_Media1--;
					continue;
				}
			}
			if (soap_flag_PTZ1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZCapabilities(soap, "tt:PTZ", &a->tt__Capabilities::PTZ, "tt:PTZCapabilities"))
				{	soap_flag_PTZ1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CapabilitiesExtension(soap, "tt:Extension", &a->tt__Capabilities::Extension, "tt:CapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Capabilities, SOAP_TYPE_tt__Capabilities, sizeof(tt__Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Capabilities * SOAP_FMAC2 soap_instantiate_tt__Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Capabilities *p;
	size_t k = sizeof(tt__Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Capabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Capabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Capabilities(soap, tag ? tag : "tt:Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__Capabilities * SOAP_FMAC4 soap_get_tt__Capabilities(struct soap *soap, tt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11AvailableNetworksExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot11AvailableNetworksExtension::__any);
}

void tt__Dot11AvailableNetworksExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot11AvailableNetworksExtension::__any);
#endif
}

int tt__Dot11AvailableNetworksExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11AvailableNetworksExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, int id, const tt__Dot11AvailableNetworksExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__Dot11AvailableNetworksExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11AvailableNetworksExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11AvailableNetworksExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11AvailableNetworksExtension * SOAP_FMAC4 soap_in_tt__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, tt__Dot11AvailableNetworksExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11AvailableNetworksExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(tt__Dot11AvailableNetworksExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11AvailableNetworksExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11AvailableNetworksExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__Dot11AvailableNetworksExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot11AvailableNetworksExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(tt__Dot11AvailableNetworksExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11AvailableNetworksExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworksExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11AvailableNetworksExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11AvailableNetworksExtension *p;
	size_t k = sizeof(tt__Dot11AvailableNetworksExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11AvailableNetworksExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11AvailableNetworksExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11AvailableNetworksExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11AvailableNetworksExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11AvailableNetworksExtension(soap, tag ? tag : "tt:Dot11AvailableNetworksExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11AvailableNetworksExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11AvailableNetworksExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11AvailableNetworksExtension * SOAP_FMAC4 soap_get_tt__Dot11AvailableNetworksExtension(struct soap *soap, tt__Dot11AvailableNetworksExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AvailableNetworksExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11AvailableNetworks::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &this->tt__Dot11AvailableNetworks::SSID);
	this->tt__Dot11AvailableNetworks::BSSID = NULL;
	soap_default_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, &this->tt__Dot11AvailableNetworks::AuthAndMangementSuite);
	soap_default_std__vectorTemplateOftt__Dot11Cipher(soap, &this->tt__Dot11AvailableNetworks::PairCipher);
	soap_default_std__vectorTemplateOftt__Dot11Cipher(soap, &this->tt__Dot11AvailableNetworks::GroupCipher);
	this->tt__Dot11AvailableNetworks::SignalStrength = NULL;
	this->tt__Dot11AvailableNetworks::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Dot11AvailableNetworks::__anyAttribute);
}

void tt__Dot11AvailableNetworks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &this->tt__Dot11AvailableNetworks::SSID);
	soap_serialize_PointerTostd__string(soap, &this->tt__Dot11AvailableNetworks::BSSID);
	soap_serialize_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, &this->tt__Dot11AvailableNetworks::AuthAndMangementSuite);
	soap_serialize_std__vectorTemplateOftt__Dot11Cipher(soap, &this->tt__Dot11AvailableNetworks::PairCipher);
	soap_serialize_std__vectorTemplateOftt__Dot11Cipher(soap, &this->tt__Dot11AvailableNetworks::GroupCipher);
	soap_serialize_PointerTott__Dot11SignalStrength(soap, &this->tt__Dot11AvailableNetworks::SignalStrength);
	soap_serialize_PointerTott__Dot11AvailableNetworksExtension(soap, &this->tt__Dot11AvailableNetworks::Extension);
#endif
}

int tt__Dot11AvailableNetworks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11AvailableNetworks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, const tt__Dot11AvailableNetworks *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Dot11AvailableNetworks*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AvailableNetworks), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->tt__Dot11AvailableNetworks::SSID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:BSSID", -1, &a->tt__Dot11AvailableNetworks::BSSID, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, "tt:AuthAndMangementSuite", -1, &a->tt__Dot11AvailableNetworks::AuthAndMangementSuite, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Dot11Cipher(soap, "tt:PairCipher", -1, &a->tt__Dot11AvailableNetworks::PairCipher, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Dot11Cipher(soap, "tt:GroupCipher", -1, &a->tt__Dot11AvailableNetworks::GroupCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", -1, &a->tt__Dot11AvailableNetworks::SignalStrength, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11AvailableNetworksExtension(soap, "tt:Extension", -1, &a->tt__Dot11AvailableNetworks::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11AvailableNetworks::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11AvailableNetworks(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_in_tt__Dot11AvailableNetworks(struct soap *soap, const char *tag, tt__Dot11AvailableNetworks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11AvailableNetworks*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(tt__Dot11AvailableNetworks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11AvailableNetworks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11AvailableNetworks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Dot11AvailableNetworks*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SSID1 = 1;
	size_t soap_flag_BSSID1 = 1;
	size_t soap_flag_SignalStrength1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->tt__Dot11AvailableNetworks::SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID1--;
					continue;
				}
			}
			if (soap_flag_BSSID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:BSSID", &a->tt__Dot11AvailableNetworks::BSSID, "xsd:string"))
				{	soap_flag_BSSID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, "tt:AuthAndMangementSuite", &a->tt__Dot11AvailableNetworks::AuthAndMangementSuite, "tt:Dot11AuthAndMangementSuite"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Dot11Cipher(soap, "tt:PairCipher", &a->tt__Dot11AvailableNetworks::PairCipher, "tt:Dot11Cipher"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Dot11Cipher(soap, "tt:GroupCipher", &a->tt__Dot11AvailableNetworks::GroupCipher, "tt:Dot11Cipher"))
					continue;
			}
			if (soap_flag_SignalStrength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", &a->tt__Dot11AvailableNetworks::SignalStrength, "tt:Dot11SignalStrength"))
				{	soap_flag_SignalStrength1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11AvailableNetworksExtension(soap, "tt:Extension", &a->tt__Dot11AvailableNetworks::Extension, "tt:Dot11AvailableNetworksExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11AvailableNetworks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AvailableNetworks, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(tt__Dot11AvailableNetworks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11AvailableNetworks * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11AvailableNetworks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11AvailableNetworks *p;
	size_t k = sizeof(tt__Dot11AvailableNetworks);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11AvailableNetworks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11AvailableNetworks);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11AvailableNetworks, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11AvailableNetworks location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11AvailableNetworks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11AvailableNetworks(soap, tag ? tag : "tt:Dot11AvailableNetworks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11AvailableNetworks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11AvailableNetworks(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_get_tt__Dot11AvailableNetworks(struct soap *soap, tt__Dot11AvailableNetworks *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AvailableNetworks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11Status::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &this->tt__Dot11Status::SSID);
	this->tt__Dot11Status::BSSID = NULL;
	this->tt__Dot11Status::PairCipher = NULL;
	this->tt__Dot11Status::GroupCipher = NULL;
	this->tt__Dot11Status::SignalStrength = NULL;
	soap_default_tt__ReferenceToken(soap, &this->tt__Dot11Status::ActiveConfigAlias);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot11Status::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__Dot11Status::__anyAttribute);
}

void tt__Dot11Status::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &this->tt__Dot11Status::SSID);
	soap_serialize_PointerTostd__string(soap, &this->tt__Dot11Status::BSSID);
	soap_serialize_PointerTott__Dot11Cipher(soap, &this->tt__Dot11Status::PairCipher);
	soap_serialize_PointerTott__Dot11Cipher(soap, &this->tt__Dot11Status::GroupCipher);
	soap_serialize_PointerTott__Dot11SignalStrength(soap, &this->tt__Dot11Status::SignalStrength);
	soap_embedded(soap, &this->tt__Dot11Status::ActiveConfigAlias, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__Dot11Status::ActiveConfigAlias);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot11Status::__any);
#endif
}

int tt__Dot11Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Status(struct soap *soap, const char *tag, int id, const tt__Dot11Status *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Dot11Status*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Status), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->tt__Dot11Status::SSID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:BSSID", -1, &a->tt__Dot11Status::BSSID, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:PairCipher", -1, &a->tt__Dot11Status::PairCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:GroupCipher", -1, &a->tt__Dot11Status::GroupCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", -1, &a->tt__Dot11Status::SignalStrength, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:ActiveConfigAlias", -1, &a->tt__Dot11Status::ActiveConfigAlias, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__Dot11Status::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11Status::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11Status(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11Status * SOAP_FMAC4 soap_in_tt__Dot11Status(struct soap *soap, const char *tag, tt__Dot11Status *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11Status*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Status, sizeof(tt__Dot11Status), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11Status)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11Status *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Dot11Status*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SSID1 = 1;
	size_t soap_flag_BSSID1 = 1;
	size_t soap_flag_PairCipher1 = 1;
	size_t soap_flag_GroupCipher1 = 1;
	size_t soap_flag_SignalStrength1 = 1;
	size_t soap_flag_ActiveConfigAlias1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->tt__Dot11Status::SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID1--;
					continue;
				}
			}
			if (soap_flag_BSSID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:BSSID", &a->tt__Dot11Status::BSSID, "xsd:string"))
				{	soap_flag_BSSID1--;
					continue;
				}
			}
			if (soap_flag_PairCipher1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Cipher(soap, "tt:PairCipher", &a->tt__Dot11Status::PairCipher, "tt:Dot11Cipher"))
				{	soap_flag_PairCipher1--;
					continue;
				}
			}
			if (soap_flag_GroupCipher1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Cipher(soap, "tt:GroupCipher", &a->tt__Dot11Status::GroupCipher, "tt:Dot11Cipher"))
				{	soap_flag_GroupCipher1--;
					continue;
				}
			}
			if (soap_flag_SignalStrength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", &a->tt__Dot11Status::SignalStrength, "tt:Dot11SignalStrength"))
				{	soap_flag_SignalStrength1--;
					continue;
				}
			}
			if (soap_flag_ActiveConfigAlias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:ActiveConfigAlias", &a->tt__Dot11Status::ActiveConfigAlias, "tt:ReferenceToken"))
				{	soap_flag_ActiveConfigAlias1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__Dot11Status::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID1 > 0 || soap_flag_ActiveConfigAlias1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Status, SOAP_TYPE_tt__Dot11Status, sizeof(tt__Dot11Status), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Status * SOAP_FMAC2 soap_instantiate_tt__Dot11Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11Status(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11Status *p;
	size_t k = sizeof(tt__Dot11Status);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11Status, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11Status);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11Status, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11Status location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11Status(soap, tag ? tag : "tt:Dot11Status", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11Status(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11Status * SOAP_FMAC4 soap_get_tt__Dot11Status(struct soap *soap, tt__Dot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11Capabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__Dot11Capabilities::TKIP);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::ScanAvailableNetworks);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::MultipleConfiguration);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::AdHocStationMode);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::WEP);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot11Capabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__Dot11Capabilities::__anyAttribute);
}

void tt__Dot11Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Dot11Capabilities::TKIP, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__Dot11Capabilities::ScanAvailableNetworks, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__Dot11Capabilities::MultipleConfiguration, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__Dot11Capabilities::AdHocStationMode, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__Dot11Capabilities::WEP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot11Capabilities::__any);
#endif
}

int tt__Dot11Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Capabilities(struct soap *soap, const char *tag, int id, const tt__Dot11Capabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Dot11Capabilities*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Capabilities), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:TKIP", -1, &a->tt__Dot11Capabilities::TKIP, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:ScanAvailableNetworks", -1, &a->tt__Dot11Capabilities::ScanAvailableNetworks, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:MultipleConfiguration", -1, &a->tt__Dot11Capabilities::MultipleConfiguration, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AdHocStationMode", -1, &a->tt__Dot11Capabilities::AdHocStationMode, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WEP", -1, &a->tt__Dot11Capabilities::WEP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__Dot11Capabilities::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11Capabilities * SOAP_FMAC4 soap_in_tt__Dot11Capabilities(struct soap *soap, const char *tag, tt__Dot11Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(tt__Dot11Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Dot11Capabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_TKIP1 = 1;
	size_t soap_flag_ScanAvailableNetworks1 = 1;
	size_t soap_flag_MultipleConfiguration1 = 1;
	size_t soap_flag_AdHocStationMode1 = 1;
	size_t soap_flag_WEP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TKIP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:TKIP", &a->tt__Dot11Capabilities::TKIP, "xsd:boolean"))
				{	soap_flag_TKIP1--;
					continue;
				}
			}
			if (soap_flag_ScanAvailableNetworks1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:ScanAvailableNetworks", &a->tt__Dot11Capabilities::ScanAvailableNetworks, "xsd:boolean"))
				{	soap_flag_ScanAvailableNetworks1--;
					continue;
				}
			}
			if (soap_flag_MultipleConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:MultipleConfiguration", &a->tt__Dot11Capabilities::MultipleConfiguration, "xsd:boolean"))
				{	soap_flag_MultipleConfiguration1--;
					continue;
				}
			}
			if (soap_flag_AdHocStationMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AdHocStationMode", &a->tt__Dot11Capabilities::AdHocStationMode, "xsd:boolean"))
				{	soap_flag_AdHocStationMode1--;
					continue;
				}
			}
			if (soap_flag_WEP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:WEP", &a->tt__Dot11Capabilities::WEP, "xsd:boolean"))
				{	soap_flag_WEP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__Dot11Capabilities::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TKIP1 > 0 || soap_flag_ScanAvailableNetworks1 > 0 || soap_flag_MultipleConfiguration1 > 0 || soap_flag_AdHocStationMode1 > 0 || soap_flag_WEP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Capabilities, SOAP_TYPE_tt__Dot11Capabilities, sizeof(tt__Dot11Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Capabilities * SOAP_FMAC2 soap_instantiate_tt__Dot11Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11Capabilities *p;
	size_t k = sizeof(tt__Dot11Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11Capabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11Capabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11Capabilities(soap, tag ? tag : "tt:Dot11Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11Capabilities * SOAP_FMAC4 soap_get_tt__Dot11Capabilities(struct soap *soap, tt__Dot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceSetConfigurationExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkInterfaceSetConfigurationExtension2::__any);
}

void tt__NetworkInterfaceSetConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkInterfaceSetConfigurationExtension2::__any);
#endif
}

int tt__NetworkInterfaceSetConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NetworkInterfaceSetConfigurationExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceSetConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceSetConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(tt__NetworkInterfaceSetConfigurationExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceSetConfigurationExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NetworkInterfaceSetConfigurationExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceSetConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(tt__NetworkInterfaceSetConfigurationExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceSetConfigurationExtension2 *p;
	size_t k = sizeof(tt__NetworkInterfaceSetConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceSetConfigurationExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceSetConfigurationExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceSetConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceSetConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceSetConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceSetConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11PSKSetExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot11PSKSetExtension::__any);
}

void tt__Dot11PSKSetExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot11PSKSetExtension::__any);
#endif
}

int tt__Dot11PSKSetExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11PSKSetExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKSetExtension(struct soap *soap, const char *tag, int id, const tt__Dot11PSKSetExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11PSKSetExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__Dot11PSKSetExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11PSKSetExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11PSKSetExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_in_tt__Dot11PSKSetExtension(struct soap *soap, const char *tag, tt__Dot11PSKSetExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11PSKSetExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(tt__Dot11PSKSetExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11PSKSetExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11PSKSetExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__Dot11PSKSetExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot11PSKSetExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSetExtension, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(tt__Dot11PSKSetExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11PSKSetExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSetExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11PSKSetExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11PSKSetExtension *p;
	size_t k = sizeof(tt__Dot11PSKSetExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11PSKSetExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11PSKSetExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11PSKSetExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11PSKSetExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11PSKSetExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11PSKSetExtension(soap, tag ? tag : "tt:Dot11PSKSetExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11PSKSetExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11PSKSetExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_get_tt__Dot11PSKSetExtension(struct soap *soap, tt__Dot11PSKSetExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKSetExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11PSKSet::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__Dot11PSKSet::Key = NULL;
	this->tt__Dot11PSKSet::Passphrase = NULL;
	this->tt__Dot11PSKSet::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Dot11PSKSet::__anyAttribute);
}

void tt__Dot11PSKSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11PSK(soap, &this->tt__Dot11PSKSet::Key);
	soap_serialize_PointerTott__Dot11PSKPassphrase(soap, &this->tt__Dot11PSKSet::Passphrase);
	soap_serialize_PointerTott__Dot11PSKSetExtension(soap, &this->tt__Dot11PSKSet::Extension);
#endif
}

int tt__Dot11PSKSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11PSKSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKSet(struct soap *soap, const char *tag, int id, const tt__Dot11PSKSet *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Dot11PSKSet*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11PSKSet), type))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSK(soap, "tt:Key", -1, &a->tt__Dot11PSKSet::Key, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKPassphrase(soap, "tt:Passphrase", -1, &a->tt__Dot11PSKSet::Passphrase, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKSetExtension(soap, "tt:Extension", -1, &a->tt__Dot11PSKSet::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11PSKSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11PSKSet(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11PSKSet * SOAP_FMAC4 soap_in_tt__Dot11PSKSet(struct soap *soap, const char *tag, tt__Dot11PSKSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11PSKSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(tt__Dot11PSKSet), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11PSKSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11PSKSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Dot11PSKSet*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Passphrase1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11PSK(soap, "tt:Key", &a->tt__Dot11PSKSet::Key, "tt:Dot11PSK"))
				{	soap_flag_Key1--;
					continue;
				}
			}
			if (soap_flag_Passphrase1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__Dot11PSKPassphrase(soap, "tt:Passphrase", &a->tt__Dot11PSKSet::Passphrase, "tt:Dot11PSKPassphrase"))
				{	soap_flag_Passphrase1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11PSKSetExtension(soap, "tt:Extension", &a->tt__Dot11PSKSet::Extension, "tt:Dot11PSKSetExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot11PSKSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSet, SOAP_TYPE_tt__Dot11PSKSet, sizeof(tt__Dot11PSKSet), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11PSKSet * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11PSKSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11PSKSet *p;
	size_t k = sizeof(tt__Dot11PSKSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11PSKSet, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11PSKSet);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11PSKSet, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11PSKSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11PSKSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11PSKSet(soap, tag ? tag : "tt:Dot11PSKSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11PSKSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11PSKSet(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11PSKSet * SOAP_FMAC4 soap_get_tt__Dot11PSKSet(struct soap *soap, tt__Dot11PSKSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11SecurityConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot11SecurityConfigurationExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__Dot11SecurityConfigurationExtension::__anyAttribute);
}

void tt__Dot11SecurityConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot11SecurityConfigurationExtension::__any);
#endif
}

int tt__Dot11SecurityConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11SecurityConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__Dot11SecurityConfigurationExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Dot11SecurityConfigurationExtension*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__Dot11SecurityConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11SecurityConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_in_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, tt__Dot11SecurityConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11SecurityConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(tt__Dot11SecurityConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11SecurityConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11SecurityConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Dot11SecurityConfigurationExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__Dot11SecurityConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot11SecurityConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(tt__Dot11SecurityConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11SecurityConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11SecurityConfigurationExtension *p;
	size_t k = sizeof(tt__Dot11SecurityConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11SecurityConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11SecurityConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11SecurityConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11SecurityConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11SecurityConfigurationExtension(soap, tag ? tag : "tt:Dot11SecurityConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11SecurityConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11SecurityConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_get_tt__Dot11SecurityConfigurationExtension(struct soap *soap, tt__Dot11SecurityConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11SecurityConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Dot11SecurityMode(soap, &this->tt__Dot11SecurityConfiguration::Mode);
	this->tt__Dot11SecurityConfiguration::Algorithm = NULL;
	this->tt__Dot11SecurityConfiguration::PSK = NULL;
	this->tt__Dot11SecurityConfiguration::Dot1X = NULL;
	this->tt__Dot11SecurityConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Dot11SecurityConfiguration::__anyAttribute);
}

void tt__Dot11SecurityConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Cipher(soap, &this->tt__Dot11SecurityConfiguration::Algorithm);
	soap_serialize_PointerTott__Dot11PSKSet(soap, &this->tt__Dot11SecurityConfiguration::PSK);
	soap_serialize_PointerTott__ReferenceToken(soap, &this->tt__Dot11SecurityConfiguration::Dot1X);
	soap_serialize_PointerTott__Dot11SecurityConfigurationExtension(soap, &this->tt__Dot11SecurityConfiguration::Extension);
#endif
}

int tt__Dot11SecurityConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11SecurityConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityConfiguration(struct soap *soap, const char *tag, int id, const tt__Dot11SecurityConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Dot11SecurityConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration), type))
		return soap->error;
	if (soap_out_tt__Dot11SecurityMode(soap, "tt:Mode", -1, &a->tt__Dot11SecurityConfiguration::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:Algorithm", -1, &a->tt__Dot11SecurityConfiguration::Algorithm, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKSet(soap, "tt:PSK", -1, &a->tt__Dot11SecurityConfiguration::PSK, ""))
		return soap->error;
	if (soap_out_PointerTott__ReferenceToken(soap, "tt:Dot1X", -1, &a->tt__Dot11SecurityConfiguration::Dot1X, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SecurityConfigurationExtension(soap, "tt:Extension", -1, &a->tt__Dot11SecurityConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11SecurityConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11SecurityConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_in_tt__Dot11SecurityConfiguration(struct soap *soap, const char *tag, tt__Dot11SecurityConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11SecurityConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(tt__Dot11SecurityConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11SecurityConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11SecurityConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Dot11SecurityConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Algorithm1 = 1;
	size_t soap_flag_PSK1 = 1;
	size_t soap_flag_Dot1X1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SecurityMode(soap, "tt:Mode", &a->tt__Dot11SecurityConfiguration::Mode, "tt:Dot11SecurityMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Algorithm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Cipher(soap, "tt:Algorithm", &a->tt__Dot11SecurityConfiguration::Algorithm, "tt:Dot11Cipher"))
				{	soap_flag_Algorithm1--;
					continue;
				}
			}
			if (soap_flag_PSK1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11PSKSet(soap, "tt:PSK", &a->tt__Dot11SecurityConfiguration::PSK, "tt:Dot11PSKSet"))
				{	soap_flag_PSK1--;
					continue;
				}
			}
			if (soap_flag_Dot1X1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__ReferenceToken(soap, "tt:Dot1X", &a->tt__Dot11SecurityConfiguration::Dot1X, "tt:ReferenceToken"))
				{	soap_flag_Dot1X1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SecurityConfigurationExtension(soap, "tt:Extension", &a->tt__Dot11SecurityConfiguration::Extension, "tt:Dot11SecurityConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11SecurityConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfiguration, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(tt__Dot11SecurityConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11SecurityConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11SecurityConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11SecurityConfiguration *p;
	size_t k = sizeof(tt__Dot11SecurityConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11SecurityConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11SecurityConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11SecurityConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11SecurityConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11SecurityConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11SecurityConfiguration(soap, tag ? tag : "tt:Dot11SecurityConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11SecurityConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11SecurityConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_get_tt__Dot11SecurityConfiguration(struct soap *soap, tt__Dot11SecurityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11Configuration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &this->tt__Dot11Configuration::SSID);
	soap_default_tt__Dot11StationMode(soap, &this->tt__Dot11Configuration::Mode);
	soap_default_tt__Name(soap, &this->tt__Dot11Configuration::Alias);
	soap_default_tt__NetworkInterfaceConfigPriority(soap, &this->tt__Dot11Configuration::Priority);
	this->tt__Dot11Configuration::Security = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot11Configuration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__Dot11Configuration::__anyAttribute);
}

void tt__Dot11Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &this->tt__Dot11Configuration::SSID);
	soap_embedded(soap, &this->tt__Dot11Configuration::Alias, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__Dot11Configuration::Alias);
	soap_serialize_tt__NetworkInterfaceConfigPriority(soap, &this->tt__Dot11Configuration::Priority);
	soap_serialize_PointerTott__Dot11SecurityConfiguration(soap, &this->tt__Dot11Configuration::Security);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot11Configuration::__any);
#endif
}

int tt__Dot11Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Configuration(struct soap *soap, const char *tag, int id, const tt__Dot11Configuration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Dot11Configuration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Configuration), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->tt__Dot11Configuration::SSID, ""))
		return soap->error;
	if (soap_out_tt__Dot11StationMode(soap, "tt:Mode", -1, &a->tt__Dot11Configuration::Mode, ""))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Alias", -1, &a->tt__Dot11Configuration::Alias, ""))
		return soap->error;
	if (soap_out_tt__NetworkInterfaceConfigPriority(soap, "tt:Priority", -1, &a->tt__Dot11Configuration::Priority, ""))
		return soap->error;
	if (!a->tt__Dot11Configuration::Security)
	{	if (soap_element_empty(soap, "tt:Security"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot11SecurityConfiguration(soap, "tt:Security", -1, &a->tt__Dot11Configuration::Security, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__Dot11Configuration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11Configuration * SOAP_FMAC4 soap_in_tt__Dot11Configuration(struct soap *soap, const char *tag, tt__Dot11Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Configuration, sizeof(tt__Dot11Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Dot11Configuration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SSID1 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Alias1 = 1;
	size_t soap_flag_Priority1 = 1;
	size_t soap_flag_Security1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->tt__Dot11Configuration::SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID1--;
					continue;
				}
			}
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11StationMode(soap, "tt:Mode", &a->tt__Dot11Configuration::Mode, "tt:Dot11StationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Alias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Alias", &a->tt__Dot11Configuration::Alias, "tt:Name"))
				{	soap_flag_Alias1--;
					continue;
				}
			}
			if (soap_flag_Priority1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__NetworkInterfaceConfigPriority(soap, "tt:Priority", &a->tt__Dot11Configuration::Priority, "tt:NetworkInterfaceConfigPriority"))
				{	soap_flag_Priority1--;
					continue;
				}
			}
			if (soap_flag_Security1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SecurityConfiguration(soap, "tt:Security", &a->tt__Dot11Configuration::Security, "tt:Dot11SecurityConfiguration"))
				{	soap_flag_Security1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__Dot11Configuration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID1 > 0 || soap_flag_Mode1 > 0 || soap_flag_Alias1 > 0 || soap_flag_Priority1 > 0 || !a->tt__Dot11Configuration::Security))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Configuration, SOAP_TYPE_tt__Dot11Configuration, sizeof(tt__Dot11Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot11Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11Configuration *p;
	size_t k = sizeof(tt__Dot11Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11Configuration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11Configuration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11Configuration(soap, tag ? tag : "tt:Dot11Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11Configuration * SOAP_FMAC4 soap_get_tt__Dot11Configuration(struct soap *soap, tt__Dot11Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPAddressFilterExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IPAddressFilterExtension::__any);
}

void tt__IPAddressFilterExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IPAddressFilterExtension::__any);
#endif
}

int tt__IPAddressFilterExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddressFilterExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, const tt__IPAddressFilterExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilterExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__IPAddressFilterExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPAddressFilterExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPAddressFilterExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddressFilterExtension * SOAP_FMAC4 soap_in_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, tt__IPAddressFilterExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPAddressFilterExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(tt__IPAddressFilterExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPAddressFilterExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPAddressFilterExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__IPAddressFilterExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPAddressFilterExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterExtension, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(tt__IPAddressFilterExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPAddressFilterExtension * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilterExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddressFilterExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPAddressFilterExtension *p;
	size_t k = sizeof(tt__IPAddressFilterExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPAddressFilterExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPAddressFilterExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPAddressFilterExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPAddressFilterExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPAddressFilterExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPAddressFilterExtension(soap, tag ? tag : "tt:IPAddressFilterExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddressFilterExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddressFilterExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddressFilterExtension * SOAP_FMAC4 soap_get_tt__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPAddressFilter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__IPAddressFilterType(soap, &this->tt__IPAddressFilter::Type);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPAddressFilter::IPv4Address);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPAddressFilter::IPv6Address);
	this->tt__IPAddressFilter::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__IPAddressFilter::__anyAttribute);
}

void tt__IPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPAddressFilter::IPv4Address);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPAddressFilter::IPv6Address);
	soap_serialize_PointerTott__IPAddressFilterExtension(soap, &this->tt__IPAddressFilter::Extension);
#endif
}

int tt__IPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilter(struct soap *soap, const char *tag, int id, const tt__IPAddressFilter *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__IPAddressFilter*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilter), type))
		return soap->error;
	if (soap_out_tt__IPAddressFilterType(soap, "tt:Type", -1, &a->tt__IPAddressFilter::Type, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:IPv4Address", -1, &a->tt__IPAddressFilter::IPv4Address, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:IPv6Address", -1, &a->tt__IPAddressFilter::IPv6Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", -1, &a->tt__IPAddressFilter::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddressFilter * SOAP_FMAC4 soap_in_tt__IPAddressFilter(struct soap *soap, const char *tag, tt__IPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilter, sizeof(tt__IPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__IPAddressFilter*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPAddressFilterType(soap, "tt:Type", &a->tt__IPAddressFilter::Type, "tt:IPAddressFilterType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:IPv4Address", &a->tt__IPAddressFilter::IPv4Address, "tt:PrefixedIPv4Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:IPv6Address", &a->tt__IPAddressFilter::IPv6Address, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", &a->tt__IPAddressFilter::Extension, "tt:IPAddressFilterExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilter, SOAP_TYPE_tt__IPAddressFilter, sizeof(tt__IPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPAddressFilter * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPAddressFilter *p;
	size_t k = sizeof(tt__IPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPAddressFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPAddressFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPAddressFilter(soap, tag ? tag : "tt:IPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddressFilter * SOAP_FMAC4 soap_get_tt__IPAddressFilter(struct soap *soap, tt__IPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkZeroConfigurationExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkZeroConfigurationExtension2::__any);
}

void tt__NetworkZeroConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkZeroConfigurationExtension2::__any);
#endif
}

int tt__NetworkZeroConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkZeroConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__NetworkZeroConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NetworkZeroConfigurationExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkZeroConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkZeroConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, tt__NetworkZeroConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkZeroConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(tt__NetworkZeroConfigurationExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkZeroConfigurationExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkZeroConfigurationExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NetworkZeroConfigurationExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkZeroConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(tt__NetworkZeroConfigurationExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkZeroConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkZeroConfigurationExtension2 *p;
	size_t k = sizeof(tt__NetworkZeroConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkZeroConfigurationExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkZeroConfigurationExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkZeroConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkZeroConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkZeroConfigurationExtension2(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkZeroConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkZeroConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__NetworkZeroConfigurationExtension2(struct soap *soap, tt__NetworkZeroConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkZeroConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkZeroConfigurationExtension::__any);
	soap_default_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, &this->tt__NetworkZeroConfigurationExtension::Additional);
	this->tt__NetworkZeroConfigurationExtension::Extension = NULL;
}

void tt__NetworkZeroConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkZeroConfigurationExtension::__any);
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, &this->tt__NetworkZeroConfigurationExtension::Additional);
	soap_serialize_PointerTott__NetworkZeroConfigurationExtension2(soap, &this->tt__NetworkZeroConfigurationExtension::Extension);
#endif
}

int tt__NetworkZeroConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkZeroConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__NetworkZeroConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NetworkZeroConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, "tt:Additional", -1, &a->tt__NetworkZeroConfigurationExtension::Additional, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__NetworkZeroConfigurationExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkZeroConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkZeroConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkZeroConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(tt__NetworkZeroConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkZeroConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkZeroConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, "tt:Additional", &a->tt__NetworkZeroConfigurationExtension::Additional, "tt:NetworkZeroConfiguration"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkZeroConfigurationExtension2(soap, "tt:Extension", &a->tt__NetworkZeroConfigurationExtension::Extension, "tt:NetworkZeroConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NetworkZeroConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkZeroConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(tt__NetworkZeroConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkZeroConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkZeroConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkZeroConfigurationExtension *p;
	size_t k = sizeof(tt__NetworkZeroConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkZeroConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkZeroConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkZeroConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkZeroConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkZeroConfigurationExtension(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkZeroConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkZeroConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkZeroConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &this->tt__NetworkZeroConfiguration::InterfaceToken);
	soap_default_bool(soap, &this->tt__NetworkZeroConfiguration::Enabled);
	soap_default_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkZeroConfiguration::Addresses);
	this->tt__NetworkZeroConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NetworkZeroConfiguration::__anyAttribute);
}

void tt__NetworkZeroConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NetworkZeroConfiguration::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__NetworkZeroConfiguration::InterfaceToken);
	soap_embedded(soap, &this->tt__NetworkZeroConfiguration::Enabled, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkZeroConfiguration::Addresses);
	soap_serialize_PointerTott__NetworkZeroConfigurationExtension(soap, &this->tt__NetworkZeroConfiguration::Extension);
#endif
}

int tt__NetworkZeroConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkZeroConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, const tt__NetworkZeroConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NetworkZeroConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:InterfaceToken", -1, &a->tt__NetworkZeroConfiguration::InterfaceToken, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__NetworkZeroConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv4Address(soap, "tt:Addresses", -1, &a->tt__NetworkZeroConfiguration::Addresses, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", -1, &a->tt__NetworkZeroConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkZeroConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkZeroConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_in_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, tt__NetworkZeroConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkZeroConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkZeroConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkZeroConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NetworkZeroConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_InterfaceToken1 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:InterfaceToken", &a->tt__NetworkZeroConfiguration::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__NetworkZeroConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv4Address(soap, "tt:Addresses", &a->tt__NetworkZeroConfiguration::Addresses, "tt:IPv4Address"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", &a->tt__NetworkZeroConfiguration::Extension, "tt:NetworkZeroConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0 || soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfiguration, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkZeroConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkZeroConfiguration *p;
	size_t k = sizeof(tt__NetworkZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkZeroConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkZeroConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkZeroConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkZeroConfiguration(soap, tag ? tag : "tt:NetworkZeroConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkZeroConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkZeroConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_get_tt__NetworkZeroConfiguration(struct soap *soap, tt__NetworkZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkGateway::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkGateway::IPv4Address);
	soap_default_std__vectorTemplateOftt__IPv6Address(soap, &this->tt__NetworkGateway::IPv6Address);
}

void tt__NetworkGateway::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkGateway::IPv4Address);
	soap_serialize_std__vectorTemplateOftt__IPv6Address(soap, &this->tt__NetworkGateway::IPv6Address);
#endif
}

int tt__NetworkGateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkGateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkGateway(struct soap *soap, const char *tag, int id, const tt__NetworkGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkGateway), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv4Address(soap, "tt:IPv4Address", -1, &a->tt__NetworkGateway::IPv4Address, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv6Address(soap, "tt:IPv6Address", -1, &a->tt__NetworkGateway::IPv6Address, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkGateway::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkGateway(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkGateway * SOAP_FMAC4 soap_in_tt__NetworkGateway(struct soap *soap, const char *tag, tt__NetworkGateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkGateway*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkGateway, sizeof(tt__NetworkGateway), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkGateway)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkGateway *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv4Address(soap, "tt:IPv4Address", &a->tt__NetworkGateway::IPv4Address, "tt:IPv4Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv6Address(soap, "tt:IPv6Address", &a->tt__NetworkGateway::IPv6Address, "tt:IPv6Address"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkGateway, SOAP_TYPE_tt__NetworkGateway, sizeof(tt__NetworkGateway), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkGateway * SOAP_FMAC2 soap_instantiate_tt__NetworkGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkGateway *p;
	size_t k = sizeof(tt__NetworkGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkGateway);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkGateway, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkGateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkGateway(soap, tag ? tag : "tt:NetworkGateway", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkGateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkGateway(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkGateway * SOAP_FMAC4 soap_get_tt__NetworkGateway(struct soap *soap, tt__NetworkGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv4NetworkInterfaceSetConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__IPv4NetworkInterfaceSetConfiguration::Enabled = NULL;
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::Manual);
	this->tt__IPv4NetworkInterfaceSetConfiguration::DHCP = NULL;
}

void tt__IPv4NetworkInterfaceSetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::Enabled);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::Manual);
	soap_serialize_PointerTobool(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::DHCP);
#endif
}

int tt__IPv4NetworkInterfaceSetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Enabled", -1, &a->tt__IPv4NetworkInterfaceSetConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", -1, &a->tt__IPv4NetworkInterfaceSetConfiguration::Manual, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:DHCP", -1, &a->tt__IPv4NetworkInterfaceSetConfiguration::DHCP, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv4NetworkInterfaceSetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv4NetworkInterfaceSetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(tt__IPv4NetworkInterfaceSetConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv4NetworkInterfaceSetConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_DHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Enabled", &a->tt__IPv4NetworkInterfaceSetConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", &a->tt__IPv4NetworkInterfaceSetConfiguration::Manual, "tt:PrefixedIPv4Address"))
					continue;
			}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:DHCP", &a->tt__IPv4NetworkInterfaceSetConfiguration::DHCP, "xsd:boolean"))
				{	soap_flag_DHCP1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv4NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(tt__IPv4NetworkInterfaceSetConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv4NetworkInterfaceSetConfiguration *p;
	size_t k = sizeof(tt__IPv4NetworkInterfaceSetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv4NetworkInterfaceSetConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv4NetworkInterfaceSetConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv4NetworkInterfaceSetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv4NetworkInterfaceSetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv4NetworkInterfaceSetConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4NetworkInterfaceSetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4NetworkInterfaceSetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6NetworkInterfaceSetConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__IPv6NetworkInterfaceSetConfiguration::Enabled = NULL;
	this->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert = NULL;
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::Manual);
	this->tt__IPv6NetworkInterfaceSetConfiguration::DHCP = NULL;
}

void tt__IPv6NetworkInterfaceSetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::Enabled);
	soap_serialize_PointerTobool(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::Manual);
	soap_serialize_PointerTott__IPv6DHCPConfiguration(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::DHCP);
#endif
}

int tt__IPv6NetworkInterfaceSetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Enabled", -1, &a->tt__IPv6NetworkInterfaceSetConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:AcceptRouterAdvert", -1, &a->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", -1, &a->tt__IPv6NetworkInterfaceSetConfiguration::Manual, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &a->tt__IPv6NetworkInterfaceSetConfiguration::DHCP, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6NetworkInterfaceSetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6NetworkInterfaceSetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(tt__IPv6NetworkInterfaceSetConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv6NetworkInterfaceSetConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_AcceptRouterAdvert1 = 1;
	size_t soap_flag_DHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Enabled", &a->tt__IPv6NetworkInterfaceSetConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_AcceptRouterAdvert1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:AcceptRouterAdvert", &a->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert, "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", &a->tt__IPv6NetworkInterfaceSetConfiguration::Manual, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", &a->tt__IPv6NetworkInterfaceSetConfiguration::DHCP, "tt:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv6NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(tt__IPv6NetworkInterfaceSetConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6NetworkInterfaceSetConfiguration *p;
	size_t k = sizeof(tt__IPv6NetworkInterfaceSetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6NetworkInterfaceSetConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6NetworkInterfaceSetConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6NetworkInterfaceSetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6NetworkInterfaceSetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv6NetworkInterfaceSetConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6NetworkInterfaceSetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6NetworkInterfaceSetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceSetConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::__any);
	soap_default_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Dot3);
	soap_default_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Dot11);
	this->tt__NetworkInterfaceSetConfigurationExtension::Extension = NULL;
}

void tt__NetworkInterfaceSetConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::__any);
	soap_serialize_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Dot3);
	soap_serialize_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Dot11);
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Extension);
#endif
}

int tt__NetworkInterfaceSetConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NetworkInterfaceSetConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, "tt:Dot3", -1, &a->tt__NetworkInterfaceSetConfigurationExtension::Dot3, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, "tt:Dot11", -1, &a->tt__NetworkInterfaceSetConfigurationExtension::Dot11, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__NetworkInterfaceSetConfigurationExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceSetConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceSetConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(tt__NetworkInterfaceSetConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceSetConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, "tt:Dot3", &a->tt__NetworkInterfaceSetConfigurationExtension::Dot3, "tt:Dot3Configuration"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, "tt:Dot11", &a->tt__NetworkInterfaceSetConfigurationExtension::Dot11, "tt:Dot11Configuration"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, "tt:Extension", &a->tt__NetworkInterfaceSetConfigurationExtension::Extension, "tt:NetworkInterfaceSetConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NetworkInterfaceSetConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceSetConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(tt__NetworkInterfaceSetConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceSetConfigurationExtension *p;
	size_t k = sizeof(tt__NetworkInterfaceSetConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceSetConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceSetConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceSetConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceSetConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceSetConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceSetConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceSetConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__NetworkInterfaceSetConfiguration::Enabled = NULL;
	this->tt__NetworkInterfaceSetConfiguration::Link = NULL;
	this->tt__NetworkInterfaceSetConfiguration::MTU = NULL;
	this->tt__NetworkInterfaceSetConfiguration::IPv4 = NULL;
	this->tt__NetworkInterfaceSetConfiguration::IPv6 = NULL;
	this->tt__NetworkInterfaceSetConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NetworkInterfaceSetConfiguration::__anyAttribute);
}

void tt__NetworkInterfaceSetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__NetworkInterfaceSetConfiguration::Enabled);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &this->tt__NetworkInterfaceSetConfiguration::Link);
	soap_serialize_PointerToint(soap, &this->tt__NetworkInterfaceSetConfiguration::MTU);
	soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, &this->tt__NetworkInterfaceSetConfiguration::IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, &this->tt__NetworkInterfaceSetConfiguration::IPv6);
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, &this->tt__NetworkInterfaceSetConfiguration::Extension);
#endif
}

int tt__NetworkInterfaceSetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NetworkInterfaceSetConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Enabled", -1, &a->tt__NetworkInterfaceSetConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", -1, &a->tt__NetworkInterfaceSetConfiguration::Link, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->tt__NetworkInterfaceSetConfiguration::MTU, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", -1, &a->tt__NetworkInterfaceSetConfiguration::IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", -1, &a->tt__NetworkInterfaceSetConfiguration::IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", -1, &a->tt__NetworkInterfaceSetConfiguration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceSetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceSetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(tt__NetworkInterfaceSetConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceSetConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceSetConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NetworkInterfaceSetConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Link1 = 1;
	size_t soap_flag_MTU1 = 1;
	size_t soap_flag_IPv41 = 1;
	size_t soap_flag_IPv61 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Enabled", &a->tt__NetworkInterfaceSetConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Link1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", &a->tt__NetworkInterfaceSetConfiguration::Link, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_Link1--;
					continue;
				}
			}
			if (soap_flag_MTU1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:MTU", &a->tt__NetworkInterfaceSetConfiguration::MTU, "xsd:int"))
				{	soap_flag_MTU1--;
					continue;
				}
			}
			if (soap_flag_IPv41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", &a->tt__NetworkInterfaceSetConfiguration::IPv4, "tt:IPv4NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv41--;
					continue;
				}
			}
			if (soap_flag_IPv61 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", &a->tt__NetworkInterfaceSetConfiguration::IPv6, "tt:IPv6NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv61--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", &a->tt__NetworkInterfaceSetConfiguration::Extension, "tt:NetworkInterfaceSetConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(tt__NetworkInterfaceSetConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceSetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceSetConfiguration *p;
	size_t k = sizeof(tt__NetworkInterfaceSetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceSetConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceSetConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceSetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceSetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:NetworkInterfaceSetConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceSetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceSetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfiguration(struct soap *soap, tt__NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DynamicDNSInformationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DynamicDNSInformationExtension::__any);
}

void tt__DynamicDNSInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DynamicDNSInformationExtension::__any);
#endif
}

int tt__DynamicDNSInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DynamicDNSInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, const tt__DynamicDNSInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__DynamicDNSInformationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DynamicDNSInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DynamicDNSInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_in_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, tt__DynamicDNSInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DynamicDNSInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(tt__DynamicDNSInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DynamicDNSInformationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DynamicDNSInformationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__DynamicDNSInformationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DynamicDNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformationExtension, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(tt__DynamicDNSInformationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DynamicDNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DynamicDNSInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DynamicDNSInformationExtension *p;
	size_t k = sizeof(tt__DynamicDNSInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DynamicDNSInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DynamicDNSInformationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DynamicDNSInformationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DynamicDNSInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DynamicDNSInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DynamicDNSInformationExtension(soap, tag ? tag : "tt:DynamicDNSInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DynamicDNSInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DynamicDNSInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_get_tt__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DynamicDNSInformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__DynamicDNSType(soap, &this->tt__DynamicDNSInformation::Type);
	this->tt__DynamicDNSInformation::Name = NULL;
	this->tt__DynamicDNSInformation::TTL = NULL;
	this->tt__DynamicDNSInformation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__DynamicDNSInformation::__anyAttribute);
}

void tt__DynamicDNSInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DNSName(soap, &this->tt__DynamicDNSInformation::Name);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__DynamicDNSInformation::TTL);
	soap_serialize_PointerTott__DynamicDNSInformationExtension(soap, &this->tt__DynamicDNSInformation::Extension);
#endif
}

int tt__DynamicDNSInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DynamicDNSInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformation(struct soap *soap, const char *tag, int id, const tt__DynamicDNSInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__DynamicDNSInformation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformation), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tt:Type", -1, &a->tt__DynamicDNSInformation::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tt:Name", -1, &a->tt__DynamicDNSInformation::Name, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:TTL", -1, &a->tt__DynamicDNSInformation::TTL, ""))
		return soap->error;
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", -1, &a->tt__DynamicDNSInformation::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DynamicDNSInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DynamicDNSInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__DynamicDNSInformation * SOAP_FMAC4 soap_in_tt__DynamicDNSInformation(struct soap *soap, const char *tag, tt__DynamicDNSInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DynamicDNSInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(tt__DynamicDNSInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DynamicDNSInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DynamicDNSInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__DynamicDNSInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_TTL1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DynamicDNSType(soap, "tt:Type", &a->tt__DynamicDNSInformation::Type, "tt:DynamicDNSType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__DNSName(soap, "tt:Name", &a->tt__DynamicDNSInformation::Name, "tt:DNSName"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_TTL1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__duration(soap, "tt:TTL", &a->tt__DynamicDNSInformation::TTL, "xsd:duration"))
				{	soap_flag_TTL1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", &a->tt__DynamicDNSInformation::Extension, "tt:DynamicDNSInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DynamicDNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformation, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(tt__DynamicDNSInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DynamicDNSInformation * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DynamicDNSInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DynamicDNSInformation *p;
	size_t k = sizeof(tt__DynamicDNSInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DynamicDNSInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DynamicDNSInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DynamicDNSInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DynamicDNSInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DynamicDNSInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DynamicDNSInformation(soap, tag ? tag : "tt:DynamicDNSInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DynamicDNSInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DynamicDNSInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__DynamicDNSInformation * SOAP_FMAC4 soap_get_tt__DynamicDNSInformation(struct soap *soap, tt__DynamicDNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NTPInformationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NTPInformationExtension::__any);
}

void tt__NTPInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NTPInformationExtension::__any);
#endif
}

int tt__NTPInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NTPInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformationExtension(struct soap *soap, const char *tag, int id, const tt__NTPInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NTPInformationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NTPInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NTPInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NTPInformationExtension * SOAP_FMAC4 soap_in_tt__NTPInformationExtension(struct soap *soap, const char *tag, tt__NTPInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NTPInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(tt__NTPInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NTPInformationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NTPInformationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NTPInformationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NTPInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformationExtension, SOAP_TYPE_tt__NTPInformationExtension, sizeof(tt__NTPInformationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NTPInformationExtension * SOAP_FMAC2 soap_instantiate_tt__NTPInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NTPInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NTPInformationExtension *p;
	size_t k = sizeof(tt__NTPInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NTPInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NTPInformationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NTPInformationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NTPInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NTPInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NTPInformationExtension(soap, tag ? tag : "tt:NTPInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NTPInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NTPInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NTPInformationExtension * SOAP_FMAC4 soap_get_tt__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NTPInformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__NTPInformation::FromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPFromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPManual);
	this->tt__NTPInformation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NTPInformation::__anyAttribute);
}

void tt__NTPInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NTPInformation::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPFromDHCP);
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPManual);
	soap_serialize_PointerTott__NTPInformationExtension(soap, &this->tt__NTPInformation::Extension);
#endif
}

int tt__NTPInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NTPInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformation(struct soap *soap, const char *tag, int id, const tt__NTPInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NTPInformation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformation), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:FromDHCP", -1, &a->tt__NTPInformation::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPFromDHCP", -1, &a->tt__NTPInformation::NTPFromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPManual", -1, &a->tt__NTPInformation::NTPManual, ""))
		return soap->error;
	if (soap_out_PointerTott__NTPInformationExtension(soap, "tt:Extension", -1, &a->tt__NTPInformation::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NTPInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NTPInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__NTPInformation * SOAP_FMAC4 soap_in_tt__NTPInformation(struct soap *soap, const char *tag, tt__NTPInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NTPInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformation, sizeof(tt__NTPInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NTPInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NTPInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NTPInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FromDHCP", &a->tt__NTPInformation::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPFromDHCP", &a->tt__NTPInformation::NTPFromDHCP, "tt:NetworkHost"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPManual", &a->tt__NTPInformation::NTPManual, "tt:NetworkHost"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NTPInformationExtension(soap, "tt:Extension", &a->tt__NTPInformation::Extension, "tt:NTPInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NTPInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformation, SOAP_TYPE_tt__NTPInformation, sizeof(tt__NTPInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NTPInformation * SOAP_FMAC2 soap_instantiate_tt__NTPInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NTPInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NTPInformation *p;
	size_t k = sizeof(tt__NTPInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NTPInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NTPInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NTPInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NTPInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NTPInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NTPInformation(soap, tag ? tag : "tt:NTPInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NTPInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NTPInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__NTPInformation * SOAP_FMAC4 soap_get_tt__NTPInformation(struct soap *soap, tt__NTPInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DNSInformationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DNSInformationExtension::__any);
}

void tt__DNSInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DNSInformationExtension::__any);
#endif
}

int tt__DNSInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DNSInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformationExtension(struct soap *soap, const char *tag, int id, const tt__DNSInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__DNSInformationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DNSInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DNSInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DNSInformationExtension * SOAP_FMAC4 soap_in_tt__DNSInformationExtension(struct soap *soap, const char *tag, tt__DNSInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DNSInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(tt__DNSInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DNSInformationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DNSInformationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__DNSInformationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformationExtension, SOAP_TYPE_tt__DNSInformationExtension, sizeof(tt__DNSInformationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DNSInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DNSInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DNSInformationExtension *p;
	size_t k = sizeof(tt__DNSInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DNSInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DNSInformationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DNSInformationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DNSInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DNSInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DNSInformationExtension(soap, tag ? tag : "tt:DNSInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DNSInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DNSInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DNSInformationExtension * SOAP_FMAC4 soap_get_tt__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DNSInformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__DNSInformation::FromDHCP);
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->tt__DNSInformation::SearchDomain);
	soap_default_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSFromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSManual);
	this->tt__DNSInformation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__DNSInformation::__anyAttribute);
}

void tt__DNSInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DNSInformation::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->tt__DNSInformation::SearchDomain);
	soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSFromDHCP);
	soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSManual);
	soap_serialize_PointerTott__DNSInformationExtension(soap, &this->tt__DNSInformation::Extension);
#endif
}

int tt__DNSInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DNSInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformation(struct soap *soap, const char *tag, int id, const tt__DNSInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__DNSInformation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformation), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:FromDHCP", -1, &a->tt__DNSInformation::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tt:SearchDomain", -1, &a->tt__DNSInformation::SearchDomain, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSFromDHCP", -1, &a->tt__DNSInformation::DNSFromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSManual", -1, &a->tt__DNSInformation::DNSManual, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSInformationExtension(soap, "tt:Extension", -1, &a->tt__DNSInformation::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DNSInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DNSInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__DNSInformation * SOAP_FMAC4 soap_in_tt__DNSInformation(struct soap *soap, const char *tag, tt__DNSInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DNSInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformation, sizeof(tt__DNSInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DNSInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DNSInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__DNSInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FromDHCP", &a->tt__DNSInformation::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__token(soap, "tt:SearchDomain", &a->tt__DNSInformation::SearchDomain, "xsd:token"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSFromDHCP", &a->tt__DNSInformation::DNSFromDHCP, "tt:IPAddress"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSManual", &a->tt__DNSInformation::DNSManual, "tt:IPAddress"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DNSInformationExtension(soap, "tt:Extension", &a->tt__DNSInformation::Extension, "tt:DNSInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformation, SOAP_TYPE_tt__DNSInformation, sizeof(tt__DNSInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DNSInformation * SOAP_FMAC2 soap_instantiate_tt__DNSInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DNSInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DNSInformation *p;
	size_t k = sizeof(tt__DNSInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DNSInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DNSInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DNSInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DNSInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DNSInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DNSInformation(soap, tag ? tag : "tt:DNSInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DNSInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DNSInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__DNSInformation * SOAP_FMAC4 soap_get_tt__DNSInformation(struct soap *soap, tt__DNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__HostnameInformationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__HostnameInformationExtension::__any);
}

void tt__HostnameInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__HostnameInformationExtension::__any);
#endif
}

int tt__HostnameInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__HostnameInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformationExtension(struct soap *soap, const char *tag, int id, const tt__HostnameInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__HostnameInformationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__HostnameInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__HostnameInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__HostnameInformationExtension * SOAP_FMAC4 soap_in_tt__HostnameInformationExtension(struct soap *soap, const char *tag, tt__HostnameInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__HostnameInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(tt__HostnameInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__HostnameInformationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__HostnameInformationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__HostnameInformationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__HostnameInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformationExtension, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(tt__HostnameInformationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__HostnameInformationExtension * SOAP_FMAC2 soap_instantiate_tt__HostnameInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__HostnameInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__HostnameInformationExtension *p;
	size_t k = sizeof(tt__HostnameInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__HostnameInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__HostnameInformationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__HostnameInformationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__HostnameInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__HostnameInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__HostnameInformationExtension(soap, tag ? tag : "tt:HostnameInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__HostnameInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__HostnameInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__HostnameInformationExtension * SOAP_FMAC4 soap_get_tt__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__HostnameInformation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__HostnameInformation::FromDHCP);
	this->tt__HostnameInformation::Name = NULL;
	this->tt__HostnameInformation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__HostnameInformation::__anyAttribute);
}

void tt__HostnameInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__HostnameInformation::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_PointerToxsd__token(soap, &this->tt__HostnameInformation::Name);
	soap_serialize_PointerTott__HostnameInformationExtension(soap, &this->tt__HostnameInformation::Extension);
#endif
}

int tt__HostnameInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__HostnameInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformation(struct soap *soap, const char *tag, int id, const tt__HostnameInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__HostnameInformation*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformation), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:FromDHCP", -1, &a->tt__HostnameInformation::FromDHCP, ""))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:Name", -1, &a->tt__HostnameInformation::Name, ""))
		return soap->error;
	if (soap_out_PointerTott__HostnameInformationExtension(soap, "tt:Extension", -1, &a->tt__HostnameInformation::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__HostnameInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__HostnameInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__HostnameInformation * SOAP_FMAC4 soap_in_tt__HostnameInformation(struct soap *soap, const char *tag, tt__HostnameInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__HostnameInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformation, sizeof(tt__HostnameInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__HostnameInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__HostnameInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__HostnameInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FromDHCP", &a->tt__HostnameInformation::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__token(soap, "tt:Name", &a->tt__HostnameInformation::Name, "xsd:token"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__HostnameInformationExtension(soap, "tt:Extension", &a->tt__HostnameInformation::Extension, "tt:HostnameInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__HostnameInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformation, SOAP_TYPE_tt__HostnameInformation, sizeof(tt__HostnameInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__HostnameInformation * SOAP_FMAC2 soap_instantiate_tt__HostnameInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__HostnameInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__HostnameInformation *p;
	size_t k = sizeof(tt__HostnameInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__HostnameInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__HostnameInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__HostnameInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__HostnameInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__HostnameInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__HostnameInformation(soap, tag ? tag : "tt:HostnameInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__HostnameInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__HostnameInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__HostnameInformation * SOAP_FMAC4 soap_get_tt__HostnameInformation(struct soap *soap, tt__HostnameInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PrefixedIPv6Address::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__IPv6Address(soap, &this->tt__PrefixedIPv6Address::Address);
	soap_default_int(soap, &this->tt__PrefixedIPv6Address::PrefixLength);
}

void tt__PrefixedIPv6Address::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PrefixedIPv6Address::Address, SOAP_TYPE_tt__IPv6Address);
	soap_serialize_tt__IPv6Address(soap, &this->tt__PrefixedIPv6Address::Address);
	soap_embedded(soap, &this->tt__PrefixedIPv6Address::PrefixLength, SOAP_TYPE_int);
#endif
}

int tt__PrefixedIPv6Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PrefixedIPv6Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const tt__PrefixedIPv6Address *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv6Address), type))
		return soap->error;
	if (soap_out_tt__IPv6Address(soap, "tt:Address", -1, &a->tt__PrefixedIPv6Address::Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &a->tt__PrefixedIPv6Address::PrefixLength, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PrefixedIPv6Address::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PrefixedIPv6Address(soap, tag, this, type);
}

SOAP_FMAC3 tt__PrefixedIPv6Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, tt__PrefixedIPv6Address *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PrefixedIPv6Address*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PrefixedIPv6Address)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PrefixedIPv6Address *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_PrefixLength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv6Address(soap, "tt:Address", &a->tt__PrefixedIPv6Address::Address, "tt:IPv6Address"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap_flag_PrefixLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:PrefixLength", &a->tt__PrefixedIPv6Address::PrefixLength, "xsd:int"))
				{	soap_flag_PrefixLength1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address1 > 0 || soap_flag_PrefixLength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PrefixedIPv6Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv6Address, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PrefixedIPv6Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PrefixedIPv6Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PrefixedIPv6Address *p;
	size_t k = sizeof(tt__PrefixedIPv6Address);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PrefixedIPv6Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PrefixedIPv6Address);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PrefixedIPv6Address, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PrefixedIPv6Address location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PrefixedIPv6Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PrefixedIPv6Address(soap, tag ? tag : "tt:PrefixedIPv6Address", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PrefixedIPv6Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PrefixedIPv6Address(soap, this, tag, type);
}

SOAP_FMAC3 tt__PrefixedIPv6Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PrefixedIPv4Address::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__IPv4Address(soap, &this->tt__PrefixedIPv4Address::Address);
	soap_default_int(soap, &this->tt__PrefixedIPv4Address::PrefixLength);
}

void tt__PrefixedIPv4Address::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PrefixedIPv4Address::Address, SOAP_TYPE_tt__IPv4Address);
	soap_serialize_tt__IPv4Address(soap, &this->tt__PrefixedIPv4Address::Address);
	soap_embedded(soap, &this->tt__PrefixedIPv4Address::PrefixLength, SOAP_TYPE_int);
#endif
}

int tt__PrefixedIPv4Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PrefixedIPv4Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const tt__PrefixedIPv4Address *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv4Address), type))
		return soap->error;
	if (soap_out_tt__IPv4Address(soap, "tt:Address", -1, &a->tt__PrefixedIPv4Address::Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &a->tt__PrefixedIPv4Address::PrefixLength, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PrefixedIPv4Address::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PrefixedIPv4Address(soap, tag, this, type);
}

SOAP_FMAC3 tt__PrefixedIPv4Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, tt__PrefixedIPv4Address *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PrefixedIPv4Address*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PrefixedIPv4Address)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PrefixedIPv4Address *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_PrefixLength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv4Address(soap, "tt:Address", &a->tt__PrefixedIPv4Address::Address, "tt:IPv4Address"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap_flag_PrefixLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:PrefixLength", &a->tt__PrefixedIPv4Address::PrefixLength, "xsd:int"))
				{	soap_flag_PrefixLength1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address1 > 0 || soap_flag_PrefixLength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PrefixedIPv4Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv4Address, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PrefixedIPv4Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PrefixedIPv4Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PrefixedIPv4Address *p;
	size_t k = sizeof(tt__PrefixedIPv4Address);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PrefixedIPv4Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PrefixedIPv4Address);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PrefixedIPv4Address, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PrefixedIPv4Address location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PrefixedIPv4Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PrefixedIPv4Address(soap, tag ? tag : "tt:PrefixedIPv4Address", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PrefixedIPv4Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PrefixedIPv4Address(soap, this, tag, type);
}

SOAP_FMAC3 tt__PrefixedIPv4Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPAddress::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__IPType(soap, &this->tt__IPAddress::Type);
	this->tt__IPAddress::IPv4Address = NULL;
	this->tt__IPAddress::IPv6Address = NULL;
}

void tt__IPAddress::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPv4Address(soap, &this->tt__IPAddress::IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &this->tt__IPAddress::IPv6Address);
#endif
}

int tt__IPAddress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddress(struct soap *soap, const char *tag, int id, const tt__IPAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddress), type))
		return soap->error;
	if (soap_out_tt__IPType(soap, "tt:Type", -1, &a->tt__IPAddress::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &a->tt__IPAddress::IPv4Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &a->tt__IPAddress::IPv6Address, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPAddress::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPAddress(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddress * SOAP_FMAC4 soap_in_tt__IPAddress(struct soap *soap, const char *tag, tt__IPAddress *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPAddress*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPAddress)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPAddress *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_IPv4Address1 = 1;
	size_t soap_flag_IPv6Address1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPType(soap, "tt:Type", &a->tt__IPAddress::Type, "tt:IPType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_IPv4Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &a->tt__IPAddress::IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address1--;
					continue;
				}
			}
			if (soap_flag_IPv6Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &a->tt__IPAddress::IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddress, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 soap_instantiate_tt__IPAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPAddress *p;
	size_t k = sizeof(tt__IPAddress);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPAddress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPAddress);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPAddress, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPAddress location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPAddress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddress(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddress * SOAP_FMAC4 soap_get_tt__IPAddress(struct soap *soap, tt__IPAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkHostExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkHostExtension::__any);
}

void tt__NetworkHostExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkHostExtension::__any);
#endif
}

int tt__NetworkHostExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkHostExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostExtension(struct soap *soap, const char *tag, int id, const tt__NetworkHostExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHostExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NetworkHostExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkHostExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkHostExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkHostExtension * SOAP_FMAC4 soap_in_tt__NetworkHostExtension(struct soap *soap, const char *tag, tt__NetworkHostExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkHostExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(tt__NetworkHostExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkHostExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkHostExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NetworkHostExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkHostExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostExtension, SOAP_TYPE_tt__NetworkHostExtension, sizeof(tt__NetworkHostExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkHostExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkHostExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkHostExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkHostExtension *p;
	size_t k = sizeof(tt__NetworkHostExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkHostExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkHostExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkHostExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkHostExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkHostExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkHostExtension(soap, tag ? tag : "tt:NetworkHostExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkHostExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkHostExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkHostExtension * SOAP_FMAC4 soap_get_tt__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkHost::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__NetworkHostType(soap, &this->tt__NetworkHost::Type);
	this->tt__NetworkHost::IPv4Address = NULL;
	this->tt__NetworkHost::IPv6Address = NULL;
	this->tt__NetworkHost::DNSname = NULL;
	this->tt__NetworkHost::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NetworkHost::__anyAttribute);
}

void tt__NetworkHost::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPv4Address(soap, &this->tt__NetworkHost::IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &this->tt__NetworkHost::IPv6Address);
	soap_serialize_PointerTott__DNSName(soap, &this->tt__NetworkHost::DNSname);
	soap_serialize_PointerTott__NetworkHostExtension(soap, &this->tt__NetworkHost::Extension);
#endif
}

int tt__NetworkHost::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkHost(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHost(struct soap *soap, const char *tag, int id, const tt__NetworkHost *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NetworkHost*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHost), type))
		return soap->error;
	if (soap_out_tt__NetworkHostType(soap, "tt:Type", -1, &a->tt__NetworkHost::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &a->tt__NetworkHost::IPv4Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &a->tt__NetworkHost::IPv6Address, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tt:DNSname", -1, &a->tt__NetworkHost::DNSname, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkHostExtension(soap, "tt:Extension", -1, &a->tt__NetworkHost::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkHost::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkHost(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkHost * SOAP_FMAC4 soap_in_tt__NetworkHost(struct soap *soap, const char *tag, tt__NetworkHost *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkHost*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHost, sizeof(tt__NetworkHost), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkHost)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkHost *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NetworkHost*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_IPv4Address1 = 1;
	size_t soap_flag_IPv6Address1 = 1;
	size_t soap_flag_DNSname1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__NetworkHostType(soap, "tt:Type", &a->tt__NetworkHost::Type, "tt:NetworkHostType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_IPv4Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &a->tt__NetworkHost::IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address1--;
					continue;
				}
			}
			if (soap_flag_IPv6Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &a->tt__NetworkHost::IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address1--;
					continue;
				}
			}
			if (soap_flag_DNSname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__DNSName(soap, "tt:DNSname", &a->tt__NetworkHost::DNSname, "tt:DNSName"))
				{	soap_flag_DNSname1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkHostExtension(soap, "tt:Extension", &a->tt__NetworkHost::Extension, "tt:NetworkHostExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkHost *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHost, SOAP_TYPE_tt__NetworkHost, sizeof(tt__NetworkHost), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkHost * SOAP_FMAC2 soap_instantiate_tt__NetworkHost(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkHost(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkHost *p;
	size_t k = sizeof(tt__NetworkHost);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkHost, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkHost);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkHost, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkHost location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkHost::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkHost(soap, tag ? tag : "tt:NetworkHost", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkHost::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkHost(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkHost * SOAP_FMAC4 soap_get_tt__NetworkHost(struct soap *soap, tt__NetworkHost *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkProtocolExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkProtocolExtension::__any);
}

void tt__NetworkProtocolExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkProtocolExtension::__any);
#endif
}

int tt__NetworkProtocolExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkProtocolExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, const tt__NetworkProtocolExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocolExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NetworkProtocolExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkProtocolExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkProtocolExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkProtocolExtension * SOAP_FMAC4 soap_in_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, tt__NetworkProtocolExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkProtocolExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(tt__NetworkProtocolExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkProtocolExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkProtocolExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NetworkProtocolExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkProtocolExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolExtension, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(tt__NetworkProtocolExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkProtocolExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocolExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkProtocolExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkProtocolExtension *p;
	size_t k = sizeof(tt__NetworkProtocolExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkProtocolExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkProtocolExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkProtocolExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkProtocolExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkProtocolExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkProtocolExtension(soap, tag ? tag : "tt:NetworkProtocolExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkProtocolExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkProtocolExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkProtocolExtension * SOAP_FMAC4 soap_get_tt__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkProtocol::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__NetworkProtocolType(soap, &this->tt__NetworkProtocol::Name);
	soap_default_bool(soap, &this->tt__NetworkProtocol::Enabled);
	soap_default_std__vectorTemplateOfint(soap, &this->tt__NetworkProtocol::Port);
	this->tt__NetworkProtocol::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NetworkProtocol::__anyAttribute);
}

void tt__NetworkProtocol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NetworkProtocol::Enabled, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfint(soap, &this->tt__NetworkProtocol::Port);
	soap_serialize_PointerTott__NetworkProtocolExtension(soap, &this->tt__NetworkProtocol::Extension);
#endif
}

int tt__NetworkProtocol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkProtocol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocol(struct soap *soap, const char *tag, int id, const tt__NetworkProtocol *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NetworkProtocol*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocol), type))
		return soap->error;
	if (soap_out_tt__NetworkProtocolType(soap, "tt:Name", -1, &a->tt__NetworkProtocol::Name, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__NetworkProtocol::Enabled, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "tt:Port", -1, &a->tt__NetworkProtocol::Port, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", -1, &a->tt__NetworkProtocol::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkProtocol::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkProtocol(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkProtocol * SOAP_FMAC4 soap_in_tt__NetworkProtocol(struct soap *soap, const char *tag, tt__NetworkProtocol *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkProtocol*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocol, sizeof(tt__NetworkProtocol), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkProtocol)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkProtocol *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NetworkProtocol*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__NetworkProtocolType(soap, "tt:Name", &a->tt__NetworkProtocol::Name, "tt:NetworkProtocolType"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__NetworkProtocol::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfint(soap, "tt:Port", &a->tt__NetworkProtocol::Port, "xsd:int"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", &a->tt__NetworkProtocol::Extension, "tt:NetworkProtocolExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_Enabled1 > 0 || a->tt__NetworkProtocol::Port.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocol, SOAP_TYPE_tt__NetworkProtocol, sizeof(tt__NetworkProtocol), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkProtocol * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkProtocol(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkProtocol *p;
	size_t k = sizeof(tt__NetworkProtocol);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkProtocol, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkProtocol);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkProtocol, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkProtocol location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkProtocol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkProtocol(soap, tag ? tag : "tt:NetworkProtocol", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkProtocol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkProtocol(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkProtocol * SOAP_FMAC4 soap_get_tt__NetworkProtocol(struct soap *soap, tt__NetworkProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6ConfigurationExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IPv6ConfigurationExtension::__any);
}

void tt__IPv6ConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IPv6ConfigurationExtension::__any);
#endif
}

int tt__IPv6ConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6ConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__IPv6ConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__IPv6ConfigurationExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6ConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6ConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_in_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, tt__IPv6ConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6ConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(tt__IPv6ConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6ConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv6ConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__IPv6ConfigurationExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv6ConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6ConfigurationExtension, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(tt__IPv6ConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6ConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__IPv6ConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6ConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6ConfigurationExtension *p;
	size_t k = sizeof(tt__IPv6ConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6ConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6ConfigurationExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6ConfigurationExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6ConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6ConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6ConfigurationExtension(soap, tag ? tag : "tt:IPv6ConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6ConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6ConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_get_tt__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6Configuration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__IPv6Configuration::AcceptRouterAdvert = NULL;
	soap_default_tt__IPv6DHCPConfiguration(soap, &this->tt__IPv6Configuration::DHCP);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::Manual);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::LinkLocal);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromRA);
	this->tt__IPv6Configuration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__IPv6Configuration::__anyAttribute);
}

void tt__IPv6Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__IPv6Configuration::AcceptRouterAdvert);
	soap_embedded(soap, &this->tt__IPv6Configuration::DHCP, SOAP_TYPE_tt__IPv6DHCPConfiguration);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::Manual);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::LinkLocal);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromDHCP);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromRA);
	soap_serialize_PointerTott__IPv6ConfigurationExtension(soap, &this->tt__IPv6Configuration::Extension);
#endif
}

int tt__IPv6Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Configuration(struct soap *soap, const char *tag, int id, const tt__IPv6Configuration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__IPv6Configuration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6Configuration), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:AcceptRouterAdvert", -1, &a->tt__IPv6Configuration::AcceptRouterAdvert, ""))
		return soap->error;
	if (soap_out_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &a->tt__IPv6Configuration::DHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", -1, &a->tt__IPv6Configuration::Manual, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:LinkLocal", -1, &a->tt__IPv6Configuration::LinkLocal, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromDHCP", -1, &a->tt__IPv6Configuration::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromRA", -1, &a->tt__IPv6Configuration::FromRA, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", -1, &a->tt__IPv6Configuration::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6Configuration * SOAP_FMAC4 soap_in_tt__IPv6Configuration(struct soap *soap, const char *tag, tt__IPv6Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6Configuration, sizeof(tt__IPv6Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv6Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__IPv6Configuration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_AcceptRouterAdvert1 = 1;
	size_t soap_flag_DHCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcceptRouterAdvert1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:AcceptRouterAdvert", &a->tt__IPv6Configuration::AcceptRouterAdvert, "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert1--;
					continue;
				}
			}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", &a->tt__IPv6Configuration::DHCP, "tt:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", &a->tt__IPv6Configuration::Manual, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:LinkLocal", &a->tt__IPv6Configuration::LinkLocal, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromDHCP", &a->tt__IPv6Configuration::FromDHCP, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromRA", &a->tt__IPv6Configuration::FromRA, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", &a->tt__IPv6Configuration::Extension, "tt:IPv6ConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPv6Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6Configuration, SOAP_TYPE_tt__IPv6Configuration, sizeof(tt__IPv6Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv6Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6Configuration *p;
	size_t k = sizeof(tt__IPv6Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6Configuration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6Configuration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6Configuration(soap, tag ? tag : "tt:IPv6Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6Configuration * SOAP_FMAC4 soap_get_tt__IPv6Configuration(struct soap *soap, tt__IPv6Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv4Configuration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::Manual);
	this->tt__IPv4Configuration::LinkLocal = NULL;
	this->tt__IPv4Configuration::FromDHCP = NULL;
	soap_default_bool(soap, &this->tt__IPv4Configuration::DHCP);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IPv4Configuration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__IPv4Configuration::__anyAttribute);
}

void tt__IPv4Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::Manual);
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::LinkLocal);
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::FromDHCP);
	soap_embedded(soap, &this->tt__IPv4Configuration::DHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IPv4Configuration::__any);
#endif
}

int tt__IPv4Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Configuration(struct soap *soap, const char *tag, int id, const tt__IPv4Configuration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__IPv4Configuration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4Configuration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", -1, &a->tt__IPv4Configuration::Manual, ""))
		return soap->error;
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", -1, &a->tt__IPv4Configuration::LinkLocal, ""))
		return soap->error;
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", -1, &a->tt__IPv4Configuration::FromDHCP, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DHCP", -1, &a->tt__IPv4Configuration::DHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__IPv4Configuration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv4Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv4Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4Configuration * SOAP_FMAC4 soap_in_tt__IPv4Configuration(struct soap *soap, const char *tag, tt__IPv4Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv4Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4Configuration, sizeof(tt__IPv4Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv4Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv4Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__IPv4Configuration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_LinkLocal1 = 1;
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_DHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", &a->tt__IPv4Configuration::Manual, "tt:PrefixedIPv4Address"))
					continue;
			}
			if (soap_flag_LinkLocal1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", &a->tt__IPv4Configuration::LinkLocal, "tt:PrefixedIPv4Address"))
				{	soap_flag_LinkLocal1--;
					continue;
				}
			}
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", &a->tt__IPv4Configuration::FromDHCP, "tt:PrefixedIPv4Address"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DHCP", &a->tt__IPv4Configuration::DHCP, "xsd:boolean"))
				{	soap_flag_DHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__IPv4Configuration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPv4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4Configuration, SOAP_TYPE_tt__IPv4Configuration, sizeof(tt__IPv4Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv4Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv4Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv4Configuration *p;
	size_t k = sizeof(tt__IPv4Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv4Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv4Configuration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv4Configuration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv4Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv4Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv4Configuration(soap, tag ? tag : "tt:IPv4Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4Configuration * SOAP_FMAC4 soap_get_tt__IPv4Configuration(struct soap *soap, tt__IPv4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv4NetworkInterface::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__IPv4NetworkInterface::Enabled);
	this->tt__IPv4NetworkInterface::Config = NULL;
}

void tt__IPv4NetworkInterface::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IPv4NetworkInterface::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTott__IPv4Configuration(soap, &this->tt__IPv4NetworkInterface::Config);
#endif
}

int tt__IPv4NetworkInterface::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4NetworkInterface(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, const tt__IPv4NetworkInterface *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterface), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__IPv4NetworkInterface::Enabled, ""))
		return soap->error;
	if (!a->tt__IPv4NetworkInterface::Config)
	{	if (soap_element_empty(soap, "tt:Config"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPv4Configuration(soap, "tt:Config", -1, &a->tt__IPv4NetworkInterface::Config, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv4NetworkInterface::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv4NetworkInterface(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, tt__IPv4NetworkInterface *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv4NetworkInterface*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(tt__IPv4NetworkInterface), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv4NetworkInterface)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv4NetworkInterface *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Config1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__IPv4NetworkInterface::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Config1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv4Configuration(soap, "tt:Config", &a->tt__IPv4NetworkInterface::Config, "tt:IPv4Configuration"))
				{	soap_flag_Config1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0 || !a->tt__IPv4NetworkInterface::Config))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPv4NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterface, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(tt__IPv4NetworkInterface), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv4NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv4NetworkInterface *p;
	size_t k = sizeof(tt__IPv4NetworkInterface);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv4NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv4NetworkInterface);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv4NetworkInterface, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv4NetworkInterface location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv4NetworkInterface::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv4NetworkInterface(soap, tag ? tag : "tt:IPv4NetworkInterface", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4NetworkInterface::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4NetworkInterface(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6NetworkInterface::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__IPv6NetworkInterface::Enabled);
	this->tt__IPv6NetworkInterface::Config = NULL;
}

void tt__IPv6NetworkInterface::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IPv6NetworkInterface::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTott__IPv6Configuration(soap, &this->tt__IPv6NetworkInterface::Config);
#endif
}

int tt__IPv6NetworkInterface::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6NetworkInterface(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, const tt__IPv6NetworkInterface *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterface), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__IPv6NetworkInterface::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Configuration(soap, "tt:Config", -1, &a->tt__IPv6NetworkInterface::Config, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6NetworkInterface::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6NetworkInterface(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, tt__IPv6NetworkInterface *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6NetworkInterface*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(tt__IPv6NetworkInterface), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6NetworkInterface)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv6NetworkInterface *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Config1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__IPv6NetworkInterface::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Config1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6Configuration(soap, "tt:Config", &a->tt__IPv6NetworkInterface::Config, "tt:IPv6Configuration"))
				{	soap_flag_Config1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPv6NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterface, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(tt__IPv6NetworkInterface), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6NetworkInterface *p;
	size_t k = sizeof(tt__IPv6NetworkInterface);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6NetworkInterface);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6NetworkInterface, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6NetworkInterface location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6NetworkInterface::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6NetworkInterface(soap, tag ? tag : "tt:IPv6NetworkInterface", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6NetworkInterface::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6NetworkInterface(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceInfo::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__NetworkInterfaceInfo::Name = NULL;
	soap_default_tt__HwAddress(soap, &this->tt__NetworkInterfaceInfo::HwAddress);
	this->tt__NetworkInterfaceInfo::MTU = NULL;
}

void tt__NetworkInterfaceInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->tt__NetworkInterfaceInfo::Name);
	soap_serialize_tt__HwAddress(soap, &this->tt__NetworkInterfaceInfo::HwAddress);
	soap_serialize_PointerToint(soap, &this->tt__NetworkInterfaceInfo::MTU);
#endif
}

int tt__NetworkInterfaceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Name", -1, &a->tt__NetworkInterfaceInfo::Name, ""))
		return soap->error;
	if (soap_out_tt__HwAddress(soap, "tt:HwAddress", -1, &a->tt__NetworkInterfaceInfo::HwAddress, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->tt__NetworkInterfaceInfo::MTU, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceInfo(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_in_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, tt__NetworkInterfaceInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(tt__NetworkInterfaceInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_HwAddress1 = 1;
	size_t soap_flag_MTU1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Name", &a->tt__NetworkInterfaceInfo::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_HwAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__HwAddress(soap, "tt:HwAddress", &a->tt__NetworkInterfaceInfo::HwAddress, "tt:HwAddress"))
				{	soap_flag_HwAddress1--;
					continue;
				}
			}
			if (soap_flag_MTU1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:MTU", &a->tt__NetworkInterfaceInfo::MTU, "xsd:int"))
				{	soap_flag_MTU1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HwAddress1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceInfo, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(tt__NetworkInterfaceInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceInfo * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceInfo *p;
	size_t k = sizeof(tt__NetworkInterfaceInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceInfo(soap, tag ? tag : "tt:NetworkInterfaceInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceInfo(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_get_tt__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceConnectionSetting::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->tt__NetworkInterfaceConnectionSetting::AutoNegotiation);
	soap_default_int(soap, &this->tt__NetworkInterfaceConnectionSetting::Speed);
	soap_default_tt__Duplex(soap, &this->tt__NetworkInterfaceConnectionSetting::Duplex);
}

void tt__NetworkInterfaceConnectionSetting::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NetworkInterfaceConnectionSetting::AutoNegotiation, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__NetworkInterfaceConnectionSetting::Speed, SOAP_TYPE_int);
#endif
}

int tt__NetworkInterfaceConnectionSetting::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoNegotiation", -1, &a->tt__NetworkInterfaceConnectionSetting::AutoNegotiation, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Speed", -1, &a->tt__NetworkInterfaceConnectionSetting::Speed, ""))
		return soap->error;
	if (soap_out_tt__Duplex(soap, "tt:Duplex", -1, &a->tt__NetworkInterfaceConnectionSetting::Duplex, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceConnectionSetting::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_in_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceConnectionSetting*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(tt__NetworkInterfaceConnectionSetting), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceConnectionSetting)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceConnectionSetting *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_AutoNegotiation1 = 1;
	size_t soap_flag_Speed1 = 1;
	size_t soap_flag_Duplex1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoNegotiation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AutoNegotiation", &a->tt__NetworkInterfaceConnectionSetting::AutoNegotiation, "xsd:boolean"))
				{	soap_flag_AutoNegotiation1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Speed", &a->tt__NetworkInterfaceConnectionSetting::Speed, "xsd:int"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_Duplex1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Duplex(soap, "tt:Duplex", &a->tt__NetworkInterfaceConnectionSetting::Duplex, "tt:Duplex"))
				{	soap_flag_Duplex1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoNegotiation1 > 0 || soap_flag_Speed1 > 0 || soap_flag_Duplex1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceConnectionSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(tt__NetworkInterfaceConnectionSetting), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceConnectionSetting(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceConnectionSetting(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceConnectionSetting *p;
	size_t k = sizeof(tt__NetworkInterfaceConnectionSetting);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceConnectionSetting);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceConnectionSetting, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceConnectionSetting location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceConnectionSetting::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag ? tag : "tt:NetworkInterfaceConnectionSetting", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceConnectionSetting::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceConnectionSetting(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_get_tt__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceLink::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__NetworkInterfaceLink::AdminSettings = NULL;
	this->tt__NetworkInterfaceLink::OperSettings = NULL;
	soap_default_tt__IANA_IfTypes(soap, &this->tt__NetworkInterfaceLink::InterfaceType);
}

void tt__NetworkInterfaceLink::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &this->tt__NetworkInterfaceLink::AdminSettings);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &this->tt__NetworkInterfaceLink::OperSettings);
#endif
}

int tt__NetworkInterfaceLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceLink), type))
		return soap->error;
	if (!a->tt__NetworkInterfaceLink::AdminSettings)
	{	if (soap_element_empty(soap, "tt:AdminSettings"))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", -1, &a->tt__NetworkInterfaceLink::AdminSettings, ""))
		return soap->error;
	if (!a->tt__NetworkInterfaceLink::OperSettings)
	{	if (soap_element_empty(soap, "tt:OperSettings"))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", -1, &a->tt__NetworkInterfaceLink::OperSettings, ""))
		return soap->error;
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &a->tt__NetworkInterfaceLink::InterfaceType, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceLink::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceLink(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceLink * SOAP_FMAC4 soap_in_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, tt__NetworkInterfaceLink *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceLink*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(tt__NetworkInterfaceLink), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceLink)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceLink *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_AdminSettings1 = 1;
	size_t soap_flag_OperSettings1 = 1;
	size_t soap_flag_InterfaceType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AdminSettings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", &a->tt__NetworkInterfaceLink::AdminSettings, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_AdminSettings1--;
					continue;
				}
			}
			if (soap_flag_OperSettings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", &a->tt__NetworkInterfaceLink::OperSettings, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_OperSettings1--;
					continue;
				}
			}
			if (soap_flag_InterfaceType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &a->tt__NetworkInterfaceLink::InterfaceType, "tt:IANA-IfTypes"))
				{	soap_flag_InterfaceType1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__NetworkInterfaceLink::AdminSettings || !a->tt__NetworkInterfaceLink::OperSettings || soap_flag_InterfaceType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceLink, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(tt__NetworkInterfaceLink), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceLink * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceLink(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceLink *p;
	size_t k = sizeof(tt__NetworkInterfaceLink);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceLink, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceLink);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceLink, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceLink location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceLink(soap, tag ? tag : "tt:NetworkInterfaceLink", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceLink(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceLink * SOAP_FMAC4 soap_get_tt__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceExtension2::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkInterfaceExtension2::__any);
}

void tt__NetworkInterfaceExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkInterfaceExtension2::__any);
#endif
}

int tt__NetworkInterfaceExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension2(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceExtension2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NetworkInterfaceExtension2::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension2(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(tt__NetworkInterfaceExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NetworkInterfaceExtension2::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension2, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(tt__NetworkInterfaceExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceExtension2 *p;
	size_t k = sizeof(tt__NetworkInterfaceExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceExtension2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceExtension2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceExtension2(soap, tag ? tag : "tt:NetworkInterfaceExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension2(struct soap *soap, tt__NetworkInterfaceExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot3Configuration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot3Configuration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__Dot3Configuration::__anyAttribute);
}

void tt__Dot3Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__Dot3Configuration::__any);
#endif
}

int tt__Dot3Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot3Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot3Configuration(struct soap *soap, const char *tag, int id, const tt__Dot3Configuration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Dot3Configuration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot3Configuration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__Dot3Configuration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot3Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot3Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot3Configuration * SOAP_FMAC4 soap_in_tt__Dot3Configuration(struct soap *soap, const char *tag, tt__Dot3Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot3Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot3Configuration, sizeof(tt__Dot3Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot3Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot3Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Dot3Configuration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__Dot3Configuration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot3Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot3Configuration, SOAP_TYPE_tt__Dot3Configuration, sizeof(tt__Dot3Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot3Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot3Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot3Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot3Configuration *p;
	size_t k = sizeof(tt__Dot3Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot3Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot3Configuration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot3Configuration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot3Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot3Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot3Configuration(soap, tag ? tag : "tt:Dot3Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot3Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot3Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot3Configuration * SOAP_FMAC4 soap_get_tt__Dot3Configuration(struct soap *soap, tt__Dot3Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot3Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkInterfaceExtension::__any);
	soap_default_tt__IANA_IfTypes(soap, &this->tt__NetworkInterfaceExtension::InterfaceType);
	soap_default_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &this->tt__NetworkInterfaceExtension::Dot3);
	soap_default_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &this->tt__NetworkInterfaceExtension::Dot11);
	this->tt__NetworkInterfaceExtension::Extension = NULL;
}

void tt__NetworkInterfaceExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkInterfaceExtension::__any);
	soap_serialize_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &this->tt__NetworkInterfaceExtension::Dot3);
	soap_serialize_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &this->tt__NetworkInterfaceExtension::Dot11);
	soap_serialize_PointerTott__NetworkInterfaceExtension2(soap, &this->tt__NetworkInterfaceExtension::Extension);
#endif
}

int tt__NetworkInterfaceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__NetworkInterfaceExtension::__any, ""))
		return soap->error;
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &a->tt__NetworkInterfaceExtension::InterfaceType, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, "tt:Dot3", -1, &a->tt__NetworkInterfaceExtension::Dot3, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, "tt:Dot11", -1, &a->tt__NetworkInterfaceExtension::Dot11, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceExtension2(soap, "tt:Extension", -1, &a->tt__NetworkInterfaceExtension::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(tt__NetworkInterfaceExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_InterfaceType1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &a->tt__NetworkInterfaceExtension::InterfaceType, "tt:IANA-IfTypes"))
				{	soap_flag_InterfaceType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, "tt:Dot3", &a->tt__NetworkInterfaceExtension::Dot3, "tt:Dot3Configuration"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, "tt:Dot11", &a->tt__NetworkInterfaceExtension::Dot11, "tt:Dot11Configuration"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceExtension2(soap, "tt:Extension", &a->tt__NetworkInterfaceExtension::Extension, "tt:NetworkInterfaceExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__NetworkInterfaceExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(tt__NetworkInterfaceExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceExtension *p;
	size_t k = sizeof(tt__NetworkInterfaceExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceExtension(soap, tag ? tag : "tt:NetworkInterfaceExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterface::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__DeviceEntity::soap_default(soap);
	soap_default_bool(soap, &this->tt__NetworkInterface::Enabled);
	this->tt__NetworkInterface::Info = NULL;
	this->tt__NetworkInterface::Link = NULL;
	this->tt__NetworkInterface::IPv4 = NULL;
	this->tt__NetworkInterface::IPv6 = NULL;
	this->tt__NetworkInterface::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NetworkInterface::__anyAttribute);
}

void tt__NetworkInterface::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NetworkInterface::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTott__NetworkInterfaceInfo(soap, &this->tt__NetworkInterface::Info);
	soap_serialize_PointerTott__NetworkInterfaceLink(soap, &this->tt__NetworkInterface::Link);
	soap_serialize_PointerTott__IPv4NetworkInterface(soap, &this->tt__NetworkInterface::IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterface(soap, &this->tt__NetworkInterface::IPv6);
	soap_serialize_PointerTott__NetworkInterfaceExtension(soap, &this->tt__NetworkInterface::Extension);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__NetworkInterface::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterface(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterface(struct soap *soap, const char *tag, int id, const tt__NetworkInterface *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NetworkInterface*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterface), type ? type : "tt:NetworkInterface"))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__NetworkInterface::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", -1, &a->tt__NetworkInterface::Info, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, "tt:Link", -1, &a->tt__NetworkInterface::Link, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", -1, &a->tt__NetworkInterface::IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", -1, &a->tt__NetworkInterface::IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", -1, &a->tt__NetworkInterface::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterface::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterface(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterface * SOAP_FMAC4 soap_in_tt__NetworkInterface(struct soap *soap, const char *tag, tt__NetworkInterface *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterface*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterface, sizeof(tt__NetworkInterface), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterface)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterface *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NetworkInterface*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Info1 = 1;
	size_t soap_flag_Link1 = 1;
	size_t soap_flag_IPv41 = 1;
	size_t soap_flag_IPv61 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__NetworkInterface::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Info1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", &a->tt__NetworkInterface::Info, "tt:NetworkInterfaceInfo"))
				{	soap_flag_Info1--;
					continue;
				}
			}
			if (soap_flag_Link1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceLink(soap, "tt:Link", &a->tt__NetworkInterface::Link, "tt:NetworkInterfaceLink"))
				{	soap_flag_Link1--;
					continue;
				}
			}
			if (soap_flag_IPv41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", &a->tt__NetworkInterface::IPv4, "tt:IPv4NetworkInterface"))
				{	soap_flag_IPv41--;
					continue;
				}
			}
			if (soap_flag_IPv61 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", &a->tt__NetworkInterface::IPv6, "tt:IPv6NetworkInterface"))
				{	soap_flag_IPv61--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", &a->tt__NetworkInterface::Extension, "tt:NetworkInterfaceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterface, SOAP_TYPE_tt__NetworkInterface, sizeof(tt__NetworkInterface), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterface *p;
	size_t k = sizeof(tt__NetworkInterface);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterface);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterface, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterface location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterface::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterface(soap, tag ? tag : "tt:NetworkInterface", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterface::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterface(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterface * SOAP_FMAC4 soap_get_tt__NetworkInterface(struct soap *soap, tt__NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Scope::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ScopeDefinition(soap, &this->tt__Scope::ScopeDef);
	soap_default_xsd__anyURI(soap, &this->tt__Scope::ScopeItem);
}

void tt__Scope::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Scope::ScopeItem, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Scope::ScopeItem);
#endif
}

int tt__Scope::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Scope(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Scope(struct soap *soap, const char *tag, int id, const tt__Scope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Scope), type))
		return soap->error;
	if (soap_out_tt__ScopeDefinition(soap, "tt:ScopeDef", -1, &a->tt__Scope::ScopeDef, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:ScopeItem", -1, &a->tt__Scope::ScopeItem, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Scope::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Scope(soap, tag, this, type);
}

SOAP_FMAC3 tt__Scope * SOAP_FMAC4 soap_in_tt__Scope(struct soap *soap, const char *tag, tt__Scope *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Scope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Scope, sizeof(tt__Scope), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Scope)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Scope *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ScopeDef1 = 1;
	size_t soap_flag_ScopeItem1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScopeDef1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ScopeDefinition(soap, "tt:ScopeDef", &a->tt__Scope::ScopeDef, "tt:ScopeDefinition"))
				{	soap_flag_ScopeDef1--;
					continue;
				}
			}
			if (soap_flag_ScopeItem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:ScopeItem", &a->tt__Scope::ScopeItem, "xsd:anyURI"))
				{	soap_flag_ScopeItem1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ScopeDef1 > 0 || soap_flag_ScopeItem1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Scope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Scope, SOAP_TYPE_tt__Scope, sizeof(tt__Scope), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Scope * SOAP_FMAC2 soap_instantiate_tt__Scope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Scope(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Scope *p;
	size_t k = sizeof(tt__Scope);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Scope, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Scope);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Scope, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Scope location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Scope::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Scope(soap, tag ? tag : "tt:Scope", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Scope::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Scope(soap, this, tag, type);
}

SOAP_FMAC3 tt__Scope * SOAP_FMAC4 soap_get_tt__Scope(struct soap *soap, tt__Scope *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MediaUri::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->tt__MediaUri::Uri);
	soap_default_bool(soap, &this->tt__MediaUri::InvalidAfterConnect);
	soap_default_bool(soap, &this->tt__MediaUri::InvalidAfterReboot);
	soap_default_xsd__duration(soap, &this->tt__MediaUri::Timeout);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaUri::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__MediaUri::__anyAttribute);
}

void tt__MediaUri::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__MediaUri::Uri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__MediaUri::Uri);
	soap_embedded(soap, &this->tt__MediaUri::InvalidAfterConnect, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__MediaUri::InvalidAfterReboot, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__MediaUri::Timeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__MediaUri::Timeout);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaUri::__any);
#endif
}

int tt__MediaUri::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaUri(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaUri(struct soap *soap, const char *tag, int id, const tt__MediaUri *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MediaUri*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaUri), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:Uri", -1, &a->tt__MediaUri::Uri, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:InvalidAfterConnect", -1, &a->tt__MediaUri::InvalidAfterConnect, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:InvalidAfterReboot", -1, &a->tt__MediaUri::InvalidAfterReboot, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Timeout", -1, &a->tt__MediaUri::Timeout, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MediaUri::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MediaUri::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MediaUri(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaUri * SOAP_FMAC4 soap_in_tt__MediaUri(struct soap *soap, const char *tag, tt__MediaUri *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaUri*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaUri, sizeof(tt__MediaUri), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MediaUri)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MediaUri *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MediaUri*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Uri1 = 1;
	size_t soap_flag_InvalidAfterConnect1 = 1;
	size_t soap_flag_InvalidAfterReboot1 = 1;
	size_t soap_flag_Timeout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Uri", &a->tt__MediaUri::Uri, "xsd:anyURI"))
				{	soap_flag_Uri1--;
					continue;
				}
			}
			if (soap_flag_InvalidAfterConnect1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:InvalidAfterConnect", &a->tt__MediaUri::InvalidAfterConnect, "xsd:boolean"))
				{	soap_flag_InvalidAfterConnect1--;
					continue;
				}
			}
			if (soap_flag_InvalidAfterReboot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:InvalidAfterReboot", &a->tt__MediaUri::InvalidAfterReboot, "xsd:boolean"))
				{	soap_flag_InvalidAfterReboot1--;
					continue;
				}
			}
			if (soap_flag_Timeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:Timeout", &a->tt__MediaUri::Timeout, "xsd:duration"))
				{	soap_flag_Timeout1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MediaUri::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Uri1 > 0 || soap_flag_InvalidAfterConnect1 > 0 || soap_flag_InvalidAfterReboot1 > 0 || soap_flag_Timeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MediaUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaUri, SOAP_TYPE_tt__MediaUri, sizeof(tt__MediaUri), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaUri * SOAP_FMAC2 soap_instantiate_tt__MediaUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaUri(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MediaUri *p;
	size_t k = sizeof(tt__MediaUri);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MediaUri, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MediaUri);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MediaUri, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MediaUri location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MediaUri::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MediaUri(soap, tag ? tag : "tt:MediaUri", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaUri::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaUri(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaUri * SOAP_FMAC4 soap_get_tt__MediaUri(struct soap *soap, tt__MediaUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Transport::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__TransportProtocol(soap, &this->tt__Transport::Protocol);
	this->tt__Transport::Tunnel = NULL;
}

void tt__Transport::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Transport(soap, &this->tt__Transport::Tunnel);
#endif
}

int tt__Transport::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Transport(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Transport(struct soap *soap, const char *tag, int id, const tt__Transport *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Transport), type))
		return soap->error;
	if (soap_out_tt__TransportProtocol(soap, "tt:Protocol", -1, &a->tt__Transport::Protocol, ""))
		return soap->error;
	if (soap_out_PointerTott__Transport(soap, "tt:Tunnel", -1, &a->tt__Transport::Tunnel, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Transport::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Transport(soap, tag, this, type);
}

SOAP_FMAC3 tt__Transport * SOAP_FMAC4 soap_in_tt__Transport(struct soap *soap, const char *tag, tt__Transport *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Transport*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transport, sizeof(tt__Transport), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Transport)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Transport *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Protocol1 = 1;
	size_t soap_flag_Tunnel1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Protocol1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__TransportProtocol(soap, "tt:Protocol", &a->tt__Transport::Protocol, "tt:TransportProtocol"))
				{	soap_flag_Protocol1--;
					continue;
				}
			}
			if (soap_flag_Tunnel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Transport(soap, "tt:Tunnel", &a->tt__Transport::Tunnel, "tt:Transport"))
				{	soap_flag_Tunnel1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Protocol1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Transport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transport, SOAP_TYPE_tt__Transport, sizeof(tt__Transport), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Transport * SOAP_FMAC2 soap_instantiate_tt__Transport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Transport(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Transport *p;
	size_t k = sizeof(tt__Transport);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Transport, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Transport);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Transport, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Transport location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Transport::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Transport(soap, tag ? tag : "tt:Transport", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Transport::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Transport(soap, this, tag, type);
}

SOAP_FMAC3 tt__Transport * SOAP_FMAC4 soap_get_tt__Transport(struct soap *soap, tt__Transport *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Transport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__StreamSetup::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__StreamType(soap, &this->tt__StreamSetup::Stream);
	this->tt__StreamSetup::Transport = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__StreamSetup::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__StreamSetup::__anyAttribute);
}

void tt__StreamSetup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Transport(soap, &this->tt__StreamSetup::Transport);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__StreamSetup::__any);
#endif
}

int tt__StreamSetup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__StreamSetup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StreamSetup(struct soap *soap, const char *tag, int id, const tt__StreamSetup *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__StreamSetup*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StreamSetup), type))
		return soap->error;
	if (soap_out_tt__StreamType(soap, "tt:Stream", -1, &a->tt__StreamSetup::Stream, ""))
		return soap->error;
	if (!a->tt__StreamSetup::Transport)
	{	if (soap_element_empty(soap, "tt:Transport"))
			return soap->error;
	}
	else if (soap_out_PointerTott__Transport(soap, "tt:Transport", -1, &a->tt__StreamSetup::Transport, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__StreamSetup::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__StreamSetup::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__StreamSetup(soap, tag, this, type);
}

SOAP_FMAC3 tt__StreamSetup * SOAP_FMAC4 soap_in_tt__StreamSetup(struct soap *soap, const char *tag, tt__StreamSetup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__StreamSetup*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamSetup, sizeof(tt__StreamSetup), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__StreamSetup)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__StreamSetup *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__StreamSetup*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Stream1 = 1;
	size_t soap_flag_Transport1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Stream1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__StreamType(soap, "tt:Stream", &a->tt__StreamSetup::Stream, "tt:StreamType"))
				{	soap_flag_Stream1--;
					continue;
				}
			}
			if (soap_flag_Transport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Transport(soap, "tt:Transport", &a->tt__StreamSetup::Transport, "tt:Transport"))
				{	soap_flag_Transport1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__StreamSetup::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Stream1 > 0 || !a->tt__StreamSetup::Transport))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__StreamSetup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamSetup, SOAP_TYPE_tt__StreamSetup, sizeof(tt__StreamSetup), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__StreamSetup * SOAP_FMAC2 soap_instantiate_tt__StreamSetup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__StreamSetup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__StreamSetup *p;
	size_t k = sizeof(tt__StreamSetup);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__StreamSetup, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__StreamSetup);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__StreamSetup, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__StreamSetup location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__StreamSetup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__StreamSetup(soap, tag ? tag : "tt:StreamSetup", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__StreamSetup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__StreamSetup(soap, this, tag, type);
}

SOAP_FMAC3 tt__StreamSetup * SOAP_FMAC4 soap_get_tt__StreamSetup(struct soap *soap, tt__StreamSetup *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StreamSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MulticastConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__MulticastConfiguration::Address = NULL;
	soap_default_int(soap, &this->tt__MulticastConfiguration::Port);
	soap_default_int(soap, &this->tt__MulticastConfiguration::TTL);
	soap_default_bool(soap, &this->tt__MulticastConfiguration::AutoStart);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MulticastConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__MulticastConfiguration::__anyAttribute);
}

void tt__MulticastConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddress(soap, &this->tt__MulticastConfiguration::Address);
	soap_embedded(soap, &this->tt__MulticastConfiguration::Port, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__MulticastConfiguration::TTL, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__MulticastConfiguration::AutoStart, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MulticastConfiguration::__any);
#endif
}

int tt__MulticastConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MulticastConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MulticastConfiguration(struct soap *soap, const char *tag, int id, const tt__MulticastConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MulticastConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MulticastConfiguration), type))
		return soap->error;
	if (!a->tt__MulticastConfiguration::Address)
	{	if (soap_element_empty(soap, "tt:Address"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddress(soap, "tt:Address", -1, &a->tt__MulticastConfiguration::Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Port", -1, &a->tt__MulticastConfiguration::Port, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:TTL", -1, &a->tt__MulticastConfiguration::TTL, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoStart", -1, &a->tt__MulticastConfiguration::AutoStart, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__MulticastConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MulticastConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MulticastConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__MulticastConfiguration * SOAP_FMAC4 soap_in_tt__MulticastConfiguration(struct soap *soap, const char *tag, tt__MulticastConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MulticastConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(tt__MulticastConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MulticastConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MulticastConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MulticastConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_Port1 = 1;
	size_t soap_flag_TTL1 = 1;
	size_t soap_flag_AutoStart1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddress(soap, "tt:Address", &a->tt__MulticastConfiguration::Address, "tt:IPAddress"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap_flag_Port1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Port", &a->tt__MulticastConfiguration::Port, "xsd:int"))
				{	soap_flag_Port1--;
					continue;
				}
			}
			if (soap_flag_TTL1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:TTL", &a->tt__MulticastConfiguration::TTL, "xsd:int"))
				{	soap_flag_TTL1--;
					continue;
				}
			}
			if (soap_flag_AutoStart1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AutoStart", &a->tt__MulticastConfiguration::AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__MulticastConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__MulticastConfiguration::Address || soap_flag_Port1 > 0 || soap_flag_TTL1 > 0 || soap_flag_AutoStart1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MulticastConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MulticastConfiguration, SOAP_TYPE_tt__MulticastConfiguration, sizeof(tt__MulticastConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MulticastConfiguration * SOAP_FMAC2 soap_instantiate_tt__MulticastConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MulticastConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MulticastConfiguration *p;
	size_t k = sizeof(tt__MulticastConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MulticastConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MulticastConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MulticastConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MulticastConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MulticastConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MulticastConfiguration(soap, tag ? tag : "tt:MulticastConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MulticastConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MulticastConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__MulticastConfiguration * SOAP_FMAC4 soap_get_tt__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioDecoderConfigurationOptionsExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioDecoderConfigurationOptionsExtension::__any);
}

void tt__AudioDecoderConfigurationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioDecoderConfigurationOptionsExtension::__any);
#endif
}

int tt__AudioDecoderConfigurationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioDecoderConfigurationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__AudioDecoderConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioDecoderConfigurationOptionsExtension::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioDecoderConfigurationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioDecoderConfigurationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__AudioDecoderConfigurationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioDecoderConfigurationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, sizeof(tt__AudioDecoderConfigurationOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioDecoderConfigurationOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioDecoderConfigurationOptionsExtension::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioDecoderConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, sizeof(tt__AudioDecoderConfigurationOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioDecoderConfigurationOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioDecoderConfigurationOptionsExtension *p;
	size_t k = sizeof(tt__AudioDecoderConfigurationOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioDecoderConfigurationOptionsExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioDecoderConfigurationOptionsExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioDecoderConfigurationOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioDecoderConfigurationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioDecoderConfigurationOptionsExtension(soap, tag ? tag : "tt:AudioDecoderConfigurationOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioDecoderConfigurationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioDecoderConfigurationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, tt__AudioDecoderConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__G726DecOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__G726DecOptions::Bitrate = NULL;
	this->tt__G726DecOptions::SampleRateRange = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__G726DecOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__G726DecOptions::__anyAttribute);
}

void tt__G726DecOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntList(soap, &this->tt__G726DecOptions::Bitrate);
	soap_serialize_PointerTott__IntList(soap, &this->tt__G726DecOptions::SampleRateRange);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__G726DecOptions::__any);
#endif
}

int tt__G726DecOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__G726DecOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__G726DecOptions(struct soap *soap, const char *tag, int id, const tt__G726DecOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__G726DecOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__G726DecOptions), type))
		return soap->error;
	if (!a->tt__G726DecOptions::Bitrate)
	{	if (soap_element_empty(soap, "tt:Bitrate"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntList(soap, "tt:Bitrate", -1, &a->tt__G726DecOptions::Bitrate, ""))
		return soap->error;
	if (!a->tt__G726DecOptions::SampleRateRange)
	{	if (soap_element_empty(soap, "tt:SampleRateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntList(soap, "tt:SampleRateRange", -1, &a->tt__G726DecOptions::SampleRateRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__G726DecOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__G726DecOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__G726DecOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__G726DecOptions * SOAP_FMAC4 soap_in_tt__G726DecOptions(struct soap *soap, const char *tag, tt__G726DecOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__G726DecOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__G726DecOptions, sizeof(tt__G726DecOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__G726DecOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__G726DecOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__G726DecOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_SampleRateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntList(soap, "tt:Bitrate", &a->tt__G726DecOptions::Bitrate, "tt:IntList"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			}
			if (soap_flag_SampleRateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntList(soap, "tt:SampleRateRange", &a->tt__G726DecOptions::SampleRateRange, "tt:IntList"))
				{	soap_flag_SampleRateRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__G726DecOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__G726DecOptions::Bitrate || !a->tt__G726DecOptions::SampleRateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__G726DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__G726DecOptions, SOAP_TYPE_tt__G726DecOptions, sizeof(tt__G726DecOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__G726DecOptions * SOAP_FMAC2 soap_instantiate_tt__G726DecOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__G726DecOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__G726DecOptions *p;
	size_t k = sizeof(tt__G726DecOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__G726DecOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__G726DecOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__G726DecOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__G726DecOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__G726DecOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__G726DecOptions(soap, tag ? tag : "tt:G726DecOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__G726DecOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__G726DecOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__G726DecOptions * SOAP_FMAC4 soap_get_tt__G726DecOptions(struct soap *soap, tt__G726DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__G726DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AACDecOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__AACDecOptions::Bitrate = NULL;
	this->tt__AACDecOptions::SampleRateRange = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AACDecOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AACDecOptions::__anyAttribute);
}

void tt__AACDecOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntList(soap, &this->tt__AACDecOptions::Bitrate);
	soap_serialize_PointerTott__IntList(soap, &this->tt__AACDecOptions::SampleRateRange);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AACDecOptions::__any);
#endif
}

int tt__AACDecOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AACDecOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AACDecOptions(struct soap *soap, const char *tag, int id, const tt__AACDecOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AACDecOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AACDecOptions), type))
		return soap->error;
	if (!a->tt__AACDecOptions::Bitrate)
	{	if (soap_element_empty(soap, "tt:Bitrate"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntList(soap, "tt:Bitrate", -1, &a->tt__AACDecOptions::Bitrate, ""))
		return soap->error;
	if (!a->tt__AACDecOptions::SampleRateRange)
	{	if (soap_element_empty(soap, "tt:SampleRateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntList(soap, "tt:SampleRateRange", -1, &a->tt__AACDecOptions::SampleRateRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AACDecOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AACDecOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AACDecOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AACDecOptions * SOAP_FMAC4 soap_in_tt__AACDecOptions(struct soap *soap, const char *tag, tt__AACDecOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AACDecOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AACDecOptions, sizeof(tt__AACDecOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AACDecOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AACDecOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AACDecOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_SampleRateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntList(soap, "tt:Bitrate", &a->tt__AACDecOptions::Bitrate, "tt:IntList"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			}
			if (soap_flag_SampleRateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntList(soap, "tt:SampleRateRange", &a->tt__AACDecOptions::SampleRateRange, "tt:IntList"))
				{	soap_flag_SampleRateRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AACDecOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__AACDecOptions::Bitrate || !a->tt__AACDecOptions::SampleRateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AACDecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AACDecOptions, SOAP_TYPE_tt__AACDecOptions, sizeof(tt__AACDecOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AACDecOptions * SOAP_FMAC2 soap_instantiate_tt__AACDecOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AACDecOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AACDecOptions *p;
	size_t k = sizeof(tt__AACDecOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AACDecOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AACDecOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AACDecOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AACDecOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AACDecOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AACDecOptions(soap, tag ? tag : "tt:AACDecOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AACDecOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AACDecOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AACDecOptions * SOAP_FMAC4 soap_get_tt__AACDecOptions(struct soap *soap, tt__AACDecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AACDecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__G711DecOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__G711DecOptions::Bitrate = NULL;
	this->tt__G711DecOptions::SampleRateRange = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__G711DecOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__G711DecOptions::__anyAttribute);
}

void tt__G711DecOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntList(soap, &this->tt__G711DecOptions::Bitrate);
	soap_serialize_PointerTott__IntList(soap, &this->tt__G711DecOptions::SampleRateRange);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__G711DecOptions::__any);
#endif
}

int tt__G711DecOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__G711DecOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__G711DecOptions(struct soap *soap, const char *tag, int id, const tt__G711DecOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__G711DecOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__G711DecOptions), type))
		return soap->error;
	if (!a->tt__G711DecOptions::Bitrate)
	{	if (soap_element_empty(soap, "tt:Bitrate"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntList(soap, "tt:Bitrate", -1, &a->tt__G711DecOptions::Bitrate, ""))
		return soap->error;
	if (!a->tt__G711DecOptions::SampleRateRange)
	{	if (soap_element_empty(soap, "tt:SampleRateRange"))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntList(soap, "tt:SampleRateRange", -1, &a->tt__G711DecOptions::SampleRateRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__G711DecOptions::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__G711DecOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__G711DecOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__G711DecOptions * SOAP_FMAC4 soap_in_tt__G711DecOptions(struct soap *soap, const char *tag, tt__G711DecOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__G711DecOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__G711DecOptions, sizeof(tt__G711DecOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__G711DecOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__G711DecOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__G711DecOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_SampleRateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntList(soap, "tt:Bitrate", &a->tt__G711DecOptions::Bitrate, "tt:IntList"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			}
			if (soap_flag_SampleRateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntList(soap, "tt:SampleRateRange", &a->tt__G711DecOptions::SampleRateRange, "tt:IntList"))
				{	soap_flag_SampleRateRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__G711DecOptions::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__G711DecOptions::Bitrate || !a->tt__G711DecOptions::SampleRateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__G711DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__G711DecOptions, SOAP_TYPE_tt__G711DecOptions, sizeof(tt__G711DecOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__G711DecOptions * SOAP_FMAC2 soap_instantiate_tt__G711DecOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__G711DecOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__G711DecOptions *p;
	size_t k = sizeof(tt__G711DecOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__G711DecOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__G711DecOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__G711DecOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__G711DecOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__G711DecOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__G711DecOptions(soap, tag ? tag : "tt:G711DecOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__G711DecOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__G711DecOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__G711DecOptions * SOAP_FMAC4 soap_get_tt__G711DecOptions(struct soap *soap, tt__G711DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__G711DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioDecoderConfigurationOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__AudioDecoderConfigurationOptions::AACDecOptions = NULL;
	this->tt__AudioDecoderConfigurationOptions::G711DecOptions = NULL;
	this->tt__AudioDecoderConfigurationOptions::G726DecOptions = NULL;
	this->tt__AudioDecoderConfigurationOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioDecoderConfigurationOptions::__anyAttribute);
}

void tt__AudioDecoderConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AACDecOptions(soap, &this->tt__AudioDecoderConfigurationOptions::AACDecOptions);
	soap_serialize_PointerTott__G711DecOptions(soap, &this->tt__AudioDecoderConfigurationOptions::G711DecOptions);
	soap_serialize_PointerTott__G726DecOptions(soap, &this->tt__AudioDecoderConfigurationOptions::G726DecOptions);
	soap_serialize_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, &this->tt__AudioDecoderConfigurationOptions::Extension);
#endif
}

int tt__AudioDecoderConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioDecoderConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioDecoderConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioDecoderConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_PointerTott__AACDecOptions(soap, "tt:AACDecOptions", -1, &a->tt__AudioDecoderConfigurationOptions::AACDecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__G711DecOptions(soap, "tt:G711DecOptions", -1, &a->tt__AudioDecoderConfigurationOptions::G711DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__G726DecOptions(soap, "tt:G726DecOptions", -1, &a->tt__AudioDecoderConfigurationOptions::G726DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->tt__AudioDecoderConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioDecoderConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioDecoderConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, tt__AudioDecoderConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioDecoderConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(tt__AudioDecoderConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioDecoderConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioDecoderConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioDecoderConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_AACDecOptions1 = 1;
	size_t soap_flag_G711DecOptions1 = 1;
	size_t soap_flag_G726DecOptions1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AACDecOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AACDecOptions(soap, "tt:AACDecOptions", &a->tt__AudioDecoderConfigurationOptions::AACDecOptions, "tt:AACDecOptions"))
				{	soap_flag_AACDecOptions1--;
					continue;
				}
			}
			if (soap_flag_G711DecOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__G711DecOptions(soap, "tt:G711DecOptions", &a->tt__AudioDecoderConfigurationOptions::G711DecOptions, "tt:G711DecOptions"))
				{	soap_flag_G711DecOptions1--;
					continue;
				}
			}
			if (soap_flag_G726DecOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__G726DecOptions(soap, "tt:G726DecOptions", &a->tt__AudioDecoderConfigurationOptions::G726DecOptions, "tt:G726DecOptions"))
				{	soap_flag_G726DecOptions1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, "tt:Extension", &a->tt__AudioDecoderConfigurationOptions::Extension, "tt:AudioDecoderConfigurationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioDecoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(tt__AudioDecoderConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioDecoderConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioDecoderConfigurationOptions *p;
	size_t k = sizeof(tt__AudioDecoderConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioDecoderConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioDecoderConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioDecoderConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioDecoderConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioDecoderConfigurationOptions(soap, tag ? tag : "tt:AudioDecoderConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioDecoderConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioDecoderConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioDecoderConfigurationOptions(struct soap *soap, tt__AudioDecoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioDecoderConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioDecoderConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioDecoderConfiguration::__anyAttribute);
}

void tt__AudioDecoderConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioDecoderConfiguration::__any);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioDecoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioDecoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioDecoderConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioDecoderConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfiguration), type ? type : "tt:AudioDecoderConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->tt__AudioDecoderConfiguration::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioDecoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioDecoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioDecoderConfiguration(struct soap *soap, const char *tag, tt__AudioDecoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioDecoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(tt__AudioDecoderConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioDecoderConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioDecoderConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioDecoderConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->tt__AudioDecoderConfiguration::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfiguration, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(tt__AudioDecoderConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioDecoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioDecoderConfiguration *p;
	size_t k = sizeof(tt__AudioDecoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioDecoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioDecoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioDecoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioDecoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioDecoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioDecoderConfiguration(soap, tag ? tag : "tt:AudioDecoderConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioDecoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioDecoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.cpp */
